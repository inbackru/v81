import os
import nearby_places
import json
import logging
import requests
import traceback

from types import SimpleNamespace
# Configure logging for debugging PDF generation
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

from flask import Flask, render_template, request, jsonify, redirect, url_for, flash, session, abort, Blueprint, send_from_directory, send_file, make_response, g
from sqlalchemy import text, func
from flask_login import LoginManager, login_user, logout_user, login_required, current_user
from werkzeug.utils import secure_filename
from flask_wtf.csrf import CSRFProtect, validate_csrf
from werkzeug.exceptions import BadRequest

# Configure CSRF protection - ENABLED for security

# Import smart search
from smart_search import smart_search
import math
from urllib.parse import unquote, quote
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import DeclarativeBase
from werkzeug.middleware.proxy_fix import ProxyFix
import secrets
import threading
import time
import atexit
import glob
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
import re
from email_service import send_notification, send_email
from services.geocoding import get_geocoding_service
from services.dadata_client import get_dadata_client
from flask_caching import Cache
from flask_compress import Compress
from services.alert_service import AlertService
import qrcode
from seo_redirects import get_redirect_city_slug, redirect_to_city_based, get_city_slug_for_resource
import io
import base64
from PIL import Image

# Models and repositories will be imported after db initialization to avoid circular imports


# Import unified transliteration functions
from utils.transliteration import create_slug, create_complex_slug, create_developer_slug
def parse_address_components(address_display_name):
    """
    –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø: –ü–∞—Ä—Å–∏—Ç –∞–¥—Ä–µ—Å –≤ —Ñ–æ—Ä–º–∞—Ç–µ: –†–æ—Å—Å–∏—è, –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π, –°–æ—á–∏, –ö—É–¥–µ–ø—Å—Ç–∞ –º-–Ω, –ò—Å–∫—Ä—ã, 88 –ª–∏—Ç7
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º–∏ –∞–¥—Ä–µ—Å–∞
    """
    # –ü–û–õ–ù–ê–Ø –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –†–ï–ó–£–õ–¨–¢–ê–¢–ê
    result = {
        'country': None,
        'region': None, 
        'city': None,
        'district': None,
        'street': None,
        'house_number': None
    }
    
    if not address_display_name:
        return result
    
    # –†–ê–ó–ë–ò–í–ê–ï–ú –ê–î–†–ï–° –ü–û –ó–ê–ü–Ø–¢–´–ú
    parts = [part.strip() for part in address_display_name.split(',')]
    
    # –ü–†–Ø–ú–û–ï –ó–ê–ü–û–õ–ù–ï–ù–ò–ï –û–°–ù–û–í–ù–´–• –ß–ê–°–¢–ï–ô
    if len(parts) >= 1:
        result['country'] = parts[0]  # –†–æ—Å—Å–∏—è
        
    if len(parts) >= 2:
        result['region'] = parts[1]   # –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π
        
    if len(parts) >= 3:
        result['city'] = parts[2]     # –°–æ—á–∏
        
    # –û–ë–†–ê–ë–ê–¢–´–í–ê–ï–ú –û–°–¢–ê–í–®–ò–ï–°–Ø –ß–ê–°–¢–ò (—Ä–∞–π–æ–Ω, —É–ª–∏—Ü–∞, –¥–æ–º)
    if len(parts) >= 4:
        remaining_parts = parts[3:]  # ['–î–∞–≥–æ–º—ã—Å', '–†–æ—Å—Å–∏–π—Å–∫–∞—è', '26–≥ —Å—Ç—Ä']
        
        if len(remaining_parts) == 1:
            # –û–¥–Ω–∞ —á–∞—Å—Ç—å: –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–π–æ–Ω –∏–ª–∏ —É–ª–∏—Ü–∞
            part = remaining_parts[0]
            if any(marker in part for marker in ['–º-–Ω', '–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω', '–ñ–ö', '–∂–∏–ª–æ–π –∫–æ–º–ø–ª–µ–∫—Å']):
                result['district'] = part
            else:
                result['street'] = part
                
        elif len(remaining_parts) == 2:
            # –î–≤–µ —á–∞—Å—Ç–∏: —Ä–∞–π–æ–Ω+—É–ª–∏—Ü–∞ –∏–ª–∏ —É–ª–∏—Ü–∞+–¥–æ–º
            first_part, second_part = remaining_parts[0], remaining_parts[1]
            
            if any(marker in first_part for marker in ['–º-–Ω', '–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω']):
                result['district'] = first_part
                result['street'] = second_part
            else:
                result['street'] = first_part
                result['house_number'] = second_part
                
        elif len(remaining_parts) == 3:
            # –¢—Ä–∏ —á–∞—Å—Ç–∏: —Ä–∞–π–æ–Ω, —É–ª–∏—Ü–∞, –¥–æ–º
            result['district'] = remaining_parts[0]
            result['street'] = remaining_parts[1]
            result['house_number'] = remaining_parts[2]
            
        elif len(remaining_parts) >= 4:
            # –ë–æ–ª—å—à–µ —Ç—Ä–µ—Ö —á–∞—Å—Ç–µ–π: —Ä–∞–π–æ–Ω, —É–ª–∏—Ü–∞, –¥–æ–º (–æ—Å—Ç–∞–ª—å–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω—è–µ–º –≤ –¥–æ–º)
            result['district'] = remaining_parts[0]
            result['street'] = remaining_parts[1]
            result['house_number'] = ', '.join(remaining_parts[2:])
    
    return result

def resolve_city_context(city_id=None, city_slug=None, default_if_none=True):
    """
    Resolve city context with priority order.
    
    Priority order:
        1. city_id parameter (explicit override)
        2. city_slug parameter (explicit override)
        3. session['city_id'] (user's selected city)
        4. default city (fallback if default_if_none=True)
    
    Args:
        city_id: Integer city ID
        city_slug: String city slug (e.g., 'krasnodar', 'sochi')
        default_if_none: If True, return default city when no params provided
        
    Returns:
        City: City model instance (NOT dict) with attributes: id, name, slug
        None: If city not found and default_if_none is False
        
    Examples:
        resolve_city_context(city_id=1) -> City(id=1, name='–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä', ...)
        resolve_city_context(city_slug='sochi') -> City(id=2, name='–°–æ—á–∏', ...)
        resolve_city_context() -> City from session or default (–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä)
    """
    from models import City
    
    city = None
    
    # Try to find city by ID
    if city_id:
        try:
            city = City.query.filter_by(id=int(city_id), is_active=True).first()
        except (ValueError, TypeError):
            pass
    
    # Try to find city by slug
    if not city and city_slug:
        city = City.query.filter_by(slug=city_slug, is_active=True).first()
    
    # Try session (user's selected city)
    if not city and 'city_id' in session:
        try:
            city = City.query.filter_by(id=session['city_id'], is_active=True).first()
        except (KeyError, ValueError, TypeError):
            pass
    
    # Fallback to default city if requested
    if not city and default_if_none:
        city = City.query.filter_by(is_default=True, is_active=True).first()
    
    # Return City model directly (NOT dict)
    return city

# DEPRECATED: Legacy function for excel_properties table - not used with normalized Property model
# def update_parsed_addresses():
#     """
#     DEPRECATED: –û–±–Ω–æ–≤–ª—è–µ—Ç –í–°–ï –ø–æ–ª—è parsed_* –¥–ª—è –≤—Å–µ—Ö –∑–∞–ø–∏—Å–µ–π –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
#     –Ω–∞ –æ—Å–Ω–æ–≤–µ address_display_name
#     
#     NOTE: This function is no longer used with the normalized Property model.
#     Address parsing is handled directly in Property model fields.
#     """
#     pass

class Base(DeclarativeBase):
    pass

db = SQLAlchemy(model_class=Base)

# Create the app
app = Flask(__name__)
app.secret_key = os.environ.get("SESSION_SECRET")
app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)

# SEO: Production canonical base URL (always HTTPS)
CANONICAL_BASE_URL = 'https://inback.ru'

# Initialize CSRF protection after app creation - ENABLED FOR SECURITY
csrf = CSRFProtect(app)

# CSRF configuration (object defined at top of file)
app.config['WTF_CSRF_TIME_LIMIT'] = None  # No expiry - tokens valid for entire session
app.config['WTF_CSRF_SSL_STRICT'] = False  # Allow non-HTTPS for development

# ==========================================
# COMPREHENSIVE SECURITY CONFIGURATION  
# ==========================================
# Initialize advanced security features:
# - Rate Limiting (DDoS protection)
# - Security Headers (XSS, Clickjacking protection)
# - Content Security Policy
# - Additional hardening measures
try:
    from security_config import init_security
    limiter, talisman = init_security(app)
    print("‚úÖ Advanced security features initialized successfully")
except Exception as e:
    print(f"‚ö†Ô∏è  Warning: Could not initialize advanced security: {e}")
    limiter = None
    talisman = None
# –ò–°–ü–†–ê–í–õ–ï–ù–û (22.10.2025): –î–æ–±–∞–≤–ª—è–µ–º hasattr –≤ Jinja2 –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
app.jinja_env.globals['hasattr'] = hasattr

# Add CSRF token to template context - ENABLED
@app.context_processor
def inject_csrf_token():
    from flask_wtf.csrf import generate_csrf
    return dict(csrf_token=generate_csrf)

def validate_json_csrf():
    """Validate CSRF token for JSON requests"""
    try:
        # For JSON requests, check both header and JSON payload
        token = request.headers.get('X-CSRFToken')
        print(f"üîí CSRF CHECK: Header token: {token[:20] if token else 'MISSING'}...")
        
        if not token and request.is_json:
            data = request.get_json()
            token = data.get('csrf_token') if data else None
            print(f"üîí CSRF CHECK: JSON token: {token[:20] if token else 'MISSING'}...")
        
        if not token:
            print("‚ùå CSRF CHECK: No token found in header or JSON")
            return False
        
        validate_csrf(token)
        print("‚úÖ CSRF CHECK: Token validated successfully")
        return True
    except Exception as e:
        print(f"‚ùå CSRF CHECK: Validation failed with error: {e}")
        return False

def require_json_csrf(f):
    """Decorator to require CSRF protection for JSON endpoints"""
    from functools import wraps
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Check CSRF for all dangerous HTTP methods with JSON content
        if request.method in ['POST', 'PUT', 'PATCH', 'DELETE'] and request.is_json:
            if not validate_json_csrf():
                return jsonify({'success': False, 'error': 'CSRF token missing or invalid'}), 400
        return f(*args, **kwargs)
    return decorated_function

# –†—É—Å—Å–∫–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –º–µ—Å—è—Ü–µ–≤ –¥–ª—è –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏
RUSSIAN_MONTHS = {
    1: '—è–Ω–≤–∞—Ä—è', 2: '—Ñ–µ–≤—Ä–∞–ª—è', 3: '–º–∞—Ä—Ç–∞', 4: '–∞–ø—Ä–µ–ª—è',
    5: '–º–∞—è', 6: '–∏—é–Ω—è', 7: '–∏—é–ª—è', 8: '–∞–≤–≥—É—Å—Ç–∞',
    9: '—Å–µ–Ω—Ç—è–±—Ä—è', 10: '–æ–∫—Ç—è–±—Ä—è', 11: '–Ω–æ—è–±—Ä—è', 12: '–¥–µ–∫–∞–±—Ä—è'
}

@app.template_filter('russian_date')
def russian_date_filter(date_value):
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –¥–∞—Ç—É –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ"""
    if not date_value:
        return '–ù–µ–¥–∞–≤–Ω–æ'
    
    if isinstance(date_value, str):
        return date_value
    
    day = date_value.day
    month = RUSSIAN_MONTHS.get(date_value.month, date_value.strftime('%B'))
    year = date_value.year
    
    return f"{day} {month} {year}"

@app.template_filter('msk_time')
def msk_time_filter(utc_datetime, format='%d.%m.%Y –≤ %H:%M'):
    """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç UTC –≤—Ä–µ–º—è –≤ –º–æ—Å–∫–æ–≤—Å–∫–æ–µ (MSK = UTC+3) –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç"""
    if not utc_datetime:
        return '–ù–µ–¥–∞–≤–Ω–æ'
    
    if isinstance(utc_datetime, str):
        return utc_datetime
    
    from datetime import timedelta
    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º UTC –≤ MSK (UTC+3)
    msk_datetime = utc_datetime + timedelta(hours=3)
    return msk_datetime.strftime(format)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—É–ø–µ—Ä-–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
app.config['CACHE_TYPE'] = 'simple'
app.config['CACHE_DEFAULT_TIMEOUT'] = 300  # 5 –º–∏–Ω—É—Ç
cache = Cache(app)
# –í–∫–ª—é—á–∞–µ–º Gzip —Å–∂–∞—Ç–∏–µ –¥–ª—è –≤—Å–µ—Ö –æ—Ç–≤–µ—Ç–æ–≤ (HTML, CSS, JS, XML)
compress = Compress()
compress.init_app(app)
app.config["COMPRESS_MIMETYPES"] = ["text/html", "text/css", "text/xml", "application/json", "application/javascript", "application/xml+rss", "application/atom+xml", "image/svg+xml"]

# Session configuration for Replit iframe environment
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'None'
app.config['SESSION_COOKIE_SECURE'] = True
app.config['PERMANENT_SESSION_LIFETIME'] = 60 * 60 * 24 * 30  # 30 days
app.config['WTF_CSRF_TIME_LIMIT'] = None  # No expiry - tokens valid for entire session
app.config['WTF_CSRF_SSL_STRICT'] = False  # Allow development over HTTP
app.config['SESSION_PERMANENT'] = True  # Make sessions permanent by default

# Enable permanent sessions by default
from datetime import timedelta
app.permanent_session_lifetime = timedelta(days=30)

# Configure the database
app.config["SQLALCHEMY_DATABASE_URI"] = os.environ.get("DATABASE_URL", "sqlite:///properties.db")
app.config["SQLALCHEMY_ENGINE_OPTIONS"] = {
    "pool_recycle": 300,
    "pool_pre_ping": True,
}

# Configure file uploads
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size
app.config['UPLOAD_FOLDER'] = os.path.join('static', 'uploads')

# Ensure upload directory exists
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

# Add route for uploaded files

# ========================================
# HELPER: Smart Property ID Resolution
# ========================================
def resolve_property_by_identifier(identifier):
    """
    Resolve property by identifier - handles both inner_id (string) and database ID (int).
    
    This is needed because:
    - JavaScript sends inner_id in URLs (e.g., "1999611557")
    - CollectionProperty.property_id contains MIXED types (old: database IDs, new: inner_ids)
    
    Returns:
        tuple: (Property object, canonical_identifier_for_collection_property)
        Returns (None, None) if not found
    
    Usage:
        property_obj, canonical_id = resolve_property_by_identifier(property_id)
        if not property_obj:
            return error_response()
    """
    from models import Property as PropertyModel
    
    # Try as inner_id first (most common case from frontend)
    property_obj = PropertyModel.query.filter_by(inner_id=str(identifier)).first()
    if property_obj:
        print(f"DEBUG: ‚úÖ Found property by inner_id: {identifier}")
        return property_obj, str(property_obj.inner_id)
    
    # If not found, try as database ID (legacy data)
    try:
        db_id = int(identifier)
        property_obj = PropertyModel.query.get(db_id)
        if property_obj:
            print(f"DEBUG: ‚úÖ Found property by database ID: {db_id} (inner_id: {property_obj.inner_id})")
            return property_obj, str(property_obj.inner_id)
    except (ValueError, TypeError):
        pass
    
    print(f"DEBUG: ‚ùå Property not found: {identifier} (tried inner_id and database ID)")
    return None, None

@app.route('/uploads/<path:filename>')
def uploaded_file(filename):
    """Serve uploaded files"""
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

# Initialize the app with the extension
db.init_app(app)

# Import and register all models with SQLAlchemy after db initialization
with app.app_context():
    # Import all models explicitly to ensure they are registered with SQLAlchemy
    from models import (User, Manager, SavedSearch, SentSearch, PropertyAlert, BlogPost, BlogArticle, Category, 
                       Developer, ResidentialComplex, CashbackRecord, 
                       Application, Favorite, Notification, District, Street, RoomType, 
                       Admin, City, Region, Offer, MarketingMaterial, ManagerCheckin, Referral,
                       Partner, PartnerReferral, PartnerWithdrawal)
    db.create_all()
    print("Database tables created successfully!")

# Import repositories after db initialization to avoid circular imports
from repositories.property_repository import PropertyRepository, ResidentialComplexRepository, DeveloperRepository

# Import Manager and Admin for isinstance checks throughout the file
from models import Manager, Admin

# Add Jinja2 helper for creating slugs
@app.template_filter('slug')
def create_slug_filter(name):
    """Jinja2 filter for creating SEO-friendly slug from complex name"""
    return create_slug(name)

# Create API blueprint without login requirement
api_bp = Blueprint('api', __name__, url_prefix='/api')

# Debug endpoint removed for security - exposed session data

@api_bp.route('/properties/filter')
def api_properties_filter():
    """
    ‚úÖ MIGRATED TO NORMALIZED TABLES (Property ‚Üí ResidentialComplex ‚Üí Developer)
    Unified API endpoint for filtering properties.
    Supports pagination, sorting, and returns properties with coordinates for map.
    
    Query parameters:
        - All filter parameters from build_property_filters()
        - page (int): Page number (default: 1)
        - per_page (int): Results per page (default: 20, max: 100)
        - sort (str): Sort type (price_asc, price_desc, area_asc, area_desc, date_desc)
    
    Returns:
        JSON with:
        - success (bool)
        - properties (list): Filtered properties with coordinates
        - total (int): Total count of filtered properties
        - page (int): Current page
        - per_page (int): Results per page
        - total_pages (int): Total pages
    """
    try:
        # Use unified filter function to parse request arguments
        where_conditions, params, filters_parsed = build_property_filters(request.args)
        
        # Convert build_property_filters() output to PropertyRepository filter format
        repo_filters = {
            'min_price': params.get('price_min'),
            'max_price': params.get('price_max'),
            'min_area': params.get('area_min'),
            'max_area': params.get('area_max'),
            'floor_min': params.get('floor_min'),
            'floor_max': params.get('floor_max'),
            'building_floors_min': params.get('building_floors_min'),
            'building_floors_max': params.get('building_floors_max'),
            'rooms': filters_parsed.get('rooms', []),
            'developer': filters_parsed.get('developer'),
            'developers': filters_parsed.get('developers', []),
            'district': filters_parsed.get('district'),
            'districts': filters_parsed.get('districts', []),
            'residential_complex': filters_parsed.get('residential_complex'),
            'building': filters_parsed.get('building'),
            'cashback_only': filters_parsed.get('cashback_only', False),
            'renovation': filters_parsed.get('renovation', []),
            'property_type': filters_parsed.get('property_type'),
            'object_classes': filters_parsed.get('object_classes', []),
            'building_types': filters_parsed.get('building_types', []),
            'floor_options': filters_parsed.get('floor_options', []),
            'deal_type': filters_parsed.get('deal_type'),
            'search': filters_parsed.get('search')
        }
        
        # Remove None values from filters
        repo_filters = {k: v for k, v in repo_filters.items() if v is not None and v != [] and v != ''}
        
        # Pagination parameters
        page = request.args.get('page', default=1, type=int)
        page = max(1, page)
        per_page = request.args.get('per_page', default=20, type=int)
        per_page = min(max(1, per_page), 10000)  # Limit to 10000 max (for map view)
        offset = (page - 1) * per_page
        
        # Sorting
        sort_type = request.args.get('sort', 'price_asc').replace('_', '-').replace('-', '_')
        sort_by = 'price'
        sort_order = 'asc'
        
        if sort_type == 'price_desc':
            sort_by, sort_order = 'price', 'desc'
        elif sort_type == 'price_asc':
            sort_by, sort_order = 'price', 'asc'
        elif sort_type == 'area_asc':
            sort_by, sort_order = 'area', 'asc'
        elif sort_type == 'area_desc':
            sort_by, sort_order = 'area', 'desc'
        elif sort_type == 'date_desc':
            sort_by, sort_order = 'date', 'desc'
        
        # Get total count using PropertyRepository
        total = PropertyRepository.count_active(filters=repo_filters)
        
        # Get properties using PropertyRepository
        properties_orm = PropertyRepository.get_all_active(
            limit=per_page,
            offset=offset,
            filters=repo_filters,
            sort_by=sort_by,
            sort_order=sort_order
        )
        
        # Format properties for JSON response (maintain backward compatibility)
        properties = []
        for prop in properties_orm:
            # Parse gallery images
            main_image = 'https://via.placeholder.com/400x300?text=No+Photo'
            gallery = [main_image]
            
            if prop.gallery_images:
                try:
                    photos_raw = json.loads(prop.gallery_images)
                    if photos_raw and isinstance(photos_raw, list) and len(photos_raw) > 0:
                        main_image = photos_raw[0]
                        gallery = photos_raw[:5]
                except:
                    pass
            elif prop.main_image:
                main_image = prop.main_image
                gallery = [main_image]
            
            # Format room type
            rooms = int(prop.rooms or 0)
            room_type = "–°—Ç—É–¥–∏—è" if rooms == 0 else f"{rooms}-–∫–æ–º–Ω"
            
            # Format floor info
            floor = int(prop.floor or 1)
            total_floors = int(prop.total_floors or floor)
            floor_text = f"{floor}/{total_floors}"
            
            # Get cashback rate from residential complex
            cashback_rate = None
            if prop.residential_complex:
                cashback_rate = float(prop.residential_complex.cashback_rate) if prop.residential_complex.cashback_rate else None
            
            # Build property object
            prop_dict = {
                'id': prop.inner_id or str(prop.id),
                'price': int(prop.price or 0),
                'area': float(prop.area or 0),
                'rooms': rooms,
                'floor': floor,
                'total_floors': total_floors,
                'room_type': room_type,
                'floor': floor_text,
                'floor_min': floor,
                'floor_max': total_floors,
                'title': f"{room_type}, {prop.area} –º¬≤",
                'address': prop.address or '',
                'complex_name': prop.residential_complex.name if prop.residential_complex else '',
                'residential_complex': prop.residential_complex.name if prop.residential_complex else '',
                'developer': prop.developer.name if prop.developer else '',
                'district': prop.district.name if prop.district else '',
                'image': main_image,
                'gallery': gallery,
                'object_class': '',  # Can add if needed
                'renovation': PropertyRepository.get_renovation_display_name(prop.renovation_type),
                'cashback_rate': cashback_rate,
                'cashback_available': bool(cashback_rate and cashback_rate > 0),
                'url': f'/object/{prop.inner_id or prop.id}',
                # Coordinates for map
                'lat': float(prop.latitude) if prop.latitude else None,
                'lon': float(prop.longitude) if prop.longitude else None,
                'coordinates': {
                    'lat': float(prop.latitude) if prop.latitude else None,
                    'lng': float(prop.longitude) if prop.longitude else None
                } if prop.latitude and prop.longitude else None
            }
            
            properties.append(prop_dict)
        
        total_pages = (total + per_page - 1) // per_page if total > 0 else 0
        
        return jsonify({
            'success': True,
            'properties': properties,
            'total': total,
            'page': page,
            'per_page': per_page,
            'total_pages': total_pages,
            'filters_applied': filters_parsed
        })
        
    except Exception as e:
        print(f"‚ùå Error in /api/properties/filter: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e),
            'properties': [],
            'total': 0
        }), 500

@api_bp.route('/property/<int:property_id>/cashback')
def api_property_cashback(property_id):
    """‚úÖ MIGRATED - Get cashback information using PropertyRepository"""
    try:
        # Get property using PropertyRepository
        prop = PropertyRepository.get_by_id(property_id)
        
        if not prop:
            return jsonify({'success': False, 'error': 'Property not found'})
        
        # Extract data from Property model
        price = int(prop.price or 0)
        rooms = int(prop.rooms or 0)
        complex_name = prop.residential_complex.name if prop.residential_complex else "–ù–µ —É–∫–∞–∑–∞–Ω"
        
        # Get cashback rate from ResidentialComplex
        cashback_percent = 0
        if prop.residential_complex and prop.residential_complex.cashback_rate:
            cashback_percent = float(prop.residential_complex.cashback_rate)
        
        # Calculate cashback amount
        cashback_amount = price * (cashback_percent / 100)
        
        # Format property name
        room_text = f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞" if rooms > 0 else "–°—Ç—É–¥–∏—è"
        property_name = f"{room_text} –≤ –ñ–ö ¬´{complex_name}¬ª"
        
        return jsonify({
            'success': True,
            'property_id': property_id,
            'property_name': property_name,
            'property_price': price,
            'cashback_percent': cashback_percent,
            'cashback_amount': int(cashback_amount),
            'complex_name': complex_name,
            'rooms': rooms
        })
        
    except Exception as e:
        print(f"Error getting property cashback: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': 'Server error'})

# Custom Jinja2 filters
def street_slug(street_name):
    """Convert street name to URL slug with transliteration"""
    import re
    
    # Transliteration mapping for Russian to Latin
    translit_map = {
        '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo',
        '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
        '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
        '—Ñ': 'f', '—Ö': 'kh', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch',
        '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
    }
    
    # Clean the name
    name = str(street_name).strip().lower()
    # Remove extra characters
    name = re.sub(r'[¬´¬ª"\(\)\.,:;]', '', name)
    
    # Transliterate
    result = ''
    for char in name:
        result += translit_map.get(char, char)
    
    # Replace spaces with hyphens and clean up
    result = re.sub(r'\s+', '-', result)
    result = re.sub(r'-+', '-', result)
    result = result.strip('-')
    
    return result

def number_format(value):
    """Format number with space separators"""
    try:
        if isinstance(value, str):
            value = int(value)
        return f"{value:,}".replace(',', ' ')
    except (ValueError, TypeError):
        return str(value)

@app.template_filter('developer_slug')
def developer_slug(developer_name):
    """Convert developer name to URL slug with transliteration"""
    import re
    if not developer_name:
        return ""
    
    # Transliteration mapping for Russian to Latin
    translit_map = {
        '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo',
        '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
        '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
        '—Ñ': 'f', '—Ö': 'kh', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch',
        '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
        '–ê': 'A', '–ë': 'B', '–í': 'V', '–ì': 'G', '–î': 'D', '–ï': 'E', '–Å': 'YO',
        '–ñ': 'ZH', '–ó': 'Z', '–ò': 'I', '–ô': 'Y', '–ö': 'K', '–õ': 'L', '–ú': 'M',
        '–ù': 'N', '–û': 'O', '–ü': 'P', '–†': 'R', '–°': 'S', '–¢': 'T', '–£': 'U',
        '–§': 'F', '–•': 'KH', '–¶': 'TS', '–ß': 'CH', '–®': 'SH', '–©': 'SCH',
        '–™': '', '–´': 'Y', '–¨': '', '–≠': 'E', '–Æ': 'YU', '–Ø': 'YA'
    }
    
    # Remove extra spaces and clean
    name = str(developer_name).strip()
    # Remove quotes, parentheses, dots, commas
    name = re.sub(r'[¬´¬ª"\(\)\.,:;]', '', name)  
    
    # Transliterate cyrillic to latin
    result = ''
    for char in name:
        result += translit_map.get(char, char)
    
    # Replace spaces with hyphens and clean up
    result = re.sub(r'\s+', '-', result)  # Replace spaces with hyphens
    result = re.sub(r'-+', '-', result)   # Replace multiple hyphens with single
    result = result.strip('-')  # Remove leading/trailing hyphens
    return result.lower()

@app.template_filter('from_json')
def from_json_filter(json_string):
    """–ü–∞—Ä—Å–∏—Ç JSON —Å—Ç—Ä–æ–∫—É –≤ –æ–±—ä–µ–∫—Ç Python"""
    if not json_string:
        return []
    try:
        if isinstance(json_string, str):
            return json.loads(json_string)
        return json_string
    except (json.JSONDecodeError, TypeError):
        return []

@app.template_filter('crop_watermark')
def crop_watermark_filter(image_url, crop_percent=8):
    """
    Convert image URL to proxied URL with watermark cropped
    Usage in template: {{ image_url | crop_watermark(10) }}
    """
    if not image_url:
        return image_url
    
    from urllib.parse import quote
    encoded_url = quote(image_url, safe='')
    return f"/api/image-proxy?url={encoded_url}&crop={crop_percent}"

def format_room_display(rooms):
    """Format room count for display"""
    if rooms == 0:
        return "–°—Ç—É–¥–∏—è"
    else:
        return f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"

app.jinja_env.filters['street_slug'] = street_slug
app.jinja_env.filters['number_format'] = number_format
app.jinja_env.filters['developer_slug'] = developer_slug

# Initialize Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'  # type: ignore
login_manager.login_message = '–í–æ–π–¥–∏—Ç–µ –≤ –∞–∫–∫–∞—É–Ω—Ç –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ.'
login_manager.login_message_category = 'info'
login_manager.session_protection = None
login_manager.remember_cookie_duration = timedelta(days=30)



# Property data loading functions with cache
_properties_cache = None
_cache_timestamp = None
CACHE_TIMEOUT = 300  # 5 minutes

def load_properties():
    """‚úÖ MIGRATED TO NORMALIZED TABLES: Load properties from Property ‚Üí ResidentialComplex ‚Üí Developer"""
    global _properties_cache, _cache_timestamp
    import time
    
    # Check if we have valid cached data
    if (_properties_cache is not None and _cache_timestamp is not None and 
        time.time() - _cache_timestamp < CACHE_TIMEOUT):
        # Cache hit - fast path
        return _properties_cache
    
    # Ensure we have app context
    from flask import has_app_context
    if not has_app_context():
        with app.app_context():
            return load_properties()
    
    try:
        # ‚úÖ MIGRATED: Load from normalized tables using PropertyRepository
        properties = PropertyRepository.get_all_active(
            limit=500,  # ‚ö° OPTIMIZED: Reduced from 10000
            filters={'min_price': 1},  # price > 0
            sort_by='price',
            sort_order='asc'
        )
        
        excel_properties = properties
        
        if excel_properties and len(excel_properties) > 0:
            # ‚úÖ MIGRATED: No need for max_floors query, data is in normalized tables
            
            # Convert Property ORM objects to dictionary format (backward compatibility)
            db_properties = []
            for prop in excel_properties:
                # Convert ORM object to dict-like structure
                # Property has relationships: residential_complex, developer, district
                complex_obj = prop.residential_complex
                developer_obj = prop.developer
                district_obj = prop.district
                
                prop_dict = {
                    'inner_id': prop.inner_id,
                    'complex_name': complex_obj.name if complex_obj else '–ñ–ö –ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è',
                    'developer_name': developer_obj.name if developer_obj else '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'object_rooms': prop.rooms,
                    'object_area': prop.area,
                    'price': prop.price,
                    'object_min_floor': prop.floor,
                    'object_max_floor': prop.total_floors,
                    'address_display_name': prop.address,
                    'address_position_lat': prop.latitude,
                    'address_position_lon': prop.longitude,
                    'address_locality_display_name': district_obj.name if district_obj else '',
                    'photos': prop.gallery_images or '[]',
                    'complex_object_class_display_name': complex_obj.object_class_display_name if complex_obj else '',
                    'renovation_type': prop.renovation_type,
                    'renovation_display_name': PropertyRepository.get_renovation_display_name(prop.renovation_type),
                    'complex_with_renovation': bool(prop.renovation_type),
                    'complex_building_end_build_year': complex_obj.end_build_year if complex_obj else None,
                    'complex_building_end_build_quarter': complex_obj.end_build_quarter if complex_obj else None,
                    'complex_building_name': prop.complex_building_name,
                    'address_subways': None,
                    'trade_in': False,  # Not in Property model yet
                    'deal_type': prop.deal_type,
                    'square_price': prop.price_per_sqm,
                    'mortgage_price': None,  # Not in Property model yet
                    'object_is_apartment': True,
                    'max_price': prop.price,
                    'min_price': prop.price,
                    'complex_has_green_mortgage': False,  # Not in Property model yet
                    'placement_type': '',  # Not in Property model yet
                    'description': prop.description,
                    'parsed_district': district_obj.name if district_obj else '',
                    'parsed_city': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',  # Default city
                    'city_id': prop.city_id,  # Multi-city support
                    'complex_id': prop.complex_id,
                    'complex_min_rate': complex_obj.cashback_rate if complex_obj else 0
                }
                
                # Parse photos field (JSON array format)
                photos_raw = prop_dict.get('photos', '')
                main_image = '/static/images/no-photo.jpg'
                
                if photos_raw and photos_raw.strip():
                    try:
                        # Try to parse as JSON array first (current database format)
                        if photos_raw.startswith('[') and photos_raw.endswith(']'):
                            images = json.loads(photos_raw)
                            if images and isinstance(images, list) and len(images) > 0:
                                main_image = images[0].strip() if images[0] else '/static/images/no-photo.jpg'
                        # Fallback: PostgreSQL array format {url1,url2,url3}
                        elif photos_raw.startswith('{') and photos_raw.endswith('}'):
                            images_str = photos_raw[1:-1]  # Remove braces
                            if images_str:
                                images = [img.strip().strip('"') for img in images_str.split(',') if img.strip()]
                                main_image = images[0] if images else '/static/images/no-photo.jpg'
                        # Single image URL
                        else:
                            main_image = photos_raw.strip()
                    except (json.JSONDecodeError, ValueError, IndexError) as e:
                        print(f"Error parsing photos for property {prop_dict.get('inner_id')}: {e}")
                        main_image = '/static/images/no-photo.jpg'
                
                # ‚úÖ MIGRATED: Get total floors directly from Property object (already in normalized tables)
                complex_total_floors = prop_dict.get('object_max_floor', 1)
                
                # Format property data  
                rooms = prop_dict.get('object_rooms', 0)
                area = prop_dict.get('object_area', 0) 
                floor = prop_dict.get('object_min_floor') or '‚Äî'
                
                # Format floor display (handle None values)
                if floor != '‚Äî' and complex_total_floors and complex_total_floors != 1:
                    floor_display = f"{floor}/{complex_total_floors} —ç—Ç."
                elif floor != '‚Äî':
                    floor_display = f"{floor} —ç—Ç."
                else:
                    floor_display = "–≠—Ç–∞–∂ –Ω–µ —É–∫–∞–∑–∞–Ω"
                
                # Create title with proper format: "–°—Ç—É–¥–∏—è, 23.40 –º¬≤, 1/12 —ç—Ç."
                if rooms == 0:
                    title = f"–°—Ç—É–¥–∏—è, {area} –º¬≤, {floor_display}"
                else:
                    title = f"{rooms}-–∫–æ–º–Ω, {area} –º¬≤, {floor_display}"
                
                # Enhanced completion date from building data
                completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω–∞'
                if prop_dict.get('complex_building_end_build_year') and prop_dict.get('complex_building_end_build_quarter'):
                    year = prop_dict.get('complex_building_end_build_year')
                    quarter = prop_dict.get('complex_building_end_build_quarter')
                    completion_date = f"{quarter} –∫–≤. {year} –≥."
                elif prop_dict.get('complex_building_end_build_year'):
                    year = prop_dict.get('complex_building_end_build_year')  
                    completion_date = f"{year} –≥."
                
                # Enhanced finishing information
                finishing = prop_dict.get('renovation_display_name') or prop_dict.get('renovation_type', '–ù–µ —É–∫–∞–∑–∞–Ω–∞')
                if prop_dict.get('complex_with_renovation'):
                    finishing = finishing if finishing != '–ù–µ —É–∫–∞–∑–∞–Ω–∞' else '–° –æ—Ç–¥–µ–ª–∫–æ–π'
                
                formatted_prop = {
                    'id': prop_dict.get('inner_id'),
                    'title': title,
                    'rooms': prop_dict.get('object_rooms', 0),
                    'area': prop_dict.get('object_area', 0),
                    'price': prop_dict.get('price', 0),
                    # Use database square_price if available, fallback to calculation
                    'price_per_sqm': prop_dict.get('square_price') or (int(prop_dict.get('price', 0) / prop_dict.get('object_area', 1)) if prop_dict.get('object_area', 0) > 0 else 0),
                    'floor': prop_dict.get('object_min_floor', 1),
                    'total_floors': complex_total_floors,
                    'address': prop_dict.get('address_display_name', ''),
                    'coordinates': {
                        'lat': float(prop_dict.get('address_position_lat') or 45.0448),
                        'lng': float(prop_dict.get('address_position_lon') or 38.9728)
                    },
                    'cashback': calculate_cashback(
                        prop_dict.get('price', 0),
                        complex_id=prop_dict.get('complex_id'),
                        complex_name=prop_dict.get('complex_name')
                    ),
                    'cashback_rate': float(prop_dict.get('complex_min_rate', 0)) if prop_dict.get('complex_min_rate') else 0,
                    'cashback_available': True,
                    'status': 'available',
                    'property_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞' if prop_dict.get('object_is_apartment', True) else '–ù–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å',
                    'developer': prop_dict.get('developer_name', '–ù–µ —É–∫–∞–∑–∞–Ω'),
                    'residential_complex': prop_dict.get('complex_name', '–ñ–ö –ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'),
                    'district': prop_dict.get('parsed_district') or prop_dict.get('parsed_city') or prop_dict.get('address_locality_display_name', '–†–∞–π–æ–Ω –Ω–µ —É–∫–∞–∑–∞–Ω'),
                    'main_image': main_image,
                    'url': f"/object/{prop_dict.get('inner_id')}",
                    'complex_name': prop_dict.get('complex_name', '–ñ–ö –ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'),
                    'type': 'property',
                    # NEW ENHANCED FIELDS FROM DATABASE:
                    'finishing': finishing,
                    'renovation_type': prop_dict.get('renovation_type'),
                    'completion_date': completion_date,
                    'complex_class': prop_dict.get('complex_object_class_display_name', ''),
                    'building_name': prop_dict.get('complex_building_name', ''),
                    'nearest_metro': prop_dict.get('address_subways', ''),
                    'trade_in_available': bool(prop_dict.get('trade_in', False)),
                    'deal_type': prop_dict.get('deal_type', ''),
                    'mortgage_price': prop_dict.get('mortgage_price'),
                    'max_price': prop_dict.get('max_price'),
                    'min_price': prop_dict.get('min_price'),
                    'green_mortgage_available': bool(prop_dict.get('complex_has_green_mortgage', False)),
                    'placement_type': prop_dict.get('placement_type', ''),
                    'description': prop_dict.get('description', ''),
                    'complex_with_renovation': bool(prop_dict.get('complex_with_renovation', False))
                }
                db_properties.append(formatted_prop)
            
            # Successfully loaded properties from database
            # Cache the data
            _properties_cache = db_properties  
            _cache_timestamp = time.time()
            return db_properties
            
    except Exception as e:
        # Database error logged  
        print(f"CRITICAL: load_properties() database error: {e}")
        import traceback
        traceback.print_exc()
        pass
        
    # No fallback - only database data from now on
    # No properties found
    return []

def load_residential_complexes():
    """Load residential complexes from database enriched with statistics from excel_properties"""
    try:
        # First try to load from database
        from models import ResidentialComplex, Developer, District
        
        complexes = ResidentialComplex.query.all()
        
        if complexes and len(complexes) > 0:
            # Convert database complexes to dictionary format
            db_complexes = []
            
            # Bulk query for available room types (optimize N+1)
            from collections import defaultdict
            rooms_by_complex = defaultdict(list)
            try:
                from models import Property
                
                # Helper function to convert room number to filter format
                def room_number_to_filter(rooms):
                    if rooms == 0:
                        return "—Å—Ç—É–¥–∏—è"
                    elif rooms == 1:
                        return "1-–∫–æ–º–Ω"
                    elif rooms == 2:
                        return "2-–∫–æ–º–Ω"
                    elif rooms == 3:
                        return "3-–∫–æ–º–Ω"
                    elif rooms and rooms >= 4:
                        return "4+-–∫–æ–º–Ω"
                    return None
                
                bulk_rooms_query = db.session.query(
                    Property.complex_id,
                    Property.rooms
                ).filter(
                    Property.complex_id.in_([c.id for c in complexes]),
                    Property.is_active == True,
                    Property.rooms.isnot(None)
                ).distinct().all()
                
                for complex_id, room_number in bulk_rooms_query:
                    room_filter = room_number_to_filter(room_number)
                    if room_filter and room_filter not in rooms_by_complex[complex_id]:
                        rooms_by_complex[complex_id].append(room_filter)
                print(f"‚úÖ Loaded room types for {len(rooms_by_complex)} complexes in bulk")
            except Exception as e:
                print(f"‚ö†Ô∏è Could not load room types in bulk: {e}")
                db.session.rollback()
            
            # FOR LOOP OUTSIDE except - process all complexes
            for complex in complexes:
                try:
                    from models import Property
                    stats_query = (
                        db.session.query(
                            func.min(Property.price).label('min_price'),
                            func.max(Property.price).label('max_price'),
                            func.count(Property.id).label('apartments_count')
                        )
                        .filter(Property.complex_id == complex.id, Property.is_active == True)
                        .first()
                    )
                    
                    min_price = stats_query.min_price if stats_query else None
                    max_price = stats_query.max_price if stats_query else None
                    apartments_count = int(stats_query.apartments_count) if stats_query and stats_query.apartments_count else 0
                    
                    # Use bulk query results
                    available_rooms = rooms_by_complex.get(complex.id, [])
                except Exception as e:
                    print(f"Warning: Could not load stats for complex {complex.id}: {e}")
                    db.session.rollback()  # Rollback failed transaction
                    min_price = None
                    max_price = None
                    apartments_count = 0
                    available_rooms = []
                
                complex_dict = {
                    'id': complex.id,
                    'name': complex.name,
                    'slug': complex.slug,
                    'complex_type': complex.complex_type or 'residential',
                    'district': complex.district.name if complex.district else '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'district_id': complex.district_id,
                    'developer': complex.developer.name if complex.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'developer_id': complex.developer_id,
                    'cashback_rate': complex.cashback_rate or 5.0,
                    'cashback_percent': complex.cashback_rate or 5.0,
                    'class': complex.object_class_display_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
                    'description': f'–ñ–ö –æ—Ç –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞ {complex.developer.name if complex.developer else "–ù–µ —É–∫–∞–∑–∞–Ω"}',
                    'start_year': complex.start_build_year,
                    'completion_year': complex.end_build_year,
                    'quarter': complex.end_build_quarter,
                    'features': {
                        'accreditation': complex.has_accreditation,
                        'green_mortgage': complex.has_green_mortgage,
                        'big_check': complex.has_big_check,
                        'with_renovation': complex.with_renovation,
                        'financing_sber': complex.financing_sber,
                    },
                    'phones': {
                        'complex': complex.complex_phone,
                        'sales': complex.sales_phone,
                    },
                    'sales_address': complex.sales_address,
                    'image': 'https://via.placeholder.com/800x600/0088CC/FFFFFF?text=' + complex.name.replace(' ', '+'),  # Placeholder for now
                    'address': complex.sales_address or '–ê–¥—Ä–µ—Å —É—Ç–æ—á–Ω—è–µ—Ç—Å—è',
                    'location': complex.sales_address or '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',  # Add missing location field
                    # Add statistics from excel_properties
                    'min_price': min_price,
                    'available_apartments_count': apartments_count,
                    'total_apartments': apartments_count,
                    # Coordinates
                    'latitude': complex.latitude,
                    'longitude': complex.longitude,
                    'coordinates': {
                        'lat': complex.latitude if complex.latitude else 45.0448,
                        'lng': complex.longitude if complex.longitude else 38.9760
                    },
                    # Images
                    'main_image': complex.main_image,
            'gallery_images': complex.gallery_images,
                    'gallery_images': complex.gallery_images,
                    # Status based on completion dates
                    'status': '–°–¥–∞–Ω' if complex.end_build_year and complex.end_build_year <= 2024 else ('–°—Ç—Ä–æ–∏—Ç—Å—è' if complex.end_build_year else '–ü–ª–∞–Ω–∏—Ä—É–µ—Ç—Å—è'),
                    # URL
                    'url': f'/residential-complex/{complex.slug}',
                    # Developer name
                    'developer_name': complex.developer.name if complex.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
            'developer_id': complex.developer.id if complex.developer else None,
            'object_class': complex.object_class_display_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
                    # Additional fields
                    'buildings_count': complex.buildings_count or 1,
                    'price_from': min_price,
                    'max_price': max_price,
                    'price_to': max_price,
                    'apartments_count': apartments_count,
                    'available_rooms': available_rooms,
                    'properties_count': apartments_count,
                }
                db_complexes.append(complex_dict)
            
            # Complexes loaded successfully
            print(f"‚úÖ load_residential_complexes returning {len(db_complexes)} complexes")
            return db_complexes
            
    except Exception as e:
        # Error loading complexes
        print(f"Error in load_residential_complexes: {e}")
        import traceback
        traceback.print_exc()
    
    # No fallback - only database data from now on
    # No complexes found
    return []

def load_blog_articles():
    """Load blog articles from JSON file"""
    try:
        with open('data/blog_articles.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def load_blog_categories():
    """Load blog categories from JSON file"""
    try:
        with open('data/blog_categories.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def load_search_data():
    """Load search data from JSON file"""
    try:
        with open('data/search_data.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def load_streets():
    """Load streets from JSON file"""
    try:
        with open('data/streets.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def load_developers():
    """Load developers from residential complexes data"""
    try:
        complexes = load_residential_complexes()
        developers = {}
        
        for complex in complexes:
            dev_name = complex.get('developer', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫')
            if dev_name not in developers:
                developers[dev_name] = {
                    'name': dev_name,
                    'projects_count': 0,
                    'complexes': []
                }
            developers[dev_name]['projects_count'] += 1
            developers[dev_name]['complexes'].append(complex['name'])
        
        return list(developers.values())
    except Exception:
        return []

def search_global(query):
    """Global search across all types: –ñ–ö, districts, developers, streets"""
    if not query or len(query.strip()) < 2:
        return []
    
    search_data = load_search_data()
    results = []
    query_lower = query.lower().strip()
    
    # Search through all categories
    for category in ['residential_complexes', 'districts', 'developers', 'streets']:
        items = search_data.get(category, [])
        for item in items:
            # Search in name and keywords
            name_match = query_lower in item['name'].lower()
            keyword_match = any(query_lower in keyword.lower() for keyword in item.get('keywords', []))
            
            if name_match or keyword_match:
                # Calculate relevance score
                score = 0
                if query_lower in item['name'].lower():
                    score += 10  # Higher score for name matches
                if query_lower == item['name'].lower():
                    score += 20  # Even higher for exact matches
                    
                result = {
                    'id': item['id'],
                    'name': item['name'],
                    'type': item['type'],
                    'url': item['url'],
                    'score': score
                }
                
                # Add additional context based on type
                if item['type'] == 'residential_complex':
                    result['district'] = item.get('district', '')
                    result['developer'] = item.get('developer', '')
                elif item['type'] == 'street':
                    result['district'] = item.get('district', '')
                    
                results.append(result)
    
    # Sort by relevance score (highest first)
    results.sort(key=lambda x: x['score'], reverse=True)
    return results[:10]  # Return top 10 results

def get_article_by_slug(slug):
    """Get a single article by slug"""
    articles = load_blog_articles()
    for article in articles:
        if article['slug'] == slug:
            return article
    return None

def search_articles(query, category=None):
    """Search articles by title, excerpt, content, and tags"""
    articles = load_blog_articles()
    if not query and not category:
        return articles
    
    filtered_articles = []
    for article in articles:
        # Filter by category if specified
        if category and article['category'].lower() != category.lower():
            continue
        
        # If no search query, return all articles in category
        if not query:
            filtered_articles.append(article)
            continue
        
        # Search in title, excerpt, content, and tags
        query_lower = query.lower()
        if (query_lower in article['title'].lower() or 
            query_lower in article['excerpt'].lower() or 
            query_lower in article['content'].lower() or 
            any(query_lower in tag.lower() for tag in article['tags'])):
            filtered_articles.append(article)
    
    return filtered_articles

def _extract_first_photo(photos_json):
    """Extract first photo from photos JSON string"""
    if not photos_json:
        return None
    
    try:
        import json
        if isinstance(photos_json, str):
            photos_list = json.loads(photos_json)
        else:
            photos_list = photos_json
            
        return photos_list[0] if photos_list and len(photos_list) > 0 else None
    except:
        return None

def calculate_cashback(price, complex_id=None, complex_name=None):
    """Calculate cashback amount based on property price and complex cashback rate"""
    if not price or price == 0:
        return 0
    
    try:
        from models import ResidentialComplex
        
        # If complex_id provided, use its cashback rate from database (backwards compatibility)
        if complex_id:
            complex_obj = ResidentialComplex.query.filter_by(id=str(complex_id)).first()
            if complex_obj and complex_obj.cashback_rate:
                rate = float(complex_obj.cashback_rate) / 100  # Convert percentage to decimal
                return int(price * rate)
        
        # If complex_name provided, look up by name
        if complex_name:
            complex_obj = ResidentialComplex.query.filter_by(name=complex_name).first()
            if complex_obj and complex_obj.cashback_rate:
                rate = float(complex_obj.cashback_rate) / 100  # Convert percentage to decimal
                return int(price * rate)
    except Exception as e:
        print(f"Error getting complex cashback rate: {e}")
    
    # Fallback to default 5% calculation if no complex found or error
    return int(price * 0.05)  # 5% default cashback

def get_property_by_id(property_id):
    """‚úÖ MIGRATED TO NORMALIZED TABLES: Get property from Property ‚Üí ResidentialComplex ‚Üí Developer"""
    try:
        # ‚úÖ MIGRATED: Use PropertyRepository to get property with all relationships
        prop = PropertyRepository.get_by_id(property_id)
        
        if not prop:
            return None
        
        # Extract related objects
        complex_obj = prop.residential_complex
        developer_obj = prop.developer
        district_obj = prop.district
        city_obj = prop.city  # Get city for fallback
        
        # Map to old variable names for backward compatibility
        inner_id = prop.inner_id
        price = prop.price
        area = prop.area
        rooms = prop.rooms
        min_floor = prop.floor
        max_floor = prop.total_floors
        address = prop.address
        renovation = PropertyRepository.get_renovation_display_name(prop.renovation_type)
        cashback_rate = complex_obj.cashback_rate if complex_obj else 0
        square_price = prop.price_per_sqm
        mortgage_price = None  # Not in Property model yet
        class_type = complex_obj.object_class_display_name if complex_obj else None
        photos = prop.gallery_images
        developer_name = developer_obj.name if developer_obj else None
        complex_name = complex_obj.name if complex_obj else None
        complex_end_year = complex_obj.end_build_year if complex_obj else None
        complex_end_quarter = complex_obj.end_build_quarter if complex_obj else None
        building_end_year = complex_obj.end_build_year if complex_obj else None
        building_end_quarter = complex_obj.end_build_quarter if complex_obj else None
        lat = getattr(prop, "latitude", None)
        lon = getattr(prop, "longitude", None)
        description = prop.description
        district_name = district_obj.name if district_obj else None
        
        # Parse photos JSON
        images = []
        floor_plan = None
        complex_photos = []
        
        try:
            if photos:
                photos_data = json.loads(photos)
                if isinstance(photos_data, list):
                    # If it's a simple list of photo URLs (like in this case)
                    images = photos_data
                    # First photo is always the floor plan
                    if len(images) > 0:
                        floor_plan = images[0]  # First image is floor plan
                elif isinstance(photos_data, dict):
                    # Get apartment gallery photos from dict structure
                    images = photos_data.get('apartment_gallery', [])
                    # Get floor plan 
                    floor_plans = photos_data.get('floor_plans', [])
                    if floor_plans and len(floor_plans) > 0:
                        floor_plan = floor_plans[0]  # Take first floor plan
                    # Get complex photos
                    complex_photos = photos_data.get('complex_gallery', [])
        except Exception as e:
            print(f"Error parsing photos for property {property_id}: {e}")
            pass
        
        # Build completion date
        completion_date = '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è'
        if building_end_year and building_end_quarter:
            completion_date = f"{building_end_year} –≥., {building_end_quarter} –∫–≤."
        elif building_end_year:
            completion_date = f"{building_end_year} –≥."
        elif complex_end_year:
            completion_date = f"{complex_end_year} –≥."
        
        # Create property data structure matching PDF template expectations
        property_data = {
            'id': property_id,  # ‚úÖ Database PK –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è
            'inner_id': inner_id,  # –í–Ω–µ—à–Ω–∏–π ID –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏
            'title': f"{'–°—Ç—É–¥–∏—è' if rooms == 0 else f'{rooms}-–∫. –∫–≤–∞—Ä—Ç–∏—Ä–∞'}, {area} –º¬≤",
            'price': price or 0,
            'area': area or 0,
            'rooms': rooms or 0,
            'floor': min_floor or 1,
            'total_floors': max_floor or min_floor or 1,
            'address': address or (complex_obj.address if complex_obj and complex_obj.address else f"{city_obj.name if city_obj else '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω'}"),
            'developer': developer_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
            'residential_complex': complex_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
            'district': district_name or (city_obj.name if city_obj else '–ù–µ —É–∫–∞–∑–∞–Ω'),
            'status': '–°–≤–æ–±–æ–¥–Ω–∞',
            'property_type': '–°—Ç—É–¥–∏—è' if rooms == 0 else '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
            'renovation_type': renovation or '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è',
            'finishing': renovation or '–ü—Ä–µ–¥—á–∏—Å—Ç–æ–≤–∞—è',
            'completion_date': completion_date,
            'cashback_rate': cashback_rate or 0,
            'mortgage_rate': f"{cashback_rate}%" if cashback_rate else '3.5%',
            'square_price': square_price,
            'mortgage_payment': mortgage_price,
            'class_type': class_type or '–ù–µ —É–∫–∞–∑–∞–Ω',
            'description': description or '',
            'residential_complex_description': f"–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –∂–∏–ª–æ–π –∫–æ–º–ø–ª–µ–∫—Å –æ—Ç –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞ {developer_name}" if developer_name else None,
            'mortgage_available': True,
            'installment_available': False,
            'cashback_available': True,
            # Photos for PDF
            'image': images[0] if images else None,  # Main photo
            'gallery': images,  # All apartment photos
            'floor_plan': floor_plan,  # Floor plan photo
            'complex_photos': complex_photos,  # Complex photos
            # Additional fields expected by PDF template
            'bathroom_type': '–°–æ–≤–º–µ—â–µ–Ω–Ω—ã–π',
            'has_balcony': True,
            'windows_type': '–ü–ª–∞—Å—Ç–∏–∫–æ–≤—ã–µ', 
            'elevators': '2 –ø–∞—Å—Å–∞–∂–∏—Ä—Å–∫–∏—Ö',
            'parking_type': '–ù–∞–∑–µ–º–Ω–∞—è',
            'developer_inn': '–ò–ù–ù –Ω–µ —É–∫–∞–∑–∞–Ω',
            'complex_name': complex_name  # Add complex_name for cashback calculation
        }
        
        return property_data
        
    except Exception as e:
        print(f"Error getting property {property_id}: {e}")
        return None

def get_filtered_properties(filters):
    """Filter properties based on criteria including regional filters"""
    properties = load_properties()
    filtered = []
    
    for prop in properties:
        # Keywords filter (–¥–ª—è —Ç–∏–ø–æ–≤ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏, –∫–ª–∞—Å—Å–æ–≤, –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤)
        if filters.get('keywords') and len(filters['keywords']) > 0:
            keywords_matched = False
            for keyword in filters['keywords']:
                keyword_lower = keyword.lower()
                
                # Check property type
                prop_type_lower = prop.get('property_type', '–ö–≤–∞—Ä—Ç–∏—Ä–∞').lower()
                if keyword_lower == '–¥–æ–º' and prop_type_lower == '–¥–æ–º':
                    keywords_matched = True
                    break
                elif keyword_lower == '—Ç–∞—É–Ω—Ö–∞—É—Å' and prop_type_lower == '—Ç–∞—É–Ω—Ö–∞—É—Å':
                    keywords_matched = True
                    break
                elif keyword_lower == '–ø–µ–Ω—Ç—Ö–∞—É—Å' and prop_type_lower == '–ø–µ–Ω—Ç—Ö–∞—É—Å':
                    keywords_matched = True
                    break
                elif keyword_lower == '–∞–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç—ã' and prop_type_lower == '–∞–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç—ã':
                    keywords_matched = True
                    break
                elif keyword_lower == '—Å—Ç—É–¥–∏—è' and (prop_type_lower == '—Å—Ç—É–¥–∏—è' or prop.get('rooms') == 0):
                    keywords_matched = True
                    break
                elif keyword_lower == '–∫–≤–∞—Ä—Ç–∏—Ä–∞' and prop_type_lower == '–∫–≤–∞—Ä—Ç–∏—Ä–∞':
                    keywords_matched = True
                    break
                
                # Check property class
                elif keyword_lower == prop.get('property_class', '').lower():
                    keywords_matched = True
                    break
                
                # Check wall material
                elif keyword_lower in prop.get('wall_material', '').lower():
                    keywords_matched = True
                    break
                
                # Check features
                elif any(keyword_lower in feature.lower() for feature in prop.get('features', [])):
                    keywords_matched = True
                    break
                
                # Check in property type as fallback  
                elif keyword_lower in (f"{prop.get('rooms', 0)}-–∫–æ–º–Ω" if prop.get('rooms', 0) > 0 else "—Å—Ç—É–¥–∏—è").lower():
                    keywords_matched = True
                    break
                    
            if not keywords_matched:
                continue
        
        # Text search with improved room number matching and word-based search
        if filters.get('search'):
            search_term = filters['search'].lower()
            
            # Create multiple variations for room descriptions
            rooms = prop.get('rooms', 0)
            if rooms == 0:
                room_variations = ["—Å—Ç—É–¥–∏—è", "studio"]
            else:
                room_variations = [
                    f"{rooms}-–∫–æ–º–Ω",
                    f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è",
                    f"{rooms} –∫–æ–º–Ω",
                    f"{rooms} –∫–æ–º–Ω–∞—Ç–Ω–∞—è"
                ]
                
                # Add spelled out numbers for 1-3 rooms
                if rooms == 1:
                    room_variations.extend(["–æ–¥–Ω–æ–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "–æ–¥–Ω–∞ –∫–æ–º–Ω–∞—Ç–∞"])
                elif rooms == 2:
                    room_variations.extend(["–¥–≤—É—Ö–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "–¥–≤–µ –∫–æ–º–Ω–∞—Ç—ã"])
                elif rooms == 3:
                    room_variations.extend(["—Ç—Ä–µ—Ö–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è", "—Ç—Ä–∏ –∫–æ–º–Ω–∞—Ç—ã"])
            
            # Create searchable text with all variations
            property_title = f"{prop.get('rooms', 0)}-–∫–æ–º–Ω" if prop.get('rooms', 0) > 0 else "—Å—Ç—É–¥–∏—è"
            searchable_text = f"{property_title} {' '.join(room_variations)} {prop.get('developer_name', prop.get('developer', ''))} {prop.get('address_locality_name', prop.get('district', ''))} {prop.get('complex_name', prop.get('residential_complex', ''))} {prop.get('location', '')} –∫–≤–∞—Ä—Ç–∏—Ä–∞".lower()
            
            # Split search term into words and check if all words are found
            search_words = search_term.split()
            match_found = True
            
            for word in search_words:
                if word not in searchable_text:
                    match_found = False
                    break
            
            if not match_found:
                continue
        
        # Rooms filter - handle both single value and array
        if filters.get('rooms'):
            rooms_filter = filters['rooms']
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º object_rooms –≤–º–µ—Å—Ç–æ rooms
            property_rooms = prop.get('object_rooms', prop.get('rooms', 0))
            
            # Helper function to parse room filter value
            def parse_room_filter(room_value):
                """Convert room filter to integer: '2-–∫–æ–º–Ω' -> 2, '—Å—Ç—É–¥–∏—è' -> 0, '2' -> 2"""
                if not room_value:
                    return None
                room_str = str(room_value).lower().strip()
                
                # Handle special cases
                if room_str in ['—Å—Ç—É–¥–∏—è', 'studio']:
                    return 0
                if room_str in ['4+-–∫–æ–º–Ω', '4+', '4+ –∫–æ–º–Ω–∞—Ç']:
                    return 4  # Will be handled as >= 4
                
                # Handle "X-–∫–æ–º–Ω" format
                if '-–∫–æ–º–Ω' in room_str:
                    try:
                        return int(room_str.split('-')[0])
                    except (ValueError, IndexError):
                        return None
                
                # Handle numeric string
                try:
                    return int(room_str)
                except (ValueError, TypeError):
                    return None
            
            # Handle array of rooms from saved searches
            if isinstance(rooms_filter, list):
                rooms_match = False
                for room_filter in rooms_filter:
                    room_num = parse_room_filter(room_filter)
                    if room_num is None:
                        continue
                    
                    # Special case for 4+ rooms
                    if str(room_filter).lower() in ['4+-–∫–æ–º–Ω', '4+', '4+ –∫–æ–º–Ω–∞—Ç']:
                        if property_rooms >= 4:
                            rooms_match = True
                            break
                    # Exact match
                    elif property_rooms == room_num:
                        rooms_match = True
                        break
                
                if not rooms_match:
                    continue
            else:
                # Handle single room value
                room_num = parse_room_filter(rooms_filter)
                if room_num is None:
                    continue
                    
                # Special case for 4+ rooms
                if str(rooms_filter).lower() in ['4+-–∫–æ–º–Ω', '4+', '4+ –∫–æ–º–Ω–∞—Ç']:
                    if property_rooms < 4:
                        continue
                # Exact match
                elif property_rooms != room_num:
                    continue
        
        # Price filter - handle both raw rubles and millions
        if filters.get('price_min') and filters['price_min']:
            try:
                min_price = int(filters['price_min'])
                # If value is small, assume it's in millions
                if min_price < 1000:
                    min_price = min_price * 1000000
                if prop['price'] < min_price:
                    continue
            except (ValueError, TypeError):
                pass
        if filters.get('price_max') and filters['price_max']:
            try:
                max_price = int(filters['price_max'])
                # If value is small, assume it's in millions
                if max_price < 1000:
                    max_price = max_price * 1000000
                if prop['price'] > max_price:
                    continue
            except (ValueError, TypeError):
                pass
        
        # District filter
        if filters.get('district') and prop['district'] != filters['district']:
            continue
        
        # Developer filter
        if filters.get('developer') and prop['developer'] != filters['developer']:
            continue
        
        # Residential complex filter
        if filters.get('residential_complex'):
            residential_complex = filters['residential_complex'].lower()
            prop_complex = prop.get('complex_name', '').lower()
            if residential_complex not in prop_complex:
                continue
        
        # Street filter
        if filters.get('street'):
            street = filters['street'].lower()
            prop_location = prop.get('location', '').lower()
            prop_address = prop.get('full_address', '').lower()
            if street not in prop_location and street not in prop_address:
                continue
        
        # Mortgage filter
        if filters.get('mortgage') and not prop.get('mortgage_available', False):
            continue
        
        filtered.append(prop)
    
    return filtered

def build_property_filters(request_args):
    """
    Unified property filtering function for /properties and /map routes.
    
    Args:
        request_args: Flask request.args object
        
    Returns:
        tuple: (where_conditions, params, filters_dict)
            - where_conditions: list of SQL WHERE clause strings
            - params: dict of parameterized values for SQL query
            - filters_dict: dict of parsed filter values for template/debugging
    """
    from datetime import datetime
    
    # Parse all filter parameters (—É–Ω–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –Ω–∞–∑–≤–∞–Ω–∏—è)
    filters = {}
    
    # Price filters (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—Å–µ—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤: price_min, priceFrom, price_from)
    filters['price_min'] = request_args.get('price_min', request_args.get('priceFrom', request_args.get('price_from', '')))
    filters['price_max'] = request_args.get('price_max', request_args.get('priceTo', request_args.get('price_to', '')))
    
    # Area filters (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—Å–µ—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤)
    filters['area_min'] = request_args.get('area_min', request_args.get('areaFrom', request_args.get('area_from', '')))
    filters['area_max'] = request_args.get('area_max', request_args.get('areaTo', request_args.get('area_to', '')))
    
    # Floor filters (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –≤—Å–µ—Ö —Ñ–æ—Ä–º–∞—Ç–æ–≤)
    filters['floor_min'] = request_args.get('floor_min', request_args.get('floorFrom', request_args.get('floor_from', '')))
    filters['floor_max'] = request_args.get('floor_max', request_args.get('floorTo', request_args.get('floor_to', '')))
    
    # Rooms filter (–º–æ–∂–µ—Ç –ø—Ä–∏–π—Ç–∏ –∫–∞–∫ "1,2,3" –∏–ª–∏ –∫–∞–∫ –º–∞—Å—Å–∏–≤ rooms=1&rooms=2 –∏–ª–∏ rooms[]=1)
    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º getlist –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ rooms=1&rooms=2 –∏ rooms[]=1
    rooms_list = request_args.getlist("rooms[]") or request_args.getlist("rooms")
    if rooms_list:
        # –ï—Å–ª–∏ –µ—Å—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã —Å –∑–∞–ø—è—Ç–æ–π - —Ä–∞–∑–±–∏—Ç—å –∏—Ö
        all_rooms = []
        for r in rooms_list:
            if isinstance(r, str) and "," in r:
                all_rooms.extend(r.split(","))
            else:
                all_rooms.append(r)
        filters["rooms"] = [str(r).strip() for r in all_rooms if str(r).strip()]
        import logging
        logging.debug(f'DEBUG: Parsed rooms: {filters["rooms"]}')
    else:
        filters["rooms"] = []
    
    # Multi-select filters
    filters['districts'] = request_args.getlist('districts') or request_args.getlist('districts[]') or []
    filters['developers'] = request_args.getlist('developers') or request_args.getlist('developers[]') or []
    
    # Support developer_id parameter (single developer by ID)
    developer_id = request_args.get('developer_id', '')
    if developer_id and developer_id not in filters['developers']:
        filters['developers'].append(developer_id)
    filters['completion'] = request_args.getlist('completion') or request_args.getlist('completion[]') or []
    filters['building_types'] = request_args.getlist('building_types') or request_args.getlist('building_types[]') or []
    filters['delivery_years'] = request_args.getlist('delivery_years') or []
    filters['features'] = request_args.getlist('features') or request_args.getlist('features[]') or []
    # Object classes filter (–º–æ–∂–µ—Ç –ø—Ä–∏–π—Ç–∏ –∫–∞–∫ —Å–ø–∏—Å–æ–∫ object_classes[]=X&object_classes[]=Y –∏–ª–∏ –∫–∞–∫ "–ë–∏–∑–Ω–µ—Å,–ö–æ–º—Ñ–æ—Ä—Ç")
    object_classes_list = request_args.getlist('object_classes[]') or request_args.getlist('object_classes') or request_args.getlist('object_class')
    if object_classes_list:
        filters['object_classes'] = object_classes_list
    else:
        object_classes_param = request_args.get('object_class', '') or request_args.get('object_classes', '') or request_args.get('object_classes[]', '')
        if object_classes_param:
            filters['object_classes'] = object_classes_param.split(',') if ',' in object_classes_param else [object_classes_param]
        else:
            filters['object_classes'] = []
    filters['renovation'] = request_args.getlist('renovation') or request_args.getlist('renovation[]') or []
    filters['building_released'] = request_args.getlist('building_released') or request_args.getlist('building_released[]') or []
    filters['floor_options'] = request_args.getlist('floor_options') or request_args.getlist('floor_options[]') or []  # not_first, not_last
    
    # Boolean filters
    filters['cashback_only'] = request_args.get('cashback_only', '').lower() in ['true', '1', 'yes']
    
    # Single value filters
    filters['developer'] = request_args.get('developer', '')
    filters['district'] = request_args.get('district', '')
    filters['residential_complex'] = request_args.get('residential_complex', '')
    filters['building'] = request_args.get('building', '')
    
    # Building floors filters
    filters['building_floors_min'] = request_args.get('building_floors_min', request_args.get('maxFloorFrom', ''))
    filters['building_floors_max'] = request_args.get('building_floors_max', request_args.get('maxFloorTo', ''))
    
    # Build year filters
    filters['build_year_min'] = request_args.get('build_year_min', request_args.get('buildYearFrom', ''))
    filters['build_year_max'] = request_args.get('build_year_max', request_args.get('buildYearTo', ''))
    
    # Regional filters
    filters['regions'] = request_args.getlist('regions') or []
    filters['cities'] = request_args.getlist('cities') or []
    filters['city'] = request_args.get('city', '')
    filters['city_id'] = request_args.get('city_id', '')  # Support city_id parameter
    filters['city'] = request_args.get('city', '')
    
    # Search query
    # Property type filter
    filters['property_type'] = request_args.get('property_type', '')
    # Search query (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ –æ–±–æ–∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤: 'q' –∏ 'search')
    filters['search'] = request_args.get('q', request_args.get('search', ''))
    
    # Auto-detect room filters from search queries (for mobile/direct URL access)
    if filters['search']:
        import re
        search_lower = filters['search'].lower().strip()
        
        # Studio patterns: "—Å—Ç—É–¥–∏—è", "studio"
        if re.search(r'\b—Å—Ç—É–¥–∏[—è—é–∏]\b', search_lower):
            if '0' not in filters['rooms']:
                filters['rooms'].append('0')
        
        # 1 room patterns: "1 –∫–æ–º–Ω", "1–∫–æ–º–Ω", "1–∫", "1-–∫–æ–º–Ω", "–æ–¥–Ω–æ–∫–æ–º–Ω"
        if re.search(r'\b1[\s\-]?–∫(–æ–º–Ω(–∞—Ç–Ω–∞—è|–∞—Ç)?)?\b|\b–æ–¥–Ω–æ[\s\-]?–∫–æ–º–Ω', search_lower):
            if '1' not in filters['rooms']:
                filters['rooms'].append('1')
        
        # 2 room patterns: "2 –∫–æ–º–Ω", "2–∫–æ–º–Ω", "2–∫", "2-–∫–æ–º–Ω", "–¥–≤—É—Ö–∫–æ–º–Ω"
        if re.search(r'\b2[\s\-]?–∫(–æ–º–Ω(–∞—Ç–Ω–∞—è|–∞—Ç)?)?\b|\b–¥–≤—É—Ö[\s\-]?–∫–æ–º–Ω', search_lower):
            if '2' not in filters['rooms']:
                filters['rooms'].append('2')
        
        # 3 room patterns: "3 –∫–æ–º–Ω", "3–∫–æ–º–Ω", "3–∫", "—Ç—Ä–µ—Ö–∫–æ–º–Ω"
        if re.search(r'\b3[\s\-]?–∫(–æ–º–Ω(–∞—Ç–Ω–∞—è|–∞—Ç)?)?\b|\b—Ç—Ä[–µ—ë]—Ö[\s\-]?–∫–æ–º–Ω', search_lower):
            if '3' not in filters['rooms']:
                filters['rooms'].append('3')
        
        # 4 room patterns: "4 –∫–æ–º–Ω", "4–∫–æ–º–Ω", "4–∫", "—á–µ—Ç—ã—Ä–µ—Ö–∫–æ–º–Ω"
        if re.search(r'\b4[\s\-]?–∫(–æ–º–Ω(–∞—Ç–Ω–∞—è|–∞—Ç)?)?\b|\b—á–µ—Ç—ã—Ä[–µ—ë]—Ö[\s\-]?–∫–æ–º–Ω', search_lower):
            if '4' not in filters['rooms']:
                filters['rooms'].append('4')
    
    # üî• FIX: Clear search parameter if it was a pure room query
    # to avoid conflicting text search that returns 0 results
    if filters['rooms'] and filters['search']:
        import re
        search_lower = filters['search'].lower().strip()
        # Patterns for pure room queries (only room number, nothing else)
        room_only_patterns = [
            r'^\s*—Å—Ç—É–¥–∏[—è—é–∏]\s*$',  # Just "—Å—Ç—É–¥–∏—è"
            r'^\s*\d+[\s\-]?–∫(–æ–º–Ω(–∞—Ç–Ω–∞—è|–∞—Ç)?)?\s*$',  # Just "1–∫", "2 –∫–æ–º–Ω", etc.
            r'^\s*(–æ–¥–Ω–æ|–¥–≤—É[—Ö—Ç]|—Ç—Ä[–µ—ë]—Ö|—á–µ—Ç—ã—Ä[–µ—ë]—Ö)[\s\-]?–∫–æ–º–Ω(–∞—Ç–Ω–∞—è|–∞—Ç)?\s*$'  # Just "–æ–¥–Ω–æ–∫–æ–º–Ω", etc.
        ]
        if any(re.search(pattern, search_lower) for pattern in room_only_patterns):
            filters['search'] = ''  # Clear search to avoid text search interference
            print(f"‚úÖ Cleared search parameter after detecting pure room query: '{search_lower}'")
    
    # Build SQL WHERE conditions and parameters
    where_conditions = []
    params = {}
    
    # Price filters (–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–≤–æ–¥–∏—Ç –≤ –º–∏–ª–ª–∏–æ–Ω–∞—Ö)
    if filters.get('price_min'):
        try:
            params['price_min'] = float(filters['price_min']) * 1000000
            where_conditions.append('price >= :price_min')
        except:
            pass
    
    if filters.get('price_max'):
        try:
            params['price_max'] = float(filters['price_max']) * 1000000
            where_conditions.append('price <= :price_max')
        except:
            pass
    
    # Area filters
    if filters.get('area_min'):
        try:
            params['area_min'] = float(filters['area_min'])
            where_conditions.append('object_area >= :area_min')
        except:
            pass
    
    if filters.get('area_max'):
        try:
            params['area_max'] = float(filters['area_max'])
            where_conditions.append('object_area <= :area_max')
        except:
            pass
    
    # Floor filters
    if filters.get('floor_min'):
        try:
            params['floor_min'] = int(filters['floor_min'])
            where_conditions.append('object_min_floor >= :floor_min')
        except:
            pass
    
    if filters.get('floor_max'):
        try:
            params['floor_max'] = int(filters['floor_max'])
            where_conditions.append('object_min_floor <= :floor_max')
        except:
            pass
    
    # Floor options (–Ω–µ –ø–µ—Ä–≤—ã–π/–Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç—Ç–∞–∂)
    if filters.get('floor_options'):
        floor_option_conditions = []
        for option in filters['floor_options']:
            if option == 'not_first':
                floor_option_conditions.append('object_min_floor > 1')
            elif option == 'not_last':
                # Not on last floor: floor < total_floors
                floor_option_conditions.append('object_min_floor < object_max_floor')
            elif option == 'last':
                # Last floor: floor == total_floors
                floor_option_conditions.append('object_min_floor = object_max_floor')
        
        if floor_option_conditions:
            where_conditions.append(f"({' AND '.join(floor_option_conditions)})")
    
    # Cashback only filter (—Ç–æ–ª—å–∫–æ –æ–±—ä–µ–∫—Ç—ã —Å –∫–µ—à–±–µ–∫–æ–º)
    if filters.get('cashback_only'):
        where_conditions.append('(min_rate > 0 AND min_rate IS NOT NULL)')
    
    # Rooms filter - support various formats
    if filters.get('rooms'):
        room_conditions = []
        for room_filter in filters['rooms']:
            if isinstance(room_filter, str):
                normalized = room_filter.lower().strip()
                if normalized in ['—Å—Ç—É–¥–∏—è', '0', 'studio']:
                    room_conditions.append('object_rooms = 0')
                elif normalized.endswith('-–∫–æ–º–Ω'):
                    try:
                        room_num = int(normalized.split('-')[0])
                        room_conditions.append(f'object_rooms = {room_num}')
                    except:
                        pass
                elif normalized in ['4+', '4+-–∫–æ–º–Ω']:
                    room_conditions.append('object_rooms >= 4')
                elif normalized.isdigit():
                    room_conditions.append(f'object_rooms = {int(normalized)}')
        
        if room_conditions:
            where_conditions.append(f"({' OR '.join(room_conditions)})")
    
    # Building types filter (—ç—Ç–∞–∂–Ω–æ—Å—Ç—å –¥–æ–º–∞)
    if filters.get('building_types'):
        building_conditions = []
        for building_type in filters['building_types']:
            if building_type == '–º–∞–ª–æ—ç—Ç–∞–∂–Ω—ã–π':
                building_conditions.append('object_max_floor <= 5')
            elif building_type == '—Å—Ä–µ–¥–Ω–µ—ç—Ç–∞–∂–Ω—ã–π':
                building_conditions.append('(object_max_floor >= 6 AND object_max_floor <= 12)')
            elif building_type == '–º–Ω–æ–≥–æ—ç—Ç–∞–∂–Ω—ã–π':
                building_conditions.append('object_max_floor >= 13')
        
        if building_conditions:
            where_conditions.append(f"({' OR '.join(building_conditions)})")
    
    # Districts filter (array)
    if filters.get('districts'):
        district_conditions = []
        for idx, district in enumerate(filters['districts']):
            param_name = f'district_{idx}'
            params[param_name] = f'%{district.lower()}%'
            district_conditions.append(f'LOWER(address_locality_name) LIKE :{param_name}')
        
        if district_conditions:
            where_conditions.append(f"({' OR '.join(district_conditions)})")
    
    # Single district filter
    if filters.get('district'):
        params['district'] = f'%{filters["district"].lower()}%'
        where_conditions.append('LOWER(address_locality_name) LIKE :district')
    
    # Developers filter (array)
    if filters.get('developers'):
        developer_conditions = []
        for idx, developer in enumerate(filters['developers']):
            param_name = f'developer_{idx}'
            params[param_name] = f'%{developer.lower()}%'
            developer_conditions.append(f'LOWER(developer_name) LIKE :{param_name}')
        
        if developer_conditions:
            where_conditions.append(f"({' OR '.join(developer_conditions)})")
    
    # Single developer filter
    if filters.get('developer'):
        params['developer'] = f'%{filters["developer"].lower()}%'
        where_conditions.append('LOWER(developer_name) LIKE :developer')
    
    # Residential complex filter
    if filters.get('residential_complex'):
        params['complex'] = f'%{filters["residential_complex"].lower()}%'
        where_conditions.append('LOWER(complex_name) LIKE :complex')
    
    # Building filter
    if filters.get('building'):
        params['building'] = f'%{filters["building"].lower()}%'
        where_conditions.append('LOWER(complex_building_name) LIKE :building')
    
    # Completion year filters
    if filters.get('completion') or filters.get('delivery_years'):
        years = filters.get('completion') or filters.get('delivery_years')
        year_conditions = []
        for year in years:
            if year != '–°–¥–∞–Ω':
                try:
                    # Convert string to integer for proper SQL comparison
                    year_int = int(year)
                    year_conditions.append(f'complex_building_end_build_year = {year_int}')
                except (ValueError, TypeError):
                    pass
        
        if year_conditions:
            where_conditions.append(f"({' OR '.join(year_conditions)})")
    
    # Object classes filter
    if filters.get('object_classes'):
        class_conditions = []
        for idx, obj_class in enumerate(filters['object_classes']):
            param_name = f'class_{idx}'
            params[param_name] = f'%{obj_class.lower()}%'
            class_conditions.append(f'LOWER(complex_object_class_display_name) LIKE :{param_name}')
        
        if class_conditions:
            where_conditions.append(f"({' OR '.join(class_conditions)})")
    
    # Renovation filter
    if filters.get('renovation'):
        renovation_conditions = []
        for idx, renovation in enumerate(filters['renovation']):
            param_name = f'renovation_{idx}'
            params[param_name] = f'%{renovation.lower()}%'
            renovation_conditions.append(f'LOWER(renovation_display_name) LIKE :{param_name}')
        
        if renovation_conditions:
            where_conditions.append(f"({' OR '.join(renovation_conditions)})")
    
    # Features filter
    if filters.get('features'):
        feature_conditions = []
        for feature in filters['features']:
            if feature == 'accreditation':
                # Filter by bank accreditation
                feature_conditions.append('complex_has_accreditation = true')
            elif feature == 'green_mortgage':
                # Filter by green mortgage availability
                feature_conditions.append('complex_has_green_mortgage = true')
            else:
                # For other features, search in description
                idx = len(params)
                param_name = f'feature_{idx}'
                params[param_name] = f'%{feature.lower()}%'
                feature_conditions.append(f'LOWER(description) LIKE :{param_name}')
        
        if feature_conditions:
            where_conditions.append(f"({' OR '.join(feature_conditions)})")
    
    # Building released filter (—Å–¥–∞–Ω/–Ω–µ —Å–¥–∞–Ω)
    if filters.get('building_released'):
        released_conditions = []
        now = datetime.now()
        current_year = now.year
        current_quarter = (now.month - 1) // 3 + 1
        
        for status in filters['building_released']:
            if status.lower() in ['—Å–¥–∞–Ω', 'delivered', 'ready']:
                released_conditions.append(f'''(
                    complex_end_build_year < {current_year} OR 
                    (complex_end_build_year = {current_year} AND 
                     (complex_end_build_quarter IS NULL OR complex_end_build_quarter < {current_quarter})) OR
                    complex_building_end_build_year < {current_year} OR
                    (complex_building_end_build_year = {current_year} AND 
                     (complex_building_end_build_quarter IS NULL OR complex_building_end_build_quarter < {current_quarter}))
                )''')
            elif status.lower() in ['—Å—Ç—Ä–æ–∏—Ç—Å—è', 'under_construction', 'building']:
                released_conditions.append(f'''(
                    complex_end_build_year > {current_year} OR
                    (complex_end_build_year = {current_year} AND 
                     (complex_end_build_quarter IS NULL OR complex_end_build_quarter >= {current_quarter})) OR
                    complex_building_end_build_year > {current_year} OR
                    (complex_building_end_build_year = {current_year} AND 
                     (complex_building_end_build_quarter IS NULL OR complex_building_end_build_quarter >= {current_quarter}))
                )''')
        
        if released_conditions:
            where_conditions.append(f"({' OR '.join(released_conditions)})")
    
    # Building floors filters
    if filters.get('building_floors_min'):
        try:
            params['building_floors_min'] = int(filters['building_floors_min'])
            where_conditions.append('object_max_floor >= :building_floors_min')
        except:
            pass
    
    if filters.get('building_floors_max'):
        try:
            params['building_floors_max'] = int(filters['building_floors_max'])
            where_conditions.append('object_max_floor <= :building_floors_max')
        except:
            pass
    
    # Build year filters
    if filters.get('build_year_min'):
        try:
            params['build_year_min'] = int(filters['build_year_min'])
            where_conditions.append('(complex_end_build_year >= :build_year_min OR complex_building_end_build_year >= :build_year_min)')
        except:
            pass
    
    if filters.get('build_year_max'):
        try:
            params['build_year_max'] = int(filters['build_year_max'])
            where_conditions.append('(complex_end_build_year <= :build_year_max OR complex_building_end_build_year <= :build_year_max)')
        except:
            pass
    
    # Regional filters
    regional_conditions = []
    
    if filters.get('regions'):
        for idx, region in enumerate(filters['regions']):
            param_name = f'region_{idx}'
            params[param_name] = f'%{region.lower()}%'
            regional_conditions.append(f'LOWER(address_display_name) LIKE :{param_name}')
    
    if filters.get('region'):
        params['region'] = f'%{filters["region"].lower()}%'
        regional_conditions.append('LOWER(address_display_name) LIKE :region')
    
    # City filtering - use city_id instead of inefficient LIKE on address_display_name
    city_context = resolve_city_context(city_id=filters.get('city_id'), city_slug=filters.get('city'))
    if city_context:
        filters['city_id'] = city_context.id
        filters['city_name'] = city_context.name
        params['city_id'] = city_context.id
        where_conditions.append('city_id = :city_id')
    
    if regional_conditions:
        where_conditions.append(f"({' OR '.join(regional_conditions)})")
    
    # Search filter (multiple fields including address/street)
    if filters.get('search'):
        params['search'] = f'%{filters["search"].lower()}%'
        where_conditions.append('''(
            LOWER(address_display_name) LIKE :search OR
            LOWER(developer_name) LIKE :search OR
            LOWER(complex_name) LIKE :search OR
            LOWER(address_locality_name) LIKE :search OR
            LOWER(complex_building_name) LIKE :search OR
            LOWER(COALESCE(parsed_street, \'\')) LIKE :search OR
            LOWER(COALESCE(address, \'\')) LIKE :search
        )''')
    
    return where_conditions, params, filters

def get_developers_list():
    """‚ö° OPTIMIZED: Get list of unique developers from database"""
    from models import Developer
    developers = Developer.query.filter(Developer.name != None, Developer.name != '').all()
    # Deduplicate names using dict, then create dict objects for template
    unique_names = {}
    for d in developers:
        if d.name and d.name not in unique_names:
            unique_names[d.name] = {
                'id': d.id,
                'name': d.name,
                'slug': d.slug if hasattr(d, 'slug') and d.slug else d.name.lower().replace(' ', '-')
            }
    return sorted(unique_names.values(), key=lambda x: x['name'])

def get_districts_list():
    """‚ö° OPTIMIZED: Get list of unique districts from database"""
    from models import District
    districts = District.query.filter(District.name != None, District.name != '').all()
    # Deduplicate names using dict, then create dict objects for template
    unique_names = {}
    for d in districts:
        if d.name and d.name not in unique_names:
            unique_names[d.name] = {
                'id': d.id,
                'name': d.name,
                'slug': d.slug if hasattr(d, 'slug') and d.slug else d.name.lower().replace(' ', '-')
            }
    return sorted(unique_names.values(), key=lambda x: x['name'])

def sort_properties(properties, sort_type):
    """Sort properties by specified criteria with None safety"""
    if sort_type == 'price_asc':
        return sorted(properties, key=lambda x: x.get('price') or 0)
    elif sort_type == 'price_desc':
        return sorted(properties, key=lambda x: x.get('price') or 0, reverse=True)
    elif sort_type == 'cashback_desc':
        return sorted(properties, key=lambda x: calculate_cashback(x.get('price') or 0), reverse=True)
    elif sort_type == 'area_asc':
        return sorted(properties, key=lambda x: x.get('area') or 0)
    elif sort_type == 'area_desc':
        return sorted(properties, key=lambda x: x.get('area') or 0, reverse=True)
    else:
        return properties

def get_similar_properties(property_id, district, limit=3):
    """Get similar properties in the same district"""
    properties = load_properties()
    similar = []
    
    for prop in properties:
        if str(prop['id']) != str(property_id) and prop['district'] == district:
            similar.append(prop)
            if len(similar) >= limit:
                break
    
    return similar


# ‚úÖ –ö–†–ò–¢–ò–ß–ù–û: –û—Ç–∫–ª—é—á–∞–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ HTML –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
@app.after_request
def add_security_headers(response):
    """Add security and no-cache headers"""
    # HSTS: Force HTTPS for 1 year (31536000 seconds)
    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains; preload'
    
    # Prevent MIME type sniffing
    response.headers['X-Content-Type-Options'] = 'nosniff'
    
    # Prevent clickjacking (allow same origin for iframes)
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    
    # XSS Protection (legacy but still useful for older browsers)
    response.headers['X-XSS-Protection'] = '1; mode=block'
    
    # Referrer policy for privacy
    response.headers['Referrer-Policy'] = 'strict-origin-when-cross-origin'
    
    # Content Security Policy (basic, can be enhanced later)
    response.headers['Permissions-Policy'] = 'geolocation=(), microphone=(), camera=()'
    
    # No-cache headers for HTML pages to prevent stale content
    if response.content_type and 'text/html' in response.content_type:
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, max-age=0'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
    
    return response

# Routes
@app.route('/')
def index(city_slug=None):
    """Home page with featured content"""
    # If accessed via root URL '/', redirect to city-prefixed homepage
    if city_slug is None and request.path == '/':
        from seo_redirects import get_redirect_city_slug
        detected_slug = get_redirect_city_slug()
        return redirect(f'/{detected_slug}/', code=301)
    
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=city_slug or request.args.get('city')
    )

    # ‚ö° OPTIMIZATION: Removed global load_properties() - replaced with targeted queries
    
    # ‚úÖ MIGRATED: Load residential complexes using normalized tables
    exclusive_complexes = []
    try:
        # Get active residential complexes with property stats
        # ‚úÖ OPTIMIZED: Filter by city in SQL instead of Python
        city_id = current_city.id if current_city else None
        complexes_orm = ResidentialComplexRepository.get_all_active(limit=20, city_id=city_id)
        
        # Get aggregated property stats for all complexes (single query, no N+1)
        # ‚úÖ OPTIMIZED: Only load stats for complexes in current city
        property_stats = PropertyRepository.get_all_property_stats(city_id=city_id)









        
        # Build list of complexes with stats
        complexes_with_stats = []
        for complex_obj in complexes_orm:
            stats = property_stats.get(complex_obj.id, {})
            
            # Skip complexes without properties
            if not stats or stats.get('total_count', 0) == 0:
                continue
            
            # Calculate sorting keys
            end_year = complex_obj.end_build_year or 9999
            end_quarter = complex_obj.end_build_quarter or 4
            is_future = (end_year == 2025 and end_quarter == 4)
            price_from = stats.get('min_price', 0)
            
            complexes_with_stats.append({
                'complex': complex_obj,
                'stats': stats,
                'sort_future': 1 if is_future else 0,
                'sort_price': price_from
            })
        
        # Sort: ready complexes first, then by price
        complexes_with_stats.sort(key=lambda x: (x['sort_future'], x['sort_price']))
        
        # Take top 6 complexes
        for item in complexes_with_stats[:6]:
            complex_obj = item['complex']
            stats = item['stats']
            # ‚úÖ MIGRATED: Format complex data from ORM objects
            # Photo loading strategy: complex.main_image ‚Üí complex.gallery_images ‚Üí properties.sample_photos ‚Üí no-photo.jpg
            photos_list = []
            main_photo = None
            
            # Try complex main_image first
            if complex_obj.main_image:
                main_photo = complex_obj.main_image
                photos_list = [main_photo]
            
            # Try complex gallery_images
            if complex_obj.gallery_images:
                try:
                    photos_raw = json.loads(complex_obj.gallery_images) if isinstance(complex_obj.gallery_images, str) else complex_obj.gallery_images
                    if photos_raw and isinstance(photos_raw, list) and len(photos_raw) > 0:
                        photos_list = photos_raw[:3]
                        main_photo = photos_list[0]
                except:
                    pass
            
            # Fallback: use photos from properties
            if not photos_list or len(photos_list) == 0:
                sample_photos = stats.get('sample_photos', [])
                if sample_photos and len(sample_photos) > 0:
                    photos_list = sample_photos[:3]
                    main_photo = photos_list[0]
            
            # Final fallback: no-photo.jpg
            if not main_photo:
                main_photo = '/static/images/no-photo.jpg'
            if not photos_list or len(photos_list) == 0:
                photos_list = [main_photo]
            
            # Determine completion status
            current_year = 2025
            current_quarter = 4
            
            is_completed = False
            completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω'
            
            if complex_obj.end_build_year and complex_obj.end_build_quarter:
                build_year = int(complex_obj.end_build_year)
                build_quarter = int(complex_obj.end_build_quarter)
                
                if build_year < current_year:
                    is_completed = True
                elif build_year == current_year and build_quarter < current_quarter:
                    is_completed = True
                
                quarter_names = {1: 'I', 2: 'II', 3: 'III', 4: 'IV'}
                quarter = quarter_names.get(build_quarter, build_quarter)
                completion_date = f"{quarter} –∫–≤. {build_year} –≥."
            
            # Determine room types based on area range
            room_types = []
            area_from = stats.get('min_area', 0)
            area_to = stats.get('max_area', 0)
            
            if area_from and area_to:
                if area_from < 35:
                    room_types.append("–°—Ç—É–¥–∏–∏")
                if area_from <= 45 and area_to >= 35:
                    room_types.append("1–ö")
                if area_to >= 55:
                    room_types.append("2-3–ö")
            else:
                room_types = ["–°—Ç—É–¥–∏–∏", "1-3–ö"]
            
            room_type_display = " - ".join(room_types) if room_types else "–†–∞–∑–ª–∏—á–Ω—ã–µ"
            
            # Safe image handling
            safe_images = photos_list if photos_list and len(photos_list) > 0 else ['/static/images/no-photo.jpg']
            safe_main_image = safe_images[0] if safe_images else '/static/images/no-photo.jpg'
            
            # Clean address - remove "–°–æ—á–∏" prefix
            clean_address = complex_obj.sales_address or stats.get('sample_address', '') or ''
            if clean_address and clean_address.startswith('–°–æ—á–∏, '):
                clean_address = clean_address[6:]
            elif clean_address and clean_address.startswith('–≥. –°–æ—á–∏, '):
                clean_address = clean_address[9:]
            
            # Cashback from admin panel
            cashback_percent = float(complex_obj.cashback_rate) if complex_obj.cashback_rate else 5.0
            
            # Calculate cashback amount based on max price
            max_price = stats.get('max_price', 0)
            cashback_amount = int(max_price * (cashback_percent / 100)) if max_price else 0
            
            complex_dict = {
                'id': complex_obj.id,
                'name': complex_obj.name or '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è',
                'price_from': int(stats.get('min_price', 0)),
                'price_to': int(stats.get('max_price', 0)),
                'area_from': int(stats.get('min_area', 0)),
                'area_to': int(stats.get('max_area', 0)),
                'room_type': room_type_display,
                'address': clean_address,
                'developer': complex_obj.developer.name if complex_obj.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
                'photos': safe_images,
                'images': safe_images,
                'image': safe_main_image,
                'main_photo': safe_main_image,
                'main_image': safe_main_image,
                'apartments_count': stats.get('total_count', 0),
                'completion_date': completion_date,
                'is_completed': is_completed,
                'cashback_amount': int(cashback_amount),
                'cashback_percent': float(cashback_percent),
                'cashback_max': int(cashback_amount),
                'buildings_count': stats.get('buildings_count', 1)
            }
            exclusive_complexes.append(complex_dict)
            
        print(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(exclusive_complexes)} —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã—Ö –ñ–ö –¥–ª—è –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã")
        
    except Exception as e:
        print(f"‚ùå Error loading exclusive complexes: {e}")
        import traceback
        traceback.print_exc()
        exclusive_complexes = []
    
    complexes = load_residential_complexes()  # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å–æ —Å—Ç–∞—Ä—ã–º –∫–æ–¥–æ–º
    developers_file = os.path.join('data', 'developers.json')
    with open(developers_file, 'r', encoding='utf-8') as f:
        developers = json.load(f)
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç–∞—Ç—å–∏ –±–ª–æ–≥–∞ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    blog_articles = []
    try:
        from models import BlogPost
        from sqlalchemy import desc
        
        # –ü–æ–ª—É—á–∞–µ–º –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç–∞—Ç—å–∏ —Ç–æ–ª—å–∫–æ –∏–∑ BlogPost —Å –∫–∞—Ç–µ–≥–æ—Ä–∏–µ–π
        blog_posts = BlogPost.query.filter_by(status='published').order_by(desc(BlogPost.published_at)).limit(4).all()
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –µ–¥–∏–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —à–∞–±–ª–æ–Ω–∞
        for post in blog_posts:
            blog_articles.append({
                'title': post.title,
                'slug': post.slug,
                'excerpt': post.excerpt or '–ò–Ω—Ç–µ—Ä–µ—Å–Ω–∞—è —Å—Ç–∞—Ç—å—è –æ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏',
                'featured_image': post.featured_image or 'https://images.unsplash.com/photo-1560518883-ce09059eeffa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80',
                'published_at': post.published_at or post.created_at,
                'reading_time': getattr(post, 'reading_time', 5),
                'category': post.category or '–ù–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å',
                'url': f'/blog/{post.slug}'
            })
        
    except Exception as e:
        print(f"Error loading blog articles for index: {e}")
        # Fallback —Å—Ç–∞—Ç—å–∏ –µ—Å–ª–∏ –±–∞–∑–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞
        blog_articles = [
            {
                'title': '–ò–ø–æ—Ç–µ–∫–∞ –º—É—Ä–∞–±–∞—Ö–∞: —á—Ç–æ —ç—Ç–æ –∏ –∫–∞–∫ –æ—Ñ–æ—Ä–º–∏—Ç—å',
                'slug': 'ipoteka-murabaha',
                'excerpt': '–ò–ø–æ—Ç–µ–∫–∞ –º—É—Ä–∞–±–∞—Ö–∞ ‚Äî —ç—Ç–æ –∏—Å–ª–∞–º—Å–∫–∞—è –∏–ø–æ—Ç–µ–∫–∞ –±–µ–∑ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤, –≥–¥–µ –±–∞–Ω–∫ –ø–æ–∫—É–ø–∞–µ—Ç –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å –∏ –ø—Ä–æ–¥–∞–µ—Ç –µ–µ –∫–ª–∏–µ–Ω—Ç—É —Å –Ω–∞—Ü–µ–Ω–∫–æ–π.',
                'featured_image': 'https://images.unsplash.com/photo-1560518883-ce09059eeffa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80',
                'published_at': datetime.now(),
                'reading_time': 5,
                'category': '–ò–ø–æ—Ç–µ–∫–∞',
                'url': '/blog/ipoteka-murabaha'
            }
        ]
    
    # ‚úÖ MIGRATED: –ü–æ–ª—É—á–∞–µ–º 6 —Å–ª—É—á–∞–π–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ normalized Property table
    try:
        import random
        from models import Property
        
        # Get random featured properties using PropertyRepository
        # ‚úÖ SECURITY FIX: Always filter by city_id to prevent cross-city data leakage
        all_properties = PropertyRepository.get_all_active(
            limit=100,
            filters={
                'city_id': current_city.id,  # Restored: prevent cross-city data leakage
                'min_price': 1  # Only properties with price > 0
            }
        )
        
        # Filter properties with area and residential complex
        # ‚úÖ FIX: Make gallery_images and coordinates optional
        # (city_id=1 has no coordinates, but still show properties)
        valid_properties = [
            p for p in all_properties
            if p.area and p.residential_complex
        ]
        
        # Shuffle and limit to 8 properties
        random.shuffle(valid_properties)
        result = valid_properties[:8]
        
        featured_properties = []
        for prop_orm in result:
            try:
                # Parse gallery images
                main_image = 'https://via.placeholder.com/400x300?text=–§–æ—Ç–æ+—Å–∫–æ—Ä–æ'
                gallery = [main_image]
                
                if prop_orm.gallery_images:
                    try:
                        photos_raw = json.loads(prop_orm.gallery_images)
                        if photos_raw and isinstance(photos_raw, list) and len(photos_raw) > 0:
                            main_image = photos_raw[0]
                            gallery = photos_raw[:5]
                    except:
                        pass
                
                # Property details
                rooms = int(prop_orm.rooms or 0)
                area = float(prop_orm.area or 0)
                price = int(prop_orm.price or 0)
                
                # Floor info
                floor_min = int(prop_orm.floor or 1)
                floor_max = int(prop_orm.total_floors or floor_min)
                floor_text = f"{floor_min}/{floor_max} —ç—Ç."
                
                # Room type
                room_type = "–°—Ç—É–¥–∏—è" if rooms == 0 else f"{rooms}-–∫–æ–º–Ω"
                
                # Completion date and status
                current_year = 2025
                build_quarter = prop_orm.residential_complex.end_build_quarter if prop_orm.residential_complex else None
                build_year = prop_orm.residential_complex.end_build_year if prop_orm.residential_complex else None
                
                if build_year and build_quarter:
                    quarter_text = f"{build_quarter}–∫–≤. {build_year}–≥."
                    status_text = "–°–¥–∞–Ω" if build_year < current_year or (build_year == current_year and build_quarter <= 1) else "–°—Ç—Ä–æ–∏—Ç—Å—è"
                else:
                    quarter_text = "–£—Ç–æ—á–Ω—è–µ—Ç—Å—è"
                    status_text = "–°—Ç—Ä–æ–∏—Ç—Å—è"
                
                # Get complex info
                complex_obj = prop_orm.residential_complex
                lat = float(prop_orm.latitude) if prop_orm.latitude else None
                lng = float(prop_orm.longitude) if prop_orm.longitude else None
                
                # Build property dict
                prop = {
                    'id': prop_orm.inner_id or str(prop_orm.id),
                    'price': price,
                    'area': area,
                    'rooms': rooms,
                    'title': f"{room_type}, {area} –º¬≤, {floor_text}",
                    'complex': complex_obj.name if complex_obj else '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω',
                    'developer': prop_orm.developer.name if prop_orm.developer else '',
                    'address': prop_orm.address or '',
                    'image': main_image,
                    'gallery': gallery,
                    'cashback': int(price * 0.02),
                    'cashback_amount': int(price * 0.02),
                    'completion_date': quarter_text,
                    'deal_type': prop_orm.deal_type if hasattr(prop_orm, 'deal_type') else 'sale',
                    'complex_building_status': getattr(complex_obj, 'status', None) if complex_obj else None,
                    'complex_building_end_build_year': getattr(complex_obj, 'end_build_year', None) if complex_obj else None,
                    'cashback': int((price or 0) * (float(complex_obj.cashback_rate or 3.5) / 100)) if complex_obj else int((price or 0) * 0.035),
                    'cashback_rate': float(complex_obj.cashback_rate) if complex_obj and complex_obj.cashback_rate else 3.5,
                    'latitude': lat,
                    'longitude': lng,
                    'complex_name': complex_obj.name if complex_obj else '',
                    'floor_info': floor_text
                }
                featured_properties.append(prop)
                if len(featured_properties) >= 6:
                    break
                
            except Exception as e:
                prop_id = getattr(prop_orm, "id", "unknown"); print(f"Error processing property {prop_id}: {e}")
                continue
        
        if featured_properties:
            print(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(featured_properties)} —Ä–µ–∞–ª—å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –±–∞–∑—ã")
        else:
            raise Exception("No properties loaded")
            
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ–∞–ª—å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤: {e}")
        # Fallback –∫ —Å—Ç–∞—Ä—ã–º –¥–∞–Ω–Ω—ã–º
        # ‚ö° OPTIMIZATION: Direct query instead of loading all properties
        fallback_props = PropertyRepository.get_all_active(limit=6, sort_by='price', sort_order='desc')
        featured_properties = []
        for prop_orm in fallback_props:
            price = prop_orm.price or 0
            featured_properties.append({
                'price': price,
                'cashback_amount': int(price * 0.02),
                'complex_id': prop_orm.complex_id,
                'residential_complex': prop_orm.residential_complex.name if prop_orm.residential_complex else ''
            })
        for prop in featured_properties:
            prop['cashback'] = calculate_cashback(
                prop['price'],
                complex_id=prop.get('complex_id'),
                complex_name=prop.get('residential_complex')
            )
    
    # Get districts with statistics
    districts_data = {}
    for complex in complexes:
        district = complex['district']
        if district not in districts_data:
            districts_data[district] = {
                'name': district,
                'complexes_count': 0,
                'price_from': float('inf'),
                'apartments_count': 0
            }
        districts_data[district]['complexes_count'] += 1
        complex_price = complex.get('price_from') or 0
        if complex_price > 0:  # Only update if we have a valid price
            districts_data[district]['price_from'] = min(districts_data[district]['price_from'], complex_price)
        districts_data[district]['apartments_count'] += complex.get('apartments_count', 0) or 0
    
    districts = sorted(districts_data.values(), key=lambda x: x['complexes_count'], reverse=True)[:8]
    
    # Get featured developers (top 3 with most complexes)
    featured_developers = []
    for developer in developers[:3]:
        developer_complexes = [c for c in complexes if c.get('developer_id') == developer['id']]
        # ‚ö° OPTIMIZATION: Direct query by developer_id instead of loading all properties
        complex_ids = [c['id'] for c in developer_complexes]
        developer_properties_count = Property.query.filter(Property.complex_id.in_(complex_ids)).count() if complex_ids else 0
        
        # ‚ö° Safe query for price_from - prevents AttributeError if no properties found
        first_prop = Property.query.filter(Property.complex_id.in_(complex_ids), Property.price > 0).order_by(Property.price).first() if complex_ids else None
        
        developer_info = {
            'id': developer['id'],
            'name': developer['name'],
            'complexes_count': len(developer_complexes),
            'apartments_count': developer_properties_count,
            'price_from': first_prop.price if first_prop else 0,
            'max_cashback': max([c.get('cashback_percent', 5) for c in developer_complexes]) if developer_complexes else 5
        }
        featured_developers.append(developer_info)
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –±–ª–æ–≥–∞ –¥–ª—è –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    blog_categories = []
    try:
        from models import Category
        blog_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
    except Exception as e:
        print(f"Error loading blog categories for index: {e}")
    
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –¥–ª—è hero —Å–µ–∫—Ü–∏–∏
    managers = []
    try:
        from models import Manager
        managers = Manager.query.filter_by(is_active=True).limit(8).all()
    except Exception as e:
        print(f"Error loading managers for index: {e}")
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–æ–≤ —Å –∞–∫—Ç–∏–≤–Ω—ã–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏ –≤ —Ç–µ–∫—É—â–µ–º –≥–æ—Ä–æ–¥–µ –¥–ª—è –±–µ–≥—É—â–µ–π —Å—Ç—Ä–æ–∫–∏
    city_developers = []
    try:
        from models import Developer, Property
        from sqlalchemy import func, distinct
        
        city_id = current_city.id if current_city else 1
        
        # –ü–æ–ª—É—á–∞–µ–º –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–æ–≤ —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –≤ —Ç–µ–∫—É—â–µ–º –≥–æ—Ä–æ–¥–µ
        developers_with_counts = db.session.query(
            Developer,
            func.count(distinct(Property.id)).label('property_count')
        ).join(
            Property, Property.developer_id == Developer.id
        ).filter(
            Property.city_id == city_id,
            Property.is_active == True,
            Developer.is_active == True
        ).group_by(
            Developer.id
        ).order_by(
            func.count(distinct(Property.id)).desc()
        ).limit(15).all()
        
        city_developers = [dev for dev, count in developers_with_counts]
        print(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(city_developers)} –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–æ–≤ –¥–ª—è –≥–æ—Ä–æ–¥–∞ {city_id}")
    except Exception as e:
        print(f"Error loading developers for index: {e}")
    
    return render_template('index.html',
                             current_city=current_city,
                         featured_properties=featured_properties,
                         districts=districts,
                         featured_developers=featured_developers,
                         city_developers=city_developers,
                         residential_complexes=complexes[:3],
                         exclusive_complexes=exclusive_complexes,
                         blog_articles=blog_articles,
                         blog_categories=blog_categories,
                         managers=managers)

@app.route('/novostrojki')
@app.route('/kvartiry')
@app.route('/properties')
def properties():
    """Legacy route - redirects to city-based URL"""
    return redirect_to_city_based('properties_city')

@app.route('/object/<property_id>')
def property_detail(property_id):
    """Legacy route - redirects to city-based URL with correct city (supports inner_id and database ID)"""
    # Resolve property to get correct ID
    property_obj, resolved_id = resolve_property_by_identifier(property_id)
    
    if property_obj:
        db_id = property_obj.id
    else:
        # Try as integer for backward compatibility
        try:
            db_id = int(property_id)
        except (ValueError, TypeError):
            db_id = None
    
    # Get city from property's actual location
    city_slug = get_city_slug_for_resource('property', resource_id=db_id) if db_id else None
    if not city_slug:
        city_slug = get_redirect_city_slug()  # fallback to session/default
    
    return redirect(
        url_for('property_detail_city', city_slug=city_slug, property_id=db_id or property_id),
        code=301
    )

@app.route('/residential_complex/<int:complex_id>')
@app.route('/residential-complex/<int:complex_id>')  # Support both formats
@app.route('/residential-complex/<complex_name>')  # Support name-based routing
@app.route('/zk/<slug>')  # New SEO-friendly format: /zk/zhk-kislorod
def residential_complex_detail(complex_id=None, complex_name=None, slug=None):
    """Legacy route - redirects to city-based URL with correct city"""
    from models import ResidentialComplex
    
    # Get city from complex's actual location and retrieve slug if needed
    city_slug = None
    complex_slug = slug  # Use provided slug if available
    
    if complex_id:
        # Look up complex to get both city and slug
        complex_obj = ResidentialComplex.query.get(complex_id)
        if complex_obj:
            city_slug = complex_obj.city.slug if complex_obj.city else None
            complex_slug = complex_obj.slug  # Get slug from database
    elif slug:
        city_slug = get_city_slug_for_resource('complex', slug=slug)
    
    if not city_slug:
        city_slug = get_redirect_city_slug()  # fallback to session/default
    
    return redirect(
        url_for('residential_complex_by_slug_city', city_slug=city_slug, slug=complex_slug),
        code=301
    )

@app.route('/developer/<int:developer_id>')
def developer_detail(developer_id):
    """Individual developer page"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    try:
        # Load developer data from JSON file instead of DB to avoid conflicts
        with open('data/developers.json', 'r', encoding='utf-8') as f:
            developers_data = json.load(f)
        
        # Find developer by ID
        developer = None
        for dev in developers_data:
            if dev['id'] == developer_id:
                developer = dev
                break
        
        if not developer:
            return "–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω", 404
        
        # Add missing template fields for new developers
        if 'total_apartments_sold' not in developer:
            developer['total_apartments_sold'] = 150
        if 'projects_completed' not in developer:
            developer['projects_completed'] = 8
        if 'years_experience' not in developer:
            developer['years_experience'] = 10
        if 'rating' not in developer:
            developer['rating'] = 4.5
        if 'construction_technology' not in developer:
            developer['construction_technology'] = '–ú–æ–Ω–æ–ª–∏—Ç–Ω–æ-–∫–∞—Ä–∫–∞—Å–Ω–∞—è'
        if 'warranty_years' not in developer:
            developer['warranty_years'] = 5
        if 'advantages' not in developer:
            developer['advantages'] = [
                '–ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ',
                '–°–æ–±–ª—é–¥–µ–Ω–∏–µ —Å—Ä–æ–∫–æ–≤ —Å–¥–∞—á–∏',
                '–†–∞–∑–≤–∏—Ç–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞',
                '–í—ã–≥–æ–¥–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –ø–æ–∫—É–ø–∫–∏'
            ]
        
        # Get all complexes by this developer
        complexes = load_residential_complexes()
        developer_complexes = [c for c in complexes if c.get('developer_id') == developer_id or c.get('developer') == developer['name']]
        
        # ‚ö° OPTIMIZATION: Direct query by developer instead of loading all properties
        developer_properties = Property.query.filter_by(developer_id=developer_id).limit(100).all()
        # Convert to dict format for template compatibility
        developer_properties = [
            {
                'inner_id': p.inner_id,
                'price': p.price,
                'area': p.area,
                'rooms': p.rooms,
                'floor': p.floor,
                'total_floors': p.total_floors,
                'address': p.address,
                'developer': developer['name']
            }
            for p in developer_properties
        ]
        
        return render_template('developer_detail.html',
                             developer=developer,
                             complexes=developer_complexes,
                             properties=developer_properties)
    except Exception as e:
        print(f"ERROR in developer_detail route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

def crop_watermark(image_url, crop_bottom_percent=8):
    """
    Crop watermark from image by removing bottom portion
    
    Args:
        image_url: URL of the image to crop
        crop_bottom_percent: Percentage of image height to crop from bottom (default 8%)
    
    Returns:
        PIL Image object with watermark cropped
    """
    try:
        # Download image
        response = requests.get(image_url, timeout=10)
        response.raise_for_status()
        
        # Open image
        img = Image.open(io.BytesIO(response.content))
        
        # Calculate crop dimensions
        width, height = img.size
        crop_height = int(height * (crop_bottom_percent / 100))
        new_height = height - crop_height
        
        # Crop image (remove bottom portion with watermark)
        cropped_img = img.crop((0, 0, width, new_height))
        
        return cropped_img
    except Exception as e:
        print(f"Error cropping watermark from {image_url}: {e}")
        return None

def generate_qr_code(url):
    """Generate QR code for given URL and return as base64 string"""
    try:
        # Create QR code instance
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        
        # Add data to QR code
        qr.add_data(url)
        qr.make(fit=True)
        
        # Create image
        qr_image = qr.make_image(fill_color="black", back_color="white")
        
        # Convert to base64
        buffer = io.BytesIO()
        qr_image.save(buffer, format='PNG')
        qr_base64 = base64.b64encode(buffer.getvalue()).decode()
        
        return qr_base64
    except Exception as e:
        print(f"Error generating QR code: {e}")
        return None

@app.route("/object/<property_id>/pdf")
def property_pdf(property_id):
    """Property PDF card page with QR code - accepts both inner_id and database ID"""
    # Resolve property by inner_id first (most common from presentations)
    property_obj, resolved_id = resolve_property_by_identifier(property_id)
    
    if property_obj:
        property_data = get_property_by_id(property_obj.id)
    else:
        property_data = None
    
    if not property_data:
        return redirect(url_for('properties'))
    
    # Calculate cashback for this property using complex_name
    cashback = calculate_cashback(property_data['price'], complex_name=property_data.get('complex_name'))
    
    # Add cashback data to property_data for PDF template
    property_data['cashback_amount'] = cashback
    
    # Get cashback percent from residential complex
    try:
        if property_data.get('complex_name'):
            from models import ResidentialComplex
            complex = ResidentialComplex.query.filter_by(name=property_data['complex_name']).first()
            if complex and complex.cashback_rate:
                property_data['cashback_percent'] = float(complex.cashback_rate)
            else:
                property_data['cashback_percent'] = 5.0  # Default 5%
        else:
            property_data['cashback_percent'] = 5.0  # Default 5%
    except:
        property_data['cashback_percent'] = 5.0  # Default 5%
    
    # Get current date for PDF generation
    current_date = datetime.now().strftime('%d.%m.%Y')
    
    # Generate QR code with link to object page
    # Use custom domain from environment variable or fall back to current request domain
    custom_domain = os.environ.get('QR_DOMAIN')
    if custom_domain:
        # Remove trailing slash and ensure it starts with http:// or https://
        custom_domain = custom_domain.rstrip('/')
        if not custom_domain.startswith(('http://', 'https://')):
            custom_domain = 'https://' + custom_domain
        object_url = custom_domain + url_for('property_detail', property_id=property_id)
    else:
        # Default behavior - use current request domain
        object_url = request.url_root.rstrip('/') + url_for('property_detail', property_id=property_id)
    
    qr_code_base64 = generate_qr_code(object_url)
    
    # Add missing fields for PDF template
    property_data['name'] = property_data.get('title', '–û–±—ä–µ–∫—Ç –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏')
    
    # Get layout image from residential complex (first photo from gallery)
    complex_layout_image = None
    try:
        if property_data.get('complex_name'):
            from models import ResidentialComplex
            complex = ResidentialComplex.query.filter_by(name=property_data['complex_name']).first()
            if complex and complex.gallery_images:
                try:
                    import json
                    gallery = json.loads(complex.gallery_images)
                    if gallery and isinstance(gallery, list) and len(gallery) > 0:
                        complex_layout_image = gallery[0]
                except (json.JSONDecodeError, TypeError, IndexError) as e:
                    print(f"Error parsing gallery images for complex {property_data.get('complex_name')}: {e}")
    except Exception as e:
        print(f"Error loading complex layout image: {e}")
    
    # Create presentation object for PDF template
    presentation = {
        'title': 'InBack.ru - –ö—ç—à–±–µ–∫ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏'
    }
    
    # Create property_images structure expected by PDF template
    property_images = {
        'photos': property_data.get('gallery', []),  # All apartment photos
        'floor_plan': property_data.get('floor_plan')  # Floor plan photo
    }
    
    return render_template('property_pdf.html', 
                         property=property_data,
                         property_images=property_images,
                         presentation=presentation,
                         cashback=cashback,
                         current_date=current_date,
                         qr_code=qr_code_base64,
                         object_url=object_url,
                         complex_layout_image=complex_layout_image)


@app.route('/wallet')
def wallet():
    """Wallet page with cashback information and benefits"""
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    
    user_property_count = 0
    if current_user.is_authenticated:
        user_property_count = Property.query.filter_by(user_id=current_user.id).count()
    
    return render_template('wallet.html', 
                         current_city=current_city,
                         user_property_count=user_property_count)


@app.route('/o-kompanii')
@app.route('/about')
def about():
    """Redirect to city-based URL"""
    return redirect_to_city_based('about_city')

@app.route('/kak-eto-rabotaet')
@app.route('/how-it-works')
def how_it_works():
    """Redirect to city-based URL"""
    return redirect_to_city_based('how_it_works_city')

@app.route('/otzyvy')
@app.route('/reviews')
def reviews():
    """Redirect to city-based URL"""
    return redirect_to_city_based('reviews_city')

@app.route('/kontakty')
@app.route('/contacts')
def contacts():
    """Redirect to city-based URL"""
    return redirect_to_city_based('contacts_city')

@app.route('/blog')
def blog():
    """Redirect to city-based URL"""
    return redirect_to_city_based('blog_city')

def _render_blog_page(current_city):
    """Internal blog rendering logic"""
    from models import BlogPost, Category
    from sqlalchemy import text
    
    # Get search parameters  
    search_query = request.args.get('search', '')
    category_filter = request.args.get('category', '')
    sort_order = request.args.get('sort', 'date_desc')
    if sort_order not in ('date_desc', 'date_asc'):
        sort_order = 'date_desc'
    page = int(request.args.get('page', 1))
    per_page = 6
    
    # –ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç–∞—Ç–µ–π —Ç–æ–ª—å–∫–æ –∏–∑ BlogPost —Å –∫–∞—Ç–µ–≥–æ—Ä–∏–µ–π
    all_articles = []
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç—å–∏ —Ç–æ–ª—å–∫–æ –∏–∑ BlogPost —Å –∫–∞—Ç–µ–≥–æ—Ä–∏–µ–π
        blog_posts = BlogPost.query.filter_by(status='published').all()
        for post in blog_posts:
            # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
            category_name = None
            if post.category_id:
                category_obj = Category.query.get(post.category_id)
                if category_obj:
                    category_name = category_obj.name
            
            all_articles.append({
                'id': post.id,
                'title': post.title,
                'slug': post.slug,
                'excerpt': post.excerpt or '–ò–Ω—Ç–µ—Ä–µ—Å–Ω–∞—è —Å—Ç–∞—Ç—å—è –æ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏',
                'content': post.content,
                'featured_image': post.featured_image or 'https://images.unsplash.com/photo-1560518883-ce09059eeffa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80',
                'published_at': post.published_at or post.created_at,
                'created_at': post.created_at,
                'reading_time': getattr(post, 'reading_time', 5),
                'category_id': post.category_id,
                'category_name': category_name,
                'url': f'/blog/{post.slug}',
                'source': 'BlogPost'
            })
        
    except Exception as e:
        print(f"Error loading unified articles for blog: {e}")
    
    # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
    filtered_articles = all_articles.copy()
    
    # –ü–æ–∏—Å–∫ –ø–æ —Ç–µ–∫—Å—Ç—É
    if search_query:
        filtered_articles = [
            article for article in filtered_articles
            if search_query.lower() in article['title'].lower() or 
               search_query.lower() in (article['excerpt'] or '').lower() or
               search_query.lower() in (article['content'] or '').lower()
        ]
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if category_filter:
        category = Category.query.filter_by(name=category_filter, is_active=True).first()
        if category:
            filtered_articles = [
                article for article in filtered_articles
                if article['category_id'] == category.id
            ]
    
    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –¥–∞—Ç–µ
    sort_reverse = sort_order != 'date_asc'
    filtered_articles.sort(key=lambda x: x['published_at'] or x['created_at'], reverse=sort_reverse)
    
    # –†—É—á–Ω–∞—è –ø–∞–≥–∏–Ω–∞—Ü–∏—è
    total_articles = len(filtered_articles)
    start_idx = (page - 1) * per_page
    end_idx = start_idx + per_page
    articles_page = filtered_articles[start_idx:end_idx]
    
    # –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –ø–æ—Ö–æ–∂–∏–π –Ω–∞ paginate –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
    class PaginationMock:
        def __init__(self, items, page, per_page, total):
            self.items = items
            self.page = page
            self.per_page = per_page
            self.total = total
    
    articles = PaginationMock(articles_page, page, per_page, total_articles)
    
    total_pages = math.ceil(len(all_articles) / per_page) if len(all_articles) > 0 else 1
    # –ï—Å–ª–∏ –Ω–µ—Ç —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —Å—Ç–∞—Ç—å–∏ –ø—Ä–æ—Å—Ç–æ —Å–ø–∏—Å–∫–æ–º
    if not search_query and not category_filter:
        # Get all active categories for navigation
        all_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —Å—Ç–∞—Ç—å–∏ –ø—Ä–æ—Å—Ç—ã–º —Å–ø–∏—Å–∫–æ–º
        articles_to_show = articles_page
        return render_template('blog.html',
                                 current_city=current_city,
                             articles=articles_to_show,
                             all_categories=all_categories,
                             search_query=search_query,
                             category_filter=category_filter,
                             sort_order=sort_order,
                             current_page=page,
                             total_articles=len(all_articles),
                             total_pages=total_pages,
                             show_category_sections=False)
    else:
        all_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
        
        return render_template('blog.html',
                             articles=articles_page,
                             all_categories=all_categories,
                             search_query=search_query,
                             category_filter=category_filter,
                             sort_order=sort_order,
                             current_page=page,
                             total_articles=total_articles,
                             total_pages=math.ceil(total_articles / per_page) if total_articles > 0 else 1,
                             show_category_sections=False)

# Removed duplicate blog route - using blog_post function at line 7515

@app.route('/blog/category/<category_slug>')
def blog_category(category_slug):
    """Blog category page with search functionality"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    try:
        from models import BlogPost, Category
        
        # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ slug —Å—Ç–∞—Ç—å–∏
        article = BlogPost.query.filter_by(slug=category_slug, status='published').first()
        if article:
            # –≠—Ç–æ —Å—Ç–∞—Ç—å—è, –∞ –Ω–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—è - –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç
            return redirect(url_for('blog_post', slug=category_slug))
        
        # –ü–æ–∏—Å–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ slug –∏–ª–∏ –ø–æ –∏–º–µ–Ω–∏
        category = Category.query.filter(
            (Category.slug == category_slug) | 
            (Category.name.ilike(f'%{category_slug}%'))
        ).first()
        
        if not category:
            return redirect(url_for('blog'))
        
        # Get search query from URL parameters
        search_query = request.args.get('q', '').strip()
        
        # Get articles in this category
        page = int(request.args.get('page', 1))
        per_page = 6
        
        # Base query - articles in this category using foreign key
        articles_query = BlogPost.query.filter_by(status='published', category_id=category.id)
        
        # Add search filter if query provided
        if search_query:
            from sqlalchemy import or_, func
            search_filter = f"%{search_query.lower()}%"
            articles_query = articles_query.filter(
                or_(
                    func.lower(BlogPost.title).like(search_filter),
                    func.lower(BlogPost.excerpt).like(search_filter),
                    func.lower(BlogPost.content).like(search_filter)
                )
            )
        
        # Order by date descending
        articles_query = articles_query.order_by(BlogPost.created_at.desc())
        
        articles = articles_query.paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        # Get all categories for navigation
        all_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
        
        return render_template('blog.html',
                             articles=articles.items,
                             all_categories=all_categories,
                             current_category=category,
                             featured_articles=[],
                             search_query=search_query,
                             category_filter=category_slug,
                             current_page=page,
                             total_pages=articles.pages,
                             total_articles=articles.total)
                             
    except Exception as e:
        # Log error for debugging
        import traceback
        print(f"[ERROR] Exception in blog_category ({category_slug}): {str(e)}")
        print(f"[ERROR] Traceback: {traceback.format_exc()}")
        # Graceful fallback - redirect to main blog page
        flash('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.', 'error')
        return redirect(url_for('blog'))

@app.route('/news')
def news():
    """News article page"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    return render_template('news.html')

@app.route('/ulitsy')
@app.route('/streets')
def streets():
    """Redirect to city-based URL"""
    return redirect_to_city_based('streets_city')

def _render_streets_page(current_city):
    """Internal streets rendering logic"""
    # –≠—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞ (—Å–æ–∑–¥–∞–Ω–∞ –¥–ª—è SEO)
    # –î–∞–Ω–Ω—ã–µ –ø–æ–∫–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞
    streets_data = []
    if not current_city or current_city.slug != 'krasnodar':
        # –î–ª—è –¥—Ä—É–≥–∏—Ö –≥–æ—Ä–æ–¥–æ–≤ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—É—Å—Ç—É—é –∑–∞–≥–ª—É—à–∫—É
        return render_template('streets.html', current_city=current_city, streets=[])
    
    # Load streets from database with slugs
    streets_db = db.session.execute(text("""
        SELECT name, slug, district_id 
        FROM streets 
        ORDER BY name
    """)).fetchall()
    
    # Get district names
    districts_db = db.session.execute(text("""
        SELECT id, name FROM districts
    """)).fetchall()
    districts_map = {d.id: d.name for d in districts_db}
    
    # Format streets data
    streets_data = []
    for street in streets_db:
        # Get first letter for grouping
        first_char = street.name[0].upper() if street.name else '–ê'
        
        streets_data.append({
            'name': street.name,
            'slug': street.slug,  # Use slug from database
            'district': districts_map.get(street.district_id, ''),
            'letter': first_char,
            'properties_count': 0,  # Can be calculated if needed
            'new_buildings': 0  # Can be calculated if needed
        })
    
    return render_template('streets.html', 
                             current_city=current_city,
                         streets=streets_data)

# Redirect from /streets/<street_name> to /street/<slug>
@app.route('/streets/<path:street_name>')
def streets_redirect(street_name):
    """–†–µ–¥–∏—Ä–µ–∫—Ç —Å /streets/ –Ω–∞ /street/ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏"""
    import urllib.parse
    
    # –î–µ–∫–æ–¥–∏—Ä—É–µ–º URL-encoded –∏–º—è
    decoded_name = urllib.parse.unquote(street_name)
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ –ª–æ–≥–∏–∫—É —á—Ç–æ –∏ street_slug() –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è slug
    translit_map = {
        '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo',
        '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
        '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
        '—Ñ': 'f', '—Ö': 'kh', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch',
        '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
    }
    
    # –û—á–∏—â–∞–µ–º –∏–º—è
    name = decoded_name.strip().lower()
    name = re.sub(r'[¬´¬ª"\(\)\.,:;]', '', name)
    
    # –¢—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è
    result = ''
    for char in name:
        result += translit_map.get(char, char)
    
    # –ó–∞–º–µ–Ω—è–µ–º –ø—Ä–æ–±–µ–ª—ã –Ω–∞ –¥–µ—Ñ–∏—Å—ã –∏ —á–∏—Å—Ç–∏–º
    result = re.sub(r'\s+', '-', result)
    result = re.sub(r'-+', '-', result)
    slug = result.strip('-')
    
    # –†–µ–¥–∏—Ä–µ–∫—Ç –Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π URL
    return redirect(url_for('street_detail', street_name=slug), code=301)

@app.route('/street/<path:street_name>')
def street_detail(street_name):
    """–°—Ç—Ä–∞–Ω–∏—Ü–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π —É–ª–∏—Ü—ã —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –∏ –∫–∞—Ä—Ç–æ–π"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    
    try:
        # –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º —É–ª–∏—Ü—É –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ slug
        street_db = db.session.execute(text("""
            SELECT name, slug, latitude, longitude, zoom_level, geometry, geometry_source
            FROM streets 
            WHERE slug = :street_slug
        """), {'street_slug': street_name}).fetchone()
        
        if street_db:
            # –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –¥–ª—è SEO
            import math
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —É–ª–∏—Ü—ã
            street_type = '—É–ª–∏—Ü–µ'
            street_type_nominative = '—É–ª–∏—Ü–∞'
            name_lower = street_db.name.lower()
            if '–ø—Ä–æ–µ–∑–¥' in name_lower:
                street_type = '–ø—Ä–æ–µ–∑–¥–µ'
                street_type_nominative = '–ø—Ä–æ–µ–∑–¥'
            elif '–ø–µ—Ä–µ—É–ª–æ–∫' in name_lower or '–ø–µ—Ä.' in name_lower:
                street_type = '–ø–µ—Ä–µ—É–ª–∫–µ'
                street_type_nominative = '–ø–µ—Ä–µ—É–ª–æ–∫'
            elif '–±—É–ª—å–≤–∞—Ä' in name_lower:
                street_type = '–±—É–ª—å–≤–∞—Ä–µ'
                street_type_nominative = '–±—É–ª—å–≤–∞—Ä'
            elif '–ø–ª–æ—â–∞–¥—å' in name_lower:
                street_type = '–ø–ª–æ—â–∞–¥–∏'
                street_type_nominative = '–ø–ª–æ—â–∞–¥—å'
            elif '—à–æ—Å—Å–µ' in name_lower:
                street_type = '—à–æ—Å—Å–µ'
                street_type_nominative = '—à–æ—Å—Å–µ'
            
            # –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–Ω—Ç—Ä–∞ –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞
            distance_to_center = 0
            if street_db.latitude and street_db.longitude:
                center_lat, center_lng = 45.0448, 38.9760
                lat_diff = street_db.latitude - center_lat
                lng_diff = street_db.longitude - center_lng
                distance_to_center = round(math.sqrt(lat_diff**2 + lng_diff**2) * 111, 1)  # –ø—Ä–∏–º–µ—Ä–Ω–æ –≤ –∫–º
                
                coordinates = {
                    'lat': float(street_db.latitude),
                    'lng': float(street_db.longitude)
                }
            else:
                coordinates = {
                    'lat': 45.0448,
                    'lng': 38.9760
                }
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–æ–Ω—É –≥–æ—Ä–æ–¥–∞ –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é
            location_zone = '—Ü–µ–Ω—Ç—Ä–µ –≥–æ—Ä–æ–¥–∞'
            if distance_to_center < 3:
                location_zone = '—Ü–µ–Ω—Ç—Ä–µ –≥–æ—Ä–æ–¥–∞'
            elif distance_to_center < 7:
                location_zone = '—Å—Ä–µ–¥–Ω–µ–π –∑–æ–Ω–µ –≥–æ—Ä–æ–¥–∞'
            else:
                location_zone = '–æ—Ç–¥–∞–ª—ë–Ω–Ω–æ–π –∑–æ–Ω–µ –≥–æ—Ä–æ–¥–∞'
            
            # –í–∞—Ä–∏–∞—Ü–∏–∏ –æ–ø–∏—Å–∞–Ω–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–µ—Ä–≤–æ–π –±—É–∫–≤—ã (–¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏)
            first_letter_ord = ord(street_db.name[0].upper()) if street_db.name else 0
            variation = first_letter_ord % 4
            
            advantages = [
                ['—Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –ñ–ö', '—Ä–∞–∑–≤–∏—Ç–æ–π –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π', '–æ—Ç–ª–∏—á–Ω–æ–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–æ–π –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å—é'],
                ['–ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–º–∏ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞–º–∏', '–≤—ã—Å–æ–∫–∏–º –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω—ã–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª–æ–º', '—É–¥–æ–±–Ω—ã–º —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ–º'],
                ['–∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∞–º–∏', '–ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω—ã–º —Ä–∞–π–æ–Ω–æ–º', '–±–ª–∏–∑–æ—Å—Ç—å—é –∫ —Ü–µ–Ω—Ç—Ä—É'],
                ['–Ω–∞–¥—ë–∂–Ω—ã–º–∏ –¥–µ–≤–µ–ª–æ–ø–µ—Ä–∞–º–∏', '–∫–æ–º—Ñ–æ—Ä—Ç–Ω–æ–π —Å—Ä–µ–¥–æ–π', '–∞–∫—Ç–∏–≤–Ω—ã–º —Ä–∞–∑–≤–∏—Ç–∏–µ–º —Ä–∞–π–æ–Ω–∞']
            ][variation]
            
            why_buy_variants = [
                '–≤—ã–≥–æ–¥–Ω–æ–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –∏ —Ö–æ—Ä–æ—à–∞—è —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–∞—è –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å',
                '—Ä–∞–∑–≤–∏—Ç–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏ –±–ª–∏–∑–æ—Å—Ç—å –∫–æ –≤—Å–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º –æ–±—ä–µ–∫—Ç–∞–º',
                '–ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω—ã–π —Ä–∞–π–æ–Ω —Å –≤—ã—Å–æ–∫–∏–º –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–æ–Ω–Ω—ã–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª–æ–º',
                '–∫–æ–º—Ñ–æ—Ä—Ç–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –∂–∏–∑–Ω–∏ –∏ –∞–∫—Ç–∏–≤–Ω–æ–µ —Ä–∞–∑–≤–∏—Ç–∏–µ —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏'
            ][variation]
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            street = {
                'name': street_db.name,
                'slug': street_db.slug,
                'district': '',
                'description': f'{street_type_nominative.capitalize()} {street_db.name} –≤ –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–µ',
                'geometry': street_db.geometry if street_db.geometry else None,
                'geometry_source': street_db.geometry_source if street_db.geometry_source else None,
                'street_type': street_type,
                'street_type_nominative': street_type_nominative,
                'distance_to_center': distance_to_center,
                'location_zone': location_zone,
                'advantages': advantages,
                'why_buy': why_buy_variants
            }
                
            app.logger.debug(f"Found street in database: {street['name']} with coordinates: {coordinates}")
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ —Å–≤–æ–π—Å—Ç–≤–∞—Ö –¥–ª—è —ç—Ç–æ–π —É–ª–∏—Ü—ã (–µ—Å–ª–∏ –µ—Å—Ç—å)
            properties_on_street = []
            try:
                with open('data/properties_new.json', 'r', encoding='utf-8') as f:
                    properties_data = json.load(f)
                
                # –§–∏–ª—å—Ç—Ä—É–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –ø–æ —É–ª–∏—Ü–µ
                for prop in properties_data:
                    if (street['name'].lower() in prop.get('location', '').lower() or
                        street['name'].lower() in prop.get('full_address', '').lower()):
                        properties_on_street.append(prop)
            except:
                pass
            
            return render_template('street_detail.html',
                                     current_city=current_city,
                                 street=street,
                                 coordinates=coordinates,
                                 properties=properties_on_street,
                                 title=f'{street["name"]} - –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ —Å –∫—ç—à–±–µ–∫–æ–º | InBack',
                                 yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
        else:
            # –ò—â–µ–º –≤ JSON —Ñ–∞–π–ª–µ –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç
            streets_data = load_streets()
            
            # –ò—â–µ–º —É–ª–∏—Ü—É –ø–æ –∏–º–µ–Ω–∏ (—É—á–∏—Ç—ã–≤–∞–µ–º URL-–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ)
            street_name_decoded = street_name.replace('-', ' ').replace('_', ' ')
            street = None
            
            # –õ–æ–≥–∏—Ä—É–µ–º –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            app.logger.debug(f"Looking for street: {street_name} -> {street_name_decoded}")
        
        # –§—É–Ω–∫—Ü–∏—è —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å—Ç–∞—Ä—ã—Ö URL
        def translit_to_latin(text):
            translit_map = {
                '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
                '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'i', '–∫': 'k', '–ª': 'l', '–º': 'm',
                '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
                '—Ñ': 'f', '—Ö': 'h', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch',
                '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
            }
            result = ''
            for char in text.lower():
                result += translit_map.get(char, char)
            return result
        
        for s in streets_data:
            # –°–æ–∑–¥–∞–µ–º URL-slug —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –≤ —Ñ–∏–ª—å—Ç—Ä–µ (—Å –∫–∏—Ä–∏–ª–ª–∏—Ü–µ–π)
            street_slug_generated = s['name'].lower().replace(' ', '-').replace('.', '').replace('(', '').replace(')', '').replace(',', '')
            
            # –°–æ–∑–¥–∞–µ–º –ø–æ–ª–Ω—É—é —Ç—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—é –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
            translit_name = translit_to_latin(s['name'])
            translit_slug = translit_name.replace(' ', '-').replace('.', '').replace('(', '').replace(')', '').replace(',', '')
            
            # –ü—Ä–æ—Å—Ç–∞—è –∑–∞–º–µ–Ω–∞ —Å–∏–º–≤–æ–ª–æ–≤ (–∫–∞–∫ –±—ã–ª–æ —Ä–∞–Ω—å—à–µ)
            simple_translit = s['name'].lower().replace(' ', '-').replace('.', '').replace('—ë', 'e').replace('–π', 'i').replace('–∞', 'a').replace('–≥', 'g').replace('—Ä', 'r').replace('–∏', 'i').replace('–Ω', 'n').replace('(', '').replace(')', '').replace(',', '')
            
            # –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –ø–æ–∏—Å–∫–∞
            if (street_slug_generated == street_name.lower() or
                translit_slug == street_name.lower() or
                simple_translit == street_name.lower() or
                s['name'].lower() == street_name_decoded.lower() or
                s['name'].lower().replace(' —É–ª.', '').replace(' —É–ª', '') == street_name_decoded.lower().replace(' —É–ª.', '').replace(' —É–ª', '')):
                street = s
                app.logger.debug(f"Found street: {s['name']} with slug: {street_slug_generated}, translit: {translit_slug}")
                break
        
        if not street:
            # –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ —á–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
            for s in streets_data:
                street_name_clean = street_name_decoded.lower().replace('—É–ª', '').replace('.', '').strip()
                street_db_clean = s['name'].lower().replace('—É–ª.', '').replace('—É–ª', '').replace('.', '').strip()
                
                if (street_name_clean in street_db_clean or 
                    street_db_clean in street_name_clean or
                    street_name_decoded.lower() in s['name'].lower()):
                    street = s
                    app.logger.debug(f"Found street by partial match: {s['name']}")
                    break
        
        if not street:
            app.logger.error(f"Street not found: {street_name} ({street_name_decoded})")
            abort(404)
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        from models import Street
        
        # –ò—â–µ–º —É–ª–∏—Ü—É –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é
        street_db = Street.query.filter_by(name=street['name']).first()
        
        if street_db and street_db.latitude and street_db.longitude:
            coordinates = {
                'lat': float(street_db.latitude),
                'lng': float(street_db.longitude)
            }
        else:
            # –ï—Å–ª–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –Ω–µ—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ü–µ–Ω—Ç—Ä –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞
            coordinates = {
                'lat': 45.035470,
                'lng': 38.975313
            }
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ —Å–≤–æ–π—Å—Ç–≤–∞—Ö –¥–ª—è —ç—Ç–æ–π —É–ª–∏—Ü—ã (–µ—Å–ª–∏ –µ—Å—Ç—å)
        properties_on_street = []
        try:
            with open('data/properties_new.json', 'r', encoding='utf-8') as f:
                properties_data = json.load(f)
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –ø–æ —É–ª–∏—Ü–µ
            for prop in properties_data:
                if (street['name'].lower() in prop.get('location', '').lower() or
                    street['name'].lower() in prop.get('full_address', '').lower()):
                    properties_on_street.append(prop)
        except:
            pass
        
        return render_template('street_detail.html',
                             street=street,
                             coordinates=coordinates,
                             properties=properties_on_street,
                             title=f'{street["name"]} - –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ —Å –∫—ç—à–±–µ–∫–æ–º | InBack',
                             yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
    
    except Exception as e:
        app.logger.error(f"Error loading street detail: {e}")
        abort(404)

@app.route('/sitemap.xml')
@cache.cached(timeout=3600)
def sitemap():
    """
    Dynamic sitemap generator with database integration.
    
    Includes:
    - Homepage
    - Static pages (properties, residential-complexes, developers, map, about, etc.)
    - All active properties (/{city_slug}/object/{inner_id})
    - All active residential complexes (/{city_slug}/residential-complex/{slug})
    - Multi-city pages (/{city_slug}/properties, /{city_slug}/residential-complexes)
    - Published blog posts (/blog/{slug})
    
    Cached for 1 hour for performance.
    Max 50,000 URLs per sitemap standard.
    """
    try:
        from models import Property as PropertyModel, ResidentialComplex, BlogPost, City
        
        # Canonical base URL
        base_url = CANONICAL_BASE_URL
        today = datetime.utcnow().strftime('%Y-%m-%d')
        generation_time = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')
        
        # Separate lists for URL counting
        static_urls = []
        property_urls = []
        complex_urls = []
        blog_urls = []
        
        # 1. Homepage (priority: 1.0, changefreq: daily)
        static_urls.append({
            'loc': f'{base_url}/',
            'lastmod': today,
            'changefreq': 'daily',
            'priority': '1.0'
        })
        
        # 2. Static pages (priority: 0.7-0.8, changefreq: weekly/monthly)
        static_pages = [
            ('properties', 'daily', '0.9'),
            ('residential-complexes', 'daily', '0.9'),
            ('developers', 'weekly', '0.8'),
            ('map', 'weekly', '0.8'),
            ('about', 'monthly', '0.7'),
            ('how-it-works', 'monthly', '0.7'),
            ('reviews', 'weekly', '0.7'),
            ('contacts', 'monthly', '0.8'),
            ('blog', 'daily', '0.8'),
        ]
        
        for page, changefreq, priority in static_pages:
            static_urls.append({
                'loc': f'{base_url}/{page}',
                'lastmod': today,
                'changefreq': changefreq,
                'priority': priority
            })
        
        # 3. Get all active cities for multi-city URLs
        cities = City.query.filter_by(is_active=True).all()
        
        # 4. Multi-city pages (/{city_slug}/properties, /{city_slug}/residential-complexes)
        for city in cities:
            static_urls.append({
                'loc': f'{base_url}/{city.slug}/properties',
                'lastmod': today,
                'changefreq': 'daily',
                'priority': '0.9'
            })
            static_urls.append({
                'loc': f'{base_url}/{city.slug}/residential-complexes',
                'lastmod': today,
                'changefreq': 'daily',
                'priority': '0.9'
            })
        
        # 5. All active properties (/{city_slug}/object/{inner_id})
        # Limit to needed fields for performance
        properties = PropertyModel.query.filter_by(is_active=True).with_entities(
            PropertyModel.inner_id,
            PropertyModel.city_id,
            PropertyModel.updated_at,
            PropertyModel.created_at
        ).limit(40000).all()
        
        # Create city_id to slug mapping for fast lookup
        city_slugs = {city.id: city.slug for city in cities}
        
        for prop in properties:
            if prop.inner_id and prop.city_id in city_slugs:
                lastmod = (prop.updated_at or prop.created_at or datetime.utcnow()).strftime('%Y-%m-%d')
                property_urls.append({
                    'loc': f'{base_url}/{city_slugs[prop.city_id]}/object/{prop.inner_id}',
                    'lastmod': lastmod,
                    'changefreq': 'weekly',
                    'priority': '0.8'
                })
        
        # 6. All active residential complexes (/{city_slug}/residential-complex/{slug})
        complexes = ResidentialComplex.query.filter_by(is_active=True).with_entities(
            ResidentialComplex.slug,
            ResidentialComplex.city_id,
            ResidentialComplex.updated_at,
            ResidentialComplex.created_at
        ).limit(5000).all()
        
        for complex in complexes:
            if complex.slug and complex.city_id in city_slugs:
                lastmod = (complex.updated_at or complex.created_at or datetime.utcnow()).strftime('%Y-%m-%d')
                complex_urls.append({
                    'loc': f'{base_url}/{city_slugs[complex.city_id]}/residential-complex/{complex.slug}',
                    'lastmod': lastmod,
                    'changefreq': 'weekly',
                    'priority': '0.8'
                })
        
        # 7. Published blog posts (/blog/{slug})
        blog_posts = BlogPost.query.filter_by(status='published').with_entities(
            BlogPost.slug,
            BlogPost.updated_at,
            BlogPost.published_at,
            BlogPost.created_at
        ).limit(5000).all()
        
        for post in blog_posts:
            if post.slug:
                lastmod = (post.updated_at or post.published_at or post.created_at or datetime.utcnow()).strftime('%Y-%m-%d')
                blog_urls.append({
                    'loc': f'{base_url}/blog/{post.slug}',
                    'lastmod': lastmod,
                    'changefreq': 'monthly',
                    'priority': '0.7'
                })
        
        # 8. Calculate URL counts
        url_counts = {
            'static': len(static_urls),
            'properties': len(property_urls),
            'complexes': len(complex_urls),
            'blog_posts': len(blog_urls),
            'total': len(static_urls) + len(property_urls) + len(complex_urls) + len(blog_urls)
        }
        
        # 9. Logging and warnings
        print(f"üìä Sitemap generated: {url_counts['total']} URLs")
        print(f"   - Static pages: {url_counts['static']}")
        print(f"   - Properties: {url_counts['properties']}")
        print(f"   - Residential Complexes: {url_counts['complexes']}")
        print(f"   - Blog posts: {url_counts['blog_posts']}")
        print(f"   - Capacity: {url_counts['total']/50000*100:.2f}% (limit: 50,000)")
        
        # Warnings for approaching limits
        if url_counts['total'] > 30000:
            print("‚ö†Ô∏è  WARNING: Consider switching to Sitemap Index (30k+ URLs)")
        if url_counts['total'] > 45000:
            print("üî¥ CRITICAL: Approaching 50k URL limit! Switch to Sitemap Index NOW")
        
        # 10. Combine all URLs
        all_urls = static_urls + property_urls + complex_urls + blog_urls
        
        # 11. Generate XML content with statistics comment
        xml_lines = ['<?xml version="1.0" encoding="UTF-8"?>']
        xml_lines.append('<!-- ')
        xml_lines.append(f'  InBack Sitemap - Generated: {generation_time}')
        xml_lines.append(f'  Total URLs: {url_counts["total"]}')
        xml_lines.append(f'  - Static pages: {url_counts["static"]}')
        xml_lines.append(f'  - Properties: {url_counts["properties"]}')
        xml_lines.append(f'  - Residential Complexes: {url_counts["complexes"]}')
        xml_lines.append(f'  - Blog posts: {url_counts["blog_posts"]}')
        xml_lines.append('  ')
        xml_lines.append('  Note: Sitemap Index recommended at 30,000+ URLs')
        xml_lines.append(f'  Current capacity: {url_counts["total"]} / 50,000 ({url_counts["total"]/50000*100:.2f}%)')
        xml_lines.append('-->')
        xml_lines.append('<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">')
        
        # Limit to 50,000 URLs per sitemap standard
        for url in all_urls[:50000]:
            xml_lines.append('  <url>')
            xml_lines.append(f'    <loc>{url["loc"]}</loc>')
            xml_lines.append(f'    <lastmod>{url["lastmod"]}</lastmod>')
            xml_lines.append(f'    <changefreq>{url["changefreq"]}</changefreq>')
            xml_lines.append(f'    <priority>{url["priority"]}</priority>')
            xml_lines.append('  </url>')
        
        xml_lines.append('</urlset>')
        xml_content = '\n'.join(xml_lines)
        
        # 12. Return XML response with proper headers
        response = app.response_class(
            response=xml_content,
            status=200,
            mimetype='application/xml'
        )
        response.headers['Content-Type'] = 'application/xml; charset=utf-8'
        
        app.logger.info(f"Sitemap generated successfully with {url_counts['total']} URLs")
        return response
        
    except Exception as e:
        app.logger.error(f"Error generating dynamic sitemap: {e}")
        import traceback
        app.logger.error(traceback.format_exc())
        abort(500)

@app.route('/google873bf5c5df6b6710.html')
def google_verification():
    """Google Search Console verification file"""
    return 'google-site-verification: google873bf5c5df6b6710.html'


@app.route('/sitemap-stats')
def sitemap_stats():
    """
    Debug endpoint for sitemap statistics.
    Only available in debug mode for security.
    Returns JSON with URL counts by type.
    """
    # Only allow in debug mode
    if not app.debug:
        abort(404)
    
    try:
        from models import Property as PropertyModel, ResidentialComplex, BlogPost, City
        
        # Count static pages
        static_pages_count = 10  # Homepage + 9 static pages
        
        # Count cities
        cities_count = City.query.filter_by(is_active=True).count()
        multi_city_pages_count = cities_count * 2  # /properties and /residential-complexes per city
        
        # Count properties
        properties_count = PropertyModel.query.filter_by(is_active=True).count()
        
        # Count residential complexes
        complexes_count = ResidentialComplex.query.filter_by(is_active=True).count()
        
        # Count blog posts
        blog_posts_count = BlogPost.query.filter_by(status='published').count()
        
        # Calculate totals
        total_static = static_pages_count + multi_city_pages_count
        total_urls = total_static + properties_count + complexes_count + blog_posts_count
        
        # Build response
        url_counts = {
            'static': total_static,
            'static_breakdown': {
                'homepage_and_pages': static_pages_count,
                'multi_city_pages': multi_city_pages_count,
                'cities': cities_count
            },
            'properties': properties_count,
            'complexes': complexes_count,
            'blog_posts': blog_posts_count,
            'total': total_urls,
            'capacity': {
                'current': total_urls,
                'limit': 50000,
                'percentage': round(total_urls / 50000 * 100, 2),
                'warning_threshold': 30000,
                'critical_threshold': 45000,
                'status': 'critical' if total_urls > 45000 else 'warning' if total_urls > 30000 else 'ok'
            },
            'recommendations': []
        }
        
        # Add recommendations based on URL count
        if total_urls > 45000:
            url_counts['recommendations'].append('üî¥ CRITICAL: Approaching 50k URL limit! Switch to Sitemap Index NOW')
        elif total_urls > 30000:
            url_counts['recommendations'].append('‚ö†Ô∏è  WARNING: Consider switching to Sitemap Index (30k+ URLs)')
        else:
            url_counts['recommendations'].append('‚úÖ URL count is healthy. No action needed.')
        
        return jsonify(url_counts)
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/sravnenie')
@app.route('/comparison')
def comparison():
    """Redirect to city-based URL"""
    return redirect_to_city_based('comparison_city')

@app.route('/comparison-new')
def comparison_new():
    """New improved comparison page for properties and complexes"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    return render_template('comparison_new.html')

@app.route('/thank-you')
def thank_you():
    """Thank you page after form submission"""
    return render_template('thank_you.html')

@app.route('/api/property/<int:property_id>')
def api_property_detail(property_id):
    """API endpoint to get property data for comparison"""
    property_data = get_property_by_id(property_id)
    
    if not property_data:
        return jsonify({'error': 'Property not found'}), 404
    
    
    # Use cashback_rate from excel_properties (already loaded in property_data)
    cashback_rate = property_data.get('cashback_rate', 5.0)
    
    # Calculate cashback amount using the actual cashback_rate from database
    if property_data.get('price'):
        property_data['cashback'] = round(property_data['price'] * cashback_rate / 100)
    else:
        property_data['cashback'] = 0
    
    # Add fields expected by comparison interface
    property_data['object_min_floor'] = property_data.get('floor')
    property_data['object_max_floor'] = property_data.get('total_floors')
    property_data['complex_name'] = property_data.get('residential_complex')
    
    return jsonify(property_data)

@app.route('/api/property/<int:property_id>/request-cashback', methods=['POST'])
@require_json_csrf
def api_property_request_cashback(property_id):
    """Handle cashback request for a property"""
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['name', 'phone', 'email']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'error': f'–ü–æ–ª–µ {field} –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        
        # Get property data
        property_data = get_property_by_id(property_id)
        if not property_data:
            return jsonify({'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Prepare notification data
        name = data.get('name')
        phone = data.get('phone')
        email = data.get('email')
        property_title = data.get('property_title', property_data.get('title', '–û–±—ä–µ–∫—Ç'))
        property_address = data.get('property_address', property_data.get('address', ''))
        property_price = data.get('property_price', property_data.get('price', 0))
        
        # Send email notification
        try:
            from email_service import send_email
            
            email_subject = f"–ó–∞—è–≤–∫–∞ –Ω–∞ –∫—ç—à–±–µ–∫ - {property_title}"
            email_content = f"""
            <h2>–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ –∫—ç—à–±–µ–∫–∞</h2>
            <p><strong>–ö–ª–∏–µ–Ω—Ç:</strong> {name}</p>
            <p><strong>–¢–µ–ª–µ—Ñ–æ–Ω:</strong> {phone}</p>
            <p><strong>Email:</strong> {email}</p>
            <hr>
            <p><strong>–û–±—ä–µ–∫—Ç:</strong> {property_title}</p>
            <p><strong>–ê–¥—Ä–µ—Å:</strong> {property_address}</p>
            <p><strong>–¶–µ–Ω–∞:</strong> {property_price:,.0f} ‚ÇΩ</p>
            <p><strong>ID –æ–±—ä–µ–∫—Ç–∞:</strong> {property_id}</p>
            """
            
            send_email(
                to_email='bithome@mail.ru',
                subject=email_subject,
                template_name='emails/general_notification.html',
                message=email_content,
                title=email_subject
            )
        except Exception as e:
            print(f"Error sending email: {e}")
        
        # Send Telegram notification
        try:
            import requests
            TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')
            TELEGRAM_CHAT_ID = os.environ.get('TELEGRAM_CHAT_ID')
            
            if TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID:
                telegram_message = f"""üí∞ <b>–ó–∞—è–≤–∫–∞ –Ω–∞ –∫—ç—à–±–µ–∫</b>

üë§ –ö–ª–∏–µ–Ω—Ç: {name}
üìû –¢–µ–ª–µ—Ñ–æ–Ω: {phone}
üìß Email: {email}

üè† –û–±—ä–µ–∫—Ç: {property_title}
üìç –ê–¥—Ä–µ—Å: {property_address}
üíµ –¶–µ–Ω–∞: {property_price:,.0f} ‚ÇΩ
üÜî ID: {property_id}"""
                
                telegram_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
                telegram_payload = {
                    'chat_id': TELEGRAM_CHAT_ID,
                    'text': telegram_message,
                    'parse_mode': 'HTML'
                }
                
                requests.post(telegram_url, data=telegram_payload, timeout=10)
        except Exception as e:
            print(f"Error sending Telegram notification: {e}")
        
        return jsonify({
            'success': True,
            'message': '–ó–∞—è–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞'
        })
        
    except Exception as e:
        print(f"Error in cashback request: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'}), 500


@app.route('/api/property/<int:property_id>/request-online-showing', methods=['POST'])
@require_json_csrf
def api_property_request_online_showing(property_id):
    """Handle online showing request for a property"""
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['name', 'phone', 'email', 'datetime']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'error': f'–ü–æ–ª–µ {field} –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        
        # Get property data
        property_data = get_property_by_id(property_id)
        if not property_data:
            return jsonify({'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Prepare notification data
        name = data.get('name')
        phone = data.get('phone')
        email = data.get('email')
        showing_datetime = data.get('datetime')
        property_title = data.get('property_title', property_data.get('title', '–û–±—ä–µ–∫—Ç'))
        property_address = data.get('property_address', property_data.get('address', ''))
        property_price = data.get('property_price', property_data.get('price', 0))
        
        # Parse datetime for better display
        try:
            from datetime import datetime
            dt = datetime.fromisoformat(showing_datetime.replace('Z', '+00:00'))
            showing_datetime_formatted = dt.strftime('%d.%m.%Y –≤ %H:%M')
        except:
            showing_datetime_formatted = showing_datetime
        
        # Send email notification
        try:
            from email_service import send_email
            
            email_subject = f"–ó–∞—è–≤–∫–∞ –Ω–∞ –æ–Ω–ª–∞–π–Ω –ø–æ–∫–∞–∑ - {property_title}"
            email_content = f"""
            <h2>–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –æ–Ω–ª–∞–π–Ω –ø–æ–∫–∞–∑</h2>
            <p><strong>–ö–ª–∏–µ–Ω—Ç:</strong> {name}</p>
            <p><strong>–¢–µ–ª–µ—Ñ–æ–Ω:</strong> {phone}</p>
            <p><strong>Email:</strong> {email}</p>
            <p><strong>–ñ–µ–ª–∞–µ–º–æ–µ –≤—Ä–µ–º—è:</strong> {showing_datetime_formatted}</p>
            <hr>
            <p><strong>–û–±—ä–µ–∫—Ç:</strong> {property_title}</p>
            <p><strong>–ê–¥—Ä–µ—Å:</strong> {property_address}</p>
            <p><strong>–¶–µ–Ω–∞:</strong> {property_price:,.0f} ‚ÇΩ</p>
            <p><strong>ID –æ–±—ä–µ–∫—Ç–∞:</strong> {property_id}</p>
            """
            
            send_email(
                to_email='bithome@mail.ru',
                subject=email_subject,
                template_name='emails/general_notification.html',
                message=email_content,
                title=email_subject
            )
        except Exception as e:
            print(f"Error sending email: {e}")
        
        # Send Telegram notification
        try:
            import requests
            TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')
            TELEGRAM_CHAT_ID = os.environ.get('TELEGRAM_CHAT_ID')
            
            if TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID:
                telegram_message = f"""üè† <b>–ó–∞—è–≤–∫–∞ –Ω–∞ –æ–Ω–ª–∞–π–Ω –ø–æ–∫–∞–∑</b>

üë§ –ö–ª–∏–µ–Ω—Ç: {name}
üìû –¢–µ–ª–µ—Ñ–æ–Ω: {phone}
üìß Email: {email}
üïê –ñ–µ–ª–∞–µ–º–æ–µ –≤—Ä–µ–º—è: {showing_datetime_formatted}

üè† –û–±—ä–µ–∫—Ç: {property_title}
üìç –ê–¥—Ä–µ—Å: {property_address}
üíµ –¶–µ–Ω–∞: {property_price:,.0f} ‚ÇΩ
üÜî ID: {property_id}"""
                
                telegram_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
                telegram_payload = {
                    'chat_id': TELEGRAM_CHAT_ID,
                    'text': telegram_message,
                    'parse_mode': 'HTML'
                }
                
                requests.post(telegram_url, data=telegram_payload, timeout=10)
        except Exception as e:
            print(f"Error sending Telegram notification: {e}")
        
        try:
            complex_name_str = property_data.get('complex_name', '–ù–µ —É–∫–∞–∑–∞–Ω')
            deal, _ = create_deal_from_website_form(
                name=name,
                phone=phone,
                email=email,
                source='–û–Ω–ª–∞–π–Ω –ø–æ–∫–∞–∑',
                complex_name=complex_name_str,
                property_price=float(property_price) if property_price else 0,
                notes=f"–û–Ω–ª–∞–π–Ω –ø–æ–∫–∞–∑ –Ω–∞ {showing_datetime_formatted}; –û–±—ä–µ–∫—Ç: {property_title}"
            )
            db.session.commit()
            if deal:
                print(f"‚úÖ Deal {deal.deal_number} created from online showing for {name}")
        except Exception as deal_err:
            print(f"Error creating deal from online showing: {deal_err}")
        
        return jsonify({
            'success': True,
            'message': '–ó–∞—è–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞'
        })
        
    except Exception as e:
        print(f"Error in online showing request: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'}), 500



@require_json_csrf
@app.route('/api/properties/batch', methods=['POST'])
def api_properties_batch():
    """Batch API endpoint to get multiple properties at once - OPTIMIZED"""
    try:
        data = request.get_json()
        property_ids = data.get('ids', [])
        
        if not property_ids or not isinstance(property_ids, list):
            return jsonify({'error': 'Invalid request, expected {"ids": [1, 2, 3]}'}), 400
        
        # Convert string IDs to integers
        try:
            property_ids = [int(pid) for pid in property_ids if pid]
        except (ValueError, TypeError) as e:
            return jsonify({'error': f'Invalid ID format: {str(e)}'}), 400
        
        # ‚úÖ SINGLE QUERY: Load all properties at once using bulk repository method
        properties_dict = PropertyRepository.get_by_ids_batch(property_ids)
        
        results = {}
        for property_id in property_ids:
            prop = properties_dict.get(property_id)
            if prop:
                # Convert ORM object to dict (same format as get_property_by_id)
                property_data = {
                    'id': prop.id,
                    'inner_id': prop.inner_id,
                    'title': prop.title,
                    'price': prop.price,
                    'rooms': prop.rooms,
                    'area': prop.area,
                    'floor': prop.floor,
                    'total_floors': prop.total_floors,
                    'main_image': prop.main_image,
                    'gallery_images': prop.gallery_images,
                    'residential_complex': prop.residential_complex.name if prop.residential_complex else '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                    'developer': prop.developer.name if prop.developer else '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                    'district': prop.district.name if prop.district else '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                    'address': prop.address,
                    'cashback_rate': prop.residential_complex.cashback_rate if prop.residential_complex else 5.0,
                    'latitude': prop.latitude,
                    'longitude': prop.longitude,
                }
                
                # Add cashback calculation
                cashback_rate = property_data.get('cashback_rate', 5.0)
                if property_data.get('price'):
                    property_data['cashback'] = round(property_data['price'] * cashback_rate / 100)
                else:
                    property_data['cashback'] = 0
                
                # Add comparison fields
                property_data['object_min_floor'] = property_data.get('floor')
                property_data['object_max_floor'] = property_data.get('total_floors')
                property_data['complex_name'] = property_data.get('residential_complex')
                
                results[str(property_id)] = property_data
        
        return jsonify({'success': True, 'items': results})
    except Exception as e:
        print(f"‚ùå Error in batch properties: {e}")
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@app.route('/complex-comparison')
def complex_comparison():
    """Complex comparison page"""
    return render_template('complex_comparison.html', current_city=current_city)


@app.route('/izbrannoe')
@app.route('/favorites')
def favorites():
    """Redirect to city-based URL"""
    return redirect_to_city_based('favorites_city')



@app.route('/robots.txt')
def robots_txt():
    """Robots.txt for search engine crawlers"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    robots_content = """User-agent: *
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/
Disallow: /dashboard

Sitemap: https://inback.ru/sitemap.xml

# Crawl-delay for better server performance
Crawl-delay: 1

# Specific rules for major search engines
User-agent: Googlebot
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/

User-agent: Yandex
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/

User-agent: Bingbot
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/"""
    
    return app.response_class(
        response=robots_content,
        status=200,
        mimetype='text/plain'
    )

# Old blog search function removed - using updated version at bottom of file


@app.route('/api/residential-complexes')
def api_residential_complexes():
    """API endpoint for getting residential complexes for cashback calculator using normalized tables"""
    from repositories.property_repository import ResidentialComplexRepository, PropertyRepository
    
    try:
        # Resolve city context for filtering
        city_context = resolve_city_context(
            city_id=request.args.get('city_id'),
            city_slug=request.args.get('city'),
            default_if_none=True
        )
        city_name = city_context.name if city_context else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä'
        city_id_filter = city_context.id if city_context else None
        complexes = ResidentialComplexRepository.get_all_active() if not city_id_filter else [
            c for c in ResidentialComplexRepository.get_all_active() 
            if c.city_id == city_id_filter
        ]
        all_stats = PropertyRepository.get_all_property_stats()
        
        api_complexes = []
        for complex in complexes:
            cashback_rate = complex.cashback_rate if complex.cashback_rate else 5.0
            stats = all_stats.get(complex.id, {'min_price': 0})
            
            api_complexes.append({
                'id': complex.id,
                'name': complex.name,
                'cashback_rate': cashback_rate,
                'price_from': stats['min_price'],
                'district': complex.district or (city_context.name if 'city_context' in locals() else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä')
            })
        
        print(f"API residential-complexes loaded from database: {len(api_complexes)} complexes")
        return jsonify({'complexes': api_complexes})
    
    except Exception as e:
        # Load all residential complexes from JSON data
        try:
            complexes = load_residential_complexes()
            api_complexes = []
            
            for complex in complexes:
                # Extract unique name and calculate cashback rate
                complex_name = complex.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ñ–ö')
                cashback_rate = 5.0  # Default rate
                
                # Try to get rate from complex data or calculate based on price
                if 'cashback_rate' in complex:
                    cashback_rate = float(complex['cashback_rate'])
                elif complex.get('real_price_from'):
                    # Calculate rate based on price range (higher price = lower rate)
                    price = complex.get('real_price_from', 5000000)
                    if price < 3000000:
                        cashback_rate = 5.0
                    elif price < 8000000:
                        cashback_rate = 4.5
                    else:
                        cashback_rate = 4.0
                
                api_complexes.append({
                    'id': complex.get('id', len(api_complexes) + 1),
                    'name': complex_name,
                    'cashback_rate': cashback_rate,
                    'price_from': complex.get('real_price_from'),
                    'district': complex.get('district', city_context.name if 'city_context' in locals() else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä')
                })
            
            # Remove duplicates by name
            unique_complexes = {}
            for complex in api_complexes:
                name = complex['name']
                if name not in unique_complexes:
                    unique_complexes[name] = complex
            
            return jsonify({'complexes': list(unique_complexes.values())})
        
        except Exception as json_error:
            print(f"Error loading JSON complexes: {json_error}")
            # Final fallback to simple list
            return jsonify({
                'complexes': [
                    {'id': 1, 'name': '–ñ–ö ¬´–õ–µ—Ç–Ω–∏–π¬ª', 'cashback_rate': 5.0},
                    {'id': 2, 'name': '–ñ–ö ¬´–ß–∞–π–Ω—ã–µ —Ö–æ–ª–º—ã¬ª', 'cashback_rate': 4.5},
                    {'id': 3, 'name': '–ñ–ö ¬´–ö–∏—Å–ª–æ—Ä–æ–¥¬ª', 'cashback_rate': 5.0},
                    {'id': 4, 'name': '–ñ–ö ¬´–ì—Ä–∞–Ω–¥ –ö–∞—Å–∫–∞–¥¬ª', 'cashback_rate': 4.0}
                ]
            })

@app.route('/api/residential-complexes-full')
def api_residential_complexes_full():
    """API endpoint for getting all residential complexes using normalized tables"""
    from repositories.property_repository import ResidentialComplexRepository
    
    try:
        complexes = ResidentialComplexRepository.get_all_active() if not city_id_filter else [
            c for c in ResidentialComplexRepository.get_all_active() 
            if c.city_id == city_id_filter
        ]
        all_stats = PropertyRepository.get_all_property_stats()
        
        complexes_data = []
        for complex in complexes:
            stats = all_stats.get(complex.id, {
                'min_price': 0,
                'max_price': 0,
                'total_properties': 0
            })
            
            complex_dict = {
                'id': complex.id,
                'name': complex.name,
                'cashback_rate': complex.cashback_rate if complex.cashback_rate else 5.0,
                'district': complex.district or (city_context.name if 'city_context' in locals() else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä'),
                'address': complex.address or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',
                'developer': complex.developer.name if complex.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
                'min_price': stats['min_price'],
                'max_price': stats['max_price'],
                'real_price_from': stats['min_price'],
                'real_price_to': stats['max_price'],
                'available_apartments': stats['total_properties']
            }
            complexes_data.append(complex_dict)
        
        return jsonify({'complexes': complexes_data})
    except Exception as e:
        print(f"Error loading residential complexes: {e}")
        return jsonify({'complexes': []}), 500

@app.route('/api/cashback/calculate', methods=['POST'])
# @csrf.exempt  # CSRF disabled  # Disable CSRF for API endpoint
def api_calculate_cashback():
    """API endpoint for calculating cashback"""
    try:
        data = request.get_json()
        price = float(data.get('price', 0))
        complex_id = data.get('complex_id')
        
        if not price or price <= 0:
            return jsonify({'error': 'Invalid price'}), 400
        
        # Get cashback rate from database
        cashback_rate = 5.0  # default
        
        if complex_id:
            try:
                # –ò—â–µ–º –∫–æ–º–ø–ª–µ–∫—Å –≤ JSON –¥–∞–Ω–Ω—ã—Ö
                import json
                import os
                
                residential_complexes_file = 'static/data/residential_complexes.json'
                if os.path.exists(residential_complexes_file):
                    with open(residential_complexes_file, 'r', encoding='utf-8') as file:
                        json_complexes = json.load(file)
                    
                    for complex in json_complexes:
                        if str(complex.get('id')) == str(complex_id):
                            if 'cashback_rate' in complex:
                                cashback_rate = float(complex['cashback_rate'])
                            elif complex.get('real_price_from'):
                                # Calculate rate based on price range
                                complex_price = complex.get('real_price_from', 5000000)
                                if complex_price < 3000000:
                                    cashback_rate = 5.0
                                elif complex_price < 8000000:
                                    cashback_rate = 4.5
                                else:
                                    cashback_rate = 4.0
                            break
                            
                # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ JSON, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback —Å—Ç–∞–≤–∫–∏ –ø–æ ID
            except:
                # Fallback rates
                complex_rates = {
                    1: 5.5, 2: 6.0, 3: 7.0, 4: 5.0,
                    5: 6.5, 6: 5.5, 7: 7.5, 8: 8.0
                }
                cashback_rate = complex_rates.get(int(complex_id), 5.0)
        
        cashback_amount = price * (cashback_rate / 100)
        
        # Cap at maximum
        max_cashback = 500000
        if cashback_amount > max_cashback:
            cashback_amount = max_cashback
        
        return jsonify({
            'cashback_amount': int(cashback_amount),
            'cashback_rate': cashback_rate,
            'price': int(price),
            'formatted_amount': f"{int(cashback_amount):,}".replace(',', ' ')
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/cashback/apply', methods=['POST'])
@login_required
# @csrf.exempt  # CSRF disabled  # Disable CSRF for API endpoint
def api_apply_cashback():
    """API endpoint for submitting cashback application"""
    try:
        from models import CashbackApplication, UserActivity, CallbackRequest
        
        data = request.get_json()
        if not data:
            return jsonify({'error': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö'}), 400
            
        price = data.get('price')
        complex_id = data.get('complex_id')  # –ú–æ–∂–µ—Ç –±—ã—Ç—å null –¥–ª—è –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞
        complex_name = data.get('complex_name', '–ù–µ —É–∫–∞–∑–∞–Ω')
        cashback_amount = data.get('cashback_amount')
        cashback_rate = data.get('cashback_rate', 2.5)
        user_phone = data.get('phone', '')
        user_name = data.get('name', '')
        
        # Validate required fields (complex_id –æ–ø—Ü–∏–æ–Ω–∞–ª–µ–Ω)
        if not all([price, cashback_amount, user_phone, user_name]):
            return jsonify({'error': '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è'}), 400
        
        # Validate data types
        try:
            price = float(price)
            cashback_amount = float(cashback_amount)
            cashback_rate = float(cashback_rate)
        except (ValueError, TypeError):
            return jsonify({'error': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —á–∏—Å–ª–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö'}), 400
        
        # Create cashback application
        cashback_app = CashbackApplication(
            user_id=current_user.id,
            property_name=f"–ö–≤–∞—Ä—Ç–∏—Ä–∞ –≤ {complex_name}",
            property_type="–ö–≤–∞—Ä—Ç–∏—Ä–∞",
            property_size=50.0,  # Default size, can be improved later
            property_price=int(price),
            complex_name=complex_name,
            developer_name=data.get('developer_name', '–ù–µ —É–∫–∞–∑–∞–Ω'),
            cashback_amount=int(cashback_amount),
            cashback_percent=cashback_rate,
            status='–í –æ–±—Ä–∞–±–æ—Ç–∫–µ'
        )
        
        db.session.add(cashback_app)
        
        # Record user activity
        UserActivity.log_activity(
            user_id=current_user.id,
            activity_type='cashback_application',
            description=f'–ü–æ–¥–∞–Ω–∞ –∑–∞—è–≤–∫–∞ –Ω–∞ –∫–µ—à–±–µ–∫ {int(cashback_amount):,} ‚ÇΩ –ø–æ –æ–±—ä–µ–∫—Ç—É –≤ {complex_name}'.replace(',', ' '),
            complex_id=complex_id
        )
        
        callback = CallbackRequest(
            name=user_name,
            phone=user_phone,
            notes=f"–ó–∞—è–≤–∫–∞ –Ω–∞ –∫–µ—à–±–µ–∫ {int(cashback_amount):,} ‚ÇΩ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã –≤ {complex_name} —Å—Ç–æ–∏–º–æ—Å—Ç—å—é {int(price):,} ‚ÇΩ".replace(',', ' ')
        )
        
        db.session.add(callback)
        
        deal, _ = create_deal_from_website_form(
            name=user_name,
            phone=user_phone,
            source='–ó–∞—è–≤–∫–∞ –Ω–∞ –∫–µ—à–±–µ–∫',
            complex_name=complex_name,
            property_price=price,
            cashback_amount=cashback_amount,
            notes=f"–ö–µ—à–±–µ–∫ {int(cashback_amount):,} ‚ÇΩ ({cashback_rate}%)".replace(',', ' ')
        )
        
        db.session.commit()
        
        if deal:
            print(f"‚úÖ Deal {deal.deal_number} created from cashback application for {user_name}")
        
        return jsonify({
            'success': True,
            'message': '–ó–∞—è–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞! –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.'
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏: {str(e)}'}), 500

@app.route('/api/image-proxy')
def image_proxy():
    """
    Proxy endpoint to serve images with watermark cropped out
    Usage: /api/image-proxy?url=<image_url>&crop=<percent>
    """
    image_url = request.args.get('url')
    crop_percent = request.args.get('crop', '8')  # Default 8%
    
    if not image_url:
        return jsonify({'error': 'No image URL provided'}), 400
    
    try:
        crop_percent = int(crop_percent)
        
        # Crop watermark from image
        cropped_img = crop_watermark(image_url, crop_bottom_percent=crop_percent)
        
        if cropped_img is None:
            # If cropping failed, redirect to original image
            return redirect(image_url)
        
        # Convert to bytes
        img_io = io.BytesIO()
        cropped_img.save(img_io, format='JPEG', quality=90, optimize=True)
        img_io.seek(0)
        
        # Return image with caching headers
        response = make_response(send_file(img_io, mimetype='image/jpeg'))
        response.headers['Cache-Control'] = 'public, max-age=2592000'  # Cache for 30 days
        response.headers['X-Content-Type-Options'] = 'nosniff'
        
        return response
        
    except Exception as e:
        print(f"Error in image proxy: {e}")
        # Fallback to original image on error
        return redirect(image_url)

@app.route('/api/search/suggestions')
def search_suggestions():
    """API endpoint for search suggestions (autocomplete) - REAL DATABASE VERSION"""
    query = request.args.get('query', request.args.get('q', '')).lower().strip()
    if not query or len(query) < 2:
        return jsonify([])
    
    # ‚úÖ Get city context from URL parameter or session
    city_id = request.args.get('city_id', type=int)
    city_name_genitive = None
    if not city_id and 'city_id' in session:
        city_id = session['city_id']
    
    if city_id:
        from models import City
        city_obj = City.query.get(city_id)
        if city_obj:
            city_name_genitive = city_obj.name_genitive or city_obj.name
    
    suggestions = []
    

    def get_plural_form(count, singular, few, many):
        """Russian plural forms: 1 –∫–≤–∞—Ä—Ç–∏—Ä–∞, 2-4 –∫–≤–∞—Ä—Ç–∏—Ä—ã, 5+ –∫–≤–∞—Ä—Ç–∏—Ä"""
        count = abs(count) % 100
        if 11 <= count <= 14:
            return many
        last_digit = count % 10
        if last_digit == 1:
            return singular
        elif 2 <= last_digit <= 4:
            return few
        else:
            return many

    try:
        # 1. Search by room types (PRIORITY - user's main request)
        room_suggestions = {
            '—Å—Ç—É–¥': '–°—Ç—É–¥–∏—è',
            '1-–∫': '1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '1-–∫–æ–º': '1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è', 
            '1–∫–æ–º–Ω': '1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '1–∫': '1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '1 –∫': '1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '–æ–¥–Ω': '1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '2-–∫': '2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '2-–∫–æ–º': '2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '2–∫–æ–º–Ω': '2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '2–∫': '2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '2 –∫': '2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è', 
            '–¥–≤—É—Ö': '2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '3-–∫': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '3-–∫–æ–º': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '3–∫–æ–º–Ω': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '3–∫': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '3 –∫': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '—Ç—Ä–µ—Ö': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '—Ç—Ä—ë—Ö': '3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '4-–∫': '4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '4-–∫–æ–º': '4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '4–∫–æ–º–Ω': '4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '4–∫': '4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è',
            '—á–µ—Ç—ã—Ä': '4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è'
        }
        
        for pattern, room_type in room_suggestions.items():
            if pattern in query:
                # ‚úÖ MIGRATED: Count properties by room type using PropertyRepository
                if '—Å—Ç—É–¥' in pattern:
                    count = PropertyRepository.count_active(filters={'rooms': [0], 'city_id': city_id}) if city_id else PropertyRepository.count_active(filters={'rooms': [0]})
                else:
                    room_num = room_type.split('-')[0] if '-' in room_type else '1'
                    count = PropertyRepository.count_active(filters={'rooms': [int(room_num)], 'city_id': city_id}) if city_id else PropertyRepository.count_active(filters={'rooms': [int(room_num)]})
                
                # –°–æ–∑–¥–∞–µ–º URL —Å —Ç–µ–º –∂–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º —á—Ç–æ –±—ã—Å—Ç—Ä—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
                if '—Å—Ç—É–¥' in pattern:
                    room_param = '0'
                else:
                    room_param = room_type.split('-')[0] if '-' in room_type else '1'
                
                
                # Build subtitle with correct city and plural form
                plural_form = get_plural_form(count, '–∫–≤–∞—Ä—Ç–∏—Ä–∞', '–∫–≤–∞—Ä—Ç–∏—Ä—ã', '–∫–≤–∞—Ä—Ç–∏—Ä')
                if city_name_genitive:
                    subtitle = f'–ù–∞–π–¥–µ–Ω–æ {count} {plural_form} –¥–ª—è {city_name_genitive}'
                else:
                    subtitle = f'–ù–∞–π–¥–µ–Ω–æ {count} {plural_form}'
                
                suggestions.append({
                    'type': 'rooms', 
                    'text': room_type,
                    'title': room_type,  # –î–æ–±–∞–≤–ª—è–µ–º title –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                    'subtitle': subtitle,
                    'url': url_for('properties', rooms=room_param)  # rooms=1 –∫–∞–∫ –±—ã—Å—Ç—Ä—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
                })
        
        # ‚úÖ NEW: Search by city name - high priority for city switching
        from models import City, Property as PropertyModel
        cities_query = (
            db.session.query(City.name, City.slug, func.count(PropertyModel.id).label('count'))
            .join(PropertyModel, PropertyModel.city_id == City.id, isouter=True)
            .filter(
                City.name.ilike(f'%{query}%'),
                PropertyModel.is_active == True
            )
            .group_by(City.id, City.name, City.slug)
            .having(func.count(PropertyModel.id) > 0)
            .order_by(func.count(PropertyModel.id).desc())
            .limit(5)
            .all()
        )
        
        for city_row in cities_query:
            city_name = city_row[0]
            city_slug = city_row[1]
            prop_count = city_row[2]
            if city_name and prop_count > 0:
                plural_form = get_plural_form(prop_count, '–∫–≤–∞—Ä—Ç–∏—Ä–∞', '–∫–≤–∞—Ä—Ç–∏—Ä—ã', '–∫–≤–∞—Ä—Ç–∏—Ä')
                suggestions.append({
                    'type': 'city',
                    'text': city_name,
                    'subtitle': f'{prop_count} {plural_form}',
                    'url': url_for('properties_city', city_slug=city_slug) if city_slug else url_for('properties', city=city_name),
                    'icon': 'fas fa-city'
                })
        
        # ‚úÖ MIGRATED: Search in residential complexes using ORM
        from models import ResidentialComplex, Property
        complexes_query = (
            db.session.query(ResidentialComplex.name, func.count(Property.id).label('count'))
            .join(Property, Property.complex_id == ResidentialComplex.id, isouter=True)
            .filter(
                ResidentialComplex.name.ilike(f'%{query}%'),
                ResidentialComplex.city_id == city_id,
                Property.is_active == True
            )
            .group_by(ResidentialComplex.name)
            .order_by(func.count(Property.id).desc())
            .limit(5)
            .all()
        )
        
        for row in complexes_query:
            if row[0] and len(row[0]) > 2:  # Skip empty/short names
                suggestions.append({
                    'type': 'complex',
                    'text': row[0],
                    'subtitle': f'{row[1]} –∫–≤–∞—Ä—Ç–∏—Ä –¥–æ—Å—Ç—É–ø–Ω–æ',
                    'url': url_for('properties', residential_complex=row[0])
                })
        
        # ‚úÖ MIGRATED: Search in developers using ORM
        from models import Developer
        developers_query = (
            db.session.query(Developer.name, func.count(Property.id).label('count'))
            .join(Property, Property.developer_id == Developer.id, isouter=True)
            .filter(
                Developer.name.ilike(f'%{query}%'),
                Property.city_id == city_id,
                Property.is_active == True
            )
            .group_by(Developer.name)
            .order_by(func.count(Property.id).desc())
            .limit(3)
            .all()
        )
        
        for row in developers_query:
            if row[0] and len(row[0]) > 2:
                suggestions.append({
                    'type': 'developer',
                    'text': row[0],
                    'subtitle': f'–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ ‚Ä¢ {row[1]} –ø—Ä–æ–µ–∫—Ç–æ–≤',
                    'url': url_for('properties', developer=row[0])
                })
        
        # ‚úÖ NEW: Search districts from District reference table (shows all districts, not just those with properties)
        from models import District
        district_ref_filter = [District.name.ilike(f'%{query}%')]
        
        if city_id:
            district_ref_filter.append(District.city_id == city_id)
        
        district_ref_query = (
            db.session.query(District.name, District.id)
            .filter(*district_ref_filter)
            .limit(5)
            .all()
        )
        
        for district_row in district_ref_query:
            district_name = district_row[0]
            district_id = district_row[1]
            
            if district_name and '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π' not in district_name:
                clean_district = district_name.replace('–†–æ—Å—Å–∏—è, ', '').replace('–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π, ', '')
                
                display_text = clean_district
                if '–º–∫—Ä' not in clean_district.lower() and '–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω' not in clean_district.lower():
                    display_text = f'–†–∞–π–æ–Ω {clean_district}'
                
                count = PropertyRepository.count_active(filters={'district_id': district_id})
                plural_form = get_plural_form(count, '–∫–≤–∞—Ä—Ç–∏—Ä–∞', '–∫–≤–∞—Ä—Ç–∏—Ä—ã', '–∫–≤–∞—Ä—Ç–∏—Ä')
                
                suggestions.append({
                    'type': 'district',
                    'text': display_text,
                    'subtitle': f'{count} {plural_form}' if count > 0 else '–†–∞–π–æ–Ω –≥–æ—Ä–æ–¥–∞',
                    'url': url_for('properties', district=clean_district)
                })
        

        # ‚úÖ MIGRATED: Search in districts using ORM with city filtering
        from models import District
        districts_filter = [
            District.name.ilike(f'%{query}%'),
            Property.is_active == True
        ]
        
        # ‚úÖ Filter by current city if city_id is set
        if city_id:
            districts_filter.append(District.city_id == city_id)
        
        districts_query = (
            db.session.query(District.name, func.count(Property.id).label('count'))
            .join(Property, Property.district_id == District.id, isouter=True)
            .filter(*districts_filter)
            .group_by(District.name)
            .order_by(func.count(Property.id).desc())
            .limit(5)
            .all()
        )
        
        for row in districts_query:
            if row[0] and '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π' not in row[0]:  # Skip generic region name
                clean_district = row[0].replace('–†–æ—Å—Å–∏—è, ', '').replace('–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π, ', '')
                
                # Format like Yandex.–ù–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å: "–†–∞–π–æ–Ω –ó–∞–ø–∞–¥–Ω—ã–π" or "–º–∫—Ä. –ë—ã—Ç—Ö–∞"
                display_text = clean_district
                if '–º–∫—Ä' not in clean_district.lower() and '–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω' not in clean_district.lower():
                    display_text = f'–†–∞–π–æ–Ω {clean_district}'
                
                plural_form = get_plural_form(row[1], '–∫–≤–∞—Ä—Ç–∏—Ä–∞', '–∫–≤–∞—Ä—Ç–∏—Ä—ã', '–∫–≤–∞—Ä—Ç–∏—Ä')
                
                already_added = any(s['text'] == display_text for s in suggestions if s.get('type') == 'district')
                
                if not already_added:
                    suggestions.append({
                    'type': 'district',
                    'text': display_text,
                    'subtitle': f'{row[1]} {plural_form}',
                    'url': url_for('properties', district=clean_district)
                })
        
        # Search by property types (–∫–≤–∞—Ä—Ç–∏—Ä–∞, –ø–µ–Ω—Ç—Ö–∞—É—Å, —Ç–∞—É–Ω—Ö–∞—É—Å, –¥–æ–º)
        property_type_keywords = {
            '–∫–≤–∞—Ä—Ç–∏—Ä': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
            '–ø–µ–Ω—Ç—Ö–∞—É—Å': '–ü–µ–Ω—Ç—Ö–∞—É—Å',
            '—Ç–∞—É–Ω—Ö–∞—É—Å': '–¢–∞—É–Ω—Ö–∞—É—Å',
            '–¥–æ–º': '–î–æ–º',
            'house': '–î–æ–º',
            'townhouse': '–¢–∞—É–Ω—Ö–∞—É—Å'
        }
        
        for keyword, prop_type in property_type_keywords.items():
            if keyword in query:
                # Count properties of this type
                try:
                    count_query = (
                        db.session.query(func.count(Property.id))
                        .filter(
                            Property.property_type.ilike(f'%{prop_type}%'),
                            Property.is_active == True
                        )
                    )
                    count = count_query.scalar() or 0
                    
                    if count > 0:  # Only show if there are results
                        suggestions.append({
                            'type': 'property_type',
                            'text': prop_type,
                            'subtitle': f'–ù–∞–π–¥–µ–Ω–æ {count} –æ–±—ä–µ–∫—Ç–æ–≤',
                            'url': url_for('properties', property_type=prop_type)
                        })
                except Exception as e:
                    print(f"Property type search error: {e}")
                    pass
        
        # ‚úÖ NEW: Search by address/street in properties table - returns list of properties
        try:
            # Get unique streets/addresses that match query
            from sqlalchemy import func as sql_func
            address_query = (
                db.session.query(
                    Property.parsed_street,
                    sql_func.count(Property.id).label('count')
                )
                .filter(
                    Property.is_active == True,
                    Property.parsed_street.isnot(None),
                    Property.parsed_street != '',
                    Property.parsed_street.ilike(f'%{query}%')
                )
            )
            
            if city_id:
                address_query = address_query.filter(Property.city_id == city_id)
            
            address_results = (
                address_query
                .group_by(Property.parsed_street)
                .order_by(sql_func.count(Property.id).desc())
                .limit(5)
                .all()
            )
            
            for row in address_results:
                street_name = row[0]
                prop_count = row[1]
                if street_name and len(street_name) > 2:
                    plural_form = get_plural_form(prop_count, '–∫–≤–∞—Ä—Ç–∏—Ä–∞', '–∫–≤–∞—Ä—Ç–∏—Ä—ã', '–∫–≤–∞—Ä—Ç–∏—Ä')
                    
                    # Build URL with city slug if available
                    if city_id:
                        from models import City
                        city_for_url = City.query.get(city_id)
                        if city_for_url and city_for_url.slug:
                            search_url = url_for('properties_city', city_slug=city_for_url.slug, search=street_name)
                        else:
                            search_url = url_for('properties', search=street_name)
                    else:
                        search_url = url_for('properties', search=street_name)
                    
                    suggestions.append({
                        'type': 'address',
                        'text': street_name,
                        'subtitle': f'{prop_count} {plural_form}',
                        'url': search_url,
                        'icon': 'fas fa-map-marker-alt'
                    })
        except Exception as e:
            print(f"Address search error: {e}")
            pass
        
        # DaData address suggestions (cities, streets, districts)
        dadata = get_dadata_client()
        if dadata.is_available():
            try:
                dadata_suggestions = dadata.suggest_address(
                    query,
                    count=5,
                    # ‚úÖ NO city_id filter - universal search for ALL cities (like Avito/Cian)
                )
                for item in dadata_suggestions:
                    addr_type = item['type']

                    # ‚úÖ CRITICAL FIX: Skip districts from DaData - we use local District table instead!
                    # DaData returns districts from ALL cities in the region (e.g., Mostovskoy, Beloglinskiy)
                    # which confuses users. Our District table has curated city-specific data.
                    if addr_type == 'district':
                        continue

                    # Map DaData types to UI-friendly names
                    type_map = {
                        'city': '–ì–æ—Ä–æ–¥',
                        'street': '–£–ª–∏—Ü–∞', 
                        'district': '–†–∞–π–æ–Ω',
                        'settlement': '–ù–∞—Å–µ–ª–µ–Ω–Ω—ã–π –ø—É–Ω–∫—Ç',
                        'region': '–†–µ–≥–∏–æ–Ω'
                    }
                    suggestions.append({
                        'type': addr_type,
                        'text': item['text'],
                        'subtitle': type_map.get(addr_type, addr_type),
                        'url': url_for('properties', search=item['text']),
                        'source': 'dadata'
                    })
                app.logger.info(f"‚úÖ DaData added {len(dadata_suggestions)} address suggestions")
            except Exception as e:
                app.logger.warning(f"DaData suggestions failed (fallback to DB): {e}")
        
        # Sort by relevance with proper priority:
        # 1. Room types (highest priority)
        # 2. Exact matches
        # 3. DaData addresses (cities, streets, districts)
        # 4. DB results (complexes, developers, districts)
        suggestions.sort(key=lambda x: (
            0 if x['type'] == 'room_type' else 
            1 if x['text'].lower().startswith(query) else
            2 if x.get('source') == 'dadata' else 3,
            len(x['text'])
        ))
        
        return jsonify(suggestions[:10])  # Return top 10 suggestions
        
    except Exception as e:
        app.logger.error(f"Error in search suggestions: {e}")
        return jsonify([])


@require_json_csrf
@app.route('/api/search/history/save', methods=['POST'])
def save_search_history():
    """Save user's search query to history"""
    try:
        from models import SearchHistory, SearchAnalytics, Manager
        
        data = request.get_json() or {}
        query = data.get('query', '').strip()
        result_count = data.get('result_count', 0)
        
        if not query:
            return jsonify({'success': False, 'error': 'Query is required'}), 400
        
        # Determine user or manager using proper isinstance check
        user_id = None
        manager_id = None
        
        if current_user.is_authenticated:
            current_obj = current_user._get_current_object()
            if isinstance(current_obj, Manager):
                manager_id = current_user.id
            else:
                user_id = current_user.id
        
        # Only save history for authenticated users
        if user_id or manager_id:
            # Save to search history
            history_entry = SearchHistory(
                query=query,
                user_id=user_id,
                manager_id=manager_id,
                result_count=result_count
            )
            db.session.add(history_entry)
            
            # Record in analytics
            SearchAnalytics.record_search(query, result_count)
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'Search saved to history'
            })
        else:
            # Unauthorized - require authentication for search history
            return jsonify({'success': False, 'error': 'Authentication required'}), 401
    
    except Exception as e:
        app.logger.error(f"Error saving search history: {e}")
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/search/history/list')
def get_search_history():
    """Get user's search history (last 20 searches)"""
    try:
        from models import SearchHistory, Manager
        
        if not current_user.is_authenticated:
            return jsonify({'success': False, 'history': [], 'error': 'Not authenticated'}), 401
        
        # Determine if user or manager using proper isinstance check
        current_obj = current_user._get_current_object()
        if isinstance(current_obj, Manager):
            history = db.session.query(SearchHistory).filter_by(
                manager_id=current_user.id
            ).order_by(SearchHistory.created_at.desc()).limit(20).all()
        else:
            history = db.session.query(SearchHistory).filter_by(
                user_id=current_user.id
            ).order_by(SearchHistory.created_at.desc()).limit(20).all()
        
        return jsonify({
            'success': True,
            'history': [h.to_dict() for h in history]
        })
    
    except Exception as e:
        app.logger.error(f"Error getting search history: {e}")
        return jsonify({'success': False, 'history': [], 'error': str(e)}), 500


@app.route('/api/search/popular')
def get_popular_searches():
    """Get popular search queries from real user data"""
    try:
        from models import SearchAnalytics
        
        limit = request.args.get('limit', default=10, type=int)
        limit = min(limit, 20)  # Cap at 20
        
        # Get popular searches from analytics
        popular = SearchAnalytics.get_popular_searches(limit=limit, min_results=1)
        
        # Format for frontend
        suggestions = []
        for analytics in popular:
            # Create room type button if it's a room search
            query = analytics.query
            icon = 'üî•'
            
            # Detect room types for appropriate icons
            if any(word in query for word in ['—Å—Ç—É–¥', 'studio']):
                icon = 'üè†'
            elif any(word in query for word in ['1', '–æ–¥–Ω', '–æ–¥–∏–Ω']):
                icon = 'üè†'
            elif any(word in query for word in ['2', '–¥–≤—É—Ö', '–¥–≤–∞']):
                icon = 'üè†'
            elif any(word in query for word in ['3', '—Ç—Ä–µ—Ö', '—Ç—Ä–∏', '—Ç—Ä—ë—Ö']):
                icon = 'üè†'
            elif any(word in query for word in ['—Ü–µ–Ω—Ç—Ä', '—Ü–µ–Ω']):
                icon = 'üìç'
            elif any(word in query for word in ['–ø–∞—Ä–∫', '—Å–∫–≤–µ—Ä']):
                icon = 'üå≥'
            
            suggestions.append({
                'query': query,
                'icon': icon,
                'count': int(analytics.result_count_avg),
                'search_count': analytics.search_count
            })
        
        return jsonify({
            'success': True,
            'popular': suggestions
        })
    
    except Exception as e:
        app.logger.error(f"Error getting popular searches: {e}")
        return jsonify({'success': False, 'popular': []})
@app.route('/semejnaya-ipoteka')
@app.route('/family-mortgage')
def family_mortgage():
    """Redirect to city-based URL"""
    return redirect_to_city_based('family_mortgage_city')

@app.route('/it-ipoteka')
@app.route('/it-mortgage')
def it_mortgage():
    """Redirect to city-based URL"""
    return redirect_to_city_based('it_mortgage_city')

@app.route('/strahovanie')
@app.route('/insurance')
def insurance():
    """Redirect to city-based URL"""
    return redirect_to_city_based('insurance_city')


@app.route('/otsenka')
@app.route('/appraisal')
def appraisal():
    """Redirect to city-based URL"""
    return redirect_to_city_based('appraisal_city')
@app.route('/submit-insurance-application', methods=['POST'])
def submit_insurance_application():
    """Submit insurance application with CSRF protection and enhanced validation"""
    try:
        # Validate CSRF token for form submissions
        try:
            validate_csrf(request.form.get('csrf_token'))
        except Exception:
            return jsonify({'success': False, 'error': 'CSRF token missing or invalid'}), 400
        
        # Get form data
        name = request.form.get('name', '').strip()
        phone = request.form.get('phone', '').strip()
        bank = request.form.get('bank', '').strip()
        credit_amount = request.form.get('credit_amount', '').strip()
        birth_date = request.form.get('birth_date', '').strip()
        gender = request.form.get('gender', '').strip()
        comment = request.form.get('comment', '').strip()
        
        # Enhanced validation for required fields
        if not all([name, phone, bank, credit_amount, birth_date, gender]):
            return jsonify({'success': False, 'error': '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è'}), 400
        
        # Validate name (2-50 characters, only letters and spaces)
        if not re.match(r'^[–∞-—è–ê-–Ø—ë–Åa-zA-Z\s]{2,50}$', name):
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∏–º—è'}), 400
        
        # Validate phone (Russian phone number format)
        phone_clean = re.sub(r'[^\d]', '', phone)
        if not re.match(r'^[78]\d{10}$', phone_clean):
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞'}), 400
        
        # Validate credit amount (numeric, reasonable range)
        try:
            credit_amount_num = float(re.sub(r'[^\d.]', '', credit_amount))
            if credit_amount_num < 100000 or credit_amount_num > 50000000:
                return jsonify({'success': False, 'error': '–°—É–º–º–∞ –∫—Ä–µ–¥–∏—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç 100 000 –¥–æ 50 000 000 —Ä—É–±–ª–µ–π'}), 400
        except (ValueError, TypeError):
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—É–º–º–∞ –∫—Ä–µ–¥–∏—Ç–∞'}), 400
        
        # Validate birth date
        try:
            from datetime import datetime
            birth_dt = datetime.strptime(birth_date, '%Y-%m-%d')
            age = (datetime.now() - birth_dt).days / 365.25
            if age < 18 or age > 100:
                return jsonify({'success': False, 'error': '–í–æ–∑—Ä–∞—Å—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 18 –¥–æ 100 –ª–µ—Ç'}), 400
        except ValueError:
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è'}), 400
        
        # Validate gender
        if gender not in ['–ú—É–∂—á–∏–Ω–∞', '–ñ–µ–Ω—â–∏–Ω–∞']:
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–æ–ª'}), 400
        
        # Format credit amount for display
        try:
            credit_amount_num = int(credit_amount)
            credit_amount_formatted = f"{credit_amount_num:,}".replace(",", " ") + " ‚ÇΩ"
        except:
            credit_amount_formatted = credit_amount + " ‚ÇΩ"
        
        # Dual notification: send to both email and Telegram
        current_time = datetime.now().strftime('%d.%m.%Y %H:%M')
        
        # Send email notification
        email_success = False
        try:
            email_success = send_email(
                'bithome@mail.ru', 
                f'–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ —Å—Ç—Ä–∞—Ö–æ–≤–∞–Ω–∏–µ –æ—Ç {name}', 
                'emails/insurance_application.html', 
                name=name, 
                phone=phone, 
                bank=bank, 
                credit_amount=credit_amount_formatted, 
                birth_date=birth_date, 
                gender=gender, 
                comment=comment, 
                submitted_at=datetime.now(),
                current_time=current_time
            )
        except Exception as email_error:
            app.logger.error(f"Error sending insurance application email: {email_error}")
        
        # Send Telegram notification
        telegram_success = False
        try:
            from email_service import send_telegram_insurance_notification
            telegram_success = send_telegram_insurance_notification(
                name=name,
                phone=phone,
                bank=bank,
                credit_amount=credit_amount_formatted,
                birth_date=birth_date,
                gender=gender,
                comment=comment,
                current_time=current_time
            )
        except Exception as telegram_error:
            app.logger.error(f"Error sending insurance application Telegram: {telegram_error}")
        
        # Determine response based on both results
        if email_success and telegram_success:
            return jsonify({'success': True, 'message': '–ó–∞—è–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ email –∏ –≤ Telegram'})
        elif email_success and not telegram_success:
            return jsonify({'success': True, 'message': '–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ email, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ Telegram', 'warning': True})
        elif not email_success and telegram_success:
            return jsonify({'success': True, 'message': '–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ Telegram, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ email', 'warning': True})
        else:
            return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–∫–∏ –∏ –Ω–∞ email, –∏ –≤ Telegram'}), 500
            
    except Exception as e:
        app.logger.error(f"Error in insurance application: {e}")
        return jsonify({'success': False, 'error': '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'}), 500



@app.route('/api/developers')
def api_developers():
    """API endpoint to get developers filtered by city_id"""
    try:
        from models import Developer, ResidentialComplex, Property
        from sqlalchemy import func, distinct
        
        # Get optional city_id from query parameter
        city_id = request.args.get('city_id', type=int)
        
        # Use subquery approach for better performance
        if city_id:
            # Subquery to count properties per developer for a specific city
            property_count_subquery = (
                db.session.query(
                    Developer.id.label('dev_id'),
                    func.count(distinct(Property.id)).label('properties_count')
                )
                .join(ResidentialComplex, Developer.id == ResidentialComplex.developer_id)
                .join(Property, ResidentialComplex.id == Property.complex_id)
                .filter(Property.city_id == city_id)
                .filter(ResidentialComplex.city_id == city_id)
                .group_by(Developer.id)
                .having(func.count(distinct(Property.id)) > 0)
                .subquery()
            )
            
            # Main query joining developers with the subquery
            developers_list = (
                db.session.query(
                    Developer,
                    property_count_subquery.c.properties_count
                )
                .join(property_count_subquery, Developer.id == property_count_subquery.c.dev_id)
                .order_by(property_count_subquery.c.properties_count.desc())
                .all()
            )
        else:
            # All developers without city filter
            developers_list = (
                db.session.query(
                    Developer,
                    func.count(distinct(Property.id)).label('properties_count')
                )
                .outerjoin(ResidentialComplex, Developer.id == ResidentialComplex.developer_id)
                .outerjoin(Property, ResidentialComplex.id == Property.complex_id)
                .group_by(Developer.id)
                .order_by(func.count(distinct(Property.id)).desc())
                .all()
            )
        
        # Format response
        developers_data = []
        for developer, properties_count in developers_list:
            developers_data.append({
                'id': developer.id,
                'name': developer.name,
                'properties_count': int(properties_count) if properties_count else 0
            })
        
        return jsonify({'developers': developers_data})
        
    except Exception as e:
        app.logger.error(f"Error in /api/developers: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@app.route('/api/check-it-company', methods=['POST'])
@csrf.exempt
def check_it_company():
    """Check if company is in IT companies list by INN or company name"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏'}), 400
            
        inn = data.get('inn', '').strip()
        company_name = data.get('company_name', '').strip()
        
        if not inn and not company_name:
            return jsonify({'error': '–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å –ò–ù–ù –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏'}), 400
        
        # –ü–æ–∏—Å–∫ –ø–æ –ò–ù–ù
        if inn:
            try:
                inn_int = int(inn)
                company = db.session.execute(text("""
                    SELECT inn, name FROM it_companies 
                    WHERE inn = :inn LIMIT 1
                """), {'inn': inn_int}).fetchone()
                
                if company:
                    return jsonify({
                        'found': True,
                        'inn': company[0],
                        'company_name': company[1],
                        'message': '–ö–æ–º–ø–∞–Ω–∏—è –Ω–∞–π–¥–µ–Ω–∞ –≤ —Ä–µ–µ—Å—Ç—Ä–µ –ò–¢-–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π'
                    })
            except ValueError:
                pass
        
        # –ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –∫–æ–º–ø–∞–Ω–∏–∏ (—á–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ)
        if company_name:
            company = db.session.execute(text("""
                SELECT inn, name FROM it_companies 
                WHERE LOWER(name) LIKE LOWER(:company_name) 
                LIMIT 1
            """), {'company_name': f'%{company_name}%'}).fetchone()
            
            if company:
                return jsonify({
                    'found': True,
                    'inn': company[0],
                    'company_name': company[1],
                    'message': '–ö–æ–º–ø–∞–Ω–∏—è –Ω–∞–π–¥–µ–Ω–∞ –≤ —Ä–µ–µ—Å—Ç—Ä–µ –ò–¢-–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π'
                })
        
        return jsonify({
            'found': False,
            'message': '–ö–æ–º–ø–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Ä–µ–µ—Å—Ç—Ä–µ –ò–¢-–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–π. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –ò–ù–ù –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–æ–º–ø–∞–Ω–∏–∏.'
        })
        
    except Exception as e:
        print(f"Error checking IT company: {e}")
        return jsonify({'error': '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫–æ–º–ø–∞–Ω–∏–∏'}), 500

@app.route('/api/suggest-it-companies', methods=['POST'])
@csrf.exempt
def suggest_it_companies():
    """Get IT company suggestions for autocomplete"""
    try:
        data = request.get_json()
        query = data.get('query', '').strip().lower()
        
        if len(query) < 2:
            return jsonify({'suggestions': []})
            
        # Search for companies matching the query
        suggestions = db.session.execute(text("""
            SELECT DISTINCT name FROM it_companies 
            WHERE LOWER(name) LIKE :query 
            ORDER BY name 
            LIMIT 10
        """), {'query': f'%{query}%'}).fetchall()
        
        return jsonify({
            'suggestions': [suggestion[0] for suggestion in suggestions]
        })
        
    except Exception as e:
        print(f"Error in suggest_it_companies: {str(e)}")
        return jsonify({'suggestions': []})

@app.route('/api/detect-city', methods=['GET'])
@csrf.exempt
def detect_city():
    """Detect user's city by IP address and auto-set session['city_id']"""
    from models import City
    
    # –°–ª–æ–≤–∞—Ä—å –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ —Ç—Ä–∞–Ω—Å–ª–∏—Ç–∞ –≥–æ—Ä–æ–¥–æ–≤ –≤ —Ä—É—Å—Å–∫–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è
    city_translations = {
        'Krasnodar': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
        'Moscow': '–ú–æ—Å–∫–≤–∞',
        'Saint Petersburg': '–°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥',
        'Novosibirsk': '–ù–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫',
        'Yekaterinburg': '–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥',
        'Nizhny Novgorod': '–ù–∏–∂–Ω–∏–π –ù–æ–≤–≥–æ—Ä–æ–¥',
        'Kazan': '–ö–∞–∑–∞–Ω—å',
        'Chelyabinsk': '–ß–µ–ª—è–±–∏–Ω—Å–∫',
        'Omsk': '–û–º—Å–∫',
        'Samara': '–°–∞–º–∞—Ä–∞',
        'Rostov-on-Don': '–†–æ—Å—Ç–æ–≤-–Ω–∞-–î–æ–Ω—É',
        'Ufa': '–£—Ñ–∞',
        'Krasnoyarsk': '–ö—Ä–∞—Å–Ω–æ—è—Ä—Å–∫',
        'Voronezh': '–í–æ—Ä–æ–Ω–µ–∂',
        'Perm': '–ü–µ—Ä–º—å',
        'Volgograd': '–í–æ–ª–≥–æ–≥—Ä–∞–¥',
        'Saratov': '–°–∞—Ä–∞—Ç–æ–≤',
        'Tyumen': '–¢—é–º–µ–Ω—å',
        'Tolyatti': '–¢–æ–ª—å—è—Ç—Ç–∏',
        'Izhevsk': '–ò–∂–µ–≤—Å–∫',
        'Barnaul': '–ë–∞—Ä–Ω–∞—É–ª',
        'Ulyanovsk': '–£–ª—å—è–Ω–æ–≤—Å–∫',
        'Irkutsk': '–ò—Ä–∫—É—Ç—Å–∫',
        'Khabarovsk': '–•–∞–±–∞—Ä–æ–≤—Å–∫',
        'Yaroslavl': '–Ø—Ä–æ—Å–ª–∞–≤–ª—å',
        'Vladivostok': '–í–ª–∞–¥–∏–≤–æ—Å—Ç–æ–∫',
        'Makhachkala': '–ú–∞—Ö–∞—á–∫–∞–ª–∞',
        'Tomsk': '–¢–æ–º—Å–∫',
        'Orenburg': '–û—Ä–µ–Ω–±—É—Ä–≥',
        'Kemerovo': '–ö–µ–º–µ—Ä–æ–≤–æ',
        'Novokuznetsk': '–ù–æ–≤–æ–∫—É–∑–Ω–µ—Ü–∫',
        'Ryazan': '–†—è–∑–∞–Ω—å',
        'Astrakhan': '–ê—Å—Ç—Ä–∞—Ö–∞–Ω—å',
        'Naberezhnye Chelny': '–ù–∞–±–µ—Ä–µ–∂–Ω—ã–µ –ß–µ–ª–Ω—ã',
        'Penza': '–ü–µ–Ω–∑–∞',
        'Lipetsk': '–õ–∏–ø–µ—Ü–∫',
        'Kirov': '–ö–∏—Ä–æ–≤',
        'Cheboksary': '–ß–µ–±–æ–∫—Å–∞—Ä—ã',
        'Kaliningrad': '–ö–∞–ª–∏–Ω–∏–Ω–≥—Ä–∞–¥',
        'Tula': '–¢—É–ª–∞',
        'Kursk': '–ö—É—Ä—Å–∫',
        'Sochi': '–°–æ—á–∏',
        'Stavropol': '–°—Ç–∞–≤—Ä–æ–ø–æ–ª—å',
        'Ulan-Ude': '–£–ª–∞–Ω-–£–¥—ç',
        'Tver': '–¢–≤–µ—Ä—å',
        'Magnitogorsk': '–ú–∞–≥–Ω–∏—Ç–æ–≥–æ—Ä—Å–∫',
        'Bryansk': '–ë—Ä—è–Ω—Å–∫',
        'Ivanovo': '–ò–≤–∞–Ω–æ–≤–æ',
        'Belgorod': '–ë–µ–ª–≥–æ—Ä–æ–¥'
    }
    
    # –°–ª–æ–≤–∞—Ä—å –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ —Ä–µ–≥–∏–æ–Ω–æ–≤
    region_translations = {
        'Krasnodar Krai': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
        'Krasnodar Territory': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
        'Moscow': '–ú–æ—Å–∫–≤–∞',
        'Saint Petersburg': '–°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥',
        'Moscow Oblast': '–ú–æ—Å–∫–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å',
        'Sverdlovsk Oblast': '–°–≤–µ—Ä–¥–ª–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å',
        'Novosibirsk Oblast': '–ù–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å',
        'Rostov Oblast': '–†–æ—Å—Ç–æ–≤—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å',
        'Tatarstan': '–†–µ—Å–ø—É–±–ª–∏–∫–∞ –¢–∞—Ç–∞—Ä—Å—Ç–∞–Ω',
        'Bashkortostan': '–†–µ—Å–ø—É–±–ª–∏–∫–∞ –ë–∞—à–∫–æ—Ä—Ç–æ—Å—Ç–∞–Ω',
        'Chelyabinsk Oblast': '–ß–µ–ª—è–±–∏–Ω—Å–∫–∞—è –æ–±–ª–∞—Å—Ç—å'
    }
    
    # Map of supported cities (in our database) to their Russian names
    supported_cities = {
        '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä': 'krasnodar',
        '–°–æ—á–∏': 'sochi',
        '–ê–Ω–∞–ø–∞': 'anapa',
        '–ì–µ–ª–µ–Ω–¥–∂–∏–∫': 'gelendzhik',
        '–ù–æ–≤–æ—Ä–æ—Å—Å–∏–π—Å–∫': 'novorossiysk',
        '–ê—Ä–º–∞–≤–∏—Ä': 'armavir',
        '–¢—É–∞–ø—Å–µ': 'tuapse',
        '–ú–∞–π–∫–æ–ø': 'maykop'
    }
    
    def set_city_in_session(city_name):
        """Helper function to set city_id in session based on city name"""
        # Find city in database
        detected_city_slug = supported_cities.get(city_name)
        
        if detected_city_slug:
            # City is supported - find in database
            city_obj = City.query.filter_by(slug=detected_city_slug, is_active=True).first()
            if city_obj:
                session['city_id'] = city_obj.id
                print(f"‚úÖ Auto-detected city: {city_obj.name} (ID: {city_obj.id})")
                return city_obj.id
        
        # If city not supported or not found, use default (Krasnodar)
        default_city = City.query.filter_by(slug='krasnodar', is_active=True).first()
        if default_city:
            session['city_id'] = default_city.id
            print(f"‚úÖ Using default city: {default_city.name} (ID: {default_city.id})")
            return default_city.id
        
        return None
    
    try:
        # Get user's IP address from request
        user_ip = request.headers.get('X-Forwarded-For', request.remote_addr)
        if ',' in user_ip:
            user_ip = user_ip.split(',')[0].strip()
        
        # Skip localhost/private IPs
        if user_ip in ['127.0.0.1', 'localhost', '::1'] or user_ip.startswith('192.168.') or user_ip.startswith('10.'):
            city_name = '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä'
            city_id = set_city_in_session(city_name)
            return jsonify({
                'success': True,
                'city': city_name,
                'region': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
                'country': '–†–æ—Å—Å–∏—è',
                'detected': False,
                'city_id': city_id,
                'message': '–õ–æ–∫–∞–ª—å–Ω—ã–π IP, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≥–æ—Ä–æ–¥ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é'
            })
        
        # Use ipwhois.io API (free, no API key required, 10,000 requests/month)
        api_url = f'http://ipwho.is/{user_ip}'
        response = requests.get(api_url, timeout=3)
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get('success', False):
                city_en = data.get('city', 'Krasnodar')
                region_en = data.get('region', 'Krasnodar Krai')
                
                # –ü–µ—Ä–µ–≤–æ–¥–∏–º –≥–æ—Ä–æ–¥ –∏ —Ä–µ–≥–∏–æ–Ω –Ω–∞ —Ä—É—Å—Å–∫–∏–π
                city = city_translations.get(city_en, city_en if not city_en else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä')
                region = region_translations.get(region_en, region_en if not region_en else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π')
                
                # Set city in session
                city_id = set_city_in_session(city)
                
                return jsonify({
                    'success': True,
                    'city': city,
                    'region': region,
                    'country': '–†–æ—Å—Å–∏—è',
                    'detected': True if supported_cities.get(city) else False,
                    'city_id': city_id,
                    'ip': user_ip
                })
        
        # Fallback to default city
        city_name = '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä'
        city_id = set_city_in_session(city_name)
        return jsonify({
            'success': True,
            'city': city_name,
            'region': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
            'country': '–†–æ—Å—Å–∏—è',
            'detected': False,
            'city_id': city_id,
            'message': '–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –≥–æ—Ä–æ–¥, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≥–æ—Ä–æ–¥ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é'
        })
        
    except Exception as e:
        print(f"Error detecting city: {e}")
        # Make sure to set default city on error too
        city_name = '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä'
        city_id = set_city_in_session(city_name)
        return jsonify({
            'success': True,
            'city': city_name,
            'region': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
            'country': '–†–æ—Å—Å–∏—è',
            'detected': False,
            'city_id': city_id,
            'error': str(e)
        })


# =============================================================================
# Geocoding API Endpoints
# =============================================================================

@app.route('/api/geocode/autocomplete', methods=['GET'])
@csrf.exempt
def geocode_autocomplete():
    """
    Address autocomplete API endpoint
    Returns address suggestions as user types
    """
    query = request.args.get('query', '').strip()
    
    if not query or len(query) < 2:
        return jsonify({'suggestions': []})
    
    # Optional geolocation bias to Krasnodar
    lat = request.args.get('lat', type=float)
    lon = request.args.get('lon', type=float)
    
    # Default to Krasnodar center if no coordinates provided
    if not lat or not lon:
        lat = 45.0355  # Krasnodar center
        lon = 38.9753
    
    try:
        geocoding_service = get_geocoding_service()
        suggestions = geocoding_service.autocomplete(
            query=query,
            latitude=lat,
            longitude=lon,
            results=7
        )
        
        return jsonify({
            'success': True,
            'suggestions': suggestions,
            'count': len(suggestions)
        })
        
    except Exception as e:
        logger.error(f"Autocomplete error: {e}")
        return jsonify({
            'success': False,
            'error': str(e),
            'suggestions': []
        }), 500


@app.route('/api/geocode/reverse', methods=['GET'])
@csrf.exempt
def geocode_reverse():
    """
    Reverse geocoding API endpoint
    Convert coordinates to address components
    """
    lat = request.args.get('lat', type=float)
    lon = request.args.get('lon', type=float)
    
    if not lat or not lon:
        return jsonify({
            'success': False,
            'error': 'Latitude and longitude are required'
        }), 400
    
    try:
        geocoding_service = get_geocoding_service()
        result = geocoding_service.enrich_property_address(lat, lon)
        
        if result:
            return jsonify({
                'success': True,
                'address': result
            })
        else:
            return jsonify({
                'success': False,
                'error': 'Address not found'
            }), 404
            
    except Exception as e:
        logger.error(f"Reverse geocoding error: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/geocode/forward', methods=['GET'])
@csrf.exempt
def geocode_forward():
    """
    Forward geocoding API endpoint
    Convert address to coordinates
    """
    address = request.args.get('address', '').strip()
    
    if not address:
        return jsonify({
            'success': False,
            'error': 'Address is required'
        }), 400
    
    try:
        geocoding_service = get_geocoding_service()
        result = geocoding_service.forward_geocode(address)
        
        if result:
            return jsonify({
                'success': True,
                'result': result
            })
        else:
            return jsonify({
                'success': False,
                'error': 'Coordinates not found'
            }), 404
            
    except Exception as e:
        logger.error(f"Forward geocoding error: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500



@app.route('/api/geocode/enrich-properties', methods=['POST'])
@login_required
def enrich_properties():
    """
    Admin endpoint to batch-enrich properties with parsed address components
    Updates properties that have coordinates but missing parsed address fields
    """
    # Only allow for admin users (you can add role check here)
    # if not current_user.is_admin:
    #     return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    limit = request.args.get('limit', type=int, default=50)
    
    try:
        from models import Property
        geocoding_service = get_geocoding_service()
        
        # Find properties with coordinates but missing parsed address data
        properties = Property.query.filter(
            Property.latitude.isnot(None),
            Property.longitude.isnot(None),
            (Property.parsed_city.is_(None) | Property.parsed_district.is_(None))
        ).limit(limit).all()
        
        updated_count = 0
        errors = []
        
        for prop in properties:
            try:
                enriched = geocoding_service.enrich_property_address(
                    prop.latitude, 
                    prop.longitude
                )
                
                if enriched:
                    prop.parsed_city = enriched.get('parsed_city', '')
                    prop.parsed_district = enriched.get('parsed_district', '')
                    prop.parsed_street = enriched.get('parsed_street', '')
                    
                    # Update full address if missing
                    if not prop.address:
                        prop.address = enriched.get('full_address', '')
                    
                    updated_count += 1
                    
            except Exception as e:
                errors.append(f"Property {prop.id}: {str(e)}")
                logger.error(f"Error enriching property {prop.id}: {e}")
        
        db.session.commit()
        
        # Get service stats
        stats = geocoding_service.get_stats()
        
        return jsonify({
            'success': True,
            'updated_count': updated_count,
            'total_checked': len(properties),
            'errors': errors,
            'geocoding_stats': stats
        })
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Batch enrichment error: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/geocode/stats', methods=['GET'])
def geocode_stats():
    """Get geocoding service statistics"""
    try:
        geocoding_service = get_geocoding_service()
        stats = geocoding_service.get_stats()
        
        return jsonify({
            'success': True,
            'stats': stats
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/voennaya-ipoteka')
@app.route('/military-mortgage')
def military_mortgage():
    """Redirect to city-based URL"""
    return redirect_to_city_based('military_mortgage_city')

@app.route('/ipoteka-ot-zastrojshchika')
@app.route('/developer-mortgage')
def developer_mortgage():
    """Redirect to city-based URL"""
    return redirect_to_city_based('developer_mortgage_city')

@app.route('/materinsky-kapital')
@app.route('/maternal-capital')
def maternal_capital():
    """Redirect to city-based URL"""
    return redirect_to_city_based('maternal_capital_city')


@app.route('/ipoteka')
def ipoteka():
    """Redirect to city-based URL"""
    return redirect_to_city_based('ipoteka_city')

@app.route('/usloviya-keshbeka')
@app.route('/cashback-terms')
def cashback_terms():
    """Redirect to city-based URL"""
    return redirect_to_city_based('cashback_terms_city')
@app.route('/nalogovyj-vychet')
@app.route('/tax-deduction')
def tax_deduction():
    """Redirect to city-based URL"""
    return redirect_to_city_based('tax_deduction_city')

@app.route('/residential')
def residential():
    """Residential complexes page"""
    return render_template('residential.html')

@app.route('/zhilye-kompleksy')
@app.route('/residential-complexes')
def residential_complexes():
    """Legacy route - redirects to city-based URL"""
    return redirect_to_city_based('residential_complexes_city')

@app.route('/karta')
@app.route('/map')
def map_view():
    """Redirect to city-based URL"""
    return redirect_to_city_based('map_city')

def _render_map_page(current_city):
    """Internal map rendering logic"""
    try:
        # ‚úÖ MIGRATED: Load properties with coordinates using repository
        properties_data = PropertyRepository.get_properties_with_coordinates()
        
        properties = []
        for prop_row in properties_data:
            # Unpack RowProxy data
            prop_id = prop_row.id
            inner_id = prop_row.inner_id
            title = prop_row.title
            price = prop_row.price or 0
            rooms = prop_row.rooms or 0
            area = prop_row.area or 0
            floor = prop_row.floor
            total_floors = prop_row.total_floors
            main_image = prop_row.main_image
            gallery_images = prop_row.gallery_images
            lat = getattr(prop_row, "latitude", None)
            lng = getattr(prop_row, "longitude", None)
            complex_name = prop_row.complex_name or ''
            cashback_rate = prop_row.cashback_rate or 0
            developer_name = prop_row.developer_name or ''
            
            # Calculate cashback
            cashback_amount = int(price * (cashback_rate / 100)) if cashback_rate > 0 else 0
            
            # Format title
            room_label = '–°—Ç—É–¥–∏—è' if rooms == 0 else f'{rooms}-–∫–æ–º–Ω'
            formatted_title = f"{room_label}, {area} –º¬≤" if title else title
            
            # Format data for map
            property_data = {
                'id': inner_id or prop_id,
                'price': price,
                'area': area,
                'rooms': rooms,
                'title': formatted_title,
                'address': '',  # Will be filled from Property model if available
                'residential_complex': complex_name,
                'complex_name': complex_name,
                'developer': developer_name,
                'district': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
                'coordinates': {
                    'lat': float(lat),
                    'lng': float(lng)
                },
                'url': f"/object/{inner_id or prop_id}",
                'type': 'property',
                'cashback': cashback_amount,
                'cashback_rate': cashback_rate,
                'cashback_available': cashback_rate > 0,
                'status': 'available',
                'property_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
                'main_image': main_image or '/static/images/no-photo.jpg',
                'gallery_images': gallery_images,
                'floor': floor,
                'total_floors': total_floors
            }
            
            properties.append(property_data)
        
        # ‚úÖ MIGRATED: Load residential complexes with coordinates
        complexes_data = ResidentialComplexRepository.get_with_coordinates()
        
        residential_complexes = []
        for idx, row in enumerate(complexes_data):
            complex_data = {
                'id': row.id,
                'name': row.name or '',
                'developer': row.developer_name or '',
                'address': '',  # Not in the query result
                'district': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
                'apartments_count': 0,  # Will be calculated if needed
                'price_from': 0,  # Will be calculated if needed
                'coordinates': {
                    'lat': float(row.latitude) if row.latitude else 45.0448,
                    'lng': float(row.longitude) if row.longitude else 38.9760
                },
                'url': f'/zk/{row.slug}' if hasattr(row, 'slug') and row.slug else f'/residential-complex/{row.id}',
                'type': 'complex'
            }
            residential_complexes.append(complex_data)
        
        # ‚úÖ –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –∫ –¥–∞–Ω–Ω—ã–º
        developers_filter = request.args.get('developers', '')
        if developers_filter:
            developers_list = [d.strip() for d in developers_filter.split(',')]
            developers_list = [d.strip() for d in developers_filter.split(',')]
            properties = [p for p in properties if p.get('developer') in developers_list]
            print(f"üîç –§–∏–ª—å—Ç—Ä –ø–æ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞–º: {developers_list}, –Ω–∞–π–¥–µ–Ω–æ –æ–±—ä–µ–∫—Ç–æ–≤: {len(properties)}")
        
        # –§–∏–ª—å—Ç—Ä—ã –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        all_districts = sorted(list(set(prop.get('district', '–ù–µ —É–∫–∞–∑–∞–Ω') for prop in properties if prop.get('district'))))
        all_developers = sorted(list(set(prop.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω') for prop in properties if prop.get('developer'))))
        all_complexes = sorted(list(set(prop.get('residential_complex', '–ù–µ —É–∫–∞–∑–∞–Ω') for prop in properties if prop.get('residential_complex'))))
        
        filters = {
            'rooms': request.args.getlist('rooms'),
            'price_min': request.args.get('price_min', ''),
            'price_max': request.args.get('price_max', ''),
            'district': request.args.get('district', ''),
            'developer': request.args.get('developer', ''),
            'developers': developers_filter,
            'residential_complex': request.args.get('residential_complex', ''),
        }
        
        # Map data loaded
        
        return render_template('map.html', 
                             properties=properties, 
                             residential_complexes=residential_complexes,
                             all_districts=all_districts,
                             all_developers=all_developers,
                             all_complexes=all_complexes,
                             filters=filters)
                             
    except Exception as e:
        print(f"ERROR in map route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500


# ==========================================
ENGLISH_TO_RUSSIAN_CITY_SLUGS = {
    'family-mortgage': 'semejnaya-ipoteka',
    'it-mortgage': 'it-ipoteka',
    'military-mortgage': 'voennaya-ipoteka',
    'developer-mortgage': 'ipoteka-ot-zastrojshchika',
    'maternal-capital': 'materinsky-kapital',
    'tax-deduction': 'nalogovyj-vychet',
    'insurance': 'strahovanie',
    'appraisal': 'otsenka',
    'about': 'o-kompanii',
    'how-it-works': 'kak-eto-rabotaet',
    'contacts': 'kontakty',
    'reviews': 'otzyvy',
    'map': 'karta',
    'comparison': 'sravnenie',
    'favorites': 'izbrannoe',
    'cashback-terms': 'usloviya-keshbeka',
    'streets': 'ulitsy',
    'properties': 'novostrojki',
    'residential-complexes': 'zhilye-kompleksy',
}

@app.before_request
def redirect_english_to_russian_slugs():
    """301 redirect English city-prefixed URLs to Russian transliterated equivalents"""
    path = request.path.rstrip('/')
    parts = path.split('/')
    if len(parts) == 3 and parts[1] and parts[2]:
        city_slug = parts[1]
        page_slug = parts[2]
        if page_slug in ENGLISH_TO_RUSSIAN_CITY_SLUGS:
            russian_slug = ENGLISH_TO_RUSSIAN_CITY_SLUGS[page_slug]
            new_path = f'/{city_slug}/{russian_slug}'
            if request.query_string:
                new_path += '?' + request.query_string.decode('utf-8')
            return redirect(new_path, code=301)

# CITY-BASED SEO-FRIENDLY ROUTES
# ==========================================
# These routes provide city-specific URLs for better SEO
# Format: /<city_slug>/properties, /<city_slug>/object/123, etc.

@app.route('/<city_slug>/ipoteka')
def ipoteka_city(city_slug):
    """City-based ipoteka page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('ipoteka'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('ipoteka.html', current_city=current_city)

@app.route('/<city_slug>/semejnaya-ipoteka')
def family_mortgage_city(city_slug):
    """City-based family mortgage page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('family_mortgage'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('family_mortgage.html', current_city=current_city)

@app.route('/<city_slug>/it-ipoteka')
def it_mortgage_city(city_slug):
    """City-based IT mortgage page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('it_mortgage'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('it_mortgage.html', current_city=current_city)

@app.route('/<city_slug>/voennaya-ipoteka')
def military_mortgage_city(city_slug):
    """City-based military mortgage page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('military_mortgage'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('military_mortgage.html', current_city=current_city)

@app.route('/<city_slug>/ipoteka-ot-zastrojshchika')
def developer_mortgage_city(city_slug):
    """City-based developer mortgage page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('developer_mortgage'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('developer_mortgage.html', current_city=current_city)

@app.route('/<city_slug>/materinsky-kapital')
def maternal_capital_city(city_slug):
    """City-based maternal capital page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('maternal_capital'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('maternal_capital.html', current_city=current_city)

@app.route('/<city_slug>/nalogovyj-vychet')
def tax_deduction_city(city_slug):
    """City-based tax deduction page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('tax_deduction'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('tax_deduction.html', current_city=current_city)

@app.route('/<city_slug>/strahovanie')
def insurance_city(city_slug):
    """City-based insurance page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('insurance'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('insurance.html', current_city=current_city)

@app.route('/<city_slug>/otsenka')
def appraisal_city(city_slug):
    """City-based appraisal page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('appraisal'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('appraisal.html', current_city=current_city)

@app.route('/<city_slug>/o-kompanii')
def about_city(city_slug):
    """City-based about page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('about'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('about.html', current_city=current_city)

@app.route('/<city_slug>/kak-eto-rabotaet')
def how_it_works_city(city_slug):
    """City-based how-it-works page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('how_it_works'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('how-it-works.html', current_city=current_city)

@app.route('/<city_slug>/kontakty')
def contacts_city(city_slug):
    """City-based contacts page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('contacts'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('contacts.html', current_city=current_city)

@app.route('/<city_slug>/otzyvy')
def reviews_city(city_slug):
    """City-based reviews page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('reviews'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('reviews.html', current_city=current_city)

@app.route('/<city_slug>/blog')
def blog_city(city_slug):
    """City-based blog page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('blog'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return _render_blog_page(current_city)

@app.route('/<city_slug>/karta')
def map_city(city_slug):
    """City-based map page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('map_view'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return _render_map_page(current_city)

@app.route('/<city_slug>/sravnenie')
def comparison_city(city_slug):
    """City-based comparison page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('comparison'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('comparison.html', current_city=current_city)

@app.route('/<city_slug>/izbrannoe')
def favorites_city(city_slug):
    """City-based favorites page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('favorites'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('favorites.html', current_city=current_city)

@app.route('/<city_slug>/usloviya-keshbeka')
def cashback_terms_city(city_slug):
    """City-based cashback terms page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('cashback_terms'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return render_template('cashback_terms.html', current_city=current_city)

@app.route('/<city_slug>/ulitsy')
def streets_city(city_slug):
    """City-based streets page"""
    current_city = resolve_city_context(city_slug=city_slug)
    if not current_city:
        return redirect(url_for('streets'))
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    return _render_streets_page(current_city)

@app.route('/<city_slug>/')
def city_home(city_slug):
    """City-based homepage - shows index page with city context"""
    from models import City
    city = City.query.filter(
        db.func.lower(City.slug) == city_slug.lower()
    ).first()
    if not city:
        abort(404)
    return index(city_slug=city_slug)


@app.route('/<city_slug>/novostrojki')
@app.route('/<city_slug>/kvartiry')
def properties_city(city_slug):
    """City-based properties listing page - SEO-friendly URL version"""
    # Resolve city context using city_slug from URL
    current_city = resolve_city_context(city_slug=city_slug)
    
    # If city not found, redirect to default properties page
    if not current_city:
        flash('–ì–æ—Ä–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞.', 'warning')
        return redirect(url_for('properties'))
    
    # ‚úÖ –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ï –ü–ï–†–ï–ö–õ–Æ–ß–ï–ù–ò–ï –ì–û–†–û–î–ê –ø—Ä–∏ –ø–æ–∏—Å–∫–µ (–∫–∞–∫ Avito/Cian)
    search_query = request.args.get('search', '').strip()
    if search_query:
        detected_city = smart_search.detect_city_from_query(search_query)
        if detected_city and detected_city['slug'] != city_slug:
            # –ì–æ—Ä–æ–¥ –≤ –∑–∞–ø—Ä–æ—Å–µ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –≥–æ—Ä–æ–¥–∞ –≤ URL - –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!
            print(f"üîÑ –ê–≤—Ç–æ–ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ: {city_slug} -> {detected_city['slug']} (search: {search_query})")
            # –£–±–∏—Ä–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä search –∏–∑ —Ä–µ–¥–∏—Ä–µ–∫—Ç–∞ - –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –Ω—É–∂–Ω–æ–≥–æ –≥–æ—Ä–æ–¥–∞
            redirect_args = {k: v for k, v in request.args.items() if k != 'search'}
            return redirect(url_for('properties_city', city_slug=detected_city['slug'], **redirect_args))
    
    
    # Only update session city if it changed or not set (preserve user's city choice)
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    
    # Save manager if provided in URL (for manager referral links)
    if 'manager_id' in request.args:
        try:
            manager_id = int(request.args.get('manager_id'))
            session['manager_id'] = manager_id
            print(f"‚úÖ Manager {manager_id} saved to session from URL")
        except (ValueError, TypeError):
            pass
    
    try:
        import json
        from repositories.property_repository import PropertyRepository, ResidentialComplexRepository, DeveloperRepository
        from models import Developer, ResidentialComplex, Property
        from services.dadata_client import DaDataClient
        
        # Parse filters using existing function
        _, _, filters = build_property_filters(request.args)
        print(f"üîç DEBUG: URL –ø–∞—Ä–∞–º–µ—Ç—Ä—ã: {dict(request.args)}")
        print(f"üîç DEBUG: –†–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã: {filters}")
        
        # Pagination
        page = request.args.get('page', default=1, type=int)
        page = max(1, page)
        per_page = 20
        offset = (page - 1) * per_page
        
        # Sorting
        sort_type = request.args.get('sort', 'price-asc').replace('_', '-')
        
        # Convert filters to Repository format
        repo_filters = {}
        if filters.get('price_min'):
            try:
                price_val = float(filters['price_min'])
                # If price < 1000, assume it's in millions; else assume rubles
                repo_filters['min_price'] = int(price_val * 1000000) if price_val < 1000 else int(price_val)
            except:
                pass
        if filters.get('price_max'):
            try:
                price_val = float(filters['price_max'])
                # If price < 1000, assume it's in millions; else assume rubles
                repo_filters['max_price'] = int(price_val * 1000000) if price_val < 1000 else int(price_val)
            except:
                pass
        if filters.get('area_min'):
            try:
                repo_filters['min_area'] = float(filters['area_min'])
            except:
                pass
        if filters.get('area_max'):
            try:
                repo_filters['max_area'] = float(filters['area_max'])
            except:
                pass
        if filters.get('rooms'):
            try:
                rooms_list = []
                for r in filters['rooms']:
                    if isinstance(r, str):
                        r_stripped = r.strip()
                        if r_stripped:
                            rooms_list.append(int(r_stripped))
                    elif isinstance(r, int):
                        rooms_list.append(r)
                if rooms_list:
                    repo_filters['rooms'] = rooms_list
                    print(f"‚úÖ /properties_city: Rooms filter applied: {rooms_list}")
            except Exception as e:
                print(f"‚ùå /properties_city: Error processing rooms filter: {e}")
                pass
        
        # Developers filter
        if filters.get('developers'):
            repo_filters['developers'] = filters['developers']
        if filters.get('developer'):
            if 'developers' not in repo_filters:
                repo_filters['developers'] = []
            if filters['developer'] not in repo_filters['developers']:
                repo_filters['developers'].append(filters['developer'])
        
        # Districts filter
        if filters.get('districts'):
            repo_filters['districts'] = filters['districts']
        
        # Residential complex filter
        if filters.get('residential_complex'):
            repo_filters['residential_complex'] = filters['residential_complex']
        
        # Completion dates filter
        if filters.get('completion'):
            repo_filters['completion'] = filters['completion']
        
        # Floor range
        if filters.get('floor_min'):
            try:
                repo_filters['floor_min'] = int(filters['floor_min'])
            except:
                pass
        if filters.get('floor_max'):
            try:
                repo_filters['floor_max'] = int(filters['floor_max'])
            except:
                pass
        
        # Building floors range
        if filters.get('building_floors_min'):
            try:
                repo_filters['building_floors_min'] = int(filters['building_floors_min'])
            except:
                pass
        if filters.get('building_floors_max'):
            try:
                repo_filters['building_floors_max'] = int(filters['building_floors_max'])
            except:
                pass
        
        # Additional filters
        if filters.get('cashback_only'):
            repo_filters['cashback_only'] = True
        if filters.get('renovation'):
            repo_filters['renovation'] = filters['renovation']
        if filters.get('object_classes'):
            repo_filters['object_classes'] = filters['object_classes']
        if filters.get('building_types'):
            repo_filters['building_types'] = filters['building_types']
        if filters.get('floor_options'):
            repo_filters['floor_options'] = filters['floor_options']
        if filters.get('features'):
            repo_filters['features'] = filters['features']
        if filters.get('deal_type'):
            repo_filters['deal_type'] = filters['deal_type']
        if filters.get('building_released'):
            repo_filters['building_released'] = filters['building_released']
        
        # ‚úÖ CRITICAL: Property type filter
        if filters.get('property_type') and filters['property_type'] != 'all':
            property_type_map = {
                'apartments': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
                'houses': '–î–æ–º',
                'townhouses': '–¢–∞—É–Ω—Ö–∞—É—Å',
                'penthouses': '–ü–µ–Ω—Ç—Ö–∞—É—Å',
                'apartments_commercial': '–ê–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç—ã'
            }
            mapped_type = property_type_map.get(filters['property_type'], filters['property_type'])
            repo_filters['property_type'] = mapped_type
            print(f"‚úÖ /properties_city: Property type filter applied: {mapped_type}")
        
        # Search filter with smart matching
        if filters.get('search'):
            search_text = filters['search'].strip()
            search_applied = False
            
            if search_text:
                # Smart search: Try to match ResidentialComplex first
                complex_match = db.session.query(ResidentialComplex).filter(
                    ResidentialComplex.name.ilike(f'%{search_text}%')
                ).first()
                
                if complex_match:
                    repo_filters['residential_complex'] = complex_match.name
                    print(f"üè¢ Smart search: Detected –ñ–ö '{complex_match.name}' from query '{search_text}'")
                    search_applied = True
                
                # Try to match Developer
                if not search_applied:
                    developer_match = db.session.query(Developer).filter(
                        Developer.name.ilike(f'%{search_text}%')
                    ).first()
                    
                    if developer_match:
                        if 'developers' not in repo_filters:
                            repo_filters['developers'] = []
                        repo_filters['developers'].append(developer_match.name)
                        print(f"üëî Smart search: Detected –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫ '{developer_match.name}' from query '{search_text}'")
                        search_applied = True
                
                # If no smart match, use address/text search
                if not search_applied:
                    if any(prefix in search_text for prefix in ['–≥ ', '—Ä-–Ω ', '—É–ª', '–º–∫—Ä', '–ø–µ—Ä', '—É–ª–∏—Ü']):
                        tokens = DaDataClient.normalize_address_for_search(search_text)
                        if tokens:
                            import re
                            clean_tokens = []
                            for token in tokens:
                                cleaned = re.sub(r'^(—É–ª–∏—Ü[–∞—ã]|—É–ª\.?|–ø—Ä–æ—Å–ø(–µ–∫—Ç)?\.?|–º–∫—Ä\.?|–ø–µ—Ä\.?|–≥\.?|—Ä-–Ω)\s*', '', token, flags=re.IGNORECASE).strip()
                                if cleaned:
                                    clean_tokens.append(cleaned)
                            
                            if clean_tokens:
                                repo_filters['search'] = clean_tokens[-1]
                                print(f"üîç Normalized search: '{search_text}' ‚Üí '{clean_tokens[-1]}'")
                            else:
                                repo_filters['search'] = search_text
                        else:
                            repo_filters['search'] = search_text
                    else:
                        repo_filters['search'] = search_text
        
        # Parse sort_type
        sort_by = 'price'
        sort_order = 'asc'
        if sort_type:
            parts = sort_type.split('-')
            if len(parts) == 2:
                sort_by = parts[0]
                sort_order = parts[1]
        
        # Add city filter
        if current_city:
            repo_filters['city_id'] = current_city.id
            print(f"‚úÖ /properties_city: Filtering by city: {current_city.name} (ID: {current_city.id})")
        
        # Get properties
        properties_list = PropertyRepository.get_all_active(
            limit=per_page,
            offset=offset,
            filters=repo_filters,
            sort_by=sort_by,
            sort_order=sort_order
        )
        
        total_properties = PropertyRepository.count_active(filters=repo_filters)
        
        # Convert to template format
        properties_data = []
        for prop in properties_list:
            try:
                complex_obj = prop.residential_complex
                developer_obj = prop.developer
                
                # Parse photos
                photos_list = []
                main_image = 'https://via.placeholder.com/400x300'
                
                if prop.main_image:
                    main_image = prop.main_image
                
                if prop.gallery_images:
                    try:
                        if isinstance(prop.gallery_images, list):
                            photos_list = prop.gallery_images
                        elif isinstance(prop.gallery_images, str):
                            photos_list = json.loads(prop.gallery_images)
                        
                        if photos_list and not prop.main_image:
                            main_image = photos_list[0]
                    except Exception as e:
                        print(f"Error parsing photos for property {prop.id}: {e}")
                
                # Calculate cashback
                cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 3.5
                cashback_amount = int(prop.price * (cashback_rate / 100)) if prop.price else 0
                
                property_dict = {
                    'id': prop.id,
                    'price': prop.price or 0,
                    'price_formatted': prop.formatted_price,
                    'area': prop.area or 0,
                    'rooms': prop.rooms or 0,
                    'room_description': prop.room_description,
                    'floor': prop.floor if prop.floor is not None else 1,
                    'total_floors': prop.total_floors if prop.total_floors is not None else 1,
                    'address': prop.address or (complex_obj.address if complex_obj else ''),
                    'renovation': prop.renovation_type or 'no_renovation',
                    'renovation_display_name': PropertyRepository.get_renovation_display_name(prop.renovation_type),
                    'price_per_sqm': prop.price_per_sqm or (int(prop.price / prop.area) if prop.price and prop.area else 0),
                    'gallery': photos_list,
                    'image': main_image,
                    'latitude': prop.latitude or (complex_obj.latitude if complex_obj else None),
                    'longitude': prop.longitude or (complex_obj.longitude if complex_obj else None),
                    'complex_name': complex_obj.name if complex_obj else '',
                    'residential_complex': complex_obj.name if complex_obj else '',
                    'developer': developer_obj.name if developer_obj else '',
                    'developer_name': developer_obj.name if developer_obj else '',
                    'cashback_rate': cashback_rate,
                    'cashback': cashback_amount,
                    'cashback_available': True,
                    'district': prop.district.name if prop.district else '',
                    'deal_type': prop.deal_type or 'sale',
                    'object_class': complex_obj.object_class_display_name if complex_obj else '',
                }
                
                properties_data.append(property_dict)
            except Exception as e:
                print(f"Error formatting property {prop.id}: {e}")
                import traceback
                traceback.print_exc()
                continue
        
        # Pagination data
        total_pages = (total_properties + per_page - 1) // per_page if total_properties > 0 else 0
        pagination = SimpleNamespace(
            page=page,
            total_pages=total_pages,
            per_page=per_page,
            total=total_properties,
            has_prev=page > 1,
            has_next=page < total_pages,
            prev_num=page - 1 if page > 1 else None,
            next_num=page + 1 if page < total_pages else None
        )
        
        # Get developers and complexes for filters
        developers = DeveloperRepository.get_all_active()
        residential_complexes = ResidentialComplexRepository.get_all_active()
        
        # Get manager if logged in
        manager_data = None
        if current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager):
            manager = current_user._get_current_object()
            manager_data = {
                'id': manager.id,
                'name': manager.name,
                'phone': manager.phone,
                'email': manager.email,
                'photo': manager.profile_image
            }
        
        # Calculate max cashback
        max_cashback = 0
        if properties_data:
            for prop_dict in properties_data:
                if prop_dict.get('cashback'):
                    if prop_dict['cashback'] > max_cashback:
                        max_cashback = prop_dict['cashback']
        
        if max_cashback == 0 and residential_complexes:
            for rc in residential_complexes:
                if rc.cashback_rate:
                    estimated_cashback = int(15000000 * (rc.cashback_rate / 100))
                    if estimated_cashback > max_cashback:
                        max_cashback = estimated_cashback
        
        if max_cashback == 0:
            max_cashback = 500000
        
        # Get current manager
        current_manager = current_user._get_current_object() if (current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager)) else None
        
        # Generate canonical URL for SEO (always use production domain)
        canonical_url = CANONICAL_BASE_URL + url_for('properties_city', city_slug=city_slug)
        
        response = make_response(render_template('properties.html',
                                 current_city=current_city,
                                 properties=properties_data,
                                 pagination=pagination,
                                 filters=filters,
                                 developers=developers,
                                 residential_complexes=residential_complexes,
                                 manager=manager_data,
                                 total_pages=total_pages,
                                 total_properties=total_properties,
                                 max_cashback=max_cashback,
                                 user_authenticated=current_user.is_authenticated,
                                 manager_authenticated=isinstance(current_user._get_current_object(), Manager) if current_user.is_authenticated else False,
                                 admin_authenticated=isinstance(current_user._get_current_object(), Admin) if current_user.is_authenticated else False,
                                 current_manager=current_manager,
                                 canonical_url=canonical_url,
                                 yandex_maps_api_key=os.environ.get('YANDEX_MAPS_API_KEY', '')))
        
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, max-age=0'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        return response
        
    except Exception as e:
        print(f"ERROR in /properties_city: {e}")
        import traceback
        traceback.print_exc()
        return render_template('error.html', 
                             error_code=500, 
                             error_message='–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å –∫–≤–∞—Ä—Ç–∏—Ä–∞–º–∏',
                             current_city=current_city), 500


@app.route('/<city_slug>/zhilye-kompleksy')
def residential_complexes_city(city_slug):
    """City-based residential complexes page - SEO-friendly URL version"""
    from repositories.property_repository import ResidentialComplexRepository, PropertyRepository, DeveloperRepository, DistrictRepository
    import json
    from datetime import datetime
    
    # Resolve city context using city_slug from URL
    current_city = resolve_city_context(city_slug=city_slug)
    
    # If city not found, redirect to default page
    if not current_city:
        flash('–ì–æ—Ä–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞.', 'warning')
        return redirect(url_for('residential_complexes'))
    
    # Only update session city if it changed or not set (preserve user's city choice)
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    
    # Save manager if provided in URL (for manager referral links)
    if 'manager_id' in request.args:
        try:
            manager_id = int(request.args.get('manager_id'))
            session['manager_id'] = manager_id
            print(f"‚úÖ Manager {manager_id} saved to session from URL")
        except (ValueError, TypeError):
            pass
    
    try:
        # Filter complexes by city
        from models import ResidentialComplex
        all_complexes = (
            db.session.query(ResidentialComplex)
            .filter(ResidentialComplex.city_id == current_city.id)
            .filter(ResidentialComplex.is_active == True)
            .limit(100)
            .all()
        )
        print(f"‚úÖ /residential-complexes_city: Filtering by city: {current_city.name} (ID: {current_city.id})")
        
        # Get property stats
        property_stats_by_complex = PropertyRepository.get_all_property_stats(city_id=current_city.id)
        
        # Current date for status
        current_year = 2025
        current_quarter = 4
        
        complexes = []
        
        for complex_obj in all_complexes:
            stats = property_stats_by_complex.get(complex_obj.id, {})
            
            # Format completion date and determine status
            completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω'
            is_completed = False
            build_year = None
            
            if complex_obj.end_build_year and complex_obj.end_build_quarter:
                build_year = int(complex_obj.end_build_year)
                build_quarter = int(complex_obj.end_build_quarter)
                
                if build_year < current_year:
                    is_completed = True
                elif build_year == current_year and build_quarter < current_quarter:
                    is_completed = True
                else:
                    is_completed = False
                    
                quarter_names = {1: 'I', 2: 'II', 3: 'III', 4: 'IV'}
                quarter = quarter_names.get(build_quarter, build_quarter)
                completion_date = f"{quarter} –∫–≤. {build_year} –≥."
            elif complex_obj.end_build_year:
                build_year = int(complex_obj.end_build_year)
                is_completed = build_year < current_year
                completion_date = f"{build_year} –≥."
            
            # Get address and district
            # Don't duplicate city name if address already contains it
            full_address = complex_obj.address or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω'
            
            # Only use city name as district if address doesn't contain it
            if current_city.name.lower() in full_address.lower() or f"–≥. {current_city.name}".lower() in full_address.lower():
                district_name = ""  # Address already has city name
            else:
                district_name = current_city.name
            
            if (not complex_obj.address or complex_obj.address == '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω') and stats.get('sample_address'):
                full_address = stats['sample_address']
                address_parts = full_address.split(',')
                if len(address_parts) >= 3:
                    district_name = address_parts[2].strip()
            
            # Build complete images list for slider
            images_list = []
            if complex_obj.gallery_images:
                try:
                    if isinstance(complex_obj.gallery_images, list):
                        images_list = complex_obj.gallery_images
                    elif isinstance(complex_obj.gallery_images, str) and complex_obj.gallery_images:
                        import json
                        images_list = json.loads(complex_obj.gallery_images)
                except:
                    pass
            
            # Fallback to main_image if no gallery
            if not images_list and complex_obj.main_image:
                images_list = [complex_obj.main_image]
            
            # Add default if still empty
            if not images_list:
                images_list = ['/static/images/no-photo.jpg']
            
            # Basic complex info
            complex_dict = {
                'id': complex_obj.id,
                'name': complex_obj.name,
                'available_apartments': stats.get('total_count', 0),
                'price_from': stats.get('min_price', 0) or 0,
                'price_to': stats.get('max_price', 0) or 0,
                'real_price_from': stats.get('min_price', 0) or 0,
                'real_price_to': stats.get('max_price', 0) or 0,
                'area_from': stats.get('min_area', 0) or 0,
                'area_to': stats.get('max_area', 0) or 0,
                'floor_from': stats.get('min_floor', 0) or 0,
                'floor_to': stats.get('max_floor', 0) or 0,
                'developer': complex_obj.developer.name if complex_obj.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
                'developer_id': complex_obj.developer_id,
                'developer_name': complex_obj.developer.name if complex_obj.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
                'address': full_address,
                'district': district_name,
                'district_name': district_name,
                'completion_date': completion_date,
                'is_completed': is_completed,
                'build_year': build_year,
                'cashback_rate': complex_obj.cashback_rate or 0,
                'object_class': complex_obj.object_class_display_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
                'latitude': complex_obj.latitude,
                'longitude': complex_obj.longitude,
                'main_image': complex_obj.main_image or '/static/images/no-photo.jpg',
                'gallery_images': complex_obj.gallery_images,
                'images': images_list,
                'image': images_list[0] if images_list else '/static/images/no-photo.jpg',
                'real_room_distribution': stats.get('room_distribution', {}),
                'room_details': stats.get('room_details', {}),
                'status': '–°–¥–∞–Ω' if is_completed else '–°—Ç—Ä–æ–∏—Ç—Å—è',
                'description': complex_obj.description or '–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –∂–∏–ª–æ–π –∫–æ–º–ø–ª–µ–∫—Å',
                'location': full_address,
                'buildings_count': stats.get('buildings_count', 1),
                'slug': complex_obj.slug or create_slug(complex_obj.name),
                'url': f'/{city_slug}/zk/{complex_obj.slug or create_slug(complex_obj.name)}',
            }
            
            complexes.append(complex_dict)
        
        # Load properties for map
        properties_list = PropertyRepository.get_all_active(
            limit=500,
            filters={'city_id': current_city.id},
            sort_by='price',
            sort_order='asc'
        )
        
        properties = []
        for prop in properties_list:
            complex_obj = prop.residential_complex
            developer_obj = prop.developer
            
            # Parse photos
            photos_list = []
            main_image = 'https://via.placeholder.com/400x300'
            
            if prop.main_image:
                main_image = prop.main_image
            
            if prop.gallery_images:
                try:
                    if isinstance(prop.gallery_images, list):
                        photos_list = prop.gallery_images
                    elif isinstance(prop.gallery_images, str):
                        photos_list = json.loads(prop.gallery_images)
                    
                    if photos_list and not prop.main_image:
                        main_image = photos_list[0]
                except Exception as e:
                    print(f"Error parsing photos: {e}")
            
            floor = prop.floor if prop.floor is not None else 1
            total_floors = prop.total_floors if prop.total_floors is not None else 1
            
            property_data = {
                'id': prop.id,
                'price': prop.price or 0,
                'area': prop.area or 0,
                'rooms': prop.rooms or 0,
                'floor': floor,
                'total_floors': total_floors,
                'address': prop.address or '',
                'residential_complex': complex_obj.name if complex_obj else '',
                'developer': developer_obj.name if developer_obj else '',
                'district': prop.district.name if prop.district else '',
                'latitude': prop.latitude,
                'longitude': prop.longitude,
                'main_image': main_image or '/static/images/no-photo.jpg',
                'gallery_images': photos_list,
                'floor': f"{floor}/{total_floors}",
                'floor_min': floor,
                'floor_max': total_floors
            }
            
            properties.append(property_data)
        
        # Use complexes list for residential_complexes (they contain the same data)
        # FIXED: Just copy complexes list instead of rebuilding it - avoids duplication and ensures consistency
        residential_complexes = complexes.copy()
        
        # Apply filters
        developers_filter = request.args.get('developers', '')
        if developers_filter:
            developers_list = [d.strip() for d in developers_filter.split(',')]
            if complexes: print(f"DEBUG: All complex keys: {list(complexes[0].keys())}")
            properties = [p for p in properties if p.get('developer') in developers_list]
            print(f"üîç –§–∏–ª—å—Ç—Ä –ø–æ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞–º: {developers_list}, –Ω–∞–π–¥–µ–Ω–æ –æ–±—ä–µ–∫—Ç–æ–≤: {len(properties)}")
        
        # Filter options
        all_districts = sorted(list(set(prop.get('district', '–ù–µ —É–∫–∞–∑–∞–Ω') for prop in properties if prop.get('district'))))
        all_developers = sorted(list(set(prop.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω') for prop in properties if prop.get('developer'))))
        all_complexes_list = sorted(list(set(prop.get('residential_complex', '–ù–µ —É–∫–∞–∑–∞–Ω') for prop in properties if prop.get('residential_complex'))))
        
        filters = {
            'rooms': request.args.getlist('rooms'),
            'price_min': request.args.get('price_min', ''),
            'price_max': request.args.get('price_max', ''),
            'district': request.args.get('district', ''),
            'developer': request.args.get('developer', ''),
            'developers': developers_filter,
            'residential_complex': request.args.get('residential_complex', ''),
        }
        # Generate canonical URL for SEO (always use production domain)
        canonical_url = CANONICAL_BASE_URL + url_for('residential_complexes_city', city_slug=city_slug)
        # DEBUG: Check complexes data before template
        print(f"DEBUG: Passing {len(complexes)} complexes to template for {current_city.name}")
        if complexes:
            print(f"DEBUG: First complex keys: {list(complexes[0].keys())[:15]}")
        
        return render_template('residential_complexes.html',
                             current_city=current_city,
                             complexes=complexes,
                             properties=properties,
                             residential_complexes=residential_complexes,
                             all_districts=all_districts,
                             all_developers=all_developers,
                             all_complexes=all_complexes_list,
                             filters=filters,
                             canonical_url=canonical_url,
                             yandex_maps_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
                             
    except Exception as e:
        print(f"ERROR in /residential-complexes_city: {e}")
        import traceback
        traceback.print_exc()
        return render_template('error.html',
                             error_code=500,
                             error_message='–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ñ–ö',
                             current_city=current_city), 500


@app.route('/<city_slug>/object/<int:property_id>')
def property_detail_city(city_slug, property_id):
    """City-based individual property page - SEO-friendly URL version"""
    # Resolve city context using city_slug from URL
    current_city = resolve_city_context(city_slug=city_slug)
    
    # If city not found, redirect to default page
    if not current_city:
        flash('–ì–æ—Ä–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞.', 'warning')
        return redirect(url_for('property_detail', property_id=property_id))
    
    # Only update session city if it changed or not set (preserve user's city choice)
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    
    # Save manager if provided in URL (for manager referral links)
    if 'manager_id' in request.args:
        try:
            manager_id = int(request.args.get('manager_id'))
            session['manager_id'] = manager_id
            print(f"‚úÖ Manager {manager_id} saved to session from URL")
        except (ValueError, TypeError):
            pass
    try:
        import json
        from sqlalchemy import func
        from repositories.property_repository import PropertyRepository
        from models import Property, ResidentialComplex
        
        # Get property
        prop = PropertyRepository.get_by_id(property_id)
        
        if not prop:
            print(f"Property {property_id} not found")
            return redirect(url_for('properties_city', city_slug=city_slug))
        
        # Get related objects
        complex_obj = prop.residential_complex
        developer_obj = prop.developer
        
        # Parse photos
        images = []
        main_image = 'https://via.placeholder.com/400x300/f3f4f6/9ca3af?text=–§–æ—Ç–æ+–Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ'
        
        if prop.main_image:
            main_image = prop.main_image
        
        if prop.gallery_images:
            try:
                if isinstance(prop.gallery_images, list):
                    images = prop.gallery_images
                elif isinstance(prop.gallery_images, str):
                    images = json.loads(prop.gallery_images)
                
                if images and not prop.main_image:
                    main_image = images[0]
            except Exception as e:
                print(f"Error parsing photos: {e}")
        
        # Create completion date
        completion_date = '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è'
        if complex_obj:
            if complex_obj.end_build_year and complex_obj.end_build_quarter:
                completion_date = f"{complex_obj.end_build_year} –≥., {complex_obj.end_build_quarter} –∫–≤."
            elif complex_obj.end_build_year:
                completion_date = f"{complex_obj.end_build_year} –≥."
        
        # Calculate cashback
        cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 3.5
        cashback_amount = int(prop.price * (cashback_rate / 100)) if prop.price else 0
        
        # Parse complex infrastructure and amenities
        infrastructure_list = []
        advantages_list = []
        if complex_obj:
            if complex_obj.infrastructure:
                try:
                    if isinstance(complex_obj.infrastructure, str):
                        infrastructure_list = json.loads(complex_obj.infrastructure)
                    elif isinstance(complex_obj.infrastructure, list):
                        infrastructure_list = complex_obj.infrastructure
                except:
                    pass
            
            if complex_obj.amenities:
                try:
                    if isinstance(complex_obj.amenities, str):
                        advantages_list = json.loads(complex_obj.amenities)
                    elif isinstance(complex_obj.amenities, list):
                        advantages_list = complex_obj.amenities
                except:
                    pass
        
        # Build property data
        property_data = {
            'id': prop.inner_id or prop.id,
            'complex_id': complex_obj.id if complex_obj else None,
            'title': prop.title or (f"–°—Ç—É–¥–∏—è {prop.area} –º¬≤" if prop.rooms == 0 else f"{prop.rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞ {prop.area} –º¬≤"),
            'description': prop.description or (complex_obj.description if complex_obj else None),
            'detailed_description': complex_obj.detailed_description if complex_obj else None,
            'price': prop.price or 0,
            'cashback_percent': cashback_rate,
            'gallery': images,
            'area': prop.area or 0,
            'rooms': prop.rooms or 0,
            'floor': prop.floor if prop.floor is not None else 1,
            'total_floors': prop.total_floors if prop.total_floors is not None else 1,
            'address': prop.address or (complex_obj.address if complex_obj else '–ê–¥—Ä–µ—Å —É—Ç–æ—á–Ω—è–µ—Ç—Å—è'),
            'full_address': prop.address or (complex_obj.address if complex_obj else '–ê–¥—Ä–µ—Å —É—Ç–æ—á–Ω—è–µ—Ç—Å—è'),
            'short_address': prop.address or (complex_obj.address if complex_obj else '–ê–¥—Ä–µ—Å —É—Ç–æ—á–Ω—è–µ—Ç—Å—è'),
            'locality_name': complex_obj.district if complex_obj else current_city.name,
            'district': complex_obj.district if complex_obj else current_city.name,
            'developer': developer_obj.name if developer_obj else '–ù–µ —É–∫–∞–∑–∞–Ω',
            'complex_name': complex_obj.name if complex_obj else '–ù–µ —É–∫–∞–∑–∞–Ω',
            'building_name': prop.complex_building_name or '–ö–æ—Ä–ø—É—Å 1',
            'building_released': True,
            'renovation_type': PropertyRepository.get_renovation_display_name(prop.renovation_type),
            'finishing': PropertyRepository.get_renovation_display_name(prop.renovation_type),
            'completion_date': completion_date,
            'mortgage_rate': '3.5%',
            'square_price': prop.price_per_sqm or (int(prop.price / prop.area) if prop.price and prop.area else 0),
            'mortgage_payment': prop.mortgage_price or 0,
            'class_type': complex_obj.object_class_display_name if complex_obj else '–ö–æ–º—Ñ–æ—Ä—Ç',
            'cashback_amount': cashback_amount,
            'images': images,
            'image': main_image,
            'latitude': prop.latitude or (complex_obj.latitude if complex_obj else None),
            'longitude': prop.longitude or (complex_obj.longitude if complex_obj else None),
            'address_position_lat': prop.latitude or (complex_obj.latitude if complex_obj else None),
            'address_position_lon': prop.longitude or (complex_obj.longitude if complex_obj else None),
            'infrastructure': infrastructure_list,
            'advantages': advantages_list,
            'complex_total_apartments': Property.query.filter_by(complex_id=complex_obj.id, is_active=True).count() if complex_obj else 0,
        }
        
        # Get similar apartments
        similar_apartments = []
        if complex_obj:
            similar_props = PropertyRepository.get_by_complex_id(
                complex_obj.id,
                limit=6,
                sort_by='price',
                sort_order='asc'
            )
            
            for similar_prop in similar_props:
                if similar_prop.id != prop.id:
                    similar_main_image = 'https://via.placeholder.com/400x300'
                    if similar_prop.main_image:
                        similar_main_image = similar_prop.main_image
                    elif similar_prop.gallery_images:
                        try:
                            if isinstance(similar_prop.gallery_images, list):
                                similar_main_image = similar_prop.gallery_images[0] if similar_prop.gallery_images else similar_main_image
                            elif isinstance(similar_prop.gallery_images, str):
                                photos = json.loads(similar_prop.gallery_images)
                                similar_main_image = photos[0] if photos else similar_main_image
                        except:
                            pass
                    
                    
                    # Calculate cashback for similar apartment
                    similar_cashback = int(similar_prop.price * (cashback_rate / 100)) if similar_prop.price else 0
                    similar_apartments.append({
                        'id': similar_prop.inner_id or similar_prop.id,
                        'rooms': similar_prop.rooms or 0,
                        'area': similar_prop.area or 0,
                        'price': similar_prop.price or 0,
                        'floor': similar_prop.floor if similar_prop.floor is not None else 1,
                        'total_floors': similar_prop.total_floors if similar_prop.total_floors is not None else 1,
                        'image': similar_main_image,
                        'url': f'/{city_slug}/object/{similar_prop.inner_id or similar_prop.id}',
                        'cashback': similar_cashback
                    })
        
        # Get complex info
        complex_info = None
        if complex_obj:
            complex_photos = []
            if complex_obj.gallery_images:
                try:
                    if isinstance(complex_obj.gallery_images, list):
                        complex_photos = complex_obj.gallery_images
                    elif isinstance(complex_obj.gallery_images, str):
                        complex_photos = json.loads(complex_obj.gallery_images)
                except:
                    pass
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ñ–ö
            total_apartments = Property.query.filter_by(complex_id=complex_obj.id, is_active=True).count()
            studios_count = Property.query.filter_by(complex_id=complex_obj.id, rooms=0, is_active=True).count()
            buildings_count_result = db.session.query(func.count(func.distinct(Property.complex_building_name))).filter(
                Property.complex_id == complex_obj.id,
                Property.is_active == True,
                Property.complex_building_name.isnot(None)
            ).scalar() or 1
            
            complex_info = {
                'id': complex_obj.id,
                'name': complex_obj.name,
                'developer': developer_obj.name if developer_obj else '–ù–µ —É–∫–∞–∑–∞–Ω',
                'address': complex_obj.address or '–ê–¥—Ä–µ—Å —É—Ç–æ—á–Ω—è–µ—Ç—Å—è',
                'description': complex_obj.description or '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç',
                'images': complex_photos,
                'latitude': complex_obj.latitude,
                'longitude': complex_obj.longitude,
                'cashback_rate': complex_obj.cashback_rate or 0,
                'url': f'/{city_slug}/zk/{complex_obj.slug or create_slug(complex_obj.name)}',
                'total_apartments': total_apartments,
                'studios_count': studios_count,
                'buildings_count': buildings_count_result
            }
        
        # Get manager for authenticated user
        manager_data = None
        if current_user.is_authenticated:
            from models import User, Manager
            # Check if current_user is a regular User (not Manager or Admin)
            current_obj = current_user._get_current_object()
            if isinstance(current_obj, User) and hasattr(current_obj, 'assigned_manager_id') and current_obj.assigned_manager_id:
                # Get assigned manager
                manager = Manager.query.get(current_obj.assigned_manager_id)
                if manager and manager.is_active:
                    manager_data = {
                        'id': manager.id,
                        'name': manager.full_name,
                        'phone': manager.phone,
                        'email': manager.email,
                        'photo': manager.profile_image
                    }
        # Generate canonical URL for SEO (always use production domain)
        canonical_url = CANONICAL_BASE_URL + url_for('property_detail_city', city_slug=city_slug, property_id=property_id)
        
        return render_template('property_detail.html',
                             current_city=current_city,
                             property=property_data,
                             complex_info=complex_info,
                             similar_apartments=similar_apartments,
                             manager=manager_data,
                             canonical_url=canonical_url)
        
    except Exception as e:
        print(f"ERROR in /property_detail_city: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500


@app.route('/<city_slug>/zk/<slug>')
def residential_complex_by_slug_city(city_slug, slug):
    """City-based residential complex detail page - SEO-friendly URL version - FULL IMPLEMENTATION"""
    # Resolve city context using city_slug from URL
    current_city = resolve_city_context(city_slug=city_slug)
    
    # If city not found, use default
    if not current_city:
        flash('–ì–æ—Ä–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞.', 'warning')
        current_city = resolve_city_context()  # Get default city
    
    # Store city in session
    if current_city:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    
    try:
        from repositories.property_repository import PropertyRepository, ResidentialComplexRepository
        from models import ResidentialComplex, Offer, MarketingMaterial, Manager, Admin
        
        # === STEP 1: Get ResidentialComplex by slug ===
        complex = None
        
        # Try exact slug match first
        complex = ResidentialComplexRepository.get_by_slug(slug)
        
        # If not found, try matching with create_slug() for transliteration support
        if not complex:
            all_complexes = ResidentialComplexRepository.get_all_active(limit=100)
            for c in all_complexes:
                if create_slug(c.name) == slug:
                    complex = c
                    break
        
        # If not found, redirect to properties page
        if not complex:
            print(f"Complex {slug} not found in residential_complexes table")
            return redirect(url_for('residential_complexes_city', city_slug=city_slug))
        
        # Convert ORM object to dict for template compatibility
        complex_data = {
            'id': complex.id,
            'name': complex.name,
            'slug': complex.slug,
            'complex_type': complex.complex_type or 'residential',
            'description': complex.description,
            'cashback_rate': complex.cashback_rate,
            'cashback_percent': complex.cashback_rate,  # Alias for template
            'developer_id': complex.developer_id,
            'developer_name': complex.developer.name if complex.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
            'developer_id': complex.developer.id if complex.developer else None,
            'object_class': complex.object_class_display_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
            'developer': complex.developer.name if complex.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
            'developer_description': complex.developer.description if complex.developer else '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ —Å –º–Ω–æ–≥–æ–ª–µ—Ç–Ω–∏–º –æ–ø—ã—Ç–æ–º —Ä–∞–±–æ—Ç—ã –Ω–∞ —Ä—ã–Ω–∫–µ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏.',
            'developer_slug': complex.developer.slug if complex.developer else None,
            'developer_website': complex.developer.website if complex.developer else None,
            'object_class_display_name': complex.object_class_display_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
            'sales_address': complex.sales_address,
            'district': complex.district.name if complex.district else (current_city.name if current_city else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä'),
            'district_name': complex.district.name if complex.district else (current_city.name if current_city else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä'),
            'start_build_year': complex.start_build_year,
            'start_build_quarter': complex.start_build_quarter,
            'end_build_year': complex.end_build_year,
            'end_build_quarter': complex.end_build_quarter,
            'latitude': complex.latitude,
            'longitude': complex.longitude,
            'main_image': complex.main_image,
            'gallery_images': complex.gallery_images,
            'gallery_images': complex.gallery_images,
            'videos': complex.videos,
            'uploaded_video': complex.uploaded_video,
            'nearby': complex.nearby,
            'detailed_description': complex.detailed_description,
            'advantages': complex.advantages,
            'ceiling_height': complex.ceiling_height,
            'construction_progress_images': complex.construction_progress_images,
            'construction_photos_updated_at': complex.construction_photos_updated_at,
            'location': complex.sales_address or complex.district.name if complex.district else ''
        }
        
        # === STEP 2: Get all properties for this complex using PropertyRepository ===
        properties = PropertyRepository.get_by_complex_id(complex.id, limit=500, sort_by='price', sort_order='asc')
        
        if not properties:
            print(f"No properties found for complex {complex.name}")
            complex_data['apartments_count'] = 0
            complex_data['total_apartments'] = 0
            complex_data['price_from'] = 0
            complex_data['price_to'] = 0
            complex_data['min_price'] = 0
            complex_data['max_price'] = 0
            complex_data['buildings_count'] = 0
            complex_data['images'] = []
            complex_data['coordinates'] = [complex.latitude or 45.0355, complex.longitude or 38.9753]
            complex_data['total_floors_in_complex'] = 25
        else:
            # Calculate aggregated stats from properties
            prices = [p.price for p in properties if p.price]
            areas = [p.area for p in properties if p.area]
            floors = [p.floor for p in properties if p.floor]
            total_floors_list = [p.total_floors for p in properties if p.total_floors]
            
            complex_data['apartments_count'] = len(properties)
            complex_data['total_apartments'] = len(properties)
            complex_data['price_from'] = int(min(prices)) if prices else 0
            complex_data['price_to'] = int(max(prices)) if prices else 0
            complex_data['min_price'] = complex_data['price_from']
            complex_data['max_price'] = complex_data['price_to']
            complex_data['real_price_from'] = complex_data['price_from']
            complex_data['real_price_to'] = complex_data['price_to']
            complex_data['real_area_from'] = float(min(areas)) if areas else 0
            complex_data['real_area_to'] = float(max(areas)) if areas else 0
            complex_data['real_floors_min'] = int(min(floors)) if floors else 1
            complex_data['real_floors_max'] = int(max(total_floors_list)) if total_floors_list else 25
            complex_data['total_floors_in_complex'] = complex_data['real_floors_max']
            
            # Count unique buildings by complex_building_name
            unique_buildings = set(p.complex_building_name for p in properties if p.complex_building_name)
            complex_data['buildings_count'] = max(len(unique_buildings), 1)
            
            # Set full address from sales_address or first property address
            complex_data['full_address'] = complex.sales_address or (properties[0].address if properties else '')
            
            # Set coordinates from complex or first property
            if complex.latitude and complex.longitude:
                complex_data['coordinates'] = [float(complex.latitude), float(complex.longitude)]
            elif properties and properties[0].latitude and properties[0].longitude:
                complex_data['coordinates'] = [float(properties[0].latitude), float(properties[0].longitude)]
            else:
                complex_data['coordinates'] = [45.0355, 38.9753]  # Default Krasnodar
            
            # Get images from complex or first property
            if complex.gallery_images:
                try:
                    import json
                    images_list = json.loads(complex.gallery_images) if isinstance(complex.gallery_images, str) else complex.gallery_images
                    complex_data['images'] = images_list[:10] if images_list else []
                    complex_data['image'] = images_list[0] if images_list else complex.main_image
                except:
                    complex_data['images'] = []
                    complex_data['image'] = complex.main_image
            elif properties and properties[0].gallery_images:
                try:
                    import json
                    images_list = json.loads(properties[0].gallery_images) if isinstance(properties[0].gallery_images, str) else []
                    complex_data['images'] = images_list[:10] if images_list else []
                    complex_data['image'] = images_list[0] if images_list else properties[0].main_image
                except:
                    complex_data['images'] = []
                    complex_data['image'] = properties[0].main_image if properties else None
            else:
                complex_data['images'] = []
                complex_data['image'] = complex.main_image
                
            print(f"Loaded {len(properties)} properties for {complex.name}: price from {complex_data['price_from']}, {complex_data['buildings_count']} buildings")
        
        # === STEP 3: Convert properties to template-compatible format ===
        complex_properties = []
        cashback_rate_decimal = complex_data.get('cashback_percent', 5.0) / 100.0
        
        for prop in properties:
            # Convert ORM Property object to dict for template
            prop_dict = {
                'id': prop.inner_id or prop.id,  # Use inner_id for compatibility
                'inner_id': prop.inner_id or prop.id,
                'price': prop.price or 0,
                'cashback_amount': int(prop.price * cashback_rate_decimal) if prop.price else 0,
                'complex_id': complex.id,
                'residential_complex': complex.name,
                'object_rooms': prop.rooms or 0,
                'object_area': prop.area or 0,
                'object_min_floor': prop.floor or 1,
                'floor': prop.floor or 1,
                'total_floors': prop.total_floors or complex_data['total_floors_in_complex'],
                'address': prop.address or '',
                'address_short_display_name': prop.address or '',
                'complex_building_name': prop.complex_building_name or '–û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å',
                'property_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
                'deal_type': prop.deal_type or 'sale',
                'renovation_type': prop.renovation_type
            }
            
            # Format title
            rooms = prop.rooms or 0
            if rooms == 0:
                room_type = "–°—Ç—É–¥–∏—è"
            else:
                room_type = f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"
            
            apartment_floor = prop.floor or 1
            total_floors = prop.total_floors or complex_data['total_floors_in_complex']
            prop_dict['title'] = f"{room_type}, {prop.area or 0} –º¬≤, {apartment_floor}/{total_floors} —ç—Ç."
            prop_dict['type'] = f"{rooms}-–∫–æ–º–Ω" if rooms > 0 else "–°—Ç—É–¥–∏—è"
            prop_dict['apartment_floor'] = apartment_floor
            prop_dict['total_floors_in_complex'] = total_floors
            
            # Parse gallery images
            try:
                import json
                if prop.gallery_images:
                    if isinstance(prop.gallery_images, str):
                        photos_list = json.loads(prop.gallery_images)
                    else:
                        photos_list = prop.gallery_images
                else:
                    photos_list = []
                
                prop_dict['image'] = photos_list[0] if photos_list else (prop.main_image or 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=–ö–≤–∞—Ä—Ç–∏—Ä–∞')
                prop_dict['photos_list'] = photos_list
            except Exception as e:
                print(f"Error parsing photos for property {prop.id}: {e}")
                prop_dict['image'] = prop.main_image or 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=–ö–≤–∞—Ä—Ç–∏—Ä–∞'
                prop_dict['photos_list'] = []
            
            complex_properties.append(prop_dict)
        
        # === STEP 4: Calculate room statistics ===
        properties_by_rooms = {}
        room_stats = {}
        for prop in complex_properties:
            rooms = prop.get('object_rooms', 0)
            room_key = '–°—Ç—É–¥–∏—è' if rooms == 0 else f'{rooms}-–∫–æ–º–Ω'
            
            if room_key not in properties_by_rooms:
                properties_by_rooms[room_key] = []
                room_stats[room_key] = {
                    'count': 0,
                    'prices': [],
                    'areas': [],
                    'price_from': 0,
                    'price_to': 0,
                    'area_from': 0,
                    'area_to': 0
                }
            
            properties_by_rooms[room_key].append(prop)
            room_stats[room_key]['count'] += 1
            if prop.get('price'):
                room_stats[room_key]['prices'].append(prop['price'])
            if prop.get('object_area'):
                room_stats[room_key]['areas'].append(prop['object_area'])
        
        # Calculate min/max for each room type
        for room_key, stats in room_stats.items():
            if stats['prices']:
                stats['price_from'] = min(stats['prices'])
                stats['price_to'] = max(stats['prices'])
            else:
                stats['price_from'] = 0
                stats['price_to'] = 0
            
            if stats['areas']:
                stats['area_from'] = min(stats['areas'])
                stats['area_to'] = max(stats['areas'])
            else:
                stats['area_from'] = 0
                stats['area_to'] = 0
        
        complex_data['room_stats'] = room_stats
        
        # === STEP 5: Group properties by complex_building_name ===
        properties_by_building_unsorted = {}
        for prop in complex_properties:
            building_name = prop.get('complex_building_name') or '–û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å'
            if not building_name or building_name.strip() == '':
                building_name = '–û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å'
            
            if building_name not in properties_by_building_unsorted:
                properties_by_building_unsorted[building_name] = []
            properties_by_building_unsorted[building_name].append(prop)
        
        # Sort buildings
        def sort_buildings(building_name):
            import re
            if not building_name or building_name == '–û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å':
                return (999, building_name)
            match = re.search(r'(\d+)', building_name)
            if match:
                return (int(match.group(1)), building_name)
            return (999, building_name)
        
        properties_by_building = {}
        sorted_building_names = sorted(properties_by_building_unsorted.keys(), key=sort_buildings)
        for building_name in sorted_building_names:
            properties_by_building[building_name] = properties_by_building_unsorted[building_name]
        
        # === STEP 5.5: Create buildings dict with stats for template ===
        buildings_dict = {}
        for building_name, building_props in properties_by_building.items():
            if not building_props:
                continue
            
            # Calculate building stats from properties
            building_prices = [p.get('price', 0) for p in building_props if p.get('price')]
            building_areas = [p.get('area', 0) for p in building_props if p.get('area')]
            
            # Get building years/quarters from first property (they should be consistent per building)
            first_prop = building_props[0]
            end_build_year = first_prop.get('end_build_year') or complex_data.get('end_build_year')
            end_build_quarter = first_prop.get('end_build_quarter') or complex_data.get('end_build_quarter')
            start_build_year = first_prop.get('start_build_year') or complex_data.get('start_build_year')
            start_build_quarter = first_prop.get('start_build_quarter') or complex_data.get('start_build_quarter')
            
            # Determine building status based on completion date
            import datetime
            current_year = datetime.datetime.now().year
            current_quarter = (datetime.datetime.now().month - 1) // 3 + 1
            
            building_status = '–í –ø—Ä–æ—Ü–µ—Å—Å–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞'
            if end_build_year and end_build_quarter:
                try:
                    if int(end_build_year) < current_year or (int(end_build_year) == current_year and int(end_build_quarter) <= current_quarter):
                        building_status = '–°–¥–∞–Ω'
                except (ValueError, TypeError):
                    pass
            
            # Get total_floors from properties in this building
            total_floors_list = [p.get('total_floors') or p.get('object_max_floor') for p in building_props if p.get('total_floors') or p.get('object_max_floor')]
            max_total_floors = max(total_floors_list) if total_floors_list else None
            
            # Create building info dict
            buildings_dict[building_name] = {
                'apartments_count': len(building_props),
                'price_from': int(min(building_prices)) if building_prices else 0,
                'price_to': int(max(building_prices)) if building_prices else 0,
                'area_from': int(min(building_areas)) if building_areas else 0,
                'area_to': int(max(building_areas)) if building_areas else 0,
                'end_build_year': end_build_year,
                'end_build_quarter': end_build_quarter,
                'start_build_year': start_build_year,
                'start_build_quarter': start_build_quarter,
                'building_status': building_status,
                'total_floors': max_total_floors
            }
        
        # Add buildings dict to complex_data for template
        complex_data['buildings'] = buildings_dict
        complex_data['current_year'] = datetime.datetime.now().year
        complex_data['current_quarter'] = (datetime.datetime.now().month - 1) // 3 + 1
        
        # === STEP 6: Find similar complexes ===
        similar_complexes = []
        try:
            other_complexes = (
                db.session.query(ResidentialComplex)
                .filter(ResidentialComplex.id != complex.id, ResidentialComplex.is_active == True)
                .limit(10)
                .all()
            )
            
            stats_by_complex = PropertyRepository.get_all_property_stats()
            
            for other_complex in other_complexes[:3]:
                stats = stats_by_complex.get(other_complex.id, {})
                
                image_url = other_complex.main_image
                if not image_url and other_complex.gallery_images:
                    try:
                        import json
                        images = json.loads(other_complex.gallery_images) if isinstance(other_complex.gallery_images, str) else []
                        image_url = images[0] if images else None
                    except:
                        pass
                
                if not image_url:
                    image_url = 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=' + quote(other_complex.name[:20])
                
                similar_complex = {
                    'id': other_complex.id,
                    'name': other_complex.name,
                    'slug': other_complex.slug,
                    'developer': other_complex.developer.name if other_complex.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'district': other_complex.district.name if other_complex.district else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
                    'price_from': stats.get('min_price', 0),
                    'total_apartments': stats.get('count', 0),
                    'object_class': other_complex.object_class_display_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
                    'image': image_url,
                    'completion_date': f"{other_complex.end_build_quarter or '3'} –∫–≤. {other_complex.end_build_year or '2025'}",
                    'cashback_percent': other_complex.cashback_rate or 5.0,
                    'url': f'/zk/{other_complex.slug}'
                }
                similar_complexes.append(similar_complex)
                
        except Exception as e:
            print(f"Error finding similar complexes: {e}")
            import traceback
            traceback.print_exc()
            similar_complexes = []
        
        # === STEP 7: Load active offers and marketing materials ===
        offers_objects = Offer.query.filter_by(
            residential_complex_id=complex.id, 
            is_active=True
        ).order_by(Offer.sort_order).all()
        
        offers = []
        for offer in offers_objects:
            offers.append({
                'id': offer.id,
                'title': offer.title,
                'description': offer.description or '',
                'image_url': offer.image_url,
                'is_active': offer.is_active,
                'sort_order': offer.sort_order
            })
        
        materials = MarketingMaterial.query.filter_by(
            residential_complex_id=complex.id,
            is_active=True
        ).order_by(MarketingMaterial.sort_order, MarketingMaterial.created_at.desc()).all()
        
        # Check if user is a manager or admin
        is_manager = isinstance(current_user._get_current_object(), Manager) if current_user.is_authenticated else False
        is_admin = isinstance(current_user._get_current_object(), Admin) if current_user.is_authenticated else False
        
        # === STEP 8: Render template ===
        return render_template('residential_complex_detail.html', 
                             current_city=current_city,
                             complex=complex_data,
                             properties=complex_properties,
                             properties_by_rooms=properties_by_rooms,
                             properties_by_building=properties_by_building,
                             similar_complexes=similar_complexes,
                             developer_info=complex.developer if complex.developer else None,
                             offers=offers,
                             materials=materials,
                             manager_authenticated=is_manager,
                             admin_authenticated=is_admin)
                             
    except Exception as e:
        print(f"ERROR in /residential_complex_by_slug_city: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

def extract_main_image_from_photos(photos_raw):
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –æ—Å–Ω–æ–≤–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ –ø–æ–ª—è photos, –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞—è –≤–Ω–µ—à–Ω–∏–µ –≤–∏–¥—ã –∑–¥–∞–Ω–∏–π"""
    if not photos_raw or not photos_raw.strip():
        return '/static/images/no-photo.jpg'
    
    try:
        import json
        # –ü–æ–ø—Ä–æ–±—É–µ–º –ø–∞—Ä—Å–∏—Ç—å –∫–∞–∫ JSON –º–∞—Å—Å–∏–≤
        if photos_raw.startswith('[') and photos_raw.endswith(']'):
            images = json.loads(photos_raw)
            if not images:
                return '/static/images/no-photo.jpg'
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞—è –≤–Ω–µ—à–Ω–∏–µ –≤–∏–¥—ã
            # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, —Ç–∞–∫ –∫–∞–∫ –ø–µ—Ä–≤—ã–µ —á–∞—Å—Ç–æ –ø–ª–∞–Ω–∏—Ä–æ–≤–∫–∏
            if len(images) > 5:
                # –ë–µ—Ä–µ–º –∏–∑ —Å–µ—Ä–µ–¥–∏–Ω—ã/–∫–æ–Ω—Ü–∞ –º–∞—Å—Å–∏–≤–∞, –≥–¥–µ –æ–±—ã—á–Ω–æ —Ñ–æ—Ç–æ –∑–¥–∞–Ω–∏–π
                return images[len(images)//2]
            elif len(images) > 2:
                return images[-1]  # –ü–æ—Å–ª–µ–¥–Ω–µ–µ —Ñ–æ—Ç–æ
            else:
                return images[0]
        
        # PostgreSQL array format: {url1,url2,url3}
        elif photos_raw.startswith('{') and photos_raw.endswith('}'):
            images_str = photos_raw[1:-1]  # Remove braces
            if images_str:
                images = [img.strip().strip('"') for img in images_str.split(',') if img.strip()]
                return images[0] if images else '/static/images/no-photo.jpg'
            else:
                return '/static/images/no-photo.jpg'
        
        # –û–¥–∏–Ω–æ—á–Ω–∞—è —Å—Å—ã–ª–∫–∞
        else:
            return photos_raw
            
    except (json.JSONDecodeError, IndexError) as e:
        print(f"Error parsing photos: {e}, raw data: {photos_raw[:100]}")
        return '/static/images/no-photo.jpg'

@app.route('/complexes-map')
def complexes_map():
    """–ö–∞—Ä—Ç–∞ –∂–∏–ª—ã—Ö –∫–æ–º–ø–ª–µ–∫—Å–æ–≤"""
    try:
        # ‚úÖ MIGRATED: Load residential complexes with coordinates using repository
        complexes_data = ResidentialComplexRepository.get_with_coordinates()
        property_stats = PropertyRepository.get_all_property_stats()
        
        residential_complexes = []
        current_year = 2025
        
        for row in complexes_data:
            complex_id = row.id
            stats = property_stats.get(complex_id, {})
            
            # Skip complexes without properties
            if not stats or stats.get('total_count', 0) == 0:
                continue
            
            # Determine status based on completion year - get from repository
            end_build_year = row.end_build_year
            end_build_quarter = row.end_build_quarter
            object_class_name = row.object_class_display_name
            status = '–ù–µ —É–∫–∞–∑–∞–Ω'
            completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω'
            
            # Calculate status and completion date
            
            if end_build_year:
                if end_build_year <= current_year:
                    status = '–°–¥–∞–Ω'
                else:
                    status = '–°—Ç—Ä–æ–∏—Ç—Å—è'
                
                if end_build_quarter:
                    completion_date = f"{end_build_quarter} –∫–≤. {end_build_year}"
                else:
                    completion_date = f"{end_build_year} –≥–æ–¥"
            
            complex_data = {
                'id': complex_id,
                'name': row.name or '',
                'developer': row.developer_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
                'address': '',  # Not in get_with_coordinates()
                'district': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
                'apartments_count': stats.get('total_count', 0),
                'price_from': int(stats.get('min_price', 0)),
                'coordinates': {
                    'lat': float(row.latitude) if row.latitude else 45.0448,
                    'lng': float(row.longitude) if row.longitude else 38.9760
                },
                'completion_date': completion_date,
                'status': status,
                'cashback_percent': float(row.cashback_rate) if row.cashback_rate else 0,
                'main_image': row.main_image or '/static/images/no-photo.jpg',
                'description': f"–ñ–∏–ª–æ–π –∫–æ–º–ø–ª–µ–∫—Å {row.name or ''}",
                'object_class': object_class_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
                'housing_class': object_class_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
                'max_floors': 0,
                'url': f'/zk/{row.slug}' if row.slug else f'/residential-complex/{complex_id}',
                'type': 'complex'
            }
            residential_complexes.append(complex_data)
        
        # –§–∏–ª—å—Ç—Ä—ã –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        all_districts = sorted(list(set(complex.get('district', '–ù–µ —É–∫–∞–∑–∞–Ω') for complex in residential_complexes)))
        all_developers = sorted(list(set(complex.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω') for complex in residential_complexes)))
        all_statuses = ['–í—Å–µ', '–°–¥–∞–Ω', '–°—Ç—Ä–æ–∏—Ç—Å—è']
        
        print(f"DEBUG: Found {len(residential_complexes)} complexes for map")
        if residential_complexes:
            print(f"DEBUG: First complex: {residential_complexes[0]}")
        
        return render_template('complexes_map.html', 
                             residential_complexes=residential_complexes,
                             all_districts=all_districts,
                             all_developers=all_developers,
                             all_statuses=all_statuses)
                             
    except Exception as e:
        print(f"ERROR in complexes-map route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

# API Routes
@app.route('/api/properties')
@csrf.exempt
def api_properties():
    """API for property list - returns properties for homepage featured section"""
    try:
        city_id = request.args.get('city_id', 1, type=int)
        limit = request.args.get('limit', 20, type=int)
        limit = min(limit, 100)  # Cap at 100
        
        app.logger.debug(f"API /api/properties: city_id={city_id}, limit={limit}")
        
        properties = PropertyRepository.get_all_active(
            limit=limit,
            filters={'city_id': city_id}
        )
        
        result = []
        for prop in properties:
            complex_obj = prop.residential_complex
            
            room_display = "–°—Ç—É–¥–∏—è"
            rooms_count = prop.rooms or 0
            if rooms_count == 1:
                room_display = "1-–∫–æ–º–Ω."
            elif rooms_count == 2:
                room_display = "2-–∫–æ–º–Ω."
            elif rooms_count == 3:
                room_display = "3-–∫–æ–º–Ω."
            elif rooms_count == 4:
                room_display = "4-–∫–æ–º–Ω."
            elif rooms_count >= 5:
                room_display = f"{rooms_count}-–∫–æ–º–Ω."
            
            photos_list = []
            if prop.gallery_images:
                try:
                    import json as json_module
                    photos_list = json_module.loads(prop.gallery_images) if isinstance(prop.gallery_images, str) else prop.gallery_images
                except:
                    photos_list = []
            
            result.append({
                'id': prop.inner_id or str(prop.id),
                'price': prop.price or 0,
                'area': prop.area or 0,
                'total_area': prop.area or 0,
                'rooms': rooms_count,
                'room_type': room_display,
                'object_rooms': room_display,
                'floor': prop.floor or 1,
                'floors_in_building': prop.total_floors or 1,
                'max_floor': prop.total_floors or 1,
                'complex_name': complex_obj.name if complex_obj else '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω',
                'residential_complex': complex_obj.name if complex_obj else '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω',
                'developer_name': prop.developer.name if prop.developer else '',
                'developer': prop.developer.name if prop.developer else '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ —É–∫–∞–∑–∞–Ω',
                'photos': json.dumps(photos_list) if photos_list else '[]',
                'parsed_district': prop.address or '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
                'district': prop.address or '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π'
            })
        
        app.logger.debug(f"API /api/properties: returning {len(result)} properties")
        return jsonify({'success': True, 'properties': result})
    except Exception as e:
        app.logger.error(f"Error in /api/properties: {str(e)}", exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/map-properties')
@cache.cached(timeout=300, query_string=True)
def api_map_properties():
    """API –¥–ª—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–π –∫–∞—Ä—Ç—ã - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–∫—Ç—ã —Å –ø–æ–ª—è–º–∏ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞"""
    try:
        city_id = request.args.get('city_id', None)
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 500, type=int)
        rooms_filter = request.args.getlist('rooms') or request.args.getlist('rooms[]')
        price_min = request.args.get('price_min', type=float)
        price_max = request.args.get('price_max', type=float)
        area_min = request.args.get('area_min', type=float)
        area_max = request.args.get('area_max', type=float)
        floor_min = request.args.get('floor_min', type=int)
        floor_max = request.args.get('floor_max', type=int)
        developers_filter = request.args.getlist('developers') or request.args.getlist('developers[]')
        completion_filter = request.args.getlist('completion') or request.args.getlist('completion[]')
        object_classes_filter = request.args.getlist('object_classes') or request.args.getlist('object_classes[]')
        building_status_filter = request.args.getlist('building_status') or request.args.getlist('building_status[]')
        building_released_filter = request.args.getlist('building_released') or request.args.getlist('building_released[]')
        renovation_filter = request.args.getlist('renovation') or request.args.getlist('renovation[]')
        floor_options_filter = request.args.getlist('floor_options') or request.args.getlist('floor_options[]')
        districts_filter = request.args.getlist('districts') or request.args.getlist('districts[]')
        features_filter = request.args.getlist('features') or request.args.getlist('features[]')
        search_query = request.args.get('search', '')
        property_type_filter = request.args.get('property_type', '')
        
        from models import Property, ResidentialComplex, City, Developer
        from sqlalchemy.orm import joinedload
        
        query = Property.query.filter(Property.is_active == True)
        
        if city_id:
            try:
                city_id = int(city_id)
                query = query.filter(Property.city_id == city_id)
            except:
                pass
        
        # Apply room filter
        if rooms_filter:
            try:
                rooms_list = [int(r) for r in rooms_filter if r]
                if rooms_list:
                    query = query.filter(Property.rooms.in_(rooms_list))
            except:
                pass
        
        # Apply property type filter
        if property_type_filter and property_type_filter != 'all':
            property_type_map = {
                'apartments': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
                'houses': '–î–æ–º',
                'townhouses': '–¢–∞—É–Ω—Ö–∞—É—Å',
                'penthouses': '–ü–µ–Ω—Ç—Ö–∞—É—Å',
                'apartments_commercial': '–ê–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç—ã'
            }
            mapped_type = property_type_map.get(property_type_filter, property_type_filter)
            query = query.filter(Property.property_type == mapped_type)
            print(f"üó∫Ô∏è Map-properties: Filtering by property_type: {mapped_type}")

        # Apply price filter
        if price_min is not None:
            query = query.filter(Property.price >= price_min)
        if price_max is not None:
            query = query.filter(Property.price <= price_max)
        
        # Apply area filter
        if area_min is not None:
            query = query.filter(Property.area >= area_min)
        if area_max is not None:
            query = query.filter(Property.area <= area_max)
        
        # Apply search filter with stop-word filtering
        if search_query:
            stop_words = {'—É–ª–∏—Ü–∞', '—É–ª', '—Ä–∞–π–æ–Ω', '—Ä-–Ω', '–≥–æ—Ä–æ–¥', '–≥', '–∂–∫', '–∂–∏–ª–æ–π', '–∫–æ–º–ø–ª–µ–∫—Å', 
                         '–¥–æ–º', '–¥', '–∫–æ—Ä–ø—É—Å', '–∫', '—Å—Ç—Ä–æ–µ–Ω–∏–µ', '—Å—Ç—Ä', '–ª–∏—Ç–µ—Ä', '–ª–∏—Ç', '–ø—Ä–æ—Å–ø–µ–∫—Ç', '–ø—Ä'}
            words = search_query.lower().split()
            significant_words = [w for w in words if w not in stop_words and len(w) > 1]
            
            query = query.outerjoin(ResidentialComplex, Property.complex_id == ResidentialComplex.id)
            query = query.outerjoin(Developer, Property.developer_id == Developer.id)
            
            if significant_words:
                for word in significant_words:
                    search_pattern = f'%{word}%'
                    query = query.filter(
                        db.or_(
                            Property.address.ilike(search_pattern),
                            ResidentialComplex.name.ilike(search_pattern),
                            Developer.name.ilike(search_pattern)
                        )
                    )
            else:
                search_pattern = f'%{search_query}%'
                query = query.filter(
                    db.or_(
                        Property.address.ilike(search_pattern),
                        ResidentialComplex.name.ilike(search_pattern),
                        Developer.name.ilike(search_pattern)
                    )
                )
        
        # Apply floor filter
        if floor_min is not None:
            query = query.filter(Property.floor >= floor_min)
        if floor_max is not None:
            query = query.filter(Property.floor <= floor_max)
        
        # Apply developer filter (supports both IDs and names)
        developer_name = request.args.get('developer', '')  # Single developer name from URL
        if developer_name:
            # Filter by developer name
            dev = Developer.query.filter(Developer.name == developer_name).first()
            if dev:
                query = query.filter(Property.developer_id == dev.id)
                print(f"üó∫Ô∏è Map-properties: Filtering by developer name: {developer_name} (ID: {dev.id})")
        elif developers_filter:
            try:
                dev_ids = [int(d) for d in developers_filter if d]
                if dev_ids:
                    query = query.filter(Property.developer_id.in_(dev_ids))
            except:
                pass
        
        # Apply district filter
        district_name = request.args.get('district', '')
        if district_name:
            from models import District
            dist = District.query.filter(District.name == district_name).first()
            if dist:
                query = query.filter(Property.district_id == dist.id)
                print(f"üó∫Ô∏è Map-properties: Filtering by district: {district_name}")
        
        # Apply residential complex filter
        rc_name = request.args.get('residential_complex', '')
        if rc_name:
            rc = ResidentialComplex.query.filter(ResidentialComplex.name == rc_name).first()
            if rc:
                query = query.filter(Property.complex_id == rc.id)
                print(f"üó∫Ô∏è Map-properties: Filtering by complex: {rc_name}")
        
        # Join ResidentialComplex once if any RC-based filter is needed
        needs_rc_join = bool(object_classes_filter or completion_filter or building_status_filter or building_released_filter)
        if needs_rc_join:
            query = query.join(ResidentialComplex, Property.complex_id == ResidentialComplex.id)
        
        # Apply object class filter
        if object_classes_filter:
            query = query.filter(
                ResidentialComplex.object_class_display_name.in_(object_classes_filter)
            )
        
        # Apply completion year filter
        if completion_filter:
            try:
                completion_years = [int(y) for y in completion_filter if y]
                if completion_years:
                    query = query.filter(
                        ResidentialComplex.end_build_year.in_(completion_years)
                    )
            except:
                pass
        
        # Apply building status filter
        if building_status_filter:
            from datetime import datetime
            current_year = datetime.now().year
            status_conditions = []
            for status in building_status_filter:
                if status == 'delivered':
                    status_conditions.append(ResidentialComplex.end_build_year < current_year)
                elif status == 'under_construction':
                    status_conditions.append(ResidentialComplex.end_build_year >= current_year)
            if status_conditions:
                from sqlalchemy import or_
                query = query.filter(or_(*status_conditions))
        
        # Apply building_released filter
        if building_released_filter and not building_status_filter:
            from datetime import datetime
            current_year = datetime.now().year
            status_conditions = []
            for status in building_released_filter:
                if status in ('true', 'delivered', '1'):
                    status_conditions.append(ResidentialComplex.end_build_year < current_year)
                elif status in ('false', 'under_construction', '0'):
                    status_conditions.append(ResidentialComplex.end_build_year >= current_year)
            if status_conditions:
                from sqlalchemy import or_
                query = query.filter(or_(*status_conditions))
        
        # Apply floor_options filter (not_first, not_last)
        if floor_options_filter:
            for option in floor_options_filter:
                if option == 'not_first':
                    query = query.filter(Property.floor > 1)
                elif option == 'not_last':
                    query = query.filter(
                        db.or_(
                            Property.floor < Property.total_floors,
                            Property.total_floors.is_(None)
                        )
                    )
                elif option == 'last':
                    query = query.filter(Property.floor == Property.total_floors)
        
        # Apply renovation filter
        if renovation_filter:
            renovation_conditions = []
            for ren in renovation_filter:
                ren_lower = ren.lower()
                if ren_lower in ('no_renovation', '–±–µ–∑ –æ—Ç–¥–µ–ª–∫–∏', '–±–µ–∑_–æ—Ç–¥–µ–ª–∫–∏'):
                    renovation_conditions.append(
                        db.or_(
                            Property.renovation_type.is_(None),
                            Property.renovation_type == '',
                            Property.renovation_type == 'no_renovation',
                            db.func.lower(Property.renovation_type).like('%–±–µ–∑%')
                        )
                    )
                elif ren_lower in ('fine_finish', '—á–∏—Å—Ç–æ–≤–∞—è', '—á–∏—Å—Ç–æ–≤–∞—è –æ—Ç–¥–µ–ª–∫–∞'):
                    renovation_conditions.append(
                        db.or_(
                            Property.renovation_type == 'fine_finish',
                            db.func.lower(Property.renovation_type).like('%—á–∏—Å—Ç–æ–≤%')
                        )
                    )
                elif ren_lower in ('rough_finish', '—á–µ—Ä–Ω–æ–≤–∞—è', '—á–µ—Ä–Ω–æ–≤–∞—è –æ—Ç–¥–µ–ª–∫–∞'):
                    renovation_conditions.append(
                        db.or_(
                            Property.renovation_type == 'rough_finish',
                            db.func.lower(Property.renovation_type).like('%—á–µ—Ä–Ω–æ–≤%')
                        )
                    )
                elif ren_lower in ('turnkey', '–ø–æ–¥ –∫–ª—é—á'):
                    renovation_conditions.append(
                        db.or_(
                            Property.renovation_type == 'turnkey',
                            db.func.lower(Property.renovation_type).like('%–∫–ª—é—á%')
                        )
                    )
                else:
                    renovation_conditions.append(
                        db.or_(
                            db.func.lower(Property.renovation_type) == ren_lower,
                            db.func.lower(Property.renovation_type).like(f'%{ren_lower}%')
                        )
                    )
            if renovation_conditions:
                query = query.filter(db.or_(*renovation_conditions))
        
        # Apply districts filter
        if districts_filter:
            try:
                dist_ids = [int(d) for d in districts_filter if d]
                if dist_ids:
                    query = query.filter(Property.district_id.in_(dist_ids))
            except:
                pass
        
        properties_list = query.options(
            joinedload(Property.residential_complex),
            joinedload(Property.developer),
            joinedload(Property.city)
        ).all()
        
        properties = []
        for prop in properties_list:
            try:
                complex_obj = prop.residential_complex
                city_obj = prop.city
                
                lat = float(prop.latitude) if prop.latitude else (float(complex_obj.latitude) if complex_obj and complex_obj.latitude else 45.0355)
                lng = float(prop.longitude) if prop.longitude else (float(complex_obj.longitude) if complex_obj and complex_obj.longitude else 38.9753)
                property_data = {
                    'id': prop.id,
                    'price': prop.price or 0,
                    'area': prop.area or 0,
                    'rooms': prop.rooms or 0,
                    'title': getattr(prop, 'room_description', '–ö–≤–∞—Ä—Ç–∏—Ä–∞'),
                    'residential_complex': complex_obj.name if complex_obj else '',
                    'complex_name': complex_obj.name if complex_obj else '',
                    'developer': prop.developer.name if prop.developer else '',
                    'coordinates': {'lat': lat, 'lng': lng},
                    'latitude': lat,
                    'longitude': lng,
                    'city_id': prop.city_id,
                    'city_name': city_obj.name if city_obj else 'N/A',
                    'url': f"/object/{prop.id}",
                    'status': '—Å—Ç—Ä–æ–∏—Ç—Å—è',
                    # –í–°–ï –ü–û–õ–Ø –î–õ–Ø –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø –°–¢–ê–¢–£–°–ê
                    'completion_date': getattr(prop, 'completion_date_quarter', None),
                    'completion_year': getattr(prop, 'completion_year', None),
                    'deal_type': getattr(prop, 'deal_type', 'sale'),
                    'complex_building_status': getattr(complex_obj, 'status', None) if complex_obj else None,
                    'complex_building_end_build_year': getattr(complex_obj, 'end_build_year', None) if complex_obj else None,
                    'cashback': int((prop.price or 0) * (float(complex_obj.cashback_rate or 3.5) / 100)) if complex_obj else int((prop.price or 0) * 0.035),
                    'cashback_rate': float(complex_obj.cashback_rate) if complex_obj and complex_obj.cashback_rate else 3.5,
                }
                
                # Add images to response
                if prop.gallery_images:
                    property_data['gallery_images'] = prop.gallery_images
                elif prop.main_image:
                    property_data['main_image'] = prop.main_image
                    property_data['gallery_images'] = [prop.main_image]
                
                properties.append(property_data)
            except Exception as e:
                continue
        
        return jsonify({'success': True, 'properties': properties[:per_page]})
    except Exception as e:
        print(f"‚ùå ERROR in api_map_properties: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500



@cache.cached(timeout=300, query_string=True)
def api_properties():
    """API endpoint for properties - NORMALIZED TABLES"""
    try:
        # Resolve city context for filtering
        city_context = resolve_city_context(
            city_id=request.args.get('city_id'),
            city_slug=request.args.get('city'),
            default_if_none=True
        )
        city_name = city_context.name if city_context else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä'
        city_id_filter = city_context.id if city_context else None
        import json
        from sqlalchemy.orm import joinedload
        from repositories.property_repository import PropertyRepository
        from models import Property, ResidentialComplex
        
        # Pagination
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 50))
        offset = (page - 1) * per_page
        
        # Get properties with coordinates
        query = Property.query.join(
            ResidentialComplex, Property.complex_id == ResidentialComplex.id, isouter=True
        ).filter(
            Property.is_active == True
        )
        
        # Apply city filter if specified
        if city_id_filter:
            query = query.filter(Property.city_id == city_id_filter)
        
        properties_list = query.options(
            joinedload(Property.residential_complex),
            joinedload(Property.developer)
        ).offset(offset).limit(per_page).all()
        
        # Count total
        total_count_query = Property.query.filter(
            Property.is_active == True
        )
        if city_id_filter:
            total_count_query = total_count_query.filter(Property.city_id == city_id_filter)
        total_count = total_count_query.count()
        
        # Format response
        properties = []
        for prop in properties_list:
            complex_obj = prop.residential_complex
            developer_obj = prop.developer
            
            property_data = {
                'id': prop.id,
                'price': prop.price or 0,
                'area': prop.area or 0,
                'rooms': prop.rooms or 0,
                'title': prop.room_description + f", {prop.area} –º¬≤",
                'subtitle': f"{complex_obj.name if complex_obj else ''} ‚Ä¢ {city_name}",
                'address': prop.address or (complex_obj.address if complex_obj else ''),
                'residential_complex': complex_obj.name if complex_obj else '',
                'developer': developer_obj.name if developer_obj else '',
                'developer_name': developer_obj.name if developer_obj else '',
                'district': city_context.name if 'city_context' in locals() else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
                'district': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
                'renovation_display_name': prop.renovation_type or '–ë–µ–∑ –æ—Ç–¥–µ–ª–∫–∏',
                'object_min_floor': prop.floor,
                'object_max_floor': prop.total_floors,
                'coordinates': {
                    'lat': float(prop.latitude) if prop.latitude else (float(complex_obj.latitude) if complex_obj and complex_obj.latitude else 45.0448),
                    'lng': float(prop.longitude) if prop.longitude else (float(complex_obj.longitude) if complex_obj and complex_obj.longitude else 38.9760)
                },
                'url': f"/object/{prop.id}",
                'type': 'property',
                'cashback': int((prop.price or 0) * (complex_obj.cashback_rate / 100 if complex_obj else 0.035)),
                'cashback_available': True,
                'status': 'available',
                'property_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞'
            }
            
            # Main image
            if prop.main_image:
                property_data['main_image'] = prop.main_image
            elif prop.gallery_images:
                try:
                    photos = json.loads(prop.gallery_images)
                    property_data['main_image'] = photos[0] if photos else 'https://via.placeholder.com/400x300'
                except:
                    property_data['main_image'] = 'https://via.placeholder.com/400x300'
            else:
                property_data['main_image'] = 'https://via.placeholder.com/400x300'
            
            properties.append(property_data)
        
        print(f"DEBUG: API returned {len(properties)} properties (page {page}, total {total_count})")
        return jsonify({
            'properties': properties,
            'total': total_count,
            'page': page,
            'per_page': per_page,
            'total_pages': (total_count + per_page - 1) // per_page,
            'success': True
        })
        
    except Exception as e:
        print(f"ERROR in api_properties: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500



@app.route('/api/search-suggestions-OLD-DISABLED')
def api_search_suggestions_old_disabled():
    """‚ùå –°–¢–ê–†–´–ô API endpoint - –û–¢–ö–õ–Æ–ß–Å–ù, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞–ª –Ω–æ–≤–æ–º—É"""
    return jsonify([])  # –í–°–ï–ì–î–ê –ü–£–°–¢–û–ô


# ===== –°–¢–ê–†–´–ô –ö–û–î –ü–û–õ–ù–û–°–¢–¨–Æ –£–î–ê–õ–Å–ù =====

@app.route('/api/properties/list')
def api_properties_list():
    """AJAX API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –æ–±—ä–µ–∫—Ç–æ–≤ —Å —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–æ–π –∏ —Ñ–∏–ª—å—Ç—Ä–∞–º–∏"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    
    try:
        import json
        from repositories.property_repository import PropertyRepository, ResidentialComplexRepository, DeveloperRepository
        
        # Parse filters
        _, _, filters = build_property_filters(request.args)
        
        # Pagination
        page = request.args.get('page', default=1, type=int)
        page = max(1, page)
        per_page = request.args.get('per_page', default=20, type=int)
        per_page = min(max(1, per_page), 1000)  # Limit between 1-1000
        offset = (page - 1) * per_page
        
        # Sorting
        sort_type = request.args.get('sort', 'price-asc').replace('_', '-')
        
        # Convert filters to Repository format (same logic as /properties route)
        repo_filters = {}
        
        # Price filters
        if filters.get('price_min'):
            try:
                price_val = float(filters['price_min'])
                # If price < 1000, assume it's in millions; else assume rubles
                repo_filters['min_price'] = int(price_val * 1000000) if price_val < 1000 else int(price_val)
            except:
                pass
        if filters.get('price_max'):
            try:
                price_val = float(filters['price_max'])
                # If price < 1000, assume it's in millions; else assume rubles
                repo_filters['max_price'] = int(price_val * 1000000) if price_val < 1000 else int(price_val)
            except:
                pass
                
        # Area filters
        if filters.get('area_min'):
            try:
                repo_filters['min_area'] = float(filters['area_min'])
            except:
                pass
        if filters.get('area_max'):
            try:
                repo_filters['max_area'] = float(filters['area_max'])
            except:
                pass
                
        # Rooms filter
        if filters.get('rooms'):
            try:
                # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –∏ —Å—Ç—Ä–æ–∫, –∏ —á–∏—Å–µ–ª –≤ –º–∞—Å—Å–∏–≤–µ rooms
                rooms_list = []
                for r in filters['rooms']:
                    if isinstance(r, str):
                        r_stripped = r.strip()
                        if r_stripped:
                            rooms_list.append(int(r_stripped))
                    elif isinstance(r, int):
                        rooms_list.append(r)
                if rooms_list:
                    repo_filters['rooms'] = rooms_list
                    app.logger.info(f"‚úÖ Rooms filter applied: {rooms_list}")
            except Exception as e:
                app.logger.error(f"‚ùå Error processing rooms filter: {e}")
        if filters.get('developers'):
            repo_filters['developers'] = filters['developers']
        if filters.get('developer'):
            if 'developers' not in repo_filters:
                repo_filters['developers'] = []
            if filters['developer'] not in repo_filters['developers']:
                repo_filters['developers'].append(filters['developer'])
                
        # Districts filter
        if filters.get('districts'):
            repo_filters['districts'] = filters['districts']
        
        # Property type filter with English to Russian mapping
        if filters.get('property_type') and filters['property_type'] != 'all':
            property_type_map = {
                'apartments': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
                'houses': '–î–æ–º',
                'townhouses': '–¢–∞—É–Ω—Ö–∞—É—Å',
                'penthouses': '–ü–µ–Ω—Ç—Ö–∞—É—Å',
                'apartments_commercial': '–ê–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç—ã',
            }
            mapped_type = property_type_map.get(filters['property_type'], filters['property_type'])
            repo_filters['property_type'] = mapped_type
        
        # Residential complex filter
        if filters.get('residential_complex'):
            repo_filters['residential_complex'] = filters['residential_complex']
        
        # Floor filters
        if filters.get('floor_min'):
            try:
                repo_filters['floor_min'] = int(filters['floor_min'])
            except:
                pass
        if filters.get('floor_max'):
            try:
                repo_filters['floor_max'] = int(filters['floor_max'])
            except:
                pass
        
        
        # Object classes filter
        if filters.get('object_classes'):
            repo_filters['object_classes'] = filters['object_classes']
        
        # Renovation filter
        if filters.get('renovation'):
            repo_filters['renovation'] = filters['renovation']
        
        # Features filter
        if filters.get('features'):
            repo_filters['features'] = filters['features']
        
        # Building released filter
        if filters.get('building_released'):
            repo_filters['building_released'] = filters['building_released']
        
        # Completion filter (years)
        if filters.get('completion'):
            repo_filters['completion'] = filters['completion']
        
        # Floor options filter (not_first, not_last, last)
        if filters.get('floor_options'):
            repo_filters['floor_options'] = filters['floor_options']
        
        # Building floors range
        if filters.get('building_floors_min'):
            try:
                repo_filters['building_floors_min'] = int(filters['building_floors_min'])
            except:
                pass
        if filters.get('building_floors_max'):
            try:
                repo_filters['building_floors_max'] = int(filters['building_floors_max'])
            except:
                pass
        
        # Search filter
        search_text = filters.get('search', '').strip()
        if search_text:
            repo_filters['search'] = search_text
        
        # Parse sort_type (e.g. 'price-asc', 'area-desc')
        sort_by = 'price'
        sort_order = 'asc'
        if sort_type:
            parts = sort_type.split('-')
            if len(parts) == 2:
                sort_by = parts[0]
                sort_order = parts[1]
        
        # Get properties with Repository
        
        # ‚úÖ ADD: Include city_id from session/context
        if current_city:
            repo_filters['city_id'] = current_city.id
            print(f"‚úÖ /properties: Filtering by city: {current_city.name} (ID: {current_city.id})")

        properties_list = PropertyRepository.get_all_active(
            limit=per_page,
            offset=offset,
            filters=repo_filters,
            sort_by=sort_by,
            sort_order=sort_order
        )
        
        total_properties = PropertyRepository.count_active(filters=repo_filters)
        
        # Convert to JSON format
        properties_data = []
        for prop in properties_list:
            try:
                complex_obj = prop.residential_complex
                developer_obj = prop.developer
                
                # Parse photos
                photos_list = []
                main_image = 'https://via.placeholder.com/400x300'
                
                if prop.main_image:
                    main_image = prop.main_image
                
                if prop.gallery_images:
                    try:
                        if isinstance(prop.gallery_images, list):
                            photos_list = prop.gallery_images
                        elif isinstance(prop.gallery_images, str):
                            photos_list = json.loads(prop.gallery_images)
                        
                        if photos_list and not prop.main_image:
                            main_image = photos_list[0]
                    except:
                        pass
                
                # Calculate cashback
                cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 3.5
                cashback_amount = int(prop.price * (cashback_rate / 100)) if prop.price else 0
                
                property_dict = {
                    'id': prop.id,
                    'price': prop.price or 0,
                    'price_formatted': prop.formatted_price,
                    'area': prop.area or 0,
                    'rooms': prop.rooms or 0,
                    'room_description': prop.room_description,
                    'floor': prop.floor if prop.floor is not None else 1,
                    'total_floors': prop.total_floors if prop.total_floors is not None else 1,
                    'address': prop.address or (complex_obj.address if complex_obj else ''),
                    'renovation': prop.renovation_type or 'no_renovation',
                    'renovation_display_name': PropertyRepository.get_renovation_display_name(prop.renovation_type),
                    'price_per_sqm': prop.price_per_sqm or (int(prop.price / prop.area) if prop.price and prop.area else 0),
                    'gallery': photos_list,
                    'image': main_image,
                    'latitude': prop.latitude or (complex_obj.latitude if complex_obj else None),
                    'longitude': prop.longitude or (complex_obj.longitude if complex_obj else None),
                    'complex_name': complex_obj.name if complex_obj else '',
                    'residential_complex': complex_obj.name if complex_obj else '',
                    'developer': developer_obj.name if developer_obj else '',
                    'developer_name': developer_obj.name if developer_obj else '',
                    'cashback_rate': cashback_rate,
                    'cashback': cashback_amount,
                    'cashback_available': True,
                    'complex_object_class_display_name': complex_obj.object_class_display_name if complex_obj else '–ö–æ–º—Ñ–æ—Ä—Ç',
                    'deal_type': prop.deal_type or '–ü–µ—Ä–≤–∏—á–∫–∞',
                    'description': prop.description or '',
                    'type': 'apartment',
                    'district': complex_obj.district if complex_obj else '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
                    'mortgage_available': True,
                    'completion_date': f"{complex_obj.end_build_quarter} –∫–≤. {complex_obj.end_build_year}" if complex_obj and complex_obj.end_build_year else '–£—Ç–æ—á–Ω—è–µ—Ç—Å—è'
                }
                properties_data.append(property_dict)
            except Exception as e:
                prop_id = getattr(prop_orm, "id", "unknown"); print(f"Error processing property {prop_id}: {e}")
                continue
        
        # Pagination info
        total_pages = (total_properties + per_page - 1) // per_page
        
        print(f"‚úÖ API /api/properties/list: returned {len(properties_data)} properties, page {page}/{total_pages}, sort={sort_type}")
        
        return jsonify({
            'success': True,
            'properties': properties_data,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total_properties,
                'total_pages': total_pages,
                'has_prev': page > 1,
                'has_next': page < total_pages
            },
            'filters': filters,
            'sort': sort_type
        })
        
    except Exception as e:
        print(f"ERROR in api_properties_list: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500



@app.route('/api/properties/count')
def api_properties_count():
    """API endpoint –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ–±—ä–µ–∫—Ç–æ–≤ —Å —É—á–µ—Ç–æ–º —Ñ–∏–ª—å—Ç—Ä–æ–≤ (–ë–ï–ó –ø–æ–ª–Ω–æ–π –≤—ã–±–æ—Ä–∫–∏ –¥–∞–Ω–Ω—ã—Ö)"""
    try:
        import json
        from repositories.property_repository import PropertyRepository
        
        # Parse filters using the same build_property_filters function
        _, _, filters = build_property_filters(request.args)
        
        # Convert filters to Repository format (same logic as /properties and /api/properties/list)
        repo_filters = {}
        
        # Price filters
        if filters.get('price_min'):
            try:
                price_val = float(filters['price_min'])
                # If price < 1000, assume it's in millions; else assume rubles
                repo_filters['min_price'] = int(price_val * 1000000) if price_val < 1000 else int(price_val)
            except:
                pass
        if filters.get('price_max'):
            try:
                price_val = float(filters['price_max'])
                # If price < 1000, assume it's in millions; else assume rubles
                repo_filters['max_price'] = int(price_val * 1000000) if price_val < 1000 else int(price_val)
            except:
                pass
                
        # Area filters
        if filters.get('area_min'):
            try:
                repo_filters['min_area'] = float(filters['area_min'])
            except:
                pass
        if filters.get('area_max'):
            try:
                repo_filters['max_area'] = float(filters['area_max'])
            except:
                pass
                
        # Rooms filter - –ò–°–ü–†–ê–í–õ–ï–ù–û: –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å–º–µ—à–∞–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤
        if filters.get('rooms'):
            try:
                room_values = []
                for r in filters['rooms']:
                    # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏ —Å—Ç—Ä–æ–∫–∏ –∏ —á–∏—Å–ª–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ
                    if isinstance(r, str):
                        r_clean = r.strip()
                        if r_clean:
                            room_values.append(int(r_clean))
                    elif isinstance(r, int):
                        room_values.append(r)
                if room_values:
                    repo_filters['rooms'] = room_values
            except Exception as e:
                print(f"Warning: error parsing rooms filter: {e}")
                pass
        
        # Developers filter
        if filters.get('developers'):
            repo_filters['developers'] = filters['developers']
        if filters.get('developer'):
            if 'developers' not in repo_filters:
                repo_filters['developers'] = []
            if filters['developer'] not in repo_filters['developers']:
                repo_filters['developers'].append(filters['developer'])
                
        # Districts filter
        if filters.get('districts'):
            repo_filters['districts'] = filters['districts']
        
        # Residential complex filter
        if filters.get('residential_complex'):
            repo_filters['residential_complex'] = filters['residential_complex']
        
        # Floor filters
        if filters.get('floor_min'):
            try:
                repo_filters['floor_min'] = int(filters['floor_min'])
            except:
                pass
        if filters.get('floor_max'):
            try:
                repo_filters['floor_max'] = int(filters['floor_max'])
            except:
                pass
        
        # Object class filter
        if filters.get('object_classes'):
            repo_filters['object_classes'] = filters['object_classes']
        
        # Renovation filter
        if filters.get('renovation'):
            repo_filters['renovation'] = filters['renovation']
        
        # Features filter
        if filters.get('features'):
            repo_filters['features'] = filters['features']
        
        # Building released filter
        if filters.get('building_released'):
            repo_filters['building_released'] = filters['building_released']
        
        # Completion filter
        if filters.get('completion'):
            repo_filters['completion'] = filters['completion']
        
        # Floor options filter
        if filters.get('floor_options'):
            repo_filters['floor_options'] = filters['floor_options']
        if filters.get('features'):
            repo_filters['features'] = filters['features']
        
        # Building floors filters
        if filters.get('building_floors_min'):
            try:
                repo_filters['building_floors_min'] = int(filters['building_floors_min'])
            except:
                pass
        if filters.get('building_floors_max'):
            try:
                repo_filters['building_floors_max'] = int(filters['building_floors_max'])
            except:
                pass
        
        # Build year filters
        if filters.get('build_year_min'):
            try:
                repo_filters['build_year_min'] = int(filters['build_year_min'])
            except:
                pass
        if filters.get('build_year_max'):
            try:
                repo_filters['build_year_max'] = int(filters['build_year_max'])
            except:
                pass
        
        # Search query filter - support both 'q' and 'search' parameters
        search_query = request.args.get('q', request.args.get('search', '')).strip()
        if search_query:
            repo_filters['search'] = search_query
        elif filters.get('search'):
            repo_filters['search'] = filters['search']
        
        # ‚úÖ –ö–†–ò–¢–ò–ß–ù–û: City filter –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ–¥—Å—á–µ—Ç–∞ –ø–æ –≥–æ—Ä–æ–¥–∞–º
        if filters.get('city_id'):
            try:
                repo_filters['city_id'] = int(filters['city_id'])
            except (ValueError, TypeError):
                pass
        
        # Get total count from repository (optimized query - count only)
        total_count = PropertyRepository.get_filtered_count(**repo_filters)
        
        return jsonify({
            'success': True,
            'count': total_count,
            'filters': filters  # Return parsed filters for debugging
        })
        
    except Exception as e:
        print(f"Error in api_properties_count: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e), 'count': 0}), 500

@app.route('/api/residential-complexes-map')
def api_residential_complexes_map():
    """API endpoint for residential complexes with enhanced data for map"""
    # Get city_id from request args first, then fallback to session
    city_id = request.args.get('city_id', type=int)
    if not city_id and 'city_id' in session:
        city_id = session['city_id']
    
    # Filter complexes by city_id (inline query - DO NOT modify load_residential_complexes())
    from models import ResidentialComplex, Property
    from sqlalchemy import func
    query = ResidentialComplex.query.filter_by(is_active=True)
    if city_id:
        query = query.filter_by(city_id=city_id)
    
    complexes_db = query.all()
    
    # Get min/max prices for all complexes in one query
    price_stats = db.session.query(
        Property.complex_id,
        func.min(Property.price).label('min_price'),
        func.max(Property.price).label('max_price'),
        func.count(Property.id).label('count')
    ).filter(
        Property.is_active == True,
        Property.complex_id.isnot(None)
    ).group_by(Property.complex_id).all()
    
    price_map = {ps.complex_id: {'min': ps.min_price, 'max': ps.max_price, 'count': ps.count} for ps in price_stats}
    

    # Get room statistics for all complexes
    room_stats = db.session.query(
        Property.complex_id,
        Property.rooms,
        func.count(Property.id).label('count'),
        func.min(Property.price).label('min_price'),
        func.max(Property.price).label('max_price'),
        func.min(Property.area).label('min_area'),
        func.max(Property.area).label('max_area')
    ).filter(
        Property.is_active == True,
        Property.complex_id.isnot(None),
        Property.rooms.isnot(None)
    ).group_by(Property.complex_id, Property.rooms).all()
    
    # Build room_details map: {complex_id: {"–°—Ç—É–¥–∏—è": {...}, "1-–∫–æ–º–Ω": {...}, ...}}
    room_map = {}
    for rs in room_stats:
        if rs.complex_id not in room_map:
            room_map[rs.complex_id] = {}
        # Map rooms number to Russian label
        if rs.rooms == 0:
            room_label = '–°—Ç—É–¥–∏—è'
        else:
            room_label = f'{rs.rooms}-–∫–æ–º–Ω'
        room_map[rs.complex_id][room_label] = {
            'count': rs.count,
            'min_price': rs.min_price,
            'max_price': rs.max_price,
            'min_area': float(rs.min_area) if rs.min_area else None,
            'max_area': float(rs.max_area) if rs.max_area else None
        }
    
    # Get sample gallery images from properties for each complex (up to 8 unique photos)
    property_photos = db.session.query(
        Property.complex_id,
        Property.gallery_images
    ).filter(
        Property.is_active == True,
        Property.complex_id.isnot(None),
        Property.gallery_images.isnot(None)
    ).all()
    
    # Build gallery map: {complex_id: [photo1, photo2, ...]}
    gallery_map = {}
    for pp in property_photos:
        if pp.complex_id not in gallery_map:
            gallery_map[pp.complex_id] = []
        if pp.gallery_images and len(gallery_map[pp.complex_id]) < 8:
            try:
                photos = json.loads(pp.gallery_images) if isinstance(pp.gallery_images, str) else pp.gallery_images
                if isinstance(photos, list):
                    # Skip first photo (index 0) - it is usually a floor plan
                    for photo in photos[1:]:
                        if photo and photo not in gallery_map[pp.complex_id] and len(gallery_map[pp.complex_id]) < 8:
                            gallery_map[pp.complex_id].append(photo)
            except:
                pass
    
    # Convert to dict format for existing processing logic
    complexes = []
    for complex in complexes_db:
        stats = price_map.get(complex.id, {})
        complexes.append({
            'id': complex.id,
            'name': complex.name,
            'slug': complex.slug,
            'latitude': complex.latitude,
            'longitude': complex.longitude,
            'cashback_rate': complex.cashback_rate,
            'main_image': complex.main_image,
            'gallery_images': complex.gallery_images or json.dumps(gallery_map.get(complex.id, [])),
            'district': complex.district.name if complex.district else '–ù–µ —É–∫–∞–∑–∞–Ω',
            'developer': complex.developer.name if complex.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
            'developer_name': complex.developer.name if complex.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
            'developer_id': complex.developer.id if complex.developer else None,
            'object_class': complex.object_class_display_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
            'address': complex.address or (complex.district.name if complex.district else '–ù–µ —É–∫–∞–∑–∞–Ω'),
            'price_from': stats.get('min'),
            'price_to': stats.get('max'),
            'available_apartments': stats.get('count', 0),
            'status': (
                '–°–¥–∞–Ω' if not complex.end_build_year or 
                (complex.end_build_year < 2026) or 
                (complex.end_build_year == 2026 and (complex.end_build_quarter or 1) <= 1)
                else f'{complex.end_build_quarter} –∫–≤. {complex.end_build_year}'
            ),
            'completion_year': complex.end_build_year,
            'completion_quarter': complex.end_build_quarter,
            'room_details': room_map.get(complex.id, {}),
        })
    
    # Enhance complexes data for map
    for i, complex in enumerate(complexes):
        # Add coordinates using latitude/longitude if available
        if 'coordinates' not in complex:
            lat = complex.get('latitude')
            lng = complex.get('longitude')
            if lat and lng and lat != 0 and lng != 0:
                complex['coordinates'] = {'lat': float(lat), 'lng': float(lng)}
            else:
                # Fallback only if no real coordinates
                base_lat = 45.0448
                base_lng = 38.9760
                lat_offset = (hash(str(i) + complex.get('name', '')) % 1000) / 8000 - 0.0625
                lng_offset = (hash(str(i) + complex.get('district', '')) % 1000) / 8000 - 0.0625
                complex['coordinates'] = {
                    'lat': base_lat + lat_offset,
                    'lng': base_lng + lng_offset
                }
        
        # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–æ–¥—Å—á–µ—Ç –∫–æ—Ä–ø—É—Å–æ–≤ –∏–∑ normalized tables
        if 'buildings_count' not in complex:
            # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ—Ä–ø—É—Å–æ–≤ –∏–∑ normalized tables
            try:
                result = db.session.execute(text("""
                    SELECT COUNT(DISTINCT p.complex_building_name) as buildings_count
                    FROM properties p
                    JOIN residential_complexes rc ON p.complex_id = rc.id
                    WHERE rc.name = :complex_name 
                      AND p.is_active = true 
                      AND p.complex_building_name IS NOT NULL
                """), {'complex_name': complex.get('name', '')})
                row = result.fetchone()
                complex['buildings_count'] = row[0] if row and row[0] else 1
            except:
                complex['buildings_count'] = 1  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 1 –∫–æ—Ä–ø—É—Å
        if 'apartments_count' not in complex:
            complex['apartments_count'] = 100 + (i % 300)
            
    return jsonify({"complexes": complexes, "total": len(complexes)})

# Removed duplicate route - using api_property_detail instead

def _get_complex_data_normalized(complex_id):
    """
    Helper function to query complex data from normalized tables.
    Handles both residential_complexes.id and complex_id (legacy external ID).
    Returns tuple with result row and success boolean.
    """
    result = db.session.execute(text("""
        SELECT 
            rc.id,
            rc.name,
            MIN(p.price) as min_price,
            MAX(p.price) as max_price,
            COUNT(DISTINCT p.id) as apartments_count,
            COUNT(DISTINCT NULLIF(p.complex_building_name,'')) as buildings_count,
            d.name as developer_name,
            MIN(p.floor) as floors_min,
            MAX(p.total_floors) as floors_max,
            rc.end_build_year as completion_year,
            rc.end_build_quarter as completion_quarter,
            dis.name as district,
            COALESCE(MAX(p.address), rc.address) as address,
            rc.cashback_rate,
            COALESCE(rc.main_image, rc.gallery_images, MIN(p.gallery_images)) as photos,
            rc.object_class_display_name AS complex_object_class_display_name
        FROM properties p
        JOIN residential_complexes rc ON p.complex_id = rc.id
        JOIN developers d ON p.developer_id = d.id
        LEFT JOIN districts dis ON rc.district_id = dis.id
        WHERE (rc.id = :complex_id OR rc.complex_id = :complex_id_str)
            AND p.is_active = true
        GROUP BY rc.id, rc.name, d.name, rc.end_build_year, rc.end_build_quarter, 
                 dis.name, rc.address, rc.cashback_rate, rc.gallery_images, 
                 rc.main_image, rc.object_class_display_name
        LIMIT 1
    """), {'complex_id': complex_id, 'complex_id_str': str(complex_id)}).fetchone()
    
    return result


@app.route('/api/complex/<int:complex_id>')
def api_complex(complex_id):
    """API endpoint for single residential complex - MIGRATED TO NORMALIZED TABLES"""
    print(f"üîç API /api/complex/{complex_id} called")
    
    try:
        # Query normalized tables (handles both rc.id and rc.complex_id)
        result = _get_complex_data_normalized(complex_id)
        
        if result:
            print(f"‚úÖ Found complex {complex_id} in normalized tables: {result[1]}, apartments: {result[4]}, price: {result[2]}-{result[3]}")
            
            # Build completion date from year and quarter
            completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
            if result[9] and result[10]:  # year and quarter
                completion_date = f"{result[9]} –≥., {result[10]} –∫–≤."
            elif result[9]:  # only year
                completion_date = f"{result[9]} –≥."
            
            # ‚úÖ Auto-calculate status based on completion date
            from datetime import datetime
            current_year = datetime.now().year
            current_quarter = (datetime.now().month - 1) // 3 + 1
            
            status = "–ù–µ —É–∫–∞–∑–∞–Ω"
            if result[9]:  # completion_year exists
                completion_year = int(result[9])
                if completion_year < current_year:
                    status = "–°–¥–∞–Ω"
                elif completion_year == current_year:
                    if result[10]:  # completion_quarter exists
                        completion_quarter = int(result[10])
                        if completion_quarter <= current_quarter:
                            status = "–°–¥–∞–Ω"
                        else:
                            status = "–°—Ç—Ä–æ–∏—Ç—Å—è"
                    else:
                        status = "–°—Ç—Ä–æ–∏—Ç—Å—è"
                else:
                    status = "–°—Ç—Ä–æ–∏—Ç—Å—è"
            
            # Extract first photo from photos array/string
            image_url = '/static/images/no-image.jpg'
            if result[14]:  # photos field
                try:
                    # Try parsing as JSON array
                    photos_data = json.loads(result[14])
                    if photos_data and isinstance(photos_data, list) and len(photos_data) > 0:
                        image_url = photos_data[0]
                except (json.JSONDecodeError, TypeError):
                    # If not JSON, treat as single image URL
                    if isinstance(result[14], str) and result[14].strip():
                        image_url = result[14]
            
            response_data = {
                'id': result[0],
                'name': result[1],
                'min_price': result[2],
                'price_from': result[2],
                'max_price': result[3],
                'price_to': result[3],
                'apartments_count': result[4],
                'properties_count': result[4],
                'buildings_count': result[5],
                'developer': result[6],
                'developer_name': result[6],

                'floors_min': result[7],
                'floors_max': result[8],
                'district': result[11] if len(result) > 11 else None,
                'address': result[12] if len(result) > 12 else None,
                'cashback_rate': result[13] if len(result) > 13 else None,
                'housing_class': result[15] if len(result) > 15 else None,
                'status': status,
                'completion_date': completion_date,
                'image_url': image_url,
                'image': image_url
            }
            return jsonify(response_data)
        else:
            return jsonify({'error': 'Complex not found'}), 404
    except Exception as e:
        print(f'Error in /api/complex endpoint: {e}')
        return jsonify({'error': 'Internal server error'}), 500

def _get_complexes_batch_optimized(complex_ids):
    """
    Bulk query for multiple complexes from normalized tables - SINGLE QUERY.
    Returns dict mapping complex_id -> result tuple (same format as _get_complex_data_normalized).
    """
    if not complex_ids:
        return {}
    
    # Single bulk query using IN clause
    results = db.session.execute(text("""
        SELECT 
            rc.id,
            rc.name,
            MIN(p.price) as min_price,
            MAX(p.price) as max_price,
            COUNT(DISTINCT p.id) as apartments_count,
            COUNT(DISTINCT NULLIF(p.complex_building_name,'')) as buildings_count,
            d.name as developer_name,
            MIN(p.floor) as floors_min,
            MAX(p.total_floors) as floors_max,
            rc.end_build_year as completion_year,
            rc.end_build_quarter as completion_quarter,
            dis.name as district,
            COALESCE(MAX(p.address), rc.address) as address,
            rc.cashback_rate,
            COALESCE(rc.main_image, rc.gallery_images, MIN(p.gallery_images)) as photos,
            rc.object_class_display_name AS complex_object_class_display_name
        FROM properties p
        JOIN residential_complexes rc ON p.complex_id = rc.id
        JOIN developers d ON p.developer_id = d.id
        LEFT JOIN districts dis ON rc.district_id = dis.id
        WHERE (rc.id IN :complex_ids OR rc.complex_id::text = ANY(ARRAY[:complex_ids_str]))
            AND p.is_active = true
        GROUP BY rc.id, rc.name, d.name, rc.end_build_year, rc.end_build_quarter, 
                 dis.name, rc.address, rc.cashback_rate, rc.gallery_images, 
                 rc.main_image, rc.object_class_display_name
    """), {
        'complex_ids': tuple(complex_ids),
        'complex_ids_str': [str(cid) for cid in complex_ids]
    }).fetchall()
    
    # Build dict mapping id -> result tuple
    result_dict = {}
    for row in results:
        result_dict[row[0]] = row  # row[0] is rc.id
    
    return result_dict

@require_json_csrf
@app.route('/api/complexes/batch', methods=['POST'])
def api_complexes_batch():
    """Batch API endpoint to get multiple complexes at once - OPTIMIZED"""
    try:
        data = request.get_json()
        complex_ids = data.get('ids', [])
        
        if not complex_ids or not isinstance(complex_ids, list):
            return jsonify({'error': 'Invalid request, expected {"ids": [1, 2, 3]}'}), 400
        
        # Convert string IDs to integers
        try:
            complex_ids = [int(cid) for cid in complex_ids if cid]
        except (ValueError, TypeError) as e:
            return jsonify({'error': f'Invalid ID format: {str(e)}'}), 400
        
        # ‚úÖ SINGLE QUERY: Load all complexes at once using bulk helper function
        complexes_dict = _get_complexes_batch_optimized(complex_ids)
        
        results = {}
        for complex_id in complex_ids:
            result = complexes_dict.get(complex_id)
            if result:
                # Build completion date
                completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
                if result[9] and result[10]:
                    completion_date = f"{result[9]} –≥., {result[10]} –∫–≤."
                elif result[9]:
                    completion_date = f"{result[9]} –≥."
                
                # Extract image
                image_url = '/static/images/no-image.jpg'
                if result[14]:
                    try:
                        photos_data = json.loads(result[14])
                        if photos_data and isinstance(photos_data, list) and len(photos_data) > 0:
                            image_url = photos_data[0]
                    except (json.JSONDecodeError, TypeError):
                        if isinstance(result[14], str) and result[14].strip():
                            image_url = result[14]
                
                response_data = {
                    'id': result[0],
                    'name': result[1],
                    'min_price': result[2],
                    'price_from': result[2],
                    'max_price': result[3],
                    'price_to': result[3],
                    'apartments_count': result[4],
                    'properties_count': result[4],
                    'buildings_count': result[5],
                    'developer': result[6],
                    'developer_name': result[6],
                    'floors_min': result[7] if result[7] else '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                    'floors_max': result[8],
                    'completion_date': completion_date,
                    'district': result[11] or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                    'address': result[12] or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                    'cashback_rate': result[13] or 0,
                    'cashback_percent': result[13] or 0,
                    'object_class': result[15] or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                    'status': '–í –ø—Ä–æ–¥–∞–∂–µ',
                    'image': image_url,
                    'original_id': complex_id
                }
                results[str(complex_id)] = response_data
        
        return jsonify({'success': True, 'items': results})
    except Exception as e:
        print(f"‚ùå Error in batch complexes: {e}")
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500




@app.route('/api/mini-map/properties')
def api_mini_map_properties():
    """API endpoint for mini-map: return property coordinates with FILTER support"""
    from repositories.property_repository import PropertyRepository
    
    try:
        # Get city context from request params or session
        city_id = request.args.get('city_id', type=int)
        if not city_id and 'city_id' in session:
            city_id = session['city_id']
            print(f"üó∫Ô∏è Mini-map API: Using city_id from session: {city_id}")
        elif city_id:
            print(f"üó∫Ô∏è Mini-map API: Using city_id from request: {city_id}")
        else:
            print(f"‚ö†Ô∏è Mini-map API: No city_id, loading all properties")
        
        # Build filters - support all main filter types
        filters = {}
        if city_id:
            filters['city_id'] = city_id
        
        # ‚úÖ CRITICAL: Apply same filters as property list
        if request.args.get('residential_complex'):
            filters['residential_complex'] = request.args.get('residential_complex')
            print(f"üó∫Ô∏è Mini-map: Filtering by residential_complex: {filters['residential_complex']}")
        
        if request.args.get('developer'):
            filters['developer'] = request.args.get('developer')
            print(f"üó∫Ô∏è Mini-map: Filtering by developer: {filters['developer']}")
        
        rooms_list = request.args.getlist('rooms') or request.args.getlist('rooms[]')
        if rooms_list:
            all_rooms = []
            for r in rooms_list:
                all_rooms.extend(r.split(','))
            filters['rooms'] = [int(r) for r in all_rooms if r.isdigit()]
            print(f"üó∫Ô∏è Mini-map: Filtering by rooms: {filters['rooms']}")
        
        if request.args.get('price_min'):
            filters['price_min'] = request.args.get('price_min', type=int)
        if request.args.get('price_max'):
            filters['price_max'] = request.args.get('price_max', type=int)
        
        if request.args.get('area_min'):
            filters['area_min'] = request.args.get('area_min', type=float)
        if request.args.get('area_max'):
            filters['area_max'] = request.args.get('area_max', type=float)
        
        developers_list = request.args.getlist('developers') or request.args.getlist('developers[]')
        if developers_list:
            all_devs = []
            for d in developers_list:
                all_devs.extend(d.split(','))
            filters['developers'] = [x.strip() for x in all_devs if x.strip()]
        
        if request.args.get('search'):
            filters['search'] = request.args.get('search')
            print(f"üó∫Ô∏è Mini-map: Filtering by search: {filters['search']}")
        
        districts_list = request.args.getlist('districts') or request.args.getlist('districts[]')
        if districts_list:
            all_dists = []
            for d in districts_list:
                all_dists.extend(d.split(','))
            filters['districts'] = [x.strip() for x in all_dists if x.strip()]
        
        if request.args.get('property_type') and request.args.get('property_type') != 'all':
            property_type_map = {
                'apartments': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
                'houses': '–î–æ–º', 
                'townhouses': '–¢–∞—É–Ω—Ö–∞—É—Å',
                'penthouses': '–ü–µ–Ω—Ç—Ö–∞—É—Å',
                'apartments_commercial': '–ê–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç—ã'
            }
            raw_type = request.args.get('property_type')
            filters['property_type'] = property_type_map.get(raw_type, raw_type)
        
        for list_key in ['completion', 'object_classes', 'renovation', 'features', 'building_released', 'floor_options', 'building_types']:
            vals = request.args.getlist(list_key) or request.args.getlist(list_key + '[]')
            if vals:
                all_vals = []
                for v in vals:
                    all_vals.extend(v.split(','))
                filters[list_key] = [x.strip() for x in all_vals if x.strip()]
        
        if request.args.get('floor_min'):
            filters['floor_min'] = request.args.get('floor_min')
        if request.args.get('floor_max'):
            filters['floor_max'] = request.args.get('floor_max')
        if request.args.get('building_floors_min'):
            filters['building_floors_min'] = request.args.get('building_floors_min')
        if request.args.get('building_floors_max'):
            filters['building_floors_max'] = request.args.get('building_floors_max')
        
        active_filters = [k for k in filters.keys() if k != 'city_id']
        if active_filters:
            print(f"üó∫Ô∏è Mini-map: Active filters: {active_filters}")
        
        # Get coordinates from properties table using Repository with ALL filters
        properties = PropertyRepository.get_all_active(limit=1000, filters=filters)
        
        coordinates = []
        for prop in properties:
            lat = getattr(prop, "latitude", None)
            lng = getattr(prop, "longitude", None)
            
            if (not lat or not lng or lat == 0 or lng == 0) and prop.residential_complex:
                lat = prop.residential_complex.latitude
                lng = prop.residential_complex.longitude
            
            if lat and lng and lat != 0 and lng != 0:
                coordinates.append({
                    'lat': float(lat),
                    'lng': float(lng)
                })
        
        print(f"‚úÖ Mini-map: Loaded {len(coordinates)} property coordinates (filters: {list(filters.keys())})")
        return jsonify({'success': True, 'coordinates': coordinates, 'count': len(coordinates)})
    except Exception as e:
        print(f"‚ùå Error in mini-map properties: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500



@app.route('/api/mini-map/complexes')
def api_mini_map_complexes():
    """API endpoint for mini-map: return complex coordinates - NORMALIZED TABLES"""
    from repositories.property_repository import ResidentialComplexRepository
    from models import ResidentialComplex
    
    try:
        # Get city_id from request args first, then fallback to session
        city_id = request.args.get('city_id', type=int)
        if not city_id and 'city_id' in session:
            city_id = session['city_id']
        
        # Filter complexes by city_id
        if city_id:
            complexes = ResidentialComplex.query.filter_by(is_active=True, city_id=city_id).all()
        else:
            complexes = ResidentialComplexRepository.get_all_active()
        
        coordinates = []
        for complex_obj in complexes:
            # Only add if complex has valid coordinates
            if complex_obj.latitude and complex_obj.longitude and complex_obj.latitude != 0 and complex_obj.longitude != 0:
                coordinates.append({
                    'name': complex_obj.name,
                    'lat': float(complex_obj.latitude),
                    'lng': float(complex_obj.longitude)
                })
        
        print(f"‚úÖ Mini-map: Loaded {len(coordinates)} complex coordinates from normalized tables")
        return jsonify({'success': True, 'coordinates': coordinates, 'count': len(coordinates)})
    except Exception as e:
        print(f"‚ùå Error in mini-map complexes: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/property/<property_id>/pdf')
def download_property_pdf(property_id):
    """Generate and download PDF for property"""
    try:
        property_data = get_property_by_id(property_id)
        if not property_data:
            return jsonify({'error': 'Property not found'}), 404
        
        # Create simple HTML for PDF generation
        html_content = f"""
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ text-align: center; margin-bottom: 30px; }}
                .property-details {{ margin-bottom: 20px; }}
                .detail-row {{ margin-bottom: 10px; }}
                .label {{ font-weight: bold; }}
                .price {{ color: #0088CC; font-size: 24px; font-weight: bold; }}
                .cashback {{ color: #FF5722; font-size: 18px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>InBack - –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∫–≤–∞—Ä—Ç–∏—Ä–µ</h1>
                <p>–ö–≤–∞—Ä—Ç–∏—Ä–∞ #{property_id}</p>
            </div>
            
            <div class="property-details">
                <div class="detail-row">
                    <span class="label">–¢–∏–ø:</span> {property_data.get('rooms', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}
                </div>
                <div class="detail-row">
                    <span class="label">–ü–ª–æ—â–∞–¥—å:</span> {property_data.get('area', '–ù–µ —É–∫–∞–∑–∞–Ω–∞')} –º¬≤
                </div>
                <div class="detail-row">
                    <span class="label">–≠—Ç–∞–∂:</span> {property_data.get('floor', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                <div class="detail-row">
                    <span class="label">–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫:</span> {property_data.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                <div class="detail-row">
                    <span class="label">–ñ–ö:</span> {property_data.get('residential_complex', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                <div class="detail-row">
                    <span class="label">–†–∞–π–æ–Ω:</span> {property_data.get('district', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                <div class="detail-row">
                    <span class="label">–ê–¥—Ä–µ—Å:</span> {property_data.get('location', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                <div class="detail-row">
                    <span class="label">–°—Ç–∞—Ç—É—Å:</span> {property_data.get('status', '–ù–µ —É–∫–∞–∑–∞–Ω')}
                </div>
                
                <div class="detail-row" style="margin-top: 30px;">
                    <div class="price">–¶–µ–Ω–∞: {property_data.get('price', 0):,} ‚ÇΩ</div>
                </div>
                <div class="detail-row">
                    <div class="cashback">–ö–µ—à–±–µ–∫: –¥–æ {calculate_cashback(property_data.get('price', 0)):,} ‚ÇΩ (5%)</div>
                </div>
            </div>
            
            <div style="margin-top: 50px; text-align: center; color: #666;">
                <p>InBack.ru - –≤–∞—à –∫–µ—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏</p>
                <p>–¢–µ–ª–µ—Ñ–æ–Ω: +7 (800) 123-12-12</p>
            </div>
        </body>
        </html>
        """
        
        # Return HTML for PDF conversion (browser will handle PDF generation)
        # Create ASCII-safe filename
        ascii_filename = f'property-{property_id}.html'
        
        response = app.response_class(
            response=html_content,
            status=200,
            mimetype='text/html'
        )
        response.headers['Content-Disposition'] = f'attachment; filename="{ascii_filename}"'
        return response
        
    except Exception as e:
        print(f"Error generating PDF for property {property_id}: {e}")
        return jsonify({'error': 'Failed to generate PDF'}), 500

@app.route('/developers')
# @cache.cached(timeout=3600)  # –ö—ç—à –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
def developers():
    """Developers listing page with real database data"""
    try:
        # For /developers without city in URL, don't use session city - show all developers
        # Only filter by city if explicitly provided in URL params
        current_city = resolve_city_context(
            city_id=request.args.get('city_id'),
            city_slug=request.args.get('city'),
            default_if_none=False  # Don't use session city for /developers route
        )
        
        print(f"Loading developers from database for city: {current_city.name if current_city else 'All'}")
        
        from models import Developer, ResidentialComplex, Property
        from services.dadata_client import DaDataClient
        from sqlalchemy import func
        
        # –ü–æ–ª—É—á–∞–µ–º –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–æ–≤ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö —Å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
        # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –≥–æ—Ä–æ–¥—É, –µ—Å–ª–∏ –≥–æ—Ä–æ–¥ –≤—ã–±—Ä–∞–Ω
        query = db.session.query(Developer, 
                            func.count(ResidentialComplex.id).label('complexes_count'),
                            func.count(Property.id).label('properties_count'))
        
        if current_city:
            # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ –ñ–ö –∏ –æ–±—ä–µ–∫—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç —Ç–µ–∫—É—â–µ–º—É –≥–æ—Ä–æ–¥—É
            query = query.outerjoin(ResidentialComplex, 
                                   (Developer.id == ResidentialComplex.developer_id) & 
                                   (ResidentialComplex.city_id == current_city.id))
            # Property —Å–≤—è–∑–∞–Ω —Å Developer —á–µ—Ä–µ–∑ ResidentialComplex, –Ω–µ –Ω–∞–ø—Ä—è–º—É—é
            query = query.outerjoin(Property, 
                                   (ResidentialComplex.id == Property.complex_id) & 
                                   (Property.city_id == current_city.id))
        else:
            query = query.outerjoin(ResidentialComplex, Developer.id == ResidentialComplex.developer_id)
            # Property —Å–≤—è–∑–∞–Ω —Å Developer —á–µ—Ä–µ–∑ ResidentialComplex
            query = query.outerjoin(Property, ResidentialComplex.id == Property.complex_id)
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä "—Ç–æ–ª—å–∫–æ —Å –æ–±—ä–µ–∫—Ç–∞–º–∏" —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –≥–æ—Ä–æ–¥—É
        query = query.group_by(Developer.id)
        if current_city:
            query = query.having(func.count(Property.id) > 0)  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–æ–≤ —Å –æ–±—ä–µ–∫—Ç–∞–º–∏ –≤ —ç—Ç–æ–º –≥–æ—Ä–æ–¥–µ
        
        developers_list = query.order_by(func.count(Property.id).desc()).all()
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–æ–≤ —Å –¥–∞–Ω–Ω—ã–º–∏
        developers_data = []
        for developer, complexes_count, properties_count in developers_list:
            developer_dict = {
                'id': developer.id,
                'name': developer.name,
                'slug': developer.slug,
                'description': developer.description or f"–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ {developer.name}",
                'logo_url': developer.logo_url or f"https://via.placeholder.com/200x100/3B82F6/FFFFFF?text={developer.name.replace(' ', '+')}",
                'website': developer.website,
                'phone': developer.phone,
                'email': developer.email,
                'address': developer.address,
                'complexes_count': complexes_count,
                'properties_count': properties_count,
                'established_year': developer.established_year,
                # –ù—É–∂–Ω—ã–µ –ø–æ–ª—è –¥–ª—è —à–∞–±–ª–æ–Ω–∞
                'max_cashback': 10,  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é 10%
                'max_cashback_percent': 10,
                # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                'stats': {
                    'total_projects': complexes_count,
                    'total_apartments': properties_count,
                    'avg_price': None  # –î–æ–±–∞–≤–∏–º –ø–æ–∑–∂–µ
                }
            }
            
            # ‚úÖ MIGRATED: Get statistics using ORM Property model
            from sqlalchemy import func
            # –§–∏–ª—å—Ç—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ —Ç–µ–∫—É—â–µ–º—É –≥–æ—Ä–æ–¥—É
            # Property —Å–≤—è–∑–∞–Ω —Å Developer —á–µ—Ä–µ–∑ ResidentialComplex
            stats_query = db.session.query(
                func.count(Property.id).label('total_properties'),
                func.avg(Property.price).label('avg_price'),
                func.min(Property.price).label('min_price'),
                func.max(Property.price).label('max_price'),
                func.count(func.distinct(Property.complex_id)).label('total_complexes')
            ).join(
                ResidentialComplex, Property.complex_id == ResidentialComplex.id
            ).filter(
                ResidentialComplex.developer_id == developer.id,
                Property.is_active == True
            )
            
            if current_city:
                stats_query = stats_query.filter(Property.city_id == current_city.id)
            
            stats_result = stats_query.first()
            
            if stats_result and stats_result.total_properties:
                total_props, avg_price, min_price, max_price, total_complexes = stats_result
                developer_dict['properties_count'] = total_props or properties_count
                developer_dict['complexes_count'] = total_complexes or complexes_count
                developer_dict['stats'] = {
                    'total_projects': total_complexes or complexes_count,
                    'total_apartments': total_props or properties_count,
                    'avg_price': int(avg_price) if avg_price else None,
                    'min_price': int(min_price) if min_price else None,
                    'max_price': int(max_price) if max_price else None
                }
            else:
                # Fallback to basic database stats
                developer_dict['stats'] = {
                    'total_projects': complexes_count,
                    'total_apartments': properties_count,
                    'avg_price': None
                }
            
            developers_data.append(developer_dict)
        
        print(f"Found {len(developers_data)} developers in database")
        
        # –ü–æ–ª—É—á–∞–µ–º –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–ø–æ –≥–æ—Ä–æ–¥—É –µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω)
        if current_city:
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Ç–µ–∫—É—â–µ–º—É –≥–æ—Ä–æ–¥—É
            total_developers = len(developers_data)  # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–æ–≤ —Å –æ–±—ä–µ–∫—Ç–∞–º–∏ –≤ –≥–æ—Ä–æ–¥–µ
            total_complexes = db.session.query(ResidentialComplex).filter(
                ResidentialComplex.city_id == current_city.id
            ).count()
            # –ë–µ—Ä–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ–≤–æ–ª—å–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
            satisfied_clients = max(50, total_developers * 10)
        else:
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –≤—Å–µ–π –±–∞–∑–µ
            total_developers = db.session.query(Developer).count()
            total_complexes = db.session.query(ResidentialComplex).count()
            satisfied_clients = 500  # –ë–µ—Ä–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ —Å about.html
        
        return render_template('developers.html', 
                             developers=developers_data,
                             current_city=current_city,
                             total_developers=total_developers,
                             total_complexes=total_complexes,
                             satisfied_clients=satisfied_clients)
        
    except Exception as e:
        print(f"Error loading developers: {e}")
        current_city = resolve_city_context()
        return render_template('developers.html', developers=[], current_city=current_city)

@app.route('/developer/<developer_slug>')  
def developer_page(developer_slug):
    """Individual developer page by slug"""
    try:
        # Transliteration mapping for finding Cyrillic slugs from Latin input
        translit_map = str.maketrans('abcdefghijklmnopqrstuvwxyz', '–∞–±—Ü–¥–µ—Ñ–≥—Ö–∏–π–∫–ª–º–Ω–æ–ø–∫—Ä—Å—Ç–≤—É—Ö—ã–∑–≥–∫-–Ω–µ–æ–º–µ—Ç—Ä–∏—è'[:26])
        
        # Create variations of the developer name to search for
        developer_name_from_slug = developer_slug.replace('-', ' ')
        
        # Try to find developer in database using multiple search strategies
        # First try exact match with original slug
        developer = db.session.execute(
            text("""
            SELECT * FROM developers WHERE 
            LOWER(slug) = LOWER(:slug)
            OR LOWER(name) LIKE LOWER(:name_pattern)
            OR LOWER(REPLACE(name, ' ', '-')) = LOWER(:slug)
            LIMIT 1
            """),
            {
                "slug": developer_slug, 
                "name_pattern": f"%{developer_name_from_slug}%"
            }
        ).fetchone()
        
        # If not found, try searching by name matching (case insensitive)
        if not developer:
            # Try all developers and match by similarity
            all_devs = db.session.execute(text("SELECT * FROM developers")).fetchall()
            for dev in all_devs:
                dev_slug = dev.slug.lower() if dev.slug else ''
                dev_name = dev.name.lower().replace(' ', '-').replace('–≥–∫', 'gk')
                dev_name = dev_name.replace('–Ω–µ–æ–º–µ—Ç—Ä–∏—è', 'neometriya')
                
                if developer_slug.lower() in [dev_slug, dev_name]:
                    developer = dev
                    break
        
        if not developer:
            print(f"Developer not found in database: {developer_slug}")
            return redirect(url_for('developers'))
        
        # Convert row to dict-like object for template
        developer_dict = dict(developer._mapping)
        
        # ‚úÖ MIGRATED: Get developer's complexes from normalized tables
        from models import ResidentialComplex
        developer_complexes_orm = (
            db.session.query(ResidentialComplex)
            .filter(ResidentialComplex.developer_id == developer.id)
            .all()
        )
        
        # Get property statistics for each complex using PropertyRepository
        developer_complexes_query = []
        for complex_orm in developer_complexes_orm:
            # Get properties for this complex
            complex_properties = PropertyRepository.get_by_complex_id(complex_orm.id, limit=10000)
            
            # Calculate statistics
            if complex_properties:
                min_price = min(p.price for p in complex_properties if p.price)
                max_price = max(p.price for p in complex_properties if p.price)
                avg_price = sum(p.price for p in complex_properties if p.price) / len(complex_properties)
                
                # Get unique buildings count
                buildings = set(p.complex_building_name for p in complex_properties if p.complex_building_name)
                buildings_count = len(buildings)
                
                # Get photos from first property
                main_image = 'https://images.unsplash.com/photo-1545324418-cc1a3fa10c00?w=800'
                images = [main_image]
                if complex_properties[0].gallery_images:
                    try:
                        photos_list = json.loads(complex_properties[0].gallery_images)
                        if photos_list and isinstance(photos_list, list):
                            images = photos_list
                            main_image = photos_list[0]
                    except:
                        pass
                
                # Get address from properties (fallback to complex address)
                property_address = complex_properties[0].address if complex_properties and complex_properties[0].address else None
                
                # Create complex data structure
                complex_data = type('obj', (object,), {
                    'name': complex_orm.name,
                    'id': complex_orm.name,
                    'location': property_address or complex_orm.address or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',
                    'apartments_count': len(complex_properties),
                    'buildings_count': buildings_count or 1,
                    'min_price': int(min_price),
                    'max_price': int(max_price),
                    'avg_price': int(avg_price),
                    'lat': complex_properties[0].latitude if complex_properties[0].latitude else None,
                    'lng': complex_properties[0].longitude if complex_properties[0].longitude else None,
                    'sales_address': property_address or complex_orm.address,
                    'images': images,
                    'image': main_image,
                    'completion_date': f"{complex_orm.end_build_quarter} –∫–≤. {complex_orm.end_build_year}" if complex_orm.end_build_quarter and complex_orm.end_build_year else '–°–¥–∞–Ω',
                    'real_price_from': int(min_price),
                    'room_types_count': len(set(p.rooms for p in complex_properties)),
                    '_mapping': {
                        'name': complex_orm.name,
                        'id': complex_orm.name,
                        'location': property_address or complex_orm.address or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',
                        'apartments_count': len(complex_properties),
                        'buildings_count': buildings_count or 1,
                        'min_price': int(min_price),
                        'max_price': int(max_price),
                        'avg_price': int(avg_price),
                        'lat': complex_properties[0].latitude if complex_properties[0].latitude else None,
                        'lng': complex_properties[0].longitude if complex_properties[0].longitude else None,
                        'sales_address': property_address or complex_orm.address,
                        'images': images,
                        'image': main_image,
                        'completion_date': f"{complex_orm.end_build_quarter} –∫–≤. {complex_orm.end_build_year}" if complex_orm.end_build_quarter and complex_orm.end_build_year else '–°–¥–∞–Ω',
                        'real_price_from': int(min_price),
                        'room_types_count': len(set(p.rooms for p in complex_properties))
                    }
                })()
                developer_complexes_query.append(complex_data)
        
        # Sort by apartments_count descending
        developer_complexes_query = sorted(developer_complexes_query, key=lambda x: x.apartments_count, reverse=True)
        
        developer_complexes = []
        for complex_row in developer_complexes_query:
            complex_dict = dict(complex_row._mapping)
            
            # ‚úÖ MIGRATED: Get room distribution from PropertyRepository
            # Get all properties for this complex from the developer_complexes_query data
            complex_name = complex_dict['name']
            matching_complex = next((c for c in developer_complexes_orm if c.name == complex_name), None)
            
            room_distribution_query = []
            if matching_complex:
                complex_props = PropertyRepository.get_by_complex_id(matching_complex.id, limit=10000)
                
                # Group by rooms
                from collections import defaultdict
                room_groups = defaultdict(list)
                for p in complex_props:
                    room_groups[p.rooms].append(p)
                
                # Create room distribution data
                for rooms, props in sorted(room_groups.items()):
                    room_type = '–°—Ç—É–¥–∏—è' if rooms == 0 else f'{rooms}-–∫–æ–º–Ω.'
                    room_data = type('obj', (object,), {
                        'room_type': room_type,
                        'count': len(props),
                        'price_from': min(p.price for p in props if p.price),
                        'price_to': max(p.price for p in props if p.price),
                        'area_from': min(p.area for p in props if p.area),
                        'area_to': max(p.area for p in props if p.area),
                        '_mapping': {
                            'room_type': room_type,
                            'count': len(props),
                            'price_from': min(p.price for p in props if p.price),
                            'price_to': max(p.price for p in props if p.price),
                            'area_from': min(p.area for p in props if p.area),
                            'area_to': max(p.area for p in props if p.area)
                        }
                    })()
                    room_distribution_query.append(room_data)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –æ –∫–æ–º–Ω–∞—Ç–Ω–æ—Å—Ç–∏
            real_room_distribution = {}
            room_details = {}
            
            for room_row in room_distribution_query:
                room_data = dict(room_row._mapping)
                room_type = room_data['room_type']
                real_room_distribution[room_type] = room_data['count']
                room_details[room_type] = {
                    'price_from': room_data['price_from'],
                    'price_to': room_data['price_to'],
                    'area_from': room_data['area_from'],
                    'area_to': room_data['area_to']
                }
            
            complex_dict['real_room_distribution'] = real_room_distribution
            complex_dict['room_details'] = room_details
            developer_complexes.append(complex_dict)
        
        # ‚úÖ MIGRATED: Get developer's properties from normalized tables
        developer_properties_orm = PropertyRepository.get_all_active(
            limit=10000,
            filters={'developer_id': developer.id},
            sort_by='price',
            sort_order='asc'
        )
        
        # Convert to old format for backward compatibility
        developer_properties = []
        for prop in developer_properties_orm:
            complex_obj = prop.residential_complex
            district_obj = prop.district
            
            # Format floor display properly: "X —ç—Ç–∞–∂ –∏–∑ Y" or "–≠—Ç–∞–∂ –Ω–µ —É–∫–∞–∑–∞–Ω"
            if prop.floor and prop.total_floors:
                floor_display = f"{prop.floor} —ç—Ç–∞–∂ –∏–∑ {prop.total_floors}"
            elif prop.total_floors:
                floor_display = f"–≠—Ç–∞–∂ –Ω–µ —É–∫–∞–∑–∞–Ω –∏–∑ {prop.total_floors}"
            else:
                floor_display = "–≠—Ç–∞–∂ –Ω–µ —É–∫–∞–∑–∞–Ω"
            
            prop_dict = {
                'inner_id': prop.inner_id,
                'price': prop.price,
                'object_area': prop.area,
                'object_rooms': prop.rooms,
                'object_min_floor': prop.floor,
                'object_max_floor': prop.total_floors,
                'floor_display': floor_display,  # New formatted field
                'complex_name': complex_obj.name if complex_obj else '',
                'developer_name': developer.name,
                'address_display_name': prop.address,
                'parsed_district': district_obj.name if district_obj else '',
                'photos': prop.gallery_images or '[]'
            }
            developer_properties.append(prop_dict)
        
        properties_count = len(developer_properties)
        min_price = min([p['price'] for p in developer_properties]) if developer_properties else 0
        
        # Parse features, infrastructure, and advantages if they exist
        import json as json_lib
        features = []
        infrastructure = []
        advantages = []
        
        if developer_dict.get('features'):
            try:
                features = json_lib.loads(developer_dict['features'])
            except:
                features = []
        
        if developer_dict.get('infrastructure'):
            try:
                infrastructure = json_lib.loads(developer_dict['infrastructure'])
            except:
                infrastructure = []
        
        if developer_dict.get('advantages'):
            try:
                advantages = json_lib.loads(developer_dict['advantages'])
            except:
                advantages = []
        
        # ‚úÖ MIGRATED: Get statistics from normalized tables (properties + residential_complexes)
        from models import Property
        from sqlalchemy import func
        
        developer_stats = db.session.query(
            func.count(Property.id).label('total_properties'),
            func.avg(Property.price).label('avg_price'),
            func.min(Property.price).label('min_price'),
            func.max(Property.price).label('max_price'),
            func.count(func.distinct(Property.complex_id)).label('total_complexes')
        ).filter(
            Property.developer_id == developer.id,
            Property.is_active == True
        ).first()
        
        # Update statistics with real data from properties table
        if developer_stats and developer_stats.total_properties:
            developer_dict['properties_count'] = developer_stats.total_properties
            developer_dict['complexes_count'] = developer_stats.total_complexes
            developer_dict['min_price'] = int(developer_stats.min_price) if developer_stats.min_price else 12000000
            developer_dict['max_price'] = int(developer_stats.max_price) if developer_stats.max_price else 0
            developer_dict['avg_price'] = int(developer_stats.avg_price) if developer_stats.avg_price else 0
            print(f"DEBUG: Normalized stats for {developer.name}: min_price={developer_stats.min_price}, total_props={developer_stats.total_properties}")
        else:
            print(f"DEBUG: No properties found for {developer.name}")
        
        # –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –ø–æ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å
        developer_dict['total_projects'] = developer_dict.get('completed_projects', 0) or developer_dict.get('complexes_count', 0)
        developer_dict['rating'] = developer_dict.get('rating') or 4.2
        developer_dict['founded_year'] = developer_dict.get('founded_year') or developer_dict.get('established_year') or 2015
        developer_dict['detailed_description'] = developer_dict.get('description') or '–ù–∞–¥—ë–∂–Ω—ã–π –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫ —Å –º–Ω–æ–≥–æ–ª–µ—Ç–Ω–∏–º –æ–ø—ã—Ç–æ–º —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∂–∏–ª—å—è –≤ —Ä–µ–≥–∏–æ–Ω–µ.'
        developer_dict['description'] = developer_dict.get('description') or developer_dict['detailed_description']
        developer_dict['logo'] = developer_dict.get('logo_url')  # Add logo field
        developer_dict['short_name'] = developer_dict.get('name', '')[:2].upper()  # First 2 letters for fallback logo
        
        # Use advantages from DB if exists, otherwise use defaults
        if not advantages:
            advantages = [
                '–°–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ –±–µ–∑ —Å—É–±–ø–æ–¥—Ä—è–¥–∞',
                '–°–¥–∞—á–∞ –æ–±—ä–µ–∫—Ç–æ–≤ —Ç–æ—á–Ω–æ –≤ —Å—Ä–æ–∫', 
                '–ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã –∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏',
                '–ü–æ–ª–Ω—ã–π –ø–∞–∫–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –∏ —Å–µ—Ä–≤–∏—Å–æ–≤'
            ]
        developer_dict['advantages'] = advantages
        
        return render_template('developer_detail.html', 
                             developer=developer_dict,
                             developer_name=developer_dict['name'],
                             complexes=developer_complexes,
                             apartments=developer_properties,
                             total_properties=properties_count,
                             min_price=min_price,
                             features=features,
                             infrastructure=infrastructure)
        
    except Exception as e:
        print(f"Error loading developer page for {developer_slug}: {e}")
        import traceback
        traceback.print_exc()
        return redirect(url_for('developers'))

# Districts routes
@app.route('/districts')
def districts():
    """Districts listing page - load 52 Krasnodar districts from JSON with full data"""
    import json
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º 52 —Ä–∞–π–æ–Ω–∞ –∏–∑ JSON —Ñ–∞–π–ª–∞ —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ –∏ –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
    districts_list = []
    try:
        json_path = os.path.join(os.path.dirname(__file__), 'data', 'seo_districts.json')
        if os.path.exists(json_path):
            with open(json_path, 'r', encoding='utf-8') as f:
                seo_districts = json.load(f)
            
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç –¥–ª—è —à–∞–±–ª–æ–Ω–∞ —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
            for idx, d in enumerate(seo_districts):
                districts_list.append({
                    'id': idx + 1,
                    'name': d['name'],
                    'slug': d['slug'],
                    'description': f"–ö–≤–∞—Ä—Ç–∏—Ä—ã –≤ —Ä–∞–π–æ–Ω–µ {d['name']} –≤ –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–µ —Å –∫—ç—à–±—ç–∫–æ–º",
                    'latitude': d.get('latitude'),
                    'longitude': d.get('longitude'),
                    'distance_to_center': d.get('distance_to_center'),
                    'infrastructure_data': {
                        'education_count': d.get('education_count'),
                        'medical_count': d.get('medical_count'),
                        'shopping_count': d.get('shopping_count'),
                        'finance_count': d.get('finance_count'),
                        'leisure_count': d.get('leisure_count'),
                        'transport_count': d.get('transport_count'),
                        'distance_to_center': d.get('distance_to_center')
                    }
                })
    except Exception as e:
        print(f"Error loading districts from JSON: {e}")
    
    return render_template('districts.html', 
                         districts=districts_list,
                         yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY'))

# ========================================
# –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–ò–í–ù–ê–Ø –ü–ê–ù–ï–õ–¨ –î–õ–Ø –ö–û–û–†–î–ò–ù–ê–¢
# ========================================

@app.route('/admin/coordinates')
def admin_coordinates():
    """–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–∏–≤–Ω–∞—è –ø–∞–Ω–µ–ª—å –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Ä–∞–π–æ–Ω–æ–≤"""
    from models import District
    
    # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ä–∞–π–æ–Ω—ã
    districts = District.query.order_by(District.name).all()
    
    return render_template('admin/coordinates.html', 
                         districts=districts,
                         yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY'))

@app.route('/admin/update-coordinates', methods=['POST'])
def admin_update_coordinates():
    """API –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Ä–∞–π–æ–Ω–∞"""
    from models import District
    import math
    
    try:
        district_id = request.form.get('district_id')
        latitude = float(request.form.get('latitude'))
        longitude = float(request.form.get('longitude'))
        
        # –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Ü–µ–Ω—Ç—Ä–∞
        theater_lat, theater_lon = 45.035180, 38.977414
        
        def haversine_distance(lat1, lon1, lat2, lon2):
            R = 6371
            dlat = math.radians(lat2 - lat1)
            dlon = math.radians(lon2 - lon1)
            a = math.sin(dlat/2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon/2)**2
            c = 2 * math.asin(math.sqrt(a))
            return R * c
        
        distance = haversine_distance(latitude, longitude, theater_lat, theater_lon)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        district = District.query.get(district_id)
        if district:
            district.latitude = latitude
            district.longitude = longitude
            district.distance_to_center = distance
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': f'–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ä–∞–π–æ–Ω–∞ {district.name} –æ–±–Ω–æ–≤–ª–µ–Ω—ã',
                'distance': round(distance, 1)
            })
        else:
            return jsonify({'success': False, 'message': '–†–∞–π–æ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω'})
            
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)})

# ========================================
# –ê–õ–ò–ê–°–´ –î–õ–Ø –°–¢–ê–†–´–• URL –†–ê–ô–û–ù–û–í
# ========================================

@app.route('/district/tec')
def district_tec_redirect():
    """–†–µ–¥–∏—Ä–µ–∫—Ç —Å–æ —Å—Ç–∞—Ä–æ–≥–æ URL –¢–≠–¶ –Ω–∞ –Ω–æ–≤—ã–π"""
    from flask import redirect, url_for
    return redirect(url_for('district_detail', district='tets'), code=301)

@app.route('/district/mkg')
def district_mkg_redirect():
    """–†–µ–¥–∏—Ä–µ–∫—Ç —Å–æ —Å—Ç–∞—Ä–æ–≥–æ URL –ú–ö–ì (–ú–•–ì) –Ω–∞ –Ω–æ–≤—ã–π"""
    from flask import redirect, url_for
    return redirect(url_for('district_detail', district='mhg'), code=301)

@app.route('/district/skhi')
def district_skhi_redirect():
    """–†–µ–¥–∏—Ä–µ–∫—Ç –¥–ª—è –°–•–ò (–°–µ–ª—å—Å–∫–æ—Ö–æ–∑—è–π—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Å—Ç–∏—Ç—É—Ç)"""
    from flask import redirect, url_for
    return redirect(url_for('district_detail', district='shi'), code=301)

@app.route('/district/<district>')
def district_detail(district):
    """Individual district page - —Ç–æ–ª—å–∫–æ –¥–ª—è –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞ (SEO)"""
    try:
        # Resolve city context
        current_city = resolve_city_context(
            city_id=request.args.get('city_id'),
            city_slug=request.args.get('city')
        )
        
        # –≠—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞ (—Å–æ–∑–¥–∞–Ω–∞ –¥–ª—è SEO)
        # –î–∞–Ω–Ω—ã–µ –ø–æ–∫–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–∞
        if not current_city or current_city.slug != 'krasnodar':
            # –î–ª—è –¥—Ä—É–≥–∏—Ö –≥–æ—Ä–æ–¥–æ–≤ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—É—Å—Ç—É—é –∑–∞–≥–ª—É—à–∫—É
            return render_template('district_detail.html', 
                                 current_city=current_city,
                                 district='',
                                 district_name='',
                                 properties=[],
                                 complexes=[],
                                 empty_state=True)
        
        # Import District model
        from models import District
        
        # Get properties and complexes in this district
        properties = load_properties()
        complexes = load_residential_complexes()
        
        # Filter by district (simplified district matching)
        district_properties = [p for p in properties if district.replace('-', ' ').lower() in (p.get('address') or '').lower()]
        district_complexes = [c for c in complexes if district.replace('-', ' ').lower() in c.get('district', '').lower()]
        
        # Add cashback calculations
        for prop in district_properties:
            prop['cashback'] = calculate_cashback(
                prop['price'],
                complex_id=prop.get('complex_id'),
                complex_name=prop.get('residential_complex')
            )
        
        # District info mapping - all 54 districts
        district_names = {
            '40-let-pobedy': '40 –ª–µ—Ç –ü–æ–±–µ–¥—ã',
            '9i-kilometr': '9-–π –∫–∏–ª–æ–º–µ—Ç—Ä', 
            'aviagorodok': '–ê–≤–∏–∞–≥–æ—Ä–æ–¥–æ–∫',
            'avrora': '–ê–≤—Ä–æ—Ä–∞',
            'basket-hall': '–ë–∞—Å–∫–µ—Ç-—Ö–æ–ª–ª',
            'berezovy': '–ë–µ—Ä–µ–∑–æ–≤—ã–π',
            'cheremushki': '–ß–µ—Ä–µ–º—É—à–∫–∏',
            'dubinka': '–î—É–±–∏–Ω–∫–∞',
            'enka': '–≠–Ω–∫–∞',
            'festivalny': '–§–µ—Å—Ç–∏–≤–∞–ª—å–Ω—ã–π',
            'gidrostroitelei': '–ì–∏–¥—Ä–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª–µ–π',
            'gorkhutor': '–ì–æ—Ä—Ö—É—Ç–æ—Ä',
            'hbk': '–•–ë–ö',
            'kalinino': '–ö–∞–ª–∏–Ω–∏–Ω–æ',
            'karasunsky': '–ö–∞—Ä–∞—Å—É–Ω—Å–∫–∏–π',
            'kolosisty': '–ö–æ–ª–æ—Å–∏—Å—Ç—ã–π',
            'komsomolsky': '–ö–æ–º—Å–æ–º–æ–ª—å—Å–∫–∏–π',
            'kozhzavod': '–ö–æ–∂–∑–∞–≤–æ–¥',
            'krasnaya-ploshchad': '–ö—Ä–∞—Å–Ω–∞—è –ø–ª–æ—â–∞–¥—å',
            'krasnodarskiy': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π',
            'kubansky': '–ö—É–±–∞–Ω—Å–∫–∏–π',
            'mkg': '–ú–ö–ì',
            'molodezhny': '–ú–æ–ª–æ–¥–µ–∂–Ω—ã–π',
            'muzykalny-mkr': '–ú—É–∑—ã–∫–∞–ª—å–Ω—ã–π –º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω',
            'nemetskaya-derevnya': '–ù–µ–º–µ—Ü–∫–∞—è –¥–µ—Ä–µ–≤–Ω—è',
            'novoznamenskiy': '–ù–æ–≤–æ–∑–Ω–∞–º–µ–Ω—Å–∫–∏–π',
            'panorama': '–ü–∞–Ω–æ—Ä–∞–º–∞',
            'pashkovskiy': '–ü–∞—à–∫–æ–≤—Å–∫–∏–π',
            'pashkovsky': '–ü–∞—à–∫–æ–≤—Å–∫–∏–π-2',
            'pokrovka': '–ü–æ–∫—Ä–æ–≤–∫–∞',
            'prikubansky': '–ü—Ä–∏–∫—É–±–∞–Ω—Å–∫–∏–π',
            'rayon-aeroporta': '–†–∞–π–æ–Ω –∞—ç—Ä–æ–ø–æ—Ä—Ç–∞',
            'repino': '–†–µ–ø–∏–Ω–æ',
            'rip': '–†–ò–ü',
            'severny': '–°–µ–≤–µ—Ä–Ω—ã–π',
            'shkolny': '–®–∫–æ–ª—å–Ω—ã–π',
            'slavyansky': '–°–ª–∞–≤—è–Ω—Å–∫–∏–π',
            'slavyansky2': '–°–ª–∞–≤—è–Ω—Å–∫–∏–π-2',
            'solnechny': '–°–æ–ª–Ω–µ—á–Ω—ã–π',
            'tabachnaya-fabrika': '–¢–∞–±–∞—á–Ω–∞—è —Ñ–∞–±—Ä–∏–∫–∞',
            'tec': '–¢–≠–¶',
            'tsentralnyy': '–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π',
            'uchhoz-kuban': '–£—á—Ö–æ–∑ –ö—É–±–∞–Ω—å',
            'vavilova': '–í–∞–≤–∏–ª–æ–≤–∞',
            'votochno-kruglikovskii': '–í–æ—Å—Ç–æ—á–Ω–æ-–ö—Ä—É–≥–ª–∏–∫–æ–≤—Å–∫–∏–π',
            'yablonovskiy': '–Ø–±–ª–æ–Ω–æ–≤—Å–∫–∏–π',
            'zapadny': '–ó–∞–ø–∞–¥–Ω—ã–π',
            'zapadny-obhod': '–ó–∞–ø–∞–¥–Ω—ã–π –æ–±—Ö–æ–¥',
            'zapadny-okrug': '–ó–∞–ø–∞–¥–Ω—ã–π –æ–∫—Ä—É–≥',
            'zip-zhukova': '–ó–ò–ü –ñ—É–∫–æ–≤–∞'
        }
        
        # Get district data from database with coordinates
        district_db = District.query.filter_by(slug=district).first()
        
        # Use district name from database if available, otherwise fallback to mapping
        if district_db and district_db.name:
            district_name = district_db.name
        else:
            district_name = district_names.get(district, district.replace('-', ' ').title())
        
        # Load district data from JSON file (with SEO descriptions, coordinates, infrastructure)
        import json
        seo_district_data = None
        try:
            json_path = os.path.join(os.path.dirname(__file__), 'data', 'seo_districts.json')
            if os.path.exists(json_path):
                with open(json_path, 'r', encoding='utf-8') as f:
                    seo_districts = json.load(f)
                    for d in seo_districts:
                        if d['slug'] == district:
                            seo_district_data = d
                            break
        except Exception as e:
            print(f"Error loading SEO district data: {e}")
        
        # Prepare district data for template
        infrastructure_data = None
        
        # First try to get from JSON file
        if seo_district_data:
            infrastructure_data = {
                'education_count': seo_district_data.get('education_count'),
                'medical_count': seo_district_data.get('medical_count'),
                'shopping_count': seo_district_data.get('shopping_count'),
                'finance_count': seo_district_data.get('finance_count'),
                'leisure_count': seo_district_data.get('leisure_count'),
                'transport_count': seo_district_data.get('transport_count'),
                'distance_to_center': seo_district_data.get('distance_to_center')
            }
        # Fallback to database
        elif district_db and district_db.infrastructure_data:
            try:
                if isinstance(district_db.infrastructure_data, str):
                    infrastructure_data = json.loads(district_db.infrastructure_data)
                else:
                    infrastructure_data = district_db.infrastructure_data
            except Exception as e:
                print(f"Infrastructure parsing error: {e}")
                infrastructure_data = None
        
        # Use SEO district data for coordinates if available
        district_lat = None
        district_lng = None
        if seo_district_data:
            district_lat = seo_district_data.get('latitude')
            district_lng = seo_district_data.get('longitude')
        if not district_lat and district_db:
            district_lat = district_db.latitude
            district_lng = district_db.longitude
        
        district_data = {
            'name': district_name,
            'slug': district,
            'latitude': district_lat,
            'longitude': district_lng,
            'zoom_level': district_db.zoom_level if district_db and district_db.zoom_level else 13,
            'description': district_db.description if district_db else None,
            'seo_description': seo_district_data.get('seo_description') if seo_district_data else None,
            'distance_to_center': seo_district_data.get('distance_to_center') if seo_district_data else (getattr(district_db, 'distance_to_center', None) if district_db else None),
            'infrastructure_data': infrastructure_data,
            'geometry': getattr(district_db, 'geometry', None) if district_db else None,
            'geometry_source': getattr(district_db, 'geometry_source', None) if district_db else None
        }
        
        return render_template('district_detail.html', 
                             district=district,
                             district_name=district_name,
                             district_data=district_data,
                             properties=district_properties,
                             complexes=district_complexes,
                             yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
    except Exception as e:
        # Log detailed error for debugging
        import traceback
        print(f"ERROR in district_detail route: {e}")
        print("Full traceback:")
        traceback.print_exc()
        
        # Return error page
        from flask import render_template_string
        error_template = """
        <html>
        <head><title>–û—à–∏–±–∫–∞ - InBack.ru</title></head>
        <body>
            <h1>–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞</h1>
            <p>–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É —Ä–∞–π–æ–Ω–∞ {{ district }}.</p>
            <p>–û—à–∏–±–∫–∞: {{ error }}</p>
            <a href="/">–í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –≥–ª–∞–≤–Ω—É—é</a>
        </body>
        </html>
        """
        return render_template_string(error_template, district=district, error=str(e)), 500


# Content pages routes are already defined above

# API endpoint for infrastructure data
@app.route('/api/infrastructure')
def get_infrastructure():
    """API endpoint to get infrastructure data for coordinates"""
    try:
        lat = request.args.get('lat', type=float)
        lng = request.args.get('lng', type=float)
        radius = request.args.get('radius', 2000, type=int)
        
        if not lat or not lng:
            return jsonify({'error': 'Coordinates required'}), 400
        
        # Import infrastructure functions
        from infrastructure_api import get_poi_around_coordinates
        
        # Get POI data
        poi_data = get_poi_around_coordinates(lat, lng, radius)
        
        return jsonify(poi_data)
        
    except Exception as e:
        print(f"Error getting infrastructure data: {e}")
        return jsonify({'error': 'Failed to get infrastructure data'}), 500

# API endpoint for district streets
@app.route('/api/streets/district/<district_slug>')
def get_district_streets(district_slug):
    """API endpoint to get streets for a specific district"""
    try:
        from models import Street, District
        
        # –ü–æ–ª—É—á–∞–µ–º —Ä–∞–π–æ–Ω –ø–æ slug
        district = District.query.filter_by(slug=district_slug).first()
        if not district:
            return jsonify({'error': 'District not found'}), 404
        
        # –ü–æ–ª—É—á–∞–µ–º —É–ª–∏—Ü—ã —Ä–∞–π–æ–Ω–∞ —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
        streets = Street.query.filter_by(district_id=district.id).filter(
            Street.latitude.isnot(None),
            Street.longitude.isnot(None)
        ).all()
        
        streets_data = []
        for street in streets:
            streets_data.append({
                'id': street.id,
                'name': street.name,
                'slug': street.slug,
                'latitude': float(street.latitude) if street.latitude else None,
                'longitude': float(street.longitude) if street.longitude else None,
                'description': street.description
            })
        
        return jsonify(streets_data)
        
    except Exception as e:
        print(f"Error getting district streets: {e}")
        return jsonify({'error': 'Failed to get district streets'}), 500

# Privacy and legal pages
@app.route('/legal')
def legal_index():
    """Legal documents hub page"""
    return render_template('legal/index.html')

@app.route('/privacy-policy')
def privacy_policy():
    """Privacy policy page"""
    return render_template('privacy_policy.html')

@app.route('/user-agreement')
def user_agreement():
    """User agreement page"""
    return render_template('legal/user_agreement.html')

@app.route('/cookie-policy')
def cookie_policy():
    """Cookie policy page"""
    return render_template('legal/cookie_policy.html')

@app.route('/consent/registration')
def consent_registration():
    """Consent for registration"""
    return render_template('legal/consent_registration.html')

@app.route('/consent/cashback')
def consent_cashback():
    """Consent for cashback"""
    return render_template('legal/consent_cashback.html')

@app.route('/consent/marketing')
def consent_marketing():
    """Consent for marketing"""
    return render_template('legal/consent_marketing.html')

@app.route('/consent/callback')
def consent_callback():
    """Consent for callback"""
    return render_template('legal/consent_callback.html')

@app.route('/consent/cookies')
def consent_cookies():
    """Consent for cookies"""
    return render_template('legal/consent_cookies.html')

# Duplicate removed
# @app.route('/cookie-policy')
def cookie_policy():
    """Cookie policy page"""
    return render_template('legal/cookie_policy.html')

def parse_user_agent(user_agent):
    """–ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–∏–Ω–≥ User-Agent —Å—Ç—Ä–æ–∫–∏"""
    info = {
        'raw': user_agent,
        'browser': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
        'version': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
        'os': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
        'device': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
    }
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –±—Ä–∞—É–∑–µ—Ä
    if 'Chrome' in user_agent and 'Edg' not in user_agent:
        info['browser'] = 'Chrome'
        if 'Chrome/' in user_agent:
            version = user_agent.split('Chrome/')[1].split()[0]
            info['version'] = version
    elif 'Firefox' in user_agent:
        info['browser'] = 'Firefox'
        if 'Firefox/' in user_agent:
            version = user_agent.split('Firefox/')[1].split()[0]
            info['version'] = version
    elif 'Edg' in user_agent:
        info['browser'] = 'Microsoft Edge'
        if 'Edg/' in user_agent:
            version = user_agent.split('Edg/')[1].split()[0]
            info['version'] = version
    elif 'Safari' in user_agent and 'Chrome' not in user_agent:
        info['browser'] = 'Safari'
        if 'Version/' in user_agent:
            version = user_agent.split('Version/')[1].split()[0]
            info['version'] = version
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –û–°
    if 'Windows NT' in user_agent:
        info['os'] = 'Windows'
        if 'Windows NT 10.0' in user_agent:
            info['os'] = 'Windows 10/11'
    elif 'Mac OS X' in user_agent:
        info['os'] = 'macOS'
    elif 'Linux' in user_agent:
        info['os'] = 'Linux'
    elif 'Android' in user_agent:
        info['os'] = 'Android'
    elif 'iPhone' in user_agent:
        info['os'] = 'iOS'
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
    if 'Mobile' in user_agent or 'Android' in user_agent or 'iPhone' in user_agent:
        info['device'] = '–ú–æ–±–∏–ª—å–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ'
    elif 'Tablet' in user_agent or 'iPad' in user_agent:
        info['device'] = '–ü–ª–∞–Ω—à–µ—Ç'
    else:
        info['device'] = '–î–µ—Å–∫—Ç–æ–ø'
    
    return info

@app.route('/technical-info')
def technical_info():
    """–°—Ç—Ä–∞–Ω–∏—Ü–∞ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ —Å –¥–∞–Ω–Ω—ã–º–∏ –æ —Å–µ—Å—Å–∏–∏ –∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ"""
    import platform
    import socket
    import uuid
    import secrets
    from datetime import datetime
    from flask_login import current_user
    
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º session_id –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
    if 'session_id' not in session:
        session['session_id'] = secrets.token_hex(16)
    
    # –ü–∞—Ä—Å–∏–º User-Agent –¥–ª—è –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    user_agent = request.headers.get('User-Agent', '')
    browser_info = parse_user_agent(user_agent)
    
    # –°–æ–±–∏—Ä–∞–µ–º —Ç–µ—Ö–Ω–∏—á–µ—Å–∫—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
    tech_info = {
        'server_info': {
            'server_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'platform': platform.platform(),
            'python_version': platform.python_version(),
            'hostname': socket.gethostname(),
            'flask_version': '2.3.3',  # –∏–ª–∏ –ø–æ–ª—É—á–∏—Ç—å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
            'environment': 'development'
        },
        'session_info': {
            'session_id': session.get('session_id'),
            'user_id': current_user.id if current_user.is_authenticated else '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω',
            'username': current_user.full_name if current_user.is_authenticated and hasattr(current_user, 'full_name') else '–ì–æ—Å—Ç—å',
            'is_authenticated': current_user.is_authenticated,
            'session_permanent': session.permanent
        },
        'request_info': {
            'user_agent': user_agent,
            'ip_address': request.environ.get('HTTP_X_FORWARDED_FOR', request.remote_addr),
            'method': request.method,
            'url': request.url,
            'referrer': request.headers.get('Referer', '–ü—Ä—è–º–æ–π –ø–µ—Ä–µ—Ö–æ–¥'),
            'accept_language': request.headers.get('Accept-Language', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'),
            'accept_encoding': request.headers.get('Accept-Encoding', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'),
            'content_type': request.headers.get('Content-Type', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'),
            'host': request.headers.get('Host', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')
        },
        'browser_info': browser_info
    }
    
    return render_template('technical_info.html', tech_info=tech_info)

@app.route('/data-processing-consent')
def data_processing_consent():
    """Data processing consent page"""
    return render_template('data_processing_consent.html')

# Override Flask-Login unauthorized handler for API routes
@login_manager.unauthorized_handler  
def handle_unauthorized():
    # Check if this is an API route
    if request.path.startswith('/api/'):
        return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    # Regular redirect for web routes
    return redirect(url_for('login', next=request.url))

# User loader for Flask-Login - OPTIMIZED with request-scoped caching
@login_manager.user_loader
def load_user(user_id):
    """OPTIMIZED: Request-scoped caching to prevent repeated DB queries"""
    from models import User, Manager, Admin
    
    # Request-scoped caching using Flask's g object
    cache_key = f'_user_cache_{user_id}'
    if hasattr(g, cache_key):
        return getattr(g, cache_key)
    
    user = None
    
    # Check prefix to determine user type
    if user_id.startswith('m_'):
        manager_id = int(user_id[2:])
        user = Manager.query.get(manager_id)
    elif user_id.startswith('a_'):
        admin_id = int(user_id[2:])
        user = Admin.query.get(admin_id)
    elif user_id.startswith('p_'):
        from models import Partner
        partner_id = int(user_id[2:])
        user = Partner.query.get(partner_id)
    else:
        # Regular user
        try:
            user_id_int = int(user_id)
            user = User.query.get(user_id_int)
        except (ValueError, TypeError):
            pass
    
    # Cache result in request context (even if None)
    setattr(g, cache_key, user)
    return user


@app.before_request
def cleanup_invalid_sessions():
    """–û—á–∏—â–∞–µ—Ç —Å–µ—Å—Å–∏–∏ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π - –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑ –≤ 10 –º–∏–Ω—É—Ç"""
    import time
    if '_user_id' in session:
        user_id = session.get('_user_id')
        if not user_id:
            return
        
        last_check = session.get('_session_validated', 0)
        now = time.time()
        if now - last_check < 600:
            return
        
        from models import User, Manager, Admin
        user_exists = False
        
        try:
            if isinstance(user_id, str):
                if user_id.startswith('m_'):
                    manager_id = int(user_id[2:])
                    user_exists = Manager.query.get(manager_id) is not None
                elif user_id.startswith('a_'):
                    admin_id = int(user_id[2:])
                    user_exists = Admin.query.get(admin_id) is not None
                else:
                    user_exists = User.query.get(int(user_id)) is not None
            else:
                user_exists = User.query.get(int(user_id)) is not None
        except (ValueError, TypeError):
            user_exists = False
        except Exception as e:
            print(f"‚ö†Ô∏è CLEANUP: DB error checking user {user_id}, keeping session: {e}")
            return
        
        if user_exists:
            session['_session_validated'] = now
        else:
            print(f"üßπ CLEANUP: Clearing invalid session for user_id: {user_id}")
            session.clear()
            logout_user()


@app.context_processor
def inject_user_role():
    """Inject user role information into all templates"""
    from models import Manager, Admin
    # Safe check: current_user might be None in background threads
    is_manager = isinstance(current_user._get_current_object(), Manager) if current_user and current_user.is_authenticated else False
    is_admin = isinstance(current_user._get_current_object(), Admin) if current_user and current_user.is_authenticated else False
    return dict(
        is_manager=is_manager,
        is_admin=is_admin,
        manager_authenticated=is_manager,
        admin_authenticated=is_admin
    )




# SEO Footer context processor - load from JSON files for performance
_seo_cache = {
    'streets': None,
    'districts': None,
    'loaded': False
}

@app.context_processor
def inject_seo_footer_data():
    """Inject SEO footer data (streets and districts) for Krasnodar - loads from JSON files"""
    import json
    import os
    
    # Check if we need current_city context
    try:
        current_city = getattr(g, 'current_city', None)
        if not current_city or current_city.slug != 'krasnodar':
            return dict(seo_streets=[], seo_districts=[])
    except:
        return dict(seo_streets=[], seo_districts=[])
    
    # Load from cache if available
    if _seo_cache['loaded']:
        return dict(
            seo_streets=_seo_cache['streets'],
            seo_districts=_seo_cache['districts']
        )
    
    try:
        base_path = os.path.dirname(__file__)
        
        # Load streets from JSON file (1600 streets)
        streets_path = os.path.join(base_path, 'data', 'seo_streets.json')
        if os.path.exists(streets_path):
            with open(streets_path, 'r', encoding='utf-8') as f:
                streets = json.load(f)
        else:
            streets = []
        
        # Load districts from JSON file (52 districts/microdistricts)
        districts_path = os.path.join(base_path, 'data', 'seo_districts.json')
        if os.path.exists(districts_path):
            with open(districts_path, 'r', encoding='utf-8') as f:
                districts = json.load(f)
        else:
            districts = []
        
        # Update cache
        _seo_cache['streets'] = streets
        _seo_cache['districts'] = districts
        _seo_cache['loaded'] = True
        
        return dict(seo_streets=streets, seo_districts=districts)
    except Exception as e:
        print(f"Error loading SEO footer data: {e}")
        return dict(seo_streets=[], seo_districts=[])



def manager_required(f):
    """Decorator to require manager authentication - –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Flask-Login"""
    from functools import wraps
    from models import Manager
    
    @wraps(f)
    def decorated_function(*args, **kwargs):
        print(f"DEBUG: manager_required - checking Flask-Login authentication")
        print(f"DEBUG: manager_required - request.path: {request.path}")
        print(f"DEBUG: manager_required - request.method: {request.method}")
        print(f"DEBUG: manager_required - current_user.is_authenticated: {current_user.is_authenticated}")
        
        # Check if this is an AJAX or JSON request
        is_ajax = (request.headers.get('X-Requested-With') == 'XMLHttpRequest' or 
                   request.content_type == 'application/json' or
                   request.path.startswith('/api/'))
        
        # Check if manager is authenticated via Flask-Login
        if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
            print(f"DEBUG: manager_required - Manager not authenticated via Flask-Login")
            if is_ajax:
                return jsonify({'success': False, 'error': 'Authentication required'}), 401
            return redirect(url_for('manager_login'))
        
        print(f"DEBUG: manager_required - Success! Manager {current_user.email} authenticated via Flask-Login")
        return f(*args, **kwargs)
    return decorated_function

# Authentication routes
@app.route('/set-demo-password')
def set_demo_password():
    """–í—Ä–µ–º–µ–Ω–Ω—ã–π —Ä–æ—É—Ç –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–∞—Ä–æ–ª—è –¥–µ–º–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
    from models import User
    from werkzeug.security import generate_password_hash
    
    # –ù–∞–π—Ç–∏ –¥–µ–º–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    demo_user = User.query.filter_by(email='demo@inback.ru').first()
    if demo_user:
        # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Å—Ç–æ–π –ø–∞—Ä–æ–ª—å "demo123"
        demo_user.password_hash = generate_password_hash('demo123')
        db.session.commit()
        return f"–ü–∞—Ä–æ–ª—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {demo_user.email}. –•—ç—à: {demo_user.password_hash[:50]}..."
    else:
        return "–î–µ–º–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω"

@app.route('/set-managers-passwords')
def set_managers_passwords():
    """–í—Ä–µ–º–µ–Ω–Ω—ã–π —Ä–æ—É—Ç –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–∞—Ä–æ–ª–µ–π –≤—Å–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä–∞–º"""
    from models import Manager
    from werkzeug.security import generate_password_hash
    
    results = []
    
    # –ù–∞–π—Ç–∏ –≤—Å–µ—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Å—Ç—ã–µ –ø–∞—Ä–æ–ª–∏
    managers = Manager.query.all()
    for manager in managers:
        if 'anna' in manager.email.lower():
            password = 'anna123'
        elif 'sergey' in manager.email.lower():
            password = 'sergey123'  
        elif 'maria' in manager.email.lower():
            password = 'maria123'
        else:
            password = 'manager123'  # –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤
            
        manager.password_hash = generate_password_hash(password)
        results.append(f"{manager.email} -> {password}")
    
    db.session.commit()
    return f"–ü–∞—Ä–æ–ª–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è {len(managers)} –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤:<br>" + "<br>".join(results)

@app.route('/login', methods=['GET', 'POST'])
@csrf.exempt
def login():
    """Login page - Phone + Password authentication"""
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    
    if current_user.is_authenticated:
        if is_ajax:
            return jsonify({'success': True, 'redirect': url_for('dashboard')})
        return redirect(url_for('dashboard'))
    
    ref_code = request.args.get('ref')
    if ref_code:
        session['referral_code'] = ref_code
    
    if request.method == 'POST':
        from models import User
        import re
        
        phone = request.form.get('phone', '').strip()
        password = request.form.get('password')
        remember = request.form.get('remember') == 'on'
        
        if not phone or not password:
            if is_ajax:
                return jsonify({'success': False, 'message': '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è'})
            flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è', 'error')
            return render_template('auth/login.html')
        
        # Normalize phone number (remove all non-digits except +)
        phone_clean = re.sub(r'[^\d+]', '', phone)
        if phone_clean.startswith('8'):
            phone_clean = '+7' + phone_clean[1:]
        elif not phone_clean.startswith('+7'):
            phone_clean = '+7' + phone_clean
        
        # Validate phone format
        if len(phone_clean) != 12:
            if is_ajax:
                return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞'})
            flash('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞', 'error')
            return render_template('auth/login.html')
        
        # OPTIMIZED: Use SQL REPLACE to normalize phone (O(1) query instead of O(n) loop)
        # SECURITY FIX: Check user exists BEFORE password validation to prevent timing attacks
        phone_digits_only = phone_clean.replace("+", "").replace("-", "").replace(" ", "")
        user = User.query.filter(
            func.replace(func.replace(func.replace(User.phone, "-", ""), " ", ""), "+", "") == phone_digits_only
        ).first()
        
        # SECURITY: Reject non-existent users BEFORE checking password (prevent information leakage)
        if not user:
            if is_ajax:
                return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏–ª–∏ –ø–∞—Ä–æ–ª—å'})
            flash('–ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏–ª–∏ –ø–∞—Ä–æ–ª—å', 'error')
            return render_template('auth/login.html')
        
        # Check if user is blocked
        if not user.is_active:
            if is_ajax:
                return jsonify({'success': False, 'message': '–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ —Å–ª—É–∂–±—É –ø–æ–¥–¥–µ—Ä–∂–∫–∏.'})
            flash('–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ —Å–ª—É–∂–±—É –ø–æ–¥–¥–µ—Ä–∂–∫–∏.', 'error')
            return render_template('auth/login.html')

        # User exists - now check password
        password_valid = user.check_password(password)
        if not password_valid:
            if is_ajax:
                return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å'})
            flash('–ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏–ª–∏ –ø–∞—Ä–æ–ª—å', 'error')
            return render_template('auth/login.html')
        
        # Authentication successful
        # Clear manager session data if exists
        session.pop('manager_id', None)
        session.pop('is_manager', None)
        
        login_user(user, remember=remember)
        session.permanent = True  # Ensure 30-day session lifetime
        user.last_login = datetime.utcnow()
        user.last_ip = request.remote_addr
        user.last_user_agent = request.headers.get('User-Agent')
        db.session.commit()
        
        try:
            from services.guest_session import merge_guest_to_user
            merge_guest_to_user(user.id, db.session)
        except Exception as e:
            print(f'Guest merge error: {e}')
        
        # Redirect to next page or dashboard
        next_page = request.args.get('next')
        redirect_url = next_page if next_page else url_for('dashboard')
        
        if is_ajax:
            return jsonify({'success': True, 'redirect': redirect_url})
        return redirect(redirect_url)
    
    return render_template('auth/login.html')
@app.route('/setup-password', methods=['GET', 'POST'])
def setup_password():
    """Setup password for users created by managers"""
    temp_user_id = session.get('temp_user_id')
    if not temp_user_id:
        flash('–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞', 'error')
        return redirect(url_for('login'))
    
    from models import User
    user = User.query.get(temp_user_id)
    if not user or not user.needs_password_setup():
        flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω', 'error')
        return redirect(url_for('login'))
    
    if request.method == 'POST':
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')
        
        if not password or not confirm_password:
            flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è', 'error')
            return render_template('auth/setup_password.html', user=user)
        
        if len(password) < 8:
            flash('–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 8 —Å–∏–º–≤–æ–ª–æ–≤', 'error')
            return render_template('auth/setup_password.html', user=user)
        
        if password != confirm_password:
            flash('–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
            return render_template('auth/setup_password.html', user=user)
        
        # Set password
        user.set_password(password)
        user.is_verified = True
        db.session.commit()
        
        # Clear temp session and manager data
        session.pop('temp_user_id', None)
        session.pop('manager_id', None)
        session.pop('is_manager', None)
        
        # Login user
        login_user(user)
        session.permanent = True  # Ensure 30-day session lifetime
        user.last_login = datetime.utcnow()
        user.last_ip = request.remote_addr
        user.last_user_agent = request.headers.get('User-Agent')
        db.session.commit()
        
        try:
            from services.guest_session import merge_guest_to_user
            merge_guest_to_user(user.id, db.session)
        except Exception as e:
            print(f'Guest merge error: {e}')
        
        flash('–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!', 'success')
        return redirect(url_for('dashboard'))
    
    return render_template('auth/setup_password.html', user=user)

# ================================
# PHONE REGISTRATION ROUTES (Two-step)
# ================================

@app.route('/register', methods=['GET'])
def register():
    """Step 1: Phone registration page"""
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    
    # Clear any old registration session data to allow fresh start
    session.pop('registration_phone', None)
    session.pop('registration_user_id', None)
    session.pop('phone_verified', None)
    
    ref_code = request.args.get('ref')
    if ref_code:
        session['referral_code'] = ref_code
    
    return render_template('auth/register_phone.html')

@app.route('/api/check-phone', methods=['POST'])
@csrf.exempt
@require_json_csrf
def check_phone():
    """API endpoint to check if phone number exists in database"""
    try:
        data = request.get_json()
        phone = data.get('phone', '').strip()
        
        if not phone:
            return jsonify({"error": "–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω", "status": 400}), 400
        
        # Normalize phone number (remove all non-digits except +)
        import re
        phone_clean = re.sub(r'[^\d+]', '', phone)
        
        # Check if phone starts with +7 or 8
        if phone_clean.startswith('8'):
            phone_clean = '+7' + phone_clean[1:]
        elif not phone_clean.startswith('+7'):
            phone_clean = '+7' + phone_clean
        
        # Validate format: must be +7XXXXXXXXXX (12 characters)
        if len(phone_clean) != 12:
            return jsonify({"error": "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞", "status": 400}), 400
        
        # Check if user exists - normalize database phone for comparison
        from models import User
        from sqlalchemy import func
        
        # Search by normalized phone (remove all non-digits except +)
        # ‚úÖ OPTIMIZED: Use SQL REPLACE to normalize phone in database (O(1) query instead of O(n) loop)
        # Remove spaces, hyphens, and + from both sides for comparison
        phone_digits_only = phone_clean.replace("+", "").replace("-", "").replace(" ", "")
        user = User.query.filter(
            func.replace(func.replace(func.replace(User.phone, "-", ""), " ", ""), "+", "") == phone_digits_only
        ).first()
        
        return jsonify({
            "exists": user is not None,
            "phone": phone_clean,
            "status": 200
        }), 200
        
    except Exception as e:
        app.logger.error(f"Error checking phone: {e}")
        return jsonify({"error": "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞", "status": 500}), 500


@app.route('/register/send-code', methods=['POST'])
@csrf.exempt  # Allow JSON requests without CSRF token
def register_send_code():
    """Send SMS verification code for registration - with full error logging"""
    import traceback
    import logging
    logger = logging.getLogger(__name__)
    
    try:
        return _register_send_code_impl()
    except Exception as e:
        error_trace = traceback.format_exc()
        logger.error(f"CRITICAL ERROR in register_send_code: {str(e)}")
        logger.error(f"Full traceback: {error_trace}")
        print(f"CRITICAL ERROR in register_send_code: {str(e)}")
        print(f"Full traceback: {error_trace}")
        return jsonify({'success': False, 'message': f'–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞: {str(e)}'}), 500


def _register_send_code_impl():
    """Send SMS verification code for registration"""
    from models import PhoneVerification
    from sms_service import sms_service
    import logging
    
    logger = logging.getLogger(__name__)
    logger.info("=" * 80)
    logger.info("üì± /register/send-code called")

    # Check if this is an AJAX request
    is_ajax = request.headers.get('Accept') == 'application/json' or request.is_json
    
    try:
        # Support both JSON and form data
        if request.is_json:
            data = request.get_json()
            phone = data.get('phone', '').strip()
            logger.info(f"üì• JSON request - phone: {phone}")
        else:
            phone = request.form.get('phone', '').strip()
            logger.info(f"üì• Form request - phone: {phone}")
    except Exception as e:
        logger.error(f"‚ùå Error reading request data: {e}", exc_info=True)
        return jsonify({'success': False, 'message': '–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞'})
    
    # Format phone: remove all non-digits
    phone_clean = ''.join(filter(str.isdigit, phone))
    logger.info(f"üî¢ Phone digits extracted: {phone_clean}")
    
    # Add +7 prefix if needed
    if phone_clean.startswith('8'):
        phone_clean = '7' + phone_clean[1:]
        logger.info(f"‚úèÔ∏è Converted 8 -> 7: {phone_clean}")
    elif phone_clean.startswith('9'):
        phone_clean = '7' + phone_clean
        logger.info(f"‚úèÔ∏è Added 7 prefix: {phone_clean}")
    
    # ‚úÖ STRICT VALIDATION: Enforce 11-digit Russian phone format starting with 7
    logger.info(f"üîç Validating phone: length={len(phone_clean)}, starts_with_7={phone_clean.startswith('7')}")
    if len(phone_clean) != 11 or not phone_clean.startswith('7'):
        logger.warning(f"‚ùå Phone validation failed: {phone_clean}")
        if request.is_json:
            return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞'})
        flash('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞', 'error')
        return redirect(url_for('register'))
    
    logger.info('üö¶ Checking rate limiting...')
    # Check rate limiting
    try:
        can_send = PhoneVerification.can_send_code(phone_clean, rate_limit_seconds=60)
        logger.info(f'‚úÖ Rate limit check result: {can_send}')
    except Exception as e:
        logger.error(f'‚ùå Rate limit check failed: {e}', exc_info=True)
        can_send = True  # Allow on error
    
    if not can_send:
        logger.warning(f'üö´ Rate limit exceeded for {phone_clean}')
        if is_ajax:
            return jsonify({'success': False, 'message': '–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ 60 —Å–µ–∫—É–Ω–¥.'})
        flash('–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ 60 —Å–µ–∫—É–Ω–¥.', 'error')
        return redirect(url_for('register'))
    
    logger.info('üë§ Checking if user exists...')
    # Check if user already registered - search by clean phone number
    from models import User
    from sqlalchemy import func as sqlfunc
    
    # Use SQL normalization to find existing users - normalize BOTH stored phone and incoming phone
    existing_user = User.query.filter(
        sqlfunc.replace(sqlfunc.replace(sqlfunc.replace(User.phone, "-", ""), " ", ""), "+", "") == phone_clean
    ).first()
    
    if existing_user:
        logger.warning(f"‚ö†Ô∏è User already exists with phone: {phone_clean} (stored as: {existing_user.phone})")
        if request.is_json:
            return jsonify({'success': False, 'message': '–≠—Ç–æ—Ç –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—Ö–æ–¥ –ø–æ SMS.'})
        flash('–≠—Ç–æ—Ç –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—Ö–æ–¥ –ø–æ SMS.', 'error')
        return redirect(url_for('register'))
    else:
        logger.info(f"‚úÖ Phone {phone_clean} is NOT registered - allowing registration")
    
    # Check if user already exists
    from models import User
    from sqlalchemy import func
    # ‚úÖ FIX: Use SQL-based normalization to match phones with dashes in database
    phone_digits_only = phone_clean.replace("+", "").replace("-", "").replace(" ", "")
    existing_user = User.query.filter(
        sqlfunc.replace(sqlfunc.replace(sqlfunc.replace(User.phone, "-", ""), " ", ""), "+", "") == phone_digits_only
    ).first()
    if existing_user:
        if is_ajax:
            return jsonify({'success': False, 'message': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω'})
        flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω', 'error')
        return redirect(url_for('login'))
    
    logger.info('üîê Creating verification code...')
    # Create verification code
    verification = PhoneVerification.create_code(
        phone=phone_clean,
        ip_address=request.remote_addr,
        user_agent=request.headers.get('User-Agent')
    )
    db.session.add(verification)
    db.session.commit()
    
    logger.info(f'üì® Sending SMS to {phone_clean}...')
    # Send SMS
    result = sms_service.send_verification_code(phone_clean, verification.code)
    
    if result['success']:
        # Store phone in session for verification step
        session['registration_phone'] = phone_clean
        if is_ajax:
            return jsonify({'success': True, 'message': '–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –≤–∞—à —Ç–µ–ª–µ—Ñ–æ–Ω', 'code': verification.code})
        flash('–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –≤–∞—à —Ç–µ–ª–µ—Ñ–æ–Ω', 'success')
    else:
        if is_ajax:
            return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ SMS: {result["message"]}'})
        flash(f'–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ SMS: {result["message"]}', 'error')
    
    return redirect(url_for('register'))

@csrf.exempt  # Allow session reset
@app.route('/register/reset', methods=['POST', 'GET'])
def register_reset():
    """Reset registration session"""
    session.pop('registration_phone', None)
    session.pop('registration_user_id', None)
    flash('–ù–∞—á–Ω–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ', 'info')
    return redirect(url_for('register'))

@app.route('/register/verify-code', methods=['POST'])
@csrf.exempt  # CSRF token handled in form
@app.route('/register/verify-code', methods=['POST'])
@csrf.exempt  # CSRF token handled in form
@app.route('/register/verify-code', methods=['POST'])
@csrf.exempt  # CSRF token handled in form
@app.route('/register/verify-code', methods=['POST'])
@csrf.exempt  # CSRF token handled in form
def register_verify_code():
    """Verify SMS code, create user with temp password, auto-login and redirect to dashboard"""
    print("[VERIFY_CODE] üî¥ –§–£–ù–ö–¶–ò–Ø –í–´–ó–í–ê–ù–ê!", flush=True)
    
    from models import PhoneVerification, User
    from sms_service import sms_service
    import secrets
    import string
    import logging
    
    logger = logging.getLogger(__name__)
    print("[VERIFY_CODE] –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ", flush=True)
    
    # Support both JSON and form data
    try:
        if request.is_json:
            print(f"[VERIFY_CODE] Checking if request is JSON: {request.is_json}", flush=True)
            print(f"[VERIFY_CODE] Calling request.get_json()...", flush=True)
            data = request.get_json()
            print(f"[VERIFY_CODE] get_json() returned successfully", flush=True)
            phone = data.get('phone')
            code_raw = data.get('code', '').strip() if data.get('code') else None
            code = code_raw if code_raw else ''
            print(f"[VERIFY_CODE] code_raw={code_raw}, final code={code}", flush=True)
            print(f"[VERIFY_CODE] –ü–æ–ª—É—á–µ–Ω–∞ JSON –ø—Ä–æ—Å—å–±–∞: phone={phone}, code={code}", flush=True)
        else:
            phone = session.get('registration_phone')
            code = request.form.get('code', '').strip()
    except Exception as e:
        print(f"[VERIFY_CODE] ‚ùå EXCEPTION: {str(e)}", flush=True)
        logger.error(f"[VERIFY_CODE] Error parsing request: {str(e)}", exc_info=True)
        if request.is_json:
            return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: {str(e)}'}), 500
        flash(f'–û—à–∏–±–∫–∞: {str(e)}', 'error')
        return redirect(url_for('register'))
    
    # If phone not provided in request, try to get from session
    if not phone:
        phone = session.get('registration_phone')
    
    if not phone or not code:
        if request.is_json:
            return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ'})
        flash('–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ', 'error')
        return redirect(url_for('register'))
    
    # ‚úÖ NORMALIZE phone format BEFORE searching - remove all formatting
    phone_clean = phone.replace("+", "").replace("-", "").replace(" ", "").replace("(", "").replace(")", "")
    logger.info(f"üì± Incoming phone: {phone}")
    logger.info(f"üì± Cleaned phone: {phone_clean}")
    logger.info(f"üîë Incoming code: {code}")
    
    # Find valid verification code using cleaned phone
    verification = PhoneVerification.query.filter_by(
        phone=phone_clean,
        code=code
    ).order_by(PhoneVerification.created_at.desc()).first()
    
    # Debug: Log all PhoneVerification records for this phone
    if not verification:
        all_records = PhoneVerification.query.filter_by(phone=phone_clean).all()
        logger.warning(f"‚ùå No verification found for phone={phone_clean}, code={code}")
        # Debug: Check what IS in the database
        all_phv = PhoneVerification.query.all()
        logger.warning(f"üìã ALL PhoneVerification records in DB: count={len(all_phv)}")
        for pvr in all_phv[-5:]:  # Show last 5
            logger.warning(f"   - phone={pvr.phone} code={pvr.code} created={pvr.created_at}")
        logger.warning(f"üìã Total records for this phone: {len(all_records)}")
        for rec in all_records:
            logger.warning(f"   - Record ID={rec.id}, phone={rec.phone}, code={rec.code}, verified={rec.is_verified}, expires={rec.expires_at}, attempts={rec.attempts}")
        
        if request.is_json:
            return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è'})
        flash('–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è', 'error')
        return redirect(url_for('register'))
    
    if not verification.is_valid():
        error_msg = '–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏—Å—Ç–µ–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥.'
        if verification.is_verified:
            error_msg = '–ö–æ–¥ —É–∂–µ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω'
        elif not verification.is_expired():
            error_msg = '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –≤–≤–æ–¥–∞ –∫–æ–¥–∞'
        
        if request.is_json:
            return jsonify({'success': False, 'message': error_msg})
        flash(error_msg, 'error')
        return redirect(url_for('register'))
    
    # Increment attempts
    verification.attempts += 1
    
    # Mark as verified
    verification.is_verified = True
    verification.verified_at = datetime.utcnow()
    
    # Format phone to database format: +7-XXX-XXX-XX-XX
    from sqlalchemy import func
    phone_digits_only = phone.replace("+", "").replace("-", "").replace(" ", "").replace("(", "").replace(")", "")
    
    # ‚úÖ STRICT VALIDATION: Enforce 11-digit Russian phone format
    if len(phone_digits_only) != 11 or not phone_digits_only.startswith('7'):
        logger.error(f"‚ùå Invalid phone format: {phone} (digits: {phone_digits_only})")
        if request.is_json:
            return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞'})
        flash('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞', 'error')
        return redirect(url_for('register'))
    
    # Format: +7-XXX-XXX-XX-XX (canonical database format)
    phone_formatted = f"+7-{phone_digits_only[1:4]}-{phone_digits_only[4:7]}-{phone_digits_only[7:9]}-{phone_digits_only[9:11]}"
    
    logger.info(f"üìû Phone formatting: {phone} -> {phone_formatted}")
    
    logger.info('üë§ Checking if user exists...')
    # Check if user already registered - search by clean phone number
    from models import User
    from sqlalchemy import func as sqlfunc
    
    # Use SQL normalization to find existing users - normalize BOTH stored phone and incoming phone
    existing_user = User.query.filter(
        sqlfunc.replace(sqlfunc.replace(sqlfunc.replace(User.phone, "-", ""), " ", ""), "+", "") == phone_clean
    ).first()
    
    if existing_user:
        logger.warning(f"‚ö†Ô∏è User already exists with phone: {phone_clean} (stored as: {existing_user.phone})")
        if request.is_json:
            return jsonify({'success': False, 'message': '–≠—Ç–æ—Ç –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—Ö–æ–¥ –ø–æ SMS.'})
        flash('–≠—Ç–æ—Ç –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—Ö–æ–¥ –ø–æ SMS.', 'error')
        return redirect(url_for('register'))
    else:
        logger.info(f"‚úÖ Phone {phone_clean} is NOT registered - allowing registration")
    
    logger.info('üîç Executing user lookup query...')
    # Check if user already exists (incomplete profile) - use SQL normalization
    user = None
    try:
        logger.debug(f"üìã Querying user with phone={phone_digits_only}")
        user = User.query.filter(
            sqlfunc.replace(sqlfunc.replace(sqlfunc.replace(User.phone, "-", ""), " ", ""), "+", "") == phone_digits_only
        ).first()
        logger.debug(f"‚úÖ User lookup complete. Found user={user is not None}")
    except Exception as e:
        logger.error(f"‚ùå Database error during user lookup: {e}", exc_info=True)
    
    logger.info(f"üî¥ ABOUT TO CREATE USER - phone_formatted={phone_formatted}, phone_clean={phone_clean}")
    
    if not user:
        # Create user with temporary password
        # Generate temporary password (8 characters: letters + digits)
        temp_password = ''.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(8))
        
        try:
            logger.info(f"üë§ Creating User object with phone={phone_formatted}, verified=True")
            user = User(
                phone=phone_formatted,  # ‚úÖ Use formatted phone (required field)
                phone_verified=True,
                is_verified=True,  # Auto-verify on registration
                profile_completed=False
            )
            logger.info(f"‚úÖ User object created successfully")
        except Exception as e:
            logger.error(f"‚ùå ERROR instantiating User: {str(e)}", exc_info=True)
            if request.is_json:
                return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}'}), 500
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}', 'error')
            return redirect(url_for('register'))
        user.set_password(temp_password)
        db.session.add(user)
        user.must_change_password = True  # –¢—Ä–µ–±—É–µ—Ç—Å—è —Å–º–µ–Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –ø–∞—Ä–æ–ª—è
        
        logger.info(f"‚úÖ Creating new user with temp password: {phone}")
        
        # Save first to get user.id
        try:
            db.session.commit()
            db.session.refresh(user)  # üîß CRITICAL FIX #1: Refresh user after commit
        except Exception as e:
            logger.error(f"‚ùå Error creating user: {str(e)}", exc_info=True)
            db.session.rollback()
            if request.is_json:
                return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}'})
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}', 'error')
            return redirect(url_for('register'))
        
        # Grant 10,000‚ÇΩ registration bonus
        from models import UserBalance, BalanceTransaction
        from decimal import Decimal
        
        try:
            # Create user balance
            logger.info(f"üîß Creating UserBalance for user {user.id}")
            user_balance = UserBalance(
                user_id=user.id,
                available_amount=Decimal('10000.00'),
                pending_amount=Decimal('0.00'),
                total_earned=Decimal('10000.00'),
                total_withdrawn=Decimal('0.00')
            )
            db.session.add(user_balance)
            
            # Create bonus transaction
            logger.info(f"üîß Creating BalanceTransaction for user {user.id}")
            bonus_transaction = BalanceTransaction(
                user_id=user.id,
                amount=Decimal('10000.00'),
                transaction_type='registration_bonus',
                description='–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π –±–æ–Ω—É—Å –∑–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é',
                balance_before=Decimal('0.00'),
                balance_after=Decimal('10000.00'),
                status='completed',
                processed_at=datetime.utcnow()
            )
            db.session.add(bonus_transaction)
            
            logger.info(f"üíæ Committing UserBalance + BalanceTransaction...")
            db.session.commit()
            db.session.refresh(user)  # üîß CRITICAL FIX #2: Refresh user after balance commit
            logger.info(f"‚úÖ Granted 10,000‚ÇΩ registration bonus to user {user.id}")
        except Exception as e:
            logger.error(f"üí• ERROR creating balance/transaction: {str(e)}", exc_info=True)
            db.session.rollback()
            if request.is_json:
                return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –±–∞–ª–∞–Ω—Å–∞: {str(e)}'}), 500
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –±–∞–ª–∞–Ω—Å–∞: {str(e)}', 'error')
            return redirect(url_for('register'))
        
        try:
            ref_code = session.pop('referral_code', None)
            if ref_code:
                ref_code = ref_code.strip().upper()
                from models import Referral
                existing_referral = Referral.query.filter_by(referred_id=user.id).first()
                referrer = User.query.filter_by(referral_code=ref_code).first() if not existing_referral else None
                if referrer and referrer.id != user.id:
                    referral = Referral(
                        referrer_id=referrer.id,
                        referred_id=user.id,
                        bonus_amount=Decimal('20000.00'),
                        status='completed',
                        bonus_credited_at=datetime.utcnow()
                    )
                    db.session.add(referral)
                    
                    user.referred_by_id = referrer.id
                    
                    referrer_balance = UserBalance.query.filter_by(user_id=referrer.id).first()
                    if referrer_balance:
                        balance_before = referrer_balance.available_amount or Decimal('0.00')
                        referrer_balance.available_amount = balance_before + Decimal('20000.00')
                        referrer_balance.total_earned = (referrer_balance.total_earned or Decimal('0.00')) + Decimal('20000.00')
                    else:
                        referrer_balance = UserBalance(
                            user_id=referrer.id,
                            available_amount=Decimal('20000.00'),
                            pending_amount=Decimal('0.00'),
                            total_earned=Decimal('20000.00'),
                            total_withdrawn=Decimal('0.00')
                        )
                        db.session.add(referrer_balance)
                        balance_before = Decimal('0.00')
                    
                    referrer.balance = (referrer.balance or Decimal('0.00')) + Decimal('20000.00')
                    referrer.total_earned = (referrer.total_earned or Decimal('0.00')) + Decimal('20000.00')
                    
                    referral_transaction = BalanceTransaction(
                        user_id=referrer.id,
                        amount=Decimal('20000.00'),
                        transaction_type='referral_bonus',
                        description=f'–†–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –±–æ–Ω—É—Å –∑–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.phone}',
                        balance_before=balance_before,
                        balance_after=balance_before + Decimal('20000.00'),
                        status='completed',
                        processed_at=datetime.utcnow()
                    )
                    db.session.add(referral_transaction)
                    
                    db.session.commit()
                    logger.info(f"‚úÖ Referral bonus 20,000‚ÇΩ credited to user {referrer.id} for referring user {user.id}")
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Error processing referral bonus: {str(e)}", exc_info=True)
            db.session.rollback()
        
        # Send temporary password via SMS
        logger.info(f"üì§ Sending temp password via SMS to {phone}")
        sms_result = sms_service.send_sms(
            phone=phone,
            message=f"–í–∞—à –≤—Ä–µ–º–µ–Ω–Ω—ã–π –ø–∞—Ä–æ–ª—å –¥–ª—è –≤—Ö–æ–¥–∞ –≤ InBack: {temp_password}. –ò–∑–º–µ–Ω–∏—Ç–µ –µ–≥–æ –≤ –ª–∏—á–Ω–æ–º –∫–∞–±–∏–Ω–µ—Ç–µ."
        )
        
        if not sms_result['success']:
            logger.warning(f"‚ö†Ô∏è Failed to send temp password SMS: {sms_result['message']}")
            # Don't fail registration, just log warning
        else:
            logger.info(f"‚úÖ Temp password SMS sent successfully")
    else:
        # Update existing incomplete user - regenerate and send temp password
        logger.info(f"User {user.id} already exists with profile_completed={user.profile_completed}")
        
        if user.profile_completed:
            # User already fully registered - should use login instead
            logger.warning(f"Attempted re-registration of completed user {user.id}")
            if request.is_json:
                return jsonify({'success': False, 'message': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—Ö–æ–¥.'})
            flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—Ö–æ–¥.', 'error')
            return redirect(url_for('login'))
        
        # Generate NEW temporary password for incomplete profile
        temp_password = ''.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(8))
        user.set_password(temp_password)
        user.phone_verified = True
        user.must_change_password = True  # –¢—Ä–µ–±—É–µ—Ç—Å—è —Å–º–µ–Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –ø–∞—Ä–æ–ª—è
        
        # ‚úÖ Check if user has balance - if not, grant registration bonus (migrated users)
        existing_balance = UserBalance.query.filter_by(user_id=user.id).first()
        if not existing_balance:
            logger.info(f"üéÅ Migrated user {user.id} has no balance - granting registration bonus")
            
            # Clear stale telegram_id from migration
            if user.telegram_id and not user.profile_completed:
                logger.info(f"üßπ Clearing stale telegram_id for migrated user {user.id}")
                user.telegram_id = None
            
            # Create user balance
            user_balance = UserBalance(
                user_id=user.id,
                available_amount=Decimal('10000.00'),
                pending_amount=Decimal('0.00'),
                total_earned=Decimal('10000.00'),
                total_withdrawn=Decimal('0.00')
            )
            db.session.add(user_balance)
            
            # Create bonus transaction
            bonus_transaction = BalanceTransaction(
                user_id=user.id,
                amount=Decimal('10000.00'),
                transaction_type='registration_bonus',
                description='–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π –±–æ–Ω—É—Å –∑–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é',
                balance_before=Decimal('0.00'),
                balance_after=Decimal('10000.00'),
                status='completed',
                processed_at=datetime.utcnow()
            )
            db.session.add(bonus_transaction)
            
            # Update legacy balance fields
            user.balance = Decimal('10000.00')
            user.registration_bonus = Decimal('10000.00')
            
            logger.info(f"‚úÖ Granted 10,000‚ÇΩ registration bonus to migrated user {user.id}")
        
        try:
            db.session.commit()
            db.session.refresh(user)  # FIX: Refresh after update
            logger.info(f"‚úÖ Updated existing user {user.id} with new temp password")
            db.session.refresh(user)  # üîß CRITICAL FIX #3: Refresh existing user after update
        except Exception as e:
            logger.error(f"‚ùå Error updating user: {str(e)}", exc_info=True)
            db.session.rollback()
            if request.is_json:
                return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}'})
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}', 'error')
            return redirect(url_for('register'))
        
        # Send temporary password via SMS
        logger.info(f"üì§ Sending NEW temp password via SMS to {phone} for existing user {user.id}")
        sms_result = sms_service.send_sms(
            phone=phone,
            message=f"–í–∞—à –Ω–æ–≤—ã–π –≤—Ä–µ–º–µ–Ω–Ω—ã–π –ø–∞—Ä–æ–ª—å –¥–ª—è –≤—Ö–æ–¥–∞ –≤ InBack: {temp_password}. –ò–∑–º–µ–Ω–∏—Ç–µ –µ–≥–æ –≤ –ª–∏—á–Ω–æ–º –∫–∞–±–∏–Ω–µ—Ç–µ."
        )
        
        if not sms_result['success']:
            logger.warning(f"‚ö†Ô∏è Failed to send temp password SMS: {sms_result['message']}")
            # Don't fail registration, just log warning
        else:
            logger.info(f"‚úÖ Temp password SMS sent successfully to existing user {user.id}")

        db.session.refresh(user)  # üîß CRITICAL FIX #4: Final refresh before login
    logger.info(f"‚úÖ Auto-logging in user: {user.id}")
    login_user(user, remember=True)
    
    try:
        from services.guest_session import merge_guest_to_user
        merge_guest_to_user(user.id, db.session)
    except Exception as e:
        print(f'Guest merge error: {e}')
    
    # Clean up session
    session.pop('registration_phone', None)
    session.pop('registration_user_id', None)
    
    # Redirect to dashboard (modal will show automatically if profile_completed=False)
    logger.info(f"‚úÖ Registration complete, redirecting to dashboard")
    
    if request.is_json:
        return jsonify({'success': True, 'redirect': url_for('dashboard')})
    
    flash('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –í—Ä–µ–º–µ–Ω–Ω—ã–π –ø–∞—Ä–æ–ª—å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤–∞–º –≤ SMS. –ó–∞–≤–µ—Ä—à–∏—Ç–µ –ø—Ä–æ—Ñ–∏–ª—å –≤ –ª–∏—á–Ω–æ–º –∫–∞–±–∏–Ω–µ—Ç–µ.', 'success')
    return redirect(url_for('dashboard'))



@app.route('/register/complete', methods=['GET'])
def register_complete():
    """Step 2: Complete profile form"""
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    
    # Check if user has verified phone
    user_id = session.get('registration_user_id')
    if not user_id:
        flash('–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞', 'error')
        return redirect(url_for('register'))
    
    from models import User
    user = User.query.get(user_id)
    if not user or not user.phone_verified:
        flash('–ù–µ–≤–µ—Ä–Ω–∞—è —Å–µ—Å—Å–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏', 'error')
        return redirect(url_for('register'))
    
    return render_template('auth/register_profile.html', user=user)

@app.route('/register/complete', methods=['POST'])
def register_complete_post():
    """Complete profile and activate account (Step 2 complete)"""
    from models import User, BalanceTransaction
    from decimal import Decimal
    
    # Check session
    user_id = session.get('registration_user_id')
    if not user_id:
        flash('–°–µ—Å—Å–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –∏—Å—Ç–µ–∫–ª–∞', 'error')
        return redirect(url_for('register'))
    
    user = User.query.get(user_id)
    if not user or not user.phone_verified:
        flash('–ù–µ–≤–µ—Ä–Ω–∞—è —Å–µ—Å—Å–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏', 'error')
        return redirect(url_for('register'))
    
    # Get form data
    full_name = request.form.get('full_name', '').strip()
    email = request.form.get('email', '').strip()
    telegram_id = request.form.get('telegram_id', '').strip()
    password = request.form.get('password', '').strip()
    confirm_password = request.form.get('confirm_password', '').strip()
    terms = request.form.get('terms')
    
    # Validation
    if not all([full_name, password, confirm_password, terms]):
        flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è', 'error')
        return redirect(url_for('register_complete'))
    
    if password != confirm_password:
        flash('–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
        return redirect(url_for('register_complete'))
    
    if len(password) < 8:
        flash('–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 8 —Å–∏–º–≤–æ–ª–æ–≤', 'error')
        return redirect(url_for('register_complete'))
    
    # Check if email already used (if provided)
    if email:
        existing_email_user = User.query.filter_by(email=email).first()
        if existing_email_user and existing_email_user.id != user.id:
            flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç', 'error')
            return redirect(url_for('register_complete'))
    
    try:
        # Update user profile
        user.full_name = full_name
        user.email = email if email else None
        user.telegram_id = telegram_id if telegram_id else None
        user.set_password(password)
        user.profile_completed = True
        
        # Grant registration bonus (idempotent check)
        existing_bonus = BalanceTransaction.query.filter_by(
            user_id=user.id,
            transaction_type='registration_bonus'
        ).first()
        
        if not existing_bonus:
            bonus_amount = Decimal('10000.00')
            balance_before = user.balance or Decimal('0')
            
            user.balance = balance_before + bonus_amount
            user.registration_bonus = (user.registration_bonus or Decimal('0')) + bonus_amount
            user.total_earned = (user.total_earned or Decimal('0')) + bonus_amount
            
            balance_after = user.balance
            
            transaction = BalanceTransaction(
                user_id=user.id,
                amount=bonus_amount,
                transaction_type='registration_bonus',
                description='–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π –±–æ–Ω—É—Å –∑–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é',
                balance_before=balance_before,
                balance_after=balance_after,
                status='completed',
                processed_at=datetime.utcnow()
            )
            db.session.add(transaction)
        
        db.session.commit()
        
        # Clear session
        session.pop('registration_user_id', None)
        
        # Login user
        login_user(user)
        user.last_login = datetime.utcnow()
        user.last_ip = request.remote_addr
        user.last_user_agent = request.headers.get('User-Agent')
        db.session.commit()
        
        flash('–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ InBack!', 'success')
        return redirect(url_for('dashboard'))
        
    except Exception as e:
        db.session.rollback()
        print(f"Profile completion error: {e}")
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {str(e)}', 'error')
        return redirect(url_for('register_complete'))

# ================================
# PHONE LOGIN ROUTES
# ================================

@app.route('/login/send-code', methods=['POST'])
def login_send_code():
    """Send SMS code for phone login"""
    from models import PhoneVerification, User
    from sms_service import sms_service
    
    phone = request.form.get('phone', '').strip()
    
    # Format phone
    phone_clean = ''.join(filter(str.isdigit, phone))
    
    if phone_clean.startswith('8'):
        phone_clean = '7' + phone_clean[1:]
    elif phone_clean.startswith('9'):
        phone_clean = '7' + phone_clean
    elif not phone_clean.startswith('7'):
        return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞'})
    
    # Check if user exists
    user = User.query.filter_by(phone=phone_clean).first()
    if not user or not user.profile_completed:
        return jsonify({'success': False, 'message': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º –Ω–µ –Ω–∞–π–¥–µ–Ω'})
    
    logger.info('üö¶ Checking rate limiting...')
    # Check rate limiting
    if not PhoneVerification.can_send_code(phone_clean, rate_limit_seconds=60):
        return jsonify({'success': False, 'message': '–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–¥–æ–∂–¥–∏—Ç–µ 60 —Å–µ–∫—É–Ω–¥.'})
    
    logger.info('üîê Creating verification code...')
    # Create verification code
    verification = PhoneVerification.create_code(
        phone=phone_clean,
        ip_address=request.remote_addr,
        user_agent=request.headers.get('User-Agent')
    )
    db.session.add(verification)
    db.session.commit()
    
    # Send SMS
    result = sms_service.send_login_code(phone_clean, verification.code)
    
    if result['success']:
        session['login_phone'] = phone_clean
        return jsonify({'success': True, 'message': '–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –≤–∞—à —Ç–µ–ª–µ—Ñ–æ–Ω'})
    else:
        return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ SMS: {result["message"]}'})

@app.route('/login/verify-code', methods=['POST'])
def login_verify_code():
    """Verify SMS code and login user"""
    from models import PhoneVerification, User
    
    phone = session.get('login_phone')
    code = request.form.get('code', '').strip()
    
    if not phone or not code:
        return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ'})
    
    # Find valid verification code
    verification = PhoneVerification.query.filter_by(
        phone=phone,
        code=code
    ).order_by(PhoneVerification.created_at.desc()).first()
    
    if not verification:
        return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è'})
    
    if not verification.is_valid():
        if verification.is_expired():
            return jsonify({'success': False, 'message': '–ö–æ–¥ –∏—Å—Ç–µ–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥.'})
        elif verification.is_verified:
            return jsonify({'success': False, 'message': '–ö–æ–¥ —É–∂–µ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω'})
        else:
            return jsonify({'success': False, 'message': '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫'})
    
    # Increment attempts
    verification.attempts += 1
    verification.is_verified = True
    verification.verified_at = datetime.utcnow()
    
    # Find user
    user = User.query.filter_by(phone=phone).first()
    if not user:
        db.session.rollback()
        return jsonify({'success': False, 'message': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω'})
    
    
    # Check if user is blocked
    if not user.is_active:
        db.session.commit()
        return jsonify({'success': False, 'message': '–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ —Å–ª—É–∂–±—É –ø–æ–¥–¥–µ—Ä–∂–∫–∏.'})
    db.session.commit()
    
    # Clear manager session data if exists
    session.pop('manager_id', None)
    session.pop('is_manager', None)
    session.pop('login_phone', None)
    
    # Login user
    login_user(user)
    user.last_login = datetime.utcnow()
    user.last_ip = request.remote_addr
    user.last_user_agent = request.headers.get('User-Agent')
    db.session.commit()
    
    return jsonify({'success': True, 'redirect': url_for('dashboard')})
@app.route('/confirm/<token>')
def confirm_email(token):
    """Email confirmation endpoint"""
    from models import User
    
    try:
        # Find user by verification token
        user = User.query.filter_by(verification_token=token).first()
        
        if not user:
            flash('–ù–µ–≤–µ—Ä–Ω–∞—è –∏–ª–∏ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω–∞—è —Å—Å—ã–ª–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è', 'error')
            return redirect(url_for('login'))
        
        if user.is_verified:
            flash('–í–∞—à –∞–∫–∫–∞—É–Ω—Ç —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω', 'info')
            return redirect(url_for('login'))
        
        # Confirm user
        user.is_verified = True
        user.verification_token = None  # Clear the token
        db.session.commit()
        
        # Send welcome email after verification
        try:
            from email_service import send_welcome_email
            send_welcome_email(user, base_url=request.url_root.rstrip('/'))
        except Exception as e:
            print(f"Error sending welcome email: {e}")
        
        flash('Email —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω! –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –≤–æ–π—Ç–∏ –≤ –∞–∫–∫–∞—É–Ω—Ç.', 'success')
        return redirect(url_for('login'))
        
    except Exception as e:
        print(f"Email confirmation error: {e}")
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏ email', 'error')
        return redirect(url_for('login'))

@app.route('/resend-verification', methods=['POST'])
@require_json_csrf
def resend_verification():
    """Resend verification email with rate limiting and enhanced security"""
    import re
    from models import User, EmailVerificationAttempt
    
    # Get request data - support both form and JSON
    if request.content_type == 'application/json':
        data = request.get_json() or {}
        email = data.get('email', '').strip().lower()
    else:
        email = request.form.get('email', '').strip().lower()
    
    # Get client info for logging
    ip_address = request.environ.get('HTTP_X_FORWARDED_FOR', request.environ.get('REMOTE_ADDR'))
    user_agent = request.headers.get('User-Agent', '')[:500]
    
    # Validate email format
    if not email:
        error_msg = '–í–≤–µ–¥–∏—Ç–µ email –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏'
        EmailVerificationAttempt.log_attempt(email or 'empty', ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 400
        flash(error_msg, 'error')
        return redirect(url_for('login'))
    
    # Basic email format validation
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        error_msg = '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email –∞–¥—Ä–µ—Å'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 400
        flash(error_msg, 'error')
        return redirect(url_for('login'))
    
    logger.info('üö¶ Checking rate limiting...')
    # Check rate limiting (5 minutes between successful attempts)
    if not EmailVerificationAttempt.can_resend_verification(email, rate_limit_minutes=5):
        error_msg = '–°–ª–∏—à–∫–æ–º —á–∞—Å—Ç—ã–µ –∑–∞–ø—Ä–æ—Å—ã. –ü–æ–¥–æ–∂–¥–∏—Ç–µ 5 –º–∏–Ω—É—Ç –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–æ–π.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 429
        flash(error_msg, 'warning')
        return redirect(url_for('login'))
    
    # Check for suspicious activity (more than 10 attempts in 1 hour)
    recent_attempts = EmailVerificationAttempt.get_recent_attempts_count(email, hours=1)
    if recent_attempts >= 10:
        error_msg = '–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –ø–æ–ø—ã—Ç–æ–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 429
        flash(error_msg, 'error')
        return redirect(url_for('login'))
    
    # Find user
    user = User.query.filter_by(email=email).first()
    
    if not user:
        # Don't reveal whether user exists for security
        success_msg = '–ï—Å–ª–∏ –∞–∫–∫–∞—É–Ω—Ç —Å —Ç–∞–∫–∏–º email —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø–∏—Å—å–º–æ —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, 'User not found')
        if request.content_type == 'application/json':
            return jsonify({'success': True, 'message': success_msg})
        flash(success_msg, 'info')
        return redirect(url_for('login'))
    
    if user.is_verified:
        error_msg = '–í–∞—à –∞–∫–∫–∞—É–Ω—Ç —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 400
        flash(error_msg, 'info')
        return redirect(url_for('login'))
    
    # Generate new verification token
    user.verification_token = secrets.token_urlsafe(32)
    db.session.commit()
    
    # Send new verification email
    try:
        from email_service import send_verification_email
        send_verification_email(user, base_url=request.url_root.rstrip('/'))
        
        # Log successful attempt
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, True, None)
        
        success_msg = '–ü–∏—Å—å–º–æ —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –≤–∞—à email.'
        print(f"‚úÖ VERIFICATION RESEND SUCCESS: Email sent to {email} from IP {ip_address}")
        
        if request.content_type == 'application/json':
            return jsonify({'success': True, 'message': success_msg})
        flash(success_msg, 'success')
        
    except Exception as e:
        error_msg = '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –ø–∏—Å—å–º–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, str(e)[:200])
        print(f"‚ùå VERIFICATION RESEND ERROR: {e} for email {email}")
        
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 500
        flash(error_msg, 'error')
    
    return redirect(url_for('login'))

@app.route('/quiz-registration')
def quiz_registration():
    """Show quiz registration page"""
    return render_template('quiz_registration.html')

@app.route('/callback-request')
def callback_request_page():
    """Show callback request page"""
    return render_template('callback_request.html')

@app.route('/api/property-selection', methods=['POST'])
def property_selection():
    """Property selection application"""
    from models import Application, User
    data = request.get_json()
    
    try:
        # Extract data
        email = data.get('email', '').strip().lower()
        name = data.get('name', '').strip()
        phone = data.get('phone', '').strip()
        
        # Application preferences
        preferred_district = data.get('preferred_district', '')
        property_type = data.get('property_type', '')
        room_count = data.get('room_count', '')
        budget_range = data.get('budget_range', '')
        
        # Property context information
        property_id = data.get('property_id')
        property_title = data.get('property_title', '')
        property_complex = data.get('property_complex', '')
        property_price = data.get('property_price')
        property_area = data.get('property_area')
        property_rooms = data.get('property_rooms')
        property_floor = data.get('property_floor')
        property_total_floors = data.get('property_total_floors')
        property_district = data.get('property_district', '')
        property_url = data.get('property_url', '')
        property_type_context = data.get('property_type_context', '')
        
        # Validation
        if not email or not name or not phone:
            return jsonify({'success': False, 'error': '–í—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã'})
        
        # Determine application type and build message
        is_specific_property = property_id and property_type_context == 'property'
        is_specific_complex = property_id and property_type_context == 'complex'
        
        if is_specific_property:
            # Specific property interest
            application_title = f"–ò–Ω—Ç–µ—Ä–µ—Å –∫ –∫–≤–∞—Ä—Ç–∏—Ä–µ: {property_title}"
            complex_name = property_complex or '–ù–µ —É–∫–∞–∑–∞–Ω'
            message = f"–ó–∞—è–≤–∫–∞ –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–≤–∞—Ä—Ç–∏—Ä–µ:\n"
            message += f"–ò–º—è: {name}\n"
            message += f"Email: {email}\n"
            message += f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n\n"
            message += f"=== –û–ë–™–ï–ö–¢ –ò–ù–¢–ï–†–ï–°–ê ===\n"
            message += f"–ö–≤–∞—Ä—Ç–∏—Ä–∞: {property_title}\n"
            message += f"–ñ–ö: {property_complex}\n"
            if property_price:
                try:
                    formatted_price = f"{int(property_price):,}".replace(',', ' ')
                    message += f"–¶–µ–Ω–∞: {formatted_price} ‚ÇΩ\n"
                except (ValueError, TypeError):
                    message += f"–¶–µ–Ω–∞: {property_price} ‚ÇΩ\n"
            if property_area:
                message += f"–ü–ª–æ—â–∞–¥—å: {property_area} –º¬≤\n"
            if property_floor and property_total_floors:
                message += f"–≠—Ç–∞–∂: {property_floor}/{property_total_floors}\n"
            if property_district:
                message += f"–†–∞–π–æ–Ω: {property_district}\n"
            if property_url:
                message += f"–°—Å—ã–ª–∫–∞: {property_url}\n"
            message += f"\n=== –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ü–†–ï–î–ü–û–ß–¢–ï–ù–ò–Ø ===\n"
            message += f"–ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—ã–π —Ä–∞–π–æ–Ω: {preferred_district or '–ù–µ —É–∫–∞–∑–∞–Ω'}\n"
            message += f"–¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}\n"
            message += f"–ö–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}\n"
            message += f"–ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}"
        elif is_specific_complex:
            # Specific complex interest
            application_title = f"–ò–Ω—Ç–µ—Ä–µ—Å –∫ –ñ–ö: {property_title}"
            complex_name = property_title
            message = f"–ó–∞—è–≤–∫–∞ –ø–æ –∂–∏–ª–æ–º—É –∫–æ–º–ø–ª–µ–∫—Å—É:\n"
            message += f"–ò–º—è: {name}\n"
            message += f"Email: {email}\n"
            message += f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n\n"
            message += f"=== –û–ë–™–ï–ö–¢ –ò–ù–¢–ï–†–ï–°–ê ===\n"
            message += f"–ñ–ö: {property_title}\n"
            if property_district:
                message += f"–†–∞–π–æ–Ω: {property_district}\n"
            if property_url:
                message += f"–°—Å—ã–ª–∫–∞: {property_url}\n"
            message += f"\n=== –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ü–†–ï–î–ü–û–ß–¢–ï–ù–ò–Ø ===\n"
            message += f"–ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º—ã–π —Ä–∞–π–æ–Ω: {preferred_district or '–ù–µ —É–∫–∞–∑–∞–Ω'}\n"
            message += f"–¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}\n"
            message += f"–ö–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}\n"
            message += f"–ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}"
        else:
            # General property selection
            application_title = "–ü–æ–¥–±–æ—Ä –∫–≤–∞—Ä—Ç–∏—Ä—ã"
            complex_name = "–ü–æ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è–º"
            message = f"–ó–∞—è–≤–∫–∞ –Ω–∞ –ø–æ–¥–±–æ—Ä –∫–≤–∞—Ä—Ç–∏—Ä—ã:\n"
            message += f"–ò–º—è: {name}\n"
            message += f"Email: {email}\n"
            message += f"–¢–µ–ª–µ—Ñ–æ–Ω: {phone}\n"
            message += f"–†–∞–π–æ–Ω: {preferred_district or '–õ—é–±–æ–π'}\n"
            message += f"–¢–∏–ø: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}\n"
            message += f"–ö–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}\n"
            message += f"–ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}"
        
        # Create application
        application = Application(
            user_id=None,  # No user account needed for applications
            property_id=property_id,  # Store specific property ID if available
            property_name=application_title,
            complex_name=complex_name,
            message=message,
            status='new',
            contact_name=name,
            contact_email=email,
            contact_phone=phone
        )
        
        db.session.add(application)
        
        # Application submitted successfully
        db.session.commit()
        
        # Send Telegram notification
        try:
            from telegram_bot import send_telegram_message
            from datetime import datetime
            
            # Calculate potential cashback (2% of average budget)
            potential_cashback = ""
            if budget_range:
                if "–º–ª–Ω" in budget_range:
                    # Extract average from range like "3-5 –º–ª–Ω"
                    numbers = [float(x) for x in budget_range.replace(" –º–ª–Ω", "").split("-") if x.strip().replace(".", "").replace(",", "").isdigit()]
                    if numbers:
                        avg_price = sum(numbers) / len(numbers) * 1000000
                        cashback = int(avg_price * 0.02)
                        formatted_cashback = f"{cashback:,}".replace(',', ' ')
                        potential_cashback = f"üí∞ *–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫:* {formatted_cashback} —Ä—É–±. (2%)\n"
            
            # Build telegram message based on application type
            if is_specific_property:
                telegram_message = f"""üè† *–ó–ê–Ø–í–ö–ê –ü–û –ö–û–ù–ö–†–ï–¢–ù–û–ô –ö–í–ê–†–¢–ò–†–ï*

üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*
‚Ä¢ –ò–º—è: {name}
‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {phone}
‚Ä¢ Email: {email}

üè° *–û–ë–™–ï–ö–¢ –ò–ù–¢–ï–†–ï–°–ê:*
‚Ä¢ –ö–≤–∞—Ä—Ç–∏—Ä–∞: {property_title}
‚Ä¢ –ñ–ö: {property_complex}
{f"‚Ä¢ –¶–µ–Ω–∞: {int(property_price):,} ‚ÇΩ".replace(',', ' ') if property_price else ''}
{f"‚Ä¢ –ü–ª–æ—â–∞–¥—å: {property_area} –º¬≤" if property_area else ''}
{f"‚Ä¢ –≠—Ç–∞–∂: {property_floor}/{property_total_floors}" if property_floor and property_total_floors else ''}
{f"‚Ä¢ –°—Å—ã–ª–∫–∞: {property_url}" if property_url else ''}

üîç *–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ü–†–ï–î–ü–û–ß–¢–ï–ù–ò–Ø:*
‚Ä¢ –†–∞–π–æ–Ω: {preferred_district or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}
‚Ä¢ –ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}

{potential_cashback}üìÖ *–í–†–ï–ú–Ø –ó–ê–Ø–í–ö–ò:* {datetime.now().strftime('%d.%m.%Y –≤ %H:%M')}
üåê *–ò–°–¢–û–ß–ù–ò–ö:* –°—Ç—Ä–∞–Ω–∏—Ü–∞ –∫–≤–∞—Ä—Ç–∏—Ä—ã –Ω–∞ InBack.ru

üìã *–°–õ–ï–î–£–Æ–©–ò–ï –®–ê–ì–ò:*
1Ô∏è‚É£ –°–≤—è–∑–∞—Ç—å—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç
2Ô∏è‚É£ –û–±—Å—É–¥–∏—Ç—å –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â—É—é –∫–≤–∞—Ä—Ç–∏—Ä—É
3Ô∏è‚É£ –†–∞—Å—Å—á–∏—Ç–∞—Ç—å –∫—ç—à–±–µ–∫ –∏ —É—Å–ª–æ–≤–∏—è –ø–æ–∫—É–ø–∫–∏
4Ô∏è‚É£ –ù–∞–∑–Ω–∞—á–∏—Ç—å –≤—Å—Ç—Ä–µ—á—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞

‚ö° *–í–ê–ñ–ù–û:* –ö–ª–∏–µ–Ω—Ç —É–∂–µ –≤—ã–±—Ä–∞–ª –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –∫–≤–∞—Ä—Ç–∏—Ä—É!"""
            elif is_specific_complex:
                telegram_message = f"""üè¢ *–ó–ê–Ø–í–ö–ê –ü–û –ñ–ò–õ–û–ú–£ –ö–û–ú–ü–õ–ï–ö–°–£*

üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*
‚Ä¢ –ò–º—è: {name}
‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {phone}
‚Ä¢ Email: {email}

üèóÔ∏è *–û–ë–™–ï–ö–¢ –ò–ù–¢–ï–†–ï–°–ê:*
‚Ä¢ –ñ–ö: {property_title}
{f"‚Ä¢ –†–∞–π–æ–Ω: {property_district}" if property_district else ''}
{f"‚Ä¢ –°—Å—ã–ª–∫–∞: {property_url}" if property_url else ''}

üîç *–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ü–†–ï–î–ü–û–ß–¢–ï–ù–ò–Ø:*
‚Ä¢ –†–∞–π–æ–Ω: {preferred_district or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}
‚Ä¢ –ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}

{potential_cashback}üìÖ *–í–†–ï–ú–Ø –ó–ê–Ø–í–ö–ò:* {datetime.now().strftime('%d.%m.%Y –≤ %H:%M')}
üåê *–ò–°–¢–û–ß–ù–ò–ö:* –°—Ç—Ä–∞–Ω–∏—Ü–∞ –ñ–ö –Ω–∞ InBack.ru

üìã *–°–õ–ï–î–£–Æ–©–ò–ï –®–ê–ì–ò:*
1Ô∏è‚É£ –°–≤—è–∑–∞—Ç—å—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç
2Ô∏è‚É£ –ü–æ–∫–∞–∑–∞—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã –≤ –ñ–ö
3Ô∏è‚É£ –†–∞—Å—Å—á–∏—Ç–∞—Ç—å –∫—ç—à–±–µ–∫ –∏ —É—Å–ª–æ–≤–∏—è –ø–æ–∫—É–ø–∫–∏
4Ô∏è‚É£ –ù–∞–∑–Ω–∞—á–∏—Ç—å –≤—Å—Ç—Ä–µ—á—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞

‚ö° *–í–ê–ñ–ù–û:* –ö–ª–∏–µ–Ω—Ç –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç—Å—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –ñ–ö!"""
            else:
                telegram_message = f"""üè† *–ù–û–í–ê–Ø –ó–ê–Ø–í–ö–ê –ù–ê –ü–û–î–ë–û–† –ö–í–ê–†–¢–ò–†–´*

üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*
‚Ä¢ –ò–º—è: {name}
‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {phone}
‚Ä¢ Email: {email}

üîç *–ö–†–ò–¢–ï–†–ò–ò –ü–û–ò–°–ö–ê:*
‚Ä¢ –†–∞–π–æ–Ω: {preferred_district or '–õ—é–±–æ–π'}
‚Ä¢ –¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {property_type or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–Ω–∞—Ç: {room_count or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}
‚Ä¢ –ë—é–¥–∂–µ—Ç: {budget_range or '–ù–µ —É–∫–∞–∑–∞–Ω'}

{potential_cashback}üìÖ *–í–†–ï–ú–Ø –ó–ê–Ø–í–ö–ò:* {datetime.now().strftime('%d.%m.%Y –≤ %H:%M')}
üåê *–ò–°–¢–û–ß–ù–ò–ö:* –§–æ—Ä–º–∞ –Ω–∞ —Å–∞–π—Ç–µ InBack.ru

üìã *–°–õ–ï–î–£–Æ–©–ò–ï –®–ê–ì–ò:*
1Ô∏è‚É£ –°–≤—è–∑–∞—Ç—å—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç
2Ô∏è‚É£ –£—Ç–æ—á–Ω–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è
3Ô∏è‚É£ –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –ø–æ–¥–±–æ—Ä–∫—É –æ–±—ä–µ–∫—Ç–æ–≤
4Ô∏è‚É£ –ù–∞–∑–Ω–∞—á–∏—Ç—å –≤—Å—Ç—Ä–µ—á—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞

‚ö° *–í–ê–ñ–ù–û:* –ë—ã—Å—Ç—Ä–∞—è —Ä–µ–∞–∫—Ü–∏—è –ø–æ–≤—ã—à–∞–µ—Ç –∫–æ–Ω–≤–µ—Ä—Å–∏—é!"""
            
            send_telegram_message('730764738', telegram_message)
            
        except Exception as notify_error:
            print(f"Notification error: {notify_error}")
        
        return jsonify({
            'success': True,
            'message': '–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞! –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏.'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Application error: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏'})

def _find_lead_receiving_manager():
    """Find next manager from a role with can_receive_leads permission using round-robin."""
    from models import Manager, OrgRole
    
    lead_roles = OrgRole.query.filter_by(is_active=True, can_receive_leads=True).all()
    if not lead_roles:
        return None
    
    role_ids = [r.id for r in lead_roles]
    eligible_managers = Manager.query.filter(
        Manager.is_active == True,
        Manager.org_role_id.in_(role_ids)
    ).order_by(Manager.id).all()
    
    if not eligible_managers:
        return None
    
    if len(eligible_managers) == 1:
        return eligible_managers[0]
    
    from models import Deal
    from sqlalchemy import func
    deal_counts = db.session.query(
        Deal.manager_id, func.count(Deal.id).label('cnt')
    ).filter(
        Deal.manager_id.in_([m.id for m in eligible_managers]),
        Deal.source.isnot(None)
    ).group_by(Deal.manager_id).all()
    
    count_map = {row[0]: row[1] for row in deal_counts}
    min_count = float('inf')
    selected = eligible_managers[0]
    for m in eligible_managers:
        c = count_map.get(m.id, 0)
        if c < min_count:
            min_count = c
            selected = m
    
    return selected

def create_deal_from_website_form(name, phone, email=None, source='–ó–∞—è–≤–∫–∞ —Å —Å–∞–π—Ç–∞', 
                                    complex_name=None, property_price=0, cashback_amount=0,
                                    notes='', manager=None, quiz_data=None):
    """Create a User (if needed) and Deal from a website form submission.
    Returns (deal, user) tuple or (None, None) on failure."""
    from models import Deal, Manager, User, DealHistory
    from decimal import Decimal
    
    try:
        if not phone or not phone.strip():
            print("Cannot create deal from website form: phone is missing")
            return None, None
        
        phone_clean = phone.strip().replace(' ', '').replace('-', '').replace('(', '').replace(')', '')
        
        user = User.query.filter_by(phone=phone_clean).first()
        if not user:
            user = User.query.filter_by(phone=phone).first()
        if not user:
            user = User(
                phone=phone_clean,
                full_name=name.strip() if name else '–ö–ª–∏–µ–Ω—Ç',
                email=email.strip() if email else None,
                registration_source=source,
                client_status='–ù–æ–≤—ã–π'
            )
            db.session.add(user)
            db.session.flush()
        
        if quiz_data:
            if quiz_data.get('interest'):
                user.preferred_district = quiz_data['interest']
            if quiz_data.get('property_type'):
                user.property_type = quiz_data['property_type']
            if quiz_data.get('rooms'):
                user.room_count = quiz_data['rooms']
            if quiz_data.get('budget'):
                user.budget_range = quiz_data['budget']
            if quiz_data.get('timing'):
                user.timing = quiz_data['timing']
            if any(quiz_data.get(k) for k in ('interest', 'property_type', 'rooms', 'budget', 'timing')):
                user.quiz_completed = True
        
        if not manager:
            manager = _find_lead_receiving_manager()
        if not manager:
            manager = Manager.query.filter_by(is_active=True).first()
        
        if not manager:
            print(f"No active manager found for website form deal creation")
            return None, user
        
        if not user.assigned_manager_id:
            user.assigned_manager_id = manager.id
        
        deal = Deal(
            manager_id=manager.id,
            client_id=user.id,
            residential_complex_name=complex_name or '–ù–µ —É–∫–∞–∑–∞–Ω',
            property_price=Decimal(str(property_price)) if property_price else Decimal('0'),
            cashback_amount=Decimal(str(cashback_amount)) if cashback_amount else Decimal('0'),
            status='new',
            source=source,
            notes=notes
        )
        db.session.add(deal)
        db.session.flush()
        
        history = DealHistory(
            deal_id=deal.id,
            author_id=manager.id,
            action='deal_created',
            description=f'–°–¥–µ–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏–∑ —Ñ–æ—Ä–º—ã: {source}'
        )
        db.session.add(history)
        
        try:
            from models import ManagerNotification
            import json
            notification = ManagerNotification(
                manager_id=manager.id,
                title='–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ —Å —Å–∞–π—Ç–∞',
                message=f'–í–∞–º –Ω–∞–∑–Ω–∞—á–µ–Ω–∞ –Ω–æ–≤–∞—è —Å–¥–µ–ª–∫–∞ #{deal.deal_number} –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞ {user.full_name or user.phone}. –ò—Å—Ç–æ—á–Ω–∏–∫: {source}',
                notification_type='new_deal',
                extra_data=json.dumps({
                    'deal_id': deal.id,
                    'deal_number': deal.deal_number,
                    'client_name': user.full_name or '',
                    'client_phone': user.phone,
                    'source': source
                })
            )
            db.session.add(notification)
        except Exception as ne:
            print(f"Failed to create manager notification: {ne}")
        
        try:
            from telegram_bot import send_telegram_message
            tg_msg = (
                f"üÜï *–ù–û–í–ê–Ø –°–î–ï–õ–ö–ê –ù–ê–ó–ù–ê–ß–ï–ù–ê*\n\n"
                f"üìã –°–¥–µ–ª–∫–∞: #{deal.deal_number}\n"
                f"üë§ –ö–ª–∏–µ–Ω—Ç: {user.full_name or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}\n"
                f"üìû –¢–µ–ª–µ—Ñ–æ–Ω: {user.phone}\n"
                f"üåê –ò—Å—Ç–æ—á–Ω–∏–∫: {source}\n"
                f"üë®‚Äçüíº –ú–µ–Ω–µ–¥–∂–µ—Ä: {manager.full_name}\n"
            )
            if notes:
                tg_msg += f"üìù –ó–∞–º–µ—Ç–∫–∏: {notes}\n"
            send_telegram_message("730764738", tg_msg)
        except Exception as te:
            print(f"Failed to send deal Telegram notification: {te}")
        
        return deal, user
    except Exception as e:
        print(f"Error creating deal from website form: {e}")
        import traceback
        traceback.print_exc()
        return None, None

@app.route('/api/callback-request', methods=['POST'])
def api_callback_request():
    """Submit callback request"""
    from models import CallbackRequest, Manager
    data = request.get_json()
    
    try:
        # Extract data
        name = data.get('name', '').strip()
        phone = data.get('phone', '').strip()
        email = data.get('email', '').strip()
        preferred_time = data.get('preferred_time', '')
        notes = data.get('notes', '').strip()
        
        # Quiz responses
        district = data.get('district', '').strip()
        interest = data.get('interest', '')
        budget = data.get('budget', '')
        timing = data.get('timing', '')
        
        # Validation
        if not name or not phone:
            return jsonify({'success': False, 'error': '–ò–º—è –∏ —Ç–µ–ª–µ—Ñ–æ–Ω –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è'})
        
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –£–±–∏—Ä–∞–µ–º —Å—Ç—Ä–æ–≥—É—é –ø—Ä–æ–≤–µ—Ä–∫—É —Ä–∞–π–æ–Ω–∞, –¥–µ–ª–∞–µ–º optional
        if not district:
            district = '–ù–µ —É–∫–∞–∑–∞–Ω'
        
        # Create callback request
        callback_req = CallbackRequest(
            name=name,
            phone=phone,
            email=email or None,
            preferred_time=preferred_time,
            notes=notes,
            interest=interest,
            budget=budget,
            timing=timing
        )
        
        # Auto-assign to first available manager
        available_manager = Manager.query.filter_by(is_active=True).first()
        if available_manager:
            callback_req.assigned_manager_id = available_manager.id
        
        db.session.add(callback_req)
        
        form_notes_parts = []
        if interest: form_notes_parts.append(f"–ò–Ω—Ç–µ—Ä–µ—Å: {interest}")
        if budget: form_notes_parts.append(f"–ë—é–¥–∂–µ—Ç: {budget}")
        if timing: form_notes_parts.append(f"–°—Ä–æ–∫–∏: {timing}")
        if district and district != '–ù–µ —É–∫–∞–∑–∞–Ω': form_notes_parts.append(f"–†–∞–π–æ–Ω: {district}")
        if preferred_time: form_notes_parts.append(f"–í—Ä–µ–º—è –∑–≤–æ–Ω–∫–∞: {preferred_time}")
        if notes: form_notes_parts.append(f"–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {notes}")
        deal_notes = '; '.join(form_notes_parts) if form_notes_parts else ''
        
        quiz_info = {}
        if district and district != '–ù–µ —É–∫–∞–∑–∞–Ω': quiz_info['district'] = district
        if interest: quiz_info['interest'] = interest
        if budget: quiz_info['budget'] = budget
        if timing: quiz_info['timing'] = timing
        
        deal, _ = create_deal_from_website_form(
            name=name,
            phone=phone,
            email=email,
            source='–§–æ—Ä–º–∞ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –∑–≤–æ–Ω–∫–∞',
            notes=deal_notes,
            quiz_data=quiz_info if quiz_info else None
        )
        
        db.session.commit()
        
        if deal:
            print(f"‚úÖ Deal {deal.deal_number} created from callback request for {name}")
        
        try:
            send_callback_notification_email(callback_req, available_manager)
            send_callback_notification_telegram(callback_req, available_manager)
        except Exception as e:
            print(f"Failed to send callback notifications: {e}")
        
        return jsonify({
            'success': True,
            'message': '–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞! –ù–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Callback request error: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.'})

@csrf.exempt  # CSRF disabled for public presentation booking
@app.route('/api/booking', methods=['POST'])
def api_booking_request():
    """‚úÖ MIGRATED TO NORMALIZED TABLES: Submit booking request for property"""
    from models import BookingRequest, Manager
    
    try:
        data = request.get_json()
        
        # Validate required fields
        property_id = data.get('property_id')
        client_name = data.get('client_name')
        client_phone = data.get('client_phone')
        presentation_id = data.get('presentation_id')
        
        if not all([property_id, client_name, client_phone]):
            return jsonify({'success': False, 'error': '–ù–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω—ã'}), 400
        
        # ‚úÖ MIGRATED: Find property details using resolve_property_by_identifier (supports inner_id)
        property_detail, _ = resolve_property_by_identifier(property_id)
        if not property_detail:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Create booking request
        booking = BookingRequest()
        booking.property_id = property_id
        booking.client_name = client_name
        booking.client_phone = client_phone
        booking.client_email = data.get('client_email')
        booking.comment = data.get('comment')
        booking.presentation_id = presentation_id
        booking.property_price = property_detail.price
        booking.property_address = property_detail.address
        booking.complex_name = property_detail.residential_complex.name if property_detail.residential_complex else '–ù–µ —É–∫–∞–∑–∞–Ω'
        booking.rooms_count = property_detail.rooms
        booking.area = property_detail.area
        booking.status = 'new'
        
        db.session.add(booking)
        
        booking_notes = f"–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã –≤ {booking.complex_name}"
        if booking.comment:
            booking_notes += f"; –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {booking.comment}"
        
        deal, _ = create_deal_from_website_form(
            name=client_name,
            phone=client_phone,
            email=data.get('client_email'),
            source='–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ',
            complex_name=booking.complex_name,
            property_price=float(booking.property_price) if booking.property_price else 0,
            notes=booking_notes
        )
        
        db.session.commit()
        
        if deal:
            print(f"‚úÖ Deal {deal.deal_number} created from booking for {client_name}")
        
        try:
            send_booking_notifications(booking, property_detail)
        except Exception as notification_error:
            print(f"Notification error: {notification_error}")
        
        return jsonify({
            'success': True, 
            'message': '–ó–∞—è–≤–∫–∞ –Ω–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞!',
            'booking_id': booking.id
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Booking request error: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞—è–≤–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.'}), 500

def send_booking_notifications(booking, property_detail):
    """Send notifications to managers about new booking request"""
    from models import Manager
    
    # Get all active managers
    managers = Manager.query.filter_by(is_active=True).all()
    
    # Email notification (if configured)
    try:
        import smtplib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        
        subject = f"üè† –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ - {property_detail.complex_name}"
        
        # Prepare property details
        rooms_text = "–°—Ç—É–¥–∏—è" if property_detail.object_rooms == 0 else f"{property_detail.object_rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è"
        
        body = f"""
üè† –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã

üìã –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ö–õ–ò–ï–ù–¢–ï:
üë§ –ò–º—è: {booking.client_name}
üì± –¢–µ–ª–µ—Ñ–æ–Ω: {booking.client_phone}
üìß Email: {booking.client_email or '–Ω–µ —É–∫–∞–∑–∞–Ω'}
üí¨ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {booking.comment or '–Ω–µ—Ç'}

üè¢ –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ö–í–ê–†–¢–ò–†–ï:
üè† –ñ–ö: {property_detail.complex_name}
üè† –¢–∏–ø: {rooms_text} –∫–≤–∞—Ä—Ç–∏—Ä–∞
üìê –ü–ª–æ—â–∞–¥—å: {property_detail.area} –º¬≤
üè¢ –≠—Ç–∞–∂: {property_detail.floor}/{property_detail.total_floors}
üí∞ –¶–µ–Ω–∞: {'{:,}'.format(int(property_detail.price)).replace(',', ' ')} ‚ÇΩ
üìç –ê–¥—Ä–µ—Å: {property_detail.address_display_name}
üèóÔ∏è –ó–∞—Å—Ç—Ä–æ–π—â–∏–∫: {property_detail.developer_name}
üîó ID –æ–±—ä–µ–∫—Ç–∞: {booking.property_id}

üìÖ –î–∞—Ç–∞ –∑–∞—è–≤–∫–∏: {booking.created_at.strftime('%d.%m.%Y %H:%M')}
üÜî ID –∑–∞—è–≤–∫–∏: {booking.id}

‚è∞ –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º —Å–≤—è–∑–∞—Ç—å—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç!
        """.strip()
        
        for manager in managers:
            if manager.email:
                try:
                    send_email_notification(manager.email, subject, body)
                except Exception as email_error:
                    print(f"Failed to send email to {manager.email}: {email_error}")
                    
    except Exception as e:
        print(f"Email notification error: {e}")
    
    # Telegram notification (if bot configured)
    try:
        send_telegram_booking_notification(booking, property_detail, managers)
    except Exception as e:
        print(f"Telegram notification error: {e}")

def send_email_notification(email, subject, body):
    """Send email notification"""
    import smtplib
    from email.mime.text import MIMEText
    
    # Simple email sending (would need proper SMTP configuration in production)
    print(f"üìß Would send email to {email}: {subject}")
    print(f"Body: {body[:100]}...")

def send_telegram_booking_notification(booking, property_detail, managers):
    """Send Telegram notification to managers"""
    try:
        import requests
        
        bot_token = os.environ.get('TELEGRAM_BOT_TOKEN')
        if not bot_token:
            print("Telegram bot token not configured")
            return
        
        rooms_text = "–°—Ç—É–¥–∏—è" if property_detail.object_rooms == 0 else f"{property_detail.object_rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è"
        
        message = f"""
üè† <b>–ù–û–í–ê–Ø –ó–ê–Ø–í–ö–ê –ù–ê –ë–†–û–ù–ò–†–û–í–ê–ù–ò–ï</b>

üë§ <b>–ö–ª–∏–µ–Ω—Ç:</b> {booking.client_name}
üì± <b>–¢–µ–ª–µ—Ñ–æ–Ω:</b> {booking.client_phone}
üìß <b>Email:</b> {booking.client_email or '–Ω–µ —É–∫–∞–∑–∞–Ω'}

üè¢ <b>–ö–≤–∞—Ä—Ç–∏—Ä–∞:</b> {rooms_text}, {property_detail.area} –º¬≤
üè† <b>–ñ–ö:</b> {property_detail.complex_name}
üí∞ <b>–¶–µ–Ω–∞:</b> {'{:,}'.format(int(property_detail.price)).replace(',', ' ')} ‚ÇΩ
üìç <b>–ê–¥—Ä–µ—Å:</b> {property_detail.address_display_name}

üí¨ <b>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</b> {booking.comment or '–Ω–µ—Ç'}
üÜî <b>ID –∑–∞—è–≤–∫–∏:</b> {booking.id}

‚è∞ <b>–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º —Å–≤—è–∑–∞—Ç—å—Å—è –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç!</b>
        """.strip()
        
        # Send to managers with telegram_chat_id
        for manager in managers:
            if hasattr(manager, 'telegram_chat_id') and manager.telegram_chat_id:
                try:
                    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                    payload = {
                        'chat_id': manager.telegram_chat_id,
                        'text': message,
                        'parse_mode': 'HTML'
                    }
                    requests.post(url, data=payload, timeout=5)
                    print(f"üì± Telegram notification sent to manager {manager.name}")
                except Exception as telegram_error:
                    print(f"Failed to send Telegram to manager {manager.name}: {telegram_error}")
                    
    except Exception as e:
        print(f"Telegram notification setup error: {e}")

@app.route('/api/cashback-application', methods=['POST'])
@login_required
def create_cashback_application():
    """Create new cashback application"""
    from models import CashbackApplication
    data = request.get_json()
    
    try:
        app = CashbackApplication(
            user_id=current_user.id,
            property_name=data['property_name'],
            property_type=data['property_type'],
            property_size=float(data['property_size']),
            property_price=int(data['property_price']),
            complex_name=data['complex_name'],
            developer_name=data['developer_name'],
            cashback_amount=int(data['cashback_amount']),
            cashback_percent=float(data['cashback_percent'])
        )
        db.session.add(app)
        db.session.commit()
        
        return jsonify({'success': True, 'application_id': app.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/contact-manager', methods=['POST'])
@csrf.exempt  # CSRF disabled - –æ—Ç–∫–ª—é—á–µ–Ω–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞—è–≤–æ–∫
def contact_manager():
    """API endpoint for contacting manager"""
    try:
        from models import Application
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'No data provided'}), 400
        
        # Validate required fields
        required_fields = ['name', 'phone']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'success': False, 'error': f'Field {field} is required'}), 400
        
        # Get current user if logged in
        user_id = session.get('user_id')
        
        # Create application with required fields
        application = Application(
            user_id=user_id,
            contact_name=data.get('name'),
            contact_email=data.get('email'),
            contact_phone=data.get('phone'),
            property_name=data.get('property_name', '–ó–∞—è–≤–∫–∞ –Ω–∞ –ø–æ–¥–±–æ—Ä –∂–∏–ª—å—è'),
            complex_name=data.get('complex_name', '–ü–æ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è–º –∫–ª–∏–µ–Ω—Ç–∞'),
            status='new',
            message=data.get('message', f"–¶–µ–ª—å: {data.get('interest', '')}, –¢–∏–ø: {data.get('property_type', '')}, –ö–æ–º–Ω–∞—Ç: {data.get('rooms', '')}, –ó–∞—Å–µ–ª–µ–Ω–∏–µ: {data.get('completion', '')}, –û–ø–ª–∞—Ç–∞: {data.get('payment', '')}"),
            preferred_contact=data.get('preferred_contact', 'phone')
        )
        
        db.session.add(application)
        
        contact_notes_parts = []
        if data.get('property_name') and data.get('property_name') != '–ó–∞—è–≤–∫–∞ –Ω–∞ –ø–æ–¥–±–æ—Ä –∂–∏–ª—å—è':
            contact_notes_parts.append(f"–û–±—ä–µ–∫—Ç: {data.get('property_name')}")
        if data.get('message'):
            contact_notes_parts.append(data.get('message'))
        deal_notes = '; '.join(contact_notes_parts) if contact_notes_parts else ''
        
        quiz_info = {}
        if data.get('interest'): quiz_info['interest'] = data['interest']
        if data.get('property_type'): quiz_info['property_type'] = data['property_type']
        if data.get('district'): quiz_info['district'] = data['district']
        if data.get('rooms'): quiz_info['rooms'] = data['rooms']
        if data.get('completion'): quiz_info['timing'] = data['completion']
        if data.get('payment'): quiz_info['budget'] = data['payment']
        if data.get('budget'): quiz_info['budget'] = data['budget']
        
        deal, _ = create_deal_from_website_form(
            name=data.get('name'),
            phone=data.get('phone'),
            email=data.get('email'),
            source='–ó–∞—è–≤–∫–∞ –Ω–∞ –ø–æ–¥–±–æ—Ä',
            complex_name=data.get('complex_name', '–ü–æ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è–º –∫–ª–∏–µ–Ω—Ç–∞'),
            property_price=float(data.get('property_price', 0)) if data.get('property_price') else 0,
            notes=deal_notes,
            quiz_data=quiz_info if quiz_info else None
        )
        
        db.session.commit()
        
        if deal:
            print(f"‚úÖ Deal {deal.deal_number} created from contact form for {data.get('name')}")
        
        try:
            from email_service import send_manager_notification
            send_manager_notification(
                name=data.get('name'),
                phone=data.get('phone'),
                email=data.get('email'),
                message=data.get('message', ''),
                application_id=application.id
            )
        except Exception as e:
            print(f"Failed to send manager notification email: {e}")
            
        # Send Telegram notification
        try:
            from telegram_bot import send_telegram_message
            from datetime import datetime
            
            # Check if this is for a specific property
            is_specific_property = data.get('property_id') and data.get('property_name')
            
            # Prepare Telegram message with quiz data or property info
            if is_specific_property:
                message_parts = [
                    "üè† *–ó–ê–Ø–í–ö–ê –ù–ê –ü–†–û–°–ú–û–¢–† –ö–û–ù–ö–†–ï–¢–ù–û–ô –ö–í–ê–†–¢–ò–†–´*",
                    "",
                    "üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*",
                    f"‚Ä¢ –ò–º—è: {data.get('name')}",
                    f"‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {data.get('phone')}",
                ]
                
                if data.get('email'):
                    message_parts.append(f"‚Ä¢ Email: {data.get('email')}")
                    
                message_parts.extend([
                    "",
                    "üè¢ *–ò–ù–¢–ï–†–ï–°–£–Æ–©–ê–Ø –ö–í–ê–†–¢–ò–†–ê:*",
                    f"‚Ä¢ –û–±—ä–µ–∫—Ç: {data.get('property_name')}",
                ])
                
                if data.get('complex_name'):
                    message_parts.append(f"‚Ä¢ –ñ–ö: {data.get('complex_name')}")
                if data.get('property_price'):
                    price_formatted = f"{int(float(data.get('property_price'))):,}".replace(',', ' ')
                    message_parts.append(f"‚Ä¢ –¶–µ–Ω–∞: {price_formatted} —Ä—É–±.")
                if data.get('property_area'):
                    message_parts.append(f"‚Ä¢ –ü–ª–æ—â–∞–¥—å: {data.get('property_area')} –º¬≤")
                if data.get('property_floor'):
                    message_parts.append(f"‚Ä¢ –≠—Ç–∞–∂: {data.get('property_floor')}")
                if data.get('property_district'):
                    message_parts.append(f"‚Ä¢ –†–∞–π–æ–Ω: {data.get('property_district')}")
                if data.get('property_address'):
                    message_parts.append(f"‚Ä¢ –ê–¥—Ä–µ—Å: {data.get('property_address')}")
                    
                # Calculate potential cashback
                if data.get('property_price'):
                    try:
                        price = float(data.get('property_price'))
                        cashback = price * 0.03  # 3% cashback
                        cashback_formatted = f"{int(cashback):,}".replace(',', ' ')
                        message_parts.append(f"üí∞ –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫: {cashback_formatted} —Ä—É–±. (3%)")
                    except:
                        pass
                        
                # Add property URL if available
                if data.get('property_url'):
                    message_parts.extend([
                        "",
                        f"üîó *–°–°–´–õ–ö–ê –ù–ê –ö–í–ê–†–¢–ò–†–£:*",
                        f"{data.get('property_url')}"
                    ])
            else:
                message_parts = [
                    "üè† *–ù–û–í–ê–Ø –ó–ê–Ø–í–ö–ê –ù–ê –ü–û–î–ë–û–† –ñ–ò–õ–¨–Ø*",
                    "",
                    "üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*",
                    f"‚Ä¢ –ò–º—è: {data.get('name')}",
                    f"‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {data.get('phone')}",
                ]
                
                if data.get('email'):
                    message_parts.append(f"‚Ä¢ Email: {data.get('email')}")
                    
                # Add quiz preferences if available
                if data.get('district'):
                    message_parts.extend([
                        "",
                        "üèòÔ∏è *–ü–†–ï–î–ü–û–ß–¢–ï–ù–ò–Ø –ö–õ–ò–ï–ù–¢–ê:*",
                        f"‚Ä¢ –†–∞–π–æ–Ω: {data.get('district')}"
                    ])
                    
                if data.get('rooms'):
                    message_parts.append(f"‚Ä¢ –ö–æ–º–Ω–∞—Ç: {data.get('rooms')}")
                    
                if data.get('completion'):
                    message_parts.append(f"‚Ä¢ –°—Ä–æ–∫ –∑–∞—Å–µ–ª–µ–Ω–∏—è: {data.get('completion')}")
                    
                if data.get('payment'):
                    message_parts.append(f"‚Ä¢ –°–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã: {data.get('payment')}")
                
            message_parts.extend([
                "",
                f"üìù *ID –∑–∞—è–≤–∫–∏:* #{application.id}",
                f"üìÖ *–í—Ä–µ–º—è:* {datetime.now().strftime('%d.%m.%Y %H:%M')}",
                "",
                "‚ö° *–í–ê–ñ–ù–û:* –ë—ã—Å—Ç—Ä–∞—è —Ä–µ–∞–∫—Ü–∏—è –ø–æ–≤—ã—à–∞–µ—Ç –∫–æ–Ω–≤–µ—Ä—Å–∏—é!"
            ])
            
            telegram_message = "\n".join(message_parts)
            
            # Send to all manager telegram IDs from environment variable
            manager_telegram_ids = os.environ.get('MANAGER_TELEGRAM_IDS', '').split(',')
            for manager_id in manager_telegram_ids:
                manager_id = manager_id.strip()
                if manager_id:
                    send_telegram_message(manager_id, telegram_message)
            
        except Exception as notify_error:
            print(f"Telegram notification error: {notify_error}")
        
        return jsonify({
            'success': True,
            'message': '–ó–∞—è–≤–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞! –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.',
            'application_id': application.id
        })
        
    except Exception as e:
        print(f"Error creating manager contact application: {e}")
        db.session.rollback()
        return jsonify({'success': False, 'error': 'Internal server error'}), 500

@app.route('/api/favorites', methods=['POST'])
@login_required  
# @csrf.exempt  # CSRF disabled  # Disable CSRF for API endpoint
def add_to_favorites():
    """Add property to favorites"""
    from models import FavoriteProperty
    data = request.get_json()
    
    # Check if already in favorites
    existing = FavoriteProperty.query.filter_by(
        user_id=current_user.id,
        property_name=data['property_name']
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': '–£–∂–µ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º'})
    
    try:
        favorite = FavoriteProperty(
            user_id=current_user.id,
            property_name=data['property_name'],
            property_type=data['property_type'],
            property_size=float(data['property_size']),
            property_price=int(data['property_price']),
            complex_name=data['complex_name'],
            developer_name=data['developer_name'],
            property_image=data.get('property_image'),
            cashback_amount=int(data.get('cashback_amount', 0)),
            cashback_percent=float(data.get('cashback_percent', 0))
        )
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/favorites/<property_id>', methods=['DELETE'])
@login_required
@csrf.exempt  # ‚úÖ FIXED: CSRF protection removed for delete action as requested
def remove_from_favorites(property_id):
    """Remove property from favorites"""
    from models import FavoriteProperty
    
    favorite = FavoriteProperty.query.filter_by(
        user_id=current_user.id,
        property_id=property_id
    ).first()
    
    if favorite:
        try:
            db.session.delete(favorite)
            db.session.commit()
            return jsonify({'success': True})
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)}), 400
    else:
        return jsonify({'success': False, 'error': 'Favorite not found'}), 404

def send_view_notification_to_manager(presentation, view):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –º–µ–Ω–µ–¥–∂–µ—Ä—É –æ –Ω–æ–≤–æ–º –ø—Ä–æ—Å–º–æ—Ç—Ä–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏"""
    try:
        manager = presentation.created_by
        if not manager:
            print(f"Manager not found for presentation {presentation.id}")
            return
            
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ
        client_info = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–ª–∏–µ–Ω—Ç"
        if presentation.client_name:
            client_info = presentation.client_name
        elif presentation.client_phone:
            client_info = presentation.client_phone
            
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        notification_text = f"""üìä –ù–æ–≤—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏!

üìã "{presentation.title}"
üë§ –ö–ª–∏–µ–Ω—Ç: {client_info}
üî¢ –í—Å–µ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤: {presentation.view_count}
‚è∞ –í—Ä–µ–º—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞: {view.viewed_at.strftime('%d.%m.%Y %H:%M')}
üåê IP: {view.view_ip}
üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ: {view.user_agent[:50] + '...' if view.user_agent and len(view.user_agent) > 50 else view.user_agent or '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}

üëÄ –°—Å—ã–ª–∫–∞ –Ω–∞ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é: {request.url_root}presentation/modern/{presentation.unique_url}
üéØ –ü–∞–Ω–µ–ª—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {request.url_root}manager/dashboard"""

        # TODO: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Telegram Bot API
        # if hasattr(manager, 'telegram_chat_id') and manager.telegram_chat_id:
        #     send_telegram_notification(manager.telegram_chat_id, notification_text)
        
        # TODO: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Email
        # if manager.email:
        #     send_email_notification(manager.email, f"–ù–æ–≤—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä: {presentation.title}", notification_text)
        
        # –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        print(f"üìß NOTIFICATION TO MANAGER {manager.email}:")
        print(notification_text)
        print("-" * 50)
        
        # –û—Ç–º–µ—á–∞–µ–º —á—Ç–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ
        view.notification_sent = True
        db.session.commit()
        
    except Exception as e:
        print(f"Error in send_view_notification_to_manager: {e}")

@app.route('/presentation/<string:unique_url>')
def redirect_old_presentation_url(unique_url):
    """–†–µ–¥–∏—Ä–µ–∫—Ç —Å–æ —Å—Ç–∞—Ä–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ URL –Ω–∞ –Ω–æ–≤—ã–π –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏"""
    return redirect(url_for('view_presentation', unique_id=unique_url), code=301)

@app.route('/presentation/view/<string:unique_id>')
def view_presentation(unique_id):
    """–ü—É–±–ª–∏—á–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ"""
    print(f"üî• ROUTE HIT: /presentation/view/{unique_id}")
    print(f"üî• CLIENT IP: {request.remote_addr}")
    print(f"üî• USER AGENT: {request.headers.get('User-Agent', 'Unknown')}")
    from models import Collection, CollectionProperty, PresentationView
    
    # –ù–∞—Ö–æ–¥–∏–º –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ
    presentation = Collection.query.filter_by(
        unique_url=unique_id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return render_template('error.html', 
                             error="–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", 
                             message="–í–æ–∑–º–æ–∂–Ω–æ, —Å—Å—ã–ª–∫–∞ —É—Å—Ç–∞—Ä–µ–ª–∞ –∏–ª–∏ –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞"), 404
    
    # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –ø—Ä–æ—Å–º–æ—Ç—Ä
    try:
        view = PresentationView(
            collection_id=presentation.id,
            view_ip=request.remote_addr,
            user_agent=request.headers.get('User-Agent'),
            referer=request.headers.get('Referer')
        )
        db.session.add(view)
        
        # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤ (–±–µ–∑ –∞–≤—Ç–æ–∫–æ–º–º–∏—Ç–∞)
        presentation.increment_view_count()
        db.session.commit()  # –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –Ω–∞ —É—Ä–æ–≤–Ω–µ view
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –º–µ–Ω–µ–¥–∂–µ—Ä—É –æ –Ω–æ–≤–æ–º –ø—Ä–æ—Å–º–æ—Ç—Ä–µ
        try:
            send_view_notification_to_manager(presentation, view)
        except Exception as e:
            print(f"Error sending view notification: {e}")
        
    except Exception as e:
        db.session.rollback()
        print(f"Error recording presentation view: {e}")
    
    print("DEBUG: Starting data loading phase...")
    
    # ‚úÖ MIGRATED: Load properties using PostgreSQL (same as manager version)
    try:
        print("DEBUG: Loading presentation data from PostgreSQL...")
        enriched_properties = _load_presentation_properties_from_db(presentation.id)
        print(f"DEBUG: Loaded {len(enriched_properties)} enriched properties")
    except Exception as e:
        print(f"ERROR: Failed to load presentation data: {e}")
        import traceback
        traceback.print_exc()
        # Fallback to empty list to allow page rendering
        print("FALLBACK: Using empty data to allow page rendering")
        enriched_properties = []
    
    print(f"DEBUG: About to render template with {len(enriched_properties)} enriched properties")
    print(f"DEBUG: Presentation object: {presentation}")
    print(f"DEBUG: First property sample: {enriched_properties[0] if enriched_properties else 'No properties'}")
    
    # Format presentation data for template (same structure as manager version)
    presentation_data = {
        'id': presentation.id,
        'title': presentation.title,
        'description': presentation.description,
        'client_name': presentation.client_name,
        'client_phone': presentation.client_phone,
        'status': presentation.status,
        'created_at': presentation.created_at,
        'view_count': presentation.view_count,
        'last_viewed_at': presentation.last_viewed_at,
        'properties_count': len(enriched_properties),
        'properties': enriched_properties,
        'unique_url': presentation.unique_url
    }
    
    try:
        print(f"üî• RENDERING: presentation_view.html with {len(enriched_properties)} properties")
        print(f"üî• PRESENTATION: {presentation_data['title']}")
        print(f"üî• VIEW COUNT: {presentation_data['view_count']}")
        
        template_result = render_template('presentation_view.html', 
                                        presentation=presentation_data,
                                        properties=enriched_properties,
                                        manager=presentation.created_by)
        print("üî• TEMPLATE RENDERED: presentation_view.html success!")
        return template_result
    except Exception as e:
        print(f"ERROR in view_presentation template rendering: {e}")
        import traceback
        traceback.print_exc()
        return f"Template rendering error: {str(e)}", 500

@app.route('/presentation/modern/<string:unique_id>')
def view_modern_presentation(unique_id):
    """–°–æ–≤—Ä–µ–º–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –ø—É–±–ª–∏—á–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏"""
    from models import Collection, CollectionProperty, PresentationView, ManagerNotification
    
    try:
        # –ù–∞—Ö–æ–¥–∏–º –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ
        presentation = Collection.query.filter_by(
            unique_url=unique_id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return render_template('error.html', 
                                 error="–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", 
                                 message="–í–æ–∑–º–æ–∂–Ω–æ, —Å—Å—ã–ª–∫–∞ —É—Å—Ç–∞—Ä–µ–ª–∞ –∏–ª–∏ –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞"), 404
        
        print(f"DEBUG: view_modern_presentation - Found presentation ID: {presentation.id}")
        
        # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –ø—Ä–æ—Å–º–æ—Ç—Ä
        try:
            view = PresentationView(
                collection_id=presentation.id,
                view_ip=request.remote_addr,
                user_agent=request.headers.get('User-Agent'),
                referer=request.headers.get('Referer')
            )
            db.session.add(view)
            presentation.increment_view_count()
            
            # –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞
            manager_id = presentation.created_by_manager_id
            client_name = presentation.client_name or '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–ª–∏–µ–Ω—Ç'
            presentation_title = presentation.title or '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è'
            view_ip = request.remote_addr or '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π IP'
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            notification_title = f"–ü—Ä–æ—Å–º–æ—Ç—Ä –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏: {presentation_title}"
            notification_message = f"–ö–ª–∏–µ–Ω—Ç {client_name} –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–ª –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é \"{presentation_title}\". IP –∞–¥—Ä–µ—Å: {view_ip}"
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –≤ JSON
            extra_data = {
                'client_name': client_name,
                'presentation_title': presentation_title,
                'view_ip': view_ip,
                'user_agent': request.headers.get('User-Agent', ''),
                'referer': request.headers.get('Referer', ''),
                'presentation_url': f"/presentation/modern/{presentation.unique_url}",
                'view_count': presentation.view_count + 1  # +1 —Ç–∞–∫ –∫–∞–∫ –µ—â–µ –Ω–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏
            }
            
            # –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            notification = ManagerNotification(
                manager_id=manager_id,
                title=notification_title,
                message=notification_message,
                notification_type='presentation_view',
                presentation_id=presentation.id
            )
            notification.set_extra_data(extra_data)
            
            db.session.add(notification)
            db.session.commit()
            
            print(f"‚úÖ Created notification for manager {manager_id}: {notification_title}")
            
        except Exception as e:
            db.session.rollback()
            print(f"Error recording presentation view or creating notification: {e}")
            import traceback
            traceback.print_exc()
        
        print(f"DEBUG: view_modern_presentation - Starting property loading")
        
        # ‚úÖ MIGRATED: Get property data using repository
        enriched_properties = []
        all_complexes = {}  # –°–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—Å–µ—Ö —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ñ–ö
        
        for prop in presentation.properties:
            # Load property - try inner_id first, then database ID (same as manager API)
            from models import Property as PropertyModel
            from sqlalchemy.orm import joinedload
            property_obj_orm = PropertyModel.query.options(
                joinedload(PropertyModel.residential_complex),
                joinedload(PropertyModel.developer),
                joinedload(PropertyModel.district)
            ).filter_by(inner_id=prop.property_id).first()
            
            if not property_obj_orm:
                try:
                    property_id_int = int(prop.property_id)
                    property_obj_orm = PropertyModel.query.options(
                        joinedload(PropertyModel.residential_complex),
                        joinedload(PropertyModel.developer),
                        joinedload(PropertyModel.district)
                    ).get(property_id_int)
                except (ValueError, TypeError):
                    pass
            
            if property_obj_orm:
                # Get cashback rate from complex
                cashback_rate = property_obj_orm.residential_complex.cashback_rate if property_obj_orm.residential_complex else 5.0
                
                # Parse photos
                photos = []
                if property_obj_orm.gallery_images:
                    try:
                        import json
                        if isinstance(property_obj_orm.gallery_images, str):
                            if property_obj_orm.gallery_images.startswith('['):
                                photos = json.loads(property_obj_orm.gallery_images)
                            elif property_obj_orm.gallery_images.startswith('http'):
                                photos = [url.strip() for url in property_obj_orm.gallery_images.split(',') if url.strip()]
                        elif isinstance(property_obj_orm.gallery_images, list):
                            photos = property_obj_orm.gallery_images
                    except Exception as e:
                        photos = []
                
                # Format title
                rooms_text = ""
                if property_obj_orm.rooms == 0:
                    rooms_text = "–°—Ç—É–¥–∏—è"
                elif property_obj_orm.rooms:
                    rooms_text = f"{property_obj_orm.rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"
                else:
                    rooms_text = "–ö–≤–∞—Ä—Ç–∏—Ä–∞"
                
                # Calculate cashback
                cashback_amount = int((property_obj_orm.price or 0) * cashback_rate / 100)
                
                # Format property object for template
                property_obj = {
                    'property_id': property_obj_orm.inner_id,
                    'title': rooms_text,
                    'rooms': property_obj_orm.rooms or 0,
                    'area': property_obj_orm.area or 0,
                    'price': property_obj_orm.price or 0,
                    'floor': property_obj_orm.floor or 1,
                    'total_floors': property_obj_orm.total_floors or property_obj_orm.floor or 1,
                    'address': property_obj_orm.address or '',
                    'images': photos,
                    'complex_name': property_obj_orm.residential_complex.name if property_obj_orm.residential_complex else '',
                    'developer_name': property_obj_orm.developer.name if property_obj_orm.developer else '',
                    'deadline': '',
                    'renovation_type': property_obj_orm.renovation_type or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                    'housing_class': property_obj_orm.residential_complex.object_class_display_name if property_obj_orm.residential_complex else '–ö–æ–º—Ñ–æ—Ä—Ç',
                    'cashback_percent': cashback_rate,
                    'cashback_amount': cashback_amount,
                    'manager_note': prop.manager_note if hasattr(prop, 'manager_note') else None
                }
                
                # Format deadline
                if property_obj_orm.residential_complex and property_obj_orm.residential_complex.end_build_year and property_obj_orm.residential_complex.end_build_quarter:
                    quarters = ['I', 'II', 'III', 'IV']
                    quarter_text = quarters[property_obj_orm.residential_complex.end_build_quarter - 1] if property_obj_orm.residential_complex.end_build_quarter <= 4 else 'IV'
                    property_obj['deadline'] = f"{quarter_text} –∫–≤. {property_obj_orm.residential_complex.end_build_year} –≥."
                
                enriched_properties.append(property_obj)
                
                # Collect unique complexes
                if property_obj_orm.residential_complex:
                    complex_key = property_obj_orm.residential_complex.name
                    if complex_key not in all_complexes:
                        all_complexes[complex_key] = {
                            'name': property_obj_orm.residential_complex.name,
                            'developer': property_obj_orm.developer.name if property_obj_orm.developer else '',
                            'address': property_obj_orm.address or '',
                            'end_year': property_obj_orm.residential_complex.end_build_year,
                            'end_quarter': property_obj_orm.residential_complex.end_build_quarter,
                            'photos': [],
                            'lat': float(property_obj_orm.latitude) if property_obj_orm.latitude else None,
                            'lon': float(property_obj_orm.longitude) if property_obj_orm.longitude else None,
                            'cashback_rate': cashback_rate
                        }
        
        # ‚úÖ MIGRATED: –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–æ–º–ø–ª–µ–∫—Å–∞ –∏–∑ normalized tables
        for complex_name in all_complexes.keys():
            # –ù–∞—Ö–æ–¥–∏–º –æ–±—ä–µ–∫—Ç—ã —ç—Ç–æ–≥–æ –∫–æ–º–ø–ª–µ–∫—Å–∞ —Å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è–º–∏
            complex_photos = []
            complex_properties = PropertyRepository.get_all_active(
                filters={'residential_complex': complex_name},
                limit=10
            )
            
            for prop in complex_properties:
                if prop.gallery_images:
                    try:
                        import json
                        prop_photos = []
                        if isinstance(prop.gallery_images, str) and prop.gallery_images.startswith('['):
                            prop_photos = json.loads(prop.gallery_images)
                        elif isinstance(prop.gallery_images, list):
                            prop_photos = prop.gallery_images
                        elif isinstance(prop.gallery_images, str) and prop.gallery_images.startswith('http'):
                            prop_photos = [url.strip() for url in prop.gallery_images.split(',') if url.strip()]
                        
                        # –î–æ–±–∞–≤–ª—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏
                        for photo in prop_photos:
                            if photo not in complex_photos:
                                complex_photos.append(photo)
                                if len(complex_photos) >= 10:  # –ú–∞–∫—Å–∏–º—É–º 10 —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –Ω–∞ –∫–æ–º–ø–ª–µ–∫—Å
                                    break
                        
                        if len(complex_photos) >= 10:
                            break
                            
                    except Exception as e:
                        continue
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –∫–æ–º–ø–ª–µ–∫—Å–∞
            all_complexes[complex_name]['photos'] = complex_photos
        
        print(f"DEBUG: view_modern_presentation - Loaded {len(enriched_properties)} properties")
        
        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Å–≤–æ–¥–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
        total_complexes = len(all_complexes)
        complex_names = list(all_complexes.keys())
        
        print(f"DEBUG: view_modern_presentation - Rendering template")
        
        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —à–∞–±–ª–æ–Ω–∞
        presentation_data = {
            'id': presentation.id,
            'unique_url': presentation.unique_url,
            'title': presentation.title,
            'client_name': presentation.client_name,
            'description': presentation.description,
            'created_at': presentation.created_at,
            'properties': enriched_properties,
            'total_objects': len(enriched_properties),
            'total_complexes': total_complexes,
            'complex_names': complex_names,
            'all_complexes': all_complexes
        }
        
        return render_template('modern_presentation_view.html', presentation=presentation_data)
        
    except Exception as e:
        print(f"ERROR in view_modern_presentation: {e}")
        import traceback
        traceback.print_exc()
        
        # Return detailed error for debugging
        return render_template('error.html',
                             error="–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏",
                             message=f"–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è: {str(e)}"), 500
@app.route('/api/manager/presentation/<int:presentation_id>/share', methods=['POST'])
@csrf.exempt
@manager_required
def share_presentation(presentation_id):
    """–ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –≤ –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä—ã (–±–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    from models import Collection
    from flask_login import current_user
    import urllib.parse
    
    current_manager = current_user
    
    print(f"DEBUG: share_presentation - presentation_id: {presentation_id}")
    print(f"DEBUG: share_presentation - current_user: {current_user}")
    print(f"DEBUG: share_presentation - current_manager.id: {current_manager.id}")
    print(f"DEBUG: share_presentation - request.method: {request.method}")
    print(f"DEBUG: share_presentation - request.content_type: {request.content_type}")
    
    try:
        data = request.get_json() or {}  # –ü—É—Å—Ç–æ–π JSON –≤–∞–ª–∏–¥–µ–Ω
        print(f"DEBUG: share_presentation - request data: {data}")
    except Exception as e:
        print(f"DEBUG: share_presentation - JSON parsing error: {e}")
        return jsonify({'success': False, 'error': f'Invalid JSON: {str(e)}'}), 400
    
    # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
    print(f"DEBUG: share_presentation - current_user.email: {getattr(current_user, 'email', 'Not authenticated')}")
    
    print(f"DEBUG: share_presentation - Looking for presentation {presentation_id} by manager {current_manager.id}")
    
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_manager.id,
        collection_type='presentation'
    ).first()
    
    print(f"DEBUG: share_presentation - Found presentation: {presentation}")
    
    if not presentation:
        # Try to find presentation regardless of owner for debugging
        any_presentation = Collection.query.filter_by(
            id=presentation_id,
            collection_type='presentation'
        ).first()
        print(f"DEBUG: share_presentation - Any presentation with this ID: {any_presentation}")
        if any_presentation:
            print(f"DEBUG: share_presentation - Presentation exists but belongs to manager {any_presentation.created_by_manager_id}")
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404
    
    client_name = data.get('client_name', presentation.client_name)
    print(f"DEBUG: share_presentation - Client name: {client_name}")
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –∏–º—è –∫–ª–∏–µ–Ω—Ç–∞ –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–æ
    if client_name and client_name != presentation.client_name:
        print(f"DEBUG: share_presentation - Updating client name from '{presentation.client_name}' to '{client_name}'")
        presentation.client_name = client_name
        db.session.commit()
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É
    base_url = request.url_root.rstrip('/')
    presentation_url = f"{base_url}/presentation/modern/{presentation.unique_url}"
    print(f"DEBUG: share_presentation - Presentation URL: {presentation_url}")
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
    properties_count = len(presentation.properties) if presentation.properties else 0
    print(f"DEBUG: share_presentation - Properties count: {properties_count}")
    
    # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–ª–µ—Ñ–æ–Ω –º–µ–Ω–µ–¥–∂–µ—Ä–∞
    manager_phone = current_user.phone if hasattr(current_user, 'phone') and current_user.phone else None
    manager_name = f"{current_user.first_name} {current_user.last_name}" if hasattr(current_user, 'first_name') and hasattr(current_user, 'last_name') else "–ú–µ–Ω–µ–¥–∂–µ—Ä InBack"
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–æ–Ω—Ç–∞–∫—Ç–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
    if manager_phone:
        contact_info = f"üë§ {manager_name}\nüìû {manager_phone}"
    else:
        contact_info = "üìû +7 (XXX) XXX-XX-XX"
    
    message_text = f"""üè† –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –æ—Ç InBack

üìã {presentation.title}
{f'üë§ –î–ª—è: {client_name}' if client_name else ''}

üî¢ –ü–æ–¥–æ–±—Ä–∞–Ω–æ –æ–±—ä–µ–∫—Ç–æ–≤: {properties_count}
üìÖ –°–æ–∑–¥–∞–Ω–æ: {presentation.created_at.strftime('%d.%m.%Y')}

üëÄ –°–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é:
{presentation_url}

üí¨ –ï—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã? –°–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏!
{contact_info}"""
    
    response_data = {
        'success': True,
        'share_url': presentation_url,
        'share_data': {
            'presentation_url': presentation_url,
            'message_text': message_text,
            'whatsapp_url': f"https://wa.me/?text={urllib.parse.quote(message_text)}",
            'telegram_url': f"https://t.me/share/url?url={presentation_url}&text={urllib.parse.quote(presentation.title)}",
            'client_name': client_name or '–ö–ª–∏–µ–Ω—Ç',
            'properties_count': properties_count
        }
    }
    
    print(f"DEBUG: share_presentation - Returning response: {response_data}")
    return jsonify(response_data)

@app.route('/api/favorites/toggle', methods=['POST'])
def toggle_favorite():
    """Toggle favorite status for property - works for both authenticated and guest users"""
    from models import FavoriteProperty
    from services.guest_session import toggle_guest_favorite
    data = request.get_json()
    property_id = data.get('property_id')
    
    if not property_id:
        return jsonify({'success': False, 'error': 'property_id required'}), 400
    
    if not current_user.is_authenticated:
        action, is_fav = toggle_guest_favorite(property_id)
        return jsonify({'success': True, 'action': action, 'is_favorite': is_fav})
    
    print(f"DEBUG: Favorites toggle called by user {getattr(current_user, 'id', 'not_authenticated')} for property {property_id}")
    
    existing = FavoriteProperty.query.filter_by(
        user_id=current_user.id,
        property_id=property_id
    ).first()
    
    try:
        if existing:
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'action': 'removed', 'is_favorite': False})
        else:
            favorite = FavoriteProperty(
                user_id=current_user.id,
                property_id=property_id,
                property_name=data.get('property_name', ''),
                property_type=data.get('property_type', ''),
                property_size=float(data.get('property_size', 0)),
                property_price=int(data.get('property_price', 0)),
                complex_name=data.get('complex_name', ''),
                developer_name=data.get('developer_name', ''),
                property_image=data.get('property_image'),
                cashback_amount=int(data.get('cashback_amount', 0)),
                cashback_percent=float(data.get('cashback_percent', 0))
            )
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'action': 'added', 'is_favorite': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400



@app.route('/api/collections', methods=['POST'])
@login_required
def create_collection():
    """Create new property collection"""
    from models import Collection
    data = request.get_json()
    
    try:
        collection = Collection(
            user_id=current_user.id,
            title=data['name'],
            description=data.get('description'),
            image_url=data.get('image_url'),
            category=data.get('category')
        )
        db.session.add(collection)
        db.session.commit()
        
        return jsonify({'success': True, 'collection_id': collection.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/collections/<int:collection_id>', methods=['DELETE'])
@login_required
def delete_collection(collection_id):
    """Delete a collection"""
    from models import Collection
    collection = Collection.query.filter_by(
        id=collection_id,
        user_id=current_user.id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    try:
        db.session.delete(collection)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/documents/upload', methods=['POST'])
@login_required
def upload_documents():
    """Upload documents"""
    from models import Document
    import os
    from werkzeug.utils import secure_filename
    from datetime import datetime
    
    if 'files' not in request.files:
        return jsonify({'success': False, 'error': '–ù–µ—Ç —Ñ–∞–π–ª–æ–≤ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏'}), 400
    
    files = request.files.getlist('files')
    uploaded_files = []
    
    # Create uploads directory if it doesn't exist
    upload_dir = 'instance/uploads'
    os.makedirs(upload_dir, exist_ok=True)
    
    for file in files:
        if file.filename == '':
            continue
        
        if file and file.filename and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            # Add timestamp to avoid conflicts
            timestamp = str(int(datetime.utcnow().timestamp()))
            filename = f"{timestamp}_{filename}"
            file_path = os.path.join(upload_dir, filename)
            
            try:
                file.save(file_path)
                file_size = os.path.getsize(file_path)
                file_ext = filename.rsplit('.', 1)[1].lower()
                
                # Create document record
                document = Document(
                    user_id=current_user.id,
                    original_filename=secure_filename(file.filename) if file.filename else 'unknown',
                    stored_filename=filename,
                    file_path=file_path,
                    file_size=file_size,
                    file_type=file_ext,
                    document_type=determine_document_type(file.filename),
                    status='–ù–∞ –ø—Ä–æ–≤–µ—Ä–∫–µ'
                )
                db.session.add(document)
                uploaded_files.append({
                    'filename': file.filename,
                    'size': file_size
                })
            except Exception as e:
                return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ {file.filename}: {str(e)}'}), 400
    
    try:
        db.session.commit()
        return jsonify({'success': True, 'uploaded_files': uploaded_files})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/documents/<int:document_id>', methods=['DELETE'])
@login_required
def delete_document(document_id):
    """Delete a document"""
    from models import Document
    import os
    
    document = Document.query.filter_by(
        id=document_id,
        user_id=current_user.id
    ).first()
    
    if not document:
        return jsonify({'success': False, 'error': '–î–æ–∫—É–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    try:
        # Delete physical file
        if os.path.exists(document.file_path):
            os.remove(document.file_path)
        
        # Delete database record
        db.session.delete(document)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

def allowed_file(filename):
    ALLOWED_EXTENSIONS = {'pdf', 'doc', 'docx', 'jpg', 'jpeg', 'png'}
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def determine_document_type(filename):
    """Determine document type from filename"""
    filename_lower = filename.lower()
    if any(word in filename_lower for word in ['–ø–∞—Å–ø–æ—Ä—Ç', 'passport']):
        return '–ü–∞—Å–ø–æ—Ä—Ç'
    elif any(word in filename_lower for word in ['—Å–ø—Ä–∞–≤–∫–∞', '–¥–æ—Ö–æ–¥—ã', 'income']):
        return '–°–ø—Ä–∞–≤–∫–∞ –æ –¥–æ—Ö–æ–¥–∞—Ö'
    elif any(word in filename_lower for word in ['–¥–æ–≥–æ–≤–æ—Ä', 'contract']):
        return '–î–æ–≥–æ–≤–æ—Ä'
    elif any(word in filename_lower for word in ['—Å–Ω–∏–ª—Å', '—Å–Ω–∏–ª—Å']):
        return '–°–ù–ò–õ–°'
    elif any(word in filename_lower for word in ['–∏–Ω–Ω', 'inn']):
        return '–ò–ù–ù'
    else:
        return '–î—Ä—É–≥–æ–µ'

# Manager authentication and dashboard routes
@app.route('/manager/logout')
def manager_logout():
    """Manager logout"""
    logout_user()
    flash('–í—ã —É—Å–ø–µ—à–Ω–æ –≤—ã—à–ª–∏ –∏–∑ —Å–∏—Å—Ç–µ–º—ã', 'success')
    return redirect(url_for('manager_login'))

@app.route('/switch-to-client')
def switch_to_client():
    """Switch from manager to client mode"""
    logout_user()
    flash('–ü–µ—Ä–µ–∫–ª—é—á–∏–ª–∏—Å—å –≤ —Ä–µ–∂–∏–º –∫–ª–∏–µ–Ω—Ç–∞', 'info')
    return redirect(url_for('index'))

@app.route('/manager/login', methods=['GET', 'POST'])
@csrf.exempt  # CSRF disabled  # Temporarily disable CSRF for login
def manager_login():
    """Simplified manager login with step-by-step error isolation"""
    if request.method == 'POST':
        # Step 1: Import and basic validation
        try:
            print("STEP 1: Starting manager login process")
            email = request.form.get('email')
            password = request.form.get('password')
            print(f"STEP 1: Got email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                print("STEP 1: Missing credentials")
                flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è', 'error')
                return render_template('auth/manager_login.html')
            print("STEP 1: Basic validation passed")
            
        except Exception as e:
            print(f"ERROR IN STEP 1: {e}")
            flash('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 2: Database query
        try:
            print("STEP 2: Importing Manager model")
            from models import Manager
            print("STEP 2: Manager model imported successfully")
            
            print("STEP 2: Querying database for manager")
            manager = Manager.query.filter_by(email=email, is_active=True).first()
            print(f"STEP 2: Database query result: {manager is not None}")
            
            if not manager:
                print("STEP 2: Manager not found")
                flash('–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞', 'error')
                return render_template('auth/manager_login.html')
            
            print(f"STEP 2: Manager found - ID: {manager.id}, Email: {manager.email}")
            
        except Exception as e:
            print(f"ERROR IN STEP 2: {e}")
            import traceback
            traceback.print_exc()
            flash('–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 3: Password verification
        try:
            print("STEP 3: Checking password")
            password_valid = manager.check_password(password)
            print(f"STEP 3: Password check result: {password_valid}")
            
            if not password_valid:
                print("STEP 3: Password invalid")
                flash('–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞', 'error')
                return render_template('auth/manager_login.html')
            
            print("STEP 3: Password verification passed")
            
        except Exception as e:
            print(f"ERROR IN STEP 3: {e}")
            import traceback
            traceback.print_exc()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–∞—Ä–æ–ª—è', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 4: Flask-Login –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è (–ò–°–ü–†–ê–í–õ–ï–ù–û)
        try:
            print("STEP 4: Using Flask-Login")
            login_user(manager, remember=True)  # –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login –≤–º–µ—Å—Ç–æ —Ä—É—á–Ω—ã—Ö —Å–µ—Å—Å–∏–π
            session.permanent = True  # Ensure 30-day session lifetime
            print(f"STEP 4: Flask-Login successful, manager.get_id()={manager.get_id()}")
            
        except Exception as e:
            print(f"ERROR IN STEP 4: {e}")
            import traceback
            traceback.print_exc()
            flash('–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 5: Database update
        try:
            print("STEP 5: Updating last login time")
            from datetime import datetime
            manager.last_login = datetime.utcnow()
            manager.last_ip = request.remote_addr
            manager.last_user_agent = request.headers.get('User-Agent')
            db.session.commit()
            print("STEP 5: Database commit successful")
            
        except Exception as e:
            print(f"ERROR IN STEP 5: {e}")
            import traceback
            traceback.print_exc()
            flash('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 6: Success redirect
        try:
            print("STEP 6: Preparing success response")
            flash('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Å–∏—Å—Ç–µ–º—É!', 'success')
            print(f"STEP 6: Login successful for manager {manager.email}")
            return redirect(url_for('manager_dashboard'))
            
        except Exception as e:
            print(f"ERROR IN STEP 6: {e}")
            import traceback
            traceback.print_exc()
            flash('–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è', 'error')
            return render_template('auth/manager_login.html')
    
    # GET request - show login form
    return render_template('auth/manager_login.html')



# Manager Comparison Routes
@app.route('/manager/property-comparison')
@manager_required
def manager_property_comparison():
    """Manager property comparison page"""
    from models import Manager
    
    current_manager = current_user
    
    return render_template('auth/manager_property_comparison.html', current_manager=current_manager)

@app.route('/manager/complex-comparison')
@manager_required
def manager_complex_comparison():
    """Manager complex comparison page"""
    from models import Manager
    
    current_manager = current_user
    
    return render_template('auth/manager_complex_comparison.html', current_manager=current_manager)

@app.route('/api/manager/favorites-properties')
@manager_required
def get_manager_favorite_properties():
    """Get properties with full characteristics for comparison"""
    try:
        # Check if specific IDs are requested for server-side filtering
        from flask import request
        requested_ids = request.args.get('ids', '')
        filter_ids_str = [id.strip() for id in requested_ids.split(',') if id.strip()] if requested_ids else []
        
        # ‚úÖ MIGRATED: Load properties using repository (batch loading)
        import json
        
        try:
            from models import Property, ResidentialComplex, Developer, District
            from sqlalchemy.orm import joinedload
            
            properties_data = []
            
            # Load properties with eager loading of relationships
            query = Property.query.options(
                joinedload(Property.residential_complex),
                joinedload(Property.developer),
                joinedload(Property.district)
            )
            
            if filter_ids_str:
                # Filter by properties.id (primary key integer)
                filter_ids_int = [int(id) for id in filter_ids_str if id.isdigit()]
                query = query.filter(Property.id.in_(filter_ids_int[:10]))
            else:
                # Get all active properties (limited)
                query = query.filter(Property.status == 'available').limit(100)
            
            properties_orm = query.all()
            
            for prop in properties_orm:
                # Get photos
                photos_data = []
                if hasattr(prop, 'photos') and prop.photos:
                    try:
                        photos_data = json.loads(prop.photos) if isinstance(prop.photos, str) else prop.photos
                    except:
                        photos_data = []
                
                # Fallback to main_image or gallery_images
                if not photos_data:
                    if hasattr(prop, 'main_image') and prop.main_image:
                        photos_data = [prop.main_image]
                    elif hasattr(prop, 'gallery_images') and prop.gallery_images:
                        try:
                            gallery = json.loads(prop.gallery_images) if isinstance(prop.gallery_images, str) else prop.gallery_images
                            photos_data = gallery if isinstance(gallery, list) else []
                        except:
                            pass
                
                first_image = photos_data[0] if photos_data else '/static/images/no-photo.jpg'
                
                # Format room text
                rooms_count = prop.rooms or 0
                area_value = prop.area or 0
                rooms_text = "–°—Ç—É–¥–∏—è" if rooms_count == 0 else f"{rooms_count}"
                
                # Format property name
                if rooms_count == 0:
                    property_name = f"–°—Ç—É–¥–∏—è, {area_value} –º¬≤"
                else:
                    property_name = f"{rooms_count} –∫–æ–º–Ω, {area_value} –º¬≤"
                
                # Calculate cashback
                complex_name = prop.residential_complex.name if prop.residential_complex else ''
                cashback_value = calculate_cashback(prop.price or 0, complex_name=complex_name)
                
                property_data = {
                    'property_id': str(prop.inner_id or ''),
                    'property_name': property_name,
                    'property_type': prop.residential_complex.object_class_display_name if prop.residential_complex else '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
                    'property_size': float(prop.area or 0),
                    'property_price': int(prop.price or 0),
                    'complex_name': complex_name or '',
                    'developer_name': prop.developer.name if prop.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
                    'property_image': first_image,
                    'property_url': f'/object/{prop.inner_id}' if prop.inner_id else None,
                    'district': prop.district.name if prop.district else '',
                    'address': prop.address or '',
                    'floor': str(prop.floor or ''),
                    'total_floors': str(prop.total_floors or ''),
                    'floors_total': str(prop.total_floors or ''),
                    'rooms': str(rooms_count),
                    'living_area': '',
                    'kitchen_area': '',
                    'price_per_sqm': int(prop.price_per_sqm or 0) if prop.price_per_sqm else 0,
                    'condition': prop.renovation_type or '',
                    'ceiling_height': '',
                    'furniture': '',
                    'balcony': '',
                    'view_from_windows': '',
                    'parking': '',
                    'metro_distance': '',
                    'year_built': str(prop.residential_complex.end_build_year or '') if prop.residential_complex else '',
                    'building_type': (prop.residential_complex.object_class_display_name if prop.residential_complex and prop.residential_complex.object_class_display_name else ''),
                    'decoration': prop.renovation_type or 'no_renovation',
                    'deal_type': prop.deal_type or 'sale',
                    'mortgage_available': '–ù–µ—Ç',
                    'added_at': '–ó–∞–≥—Ä—É–∂–µ–Ω–æ –∏–∑ PostgreSQL',
                    'cashback_amount': cashback_value,
                    'cashback': cashback_value
                }
                properties_data.append(property_data)
            
            return jsonify({
                'success': True,
                'properties': properties_data,
                'count': len(properties_data)
            })
            
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)}), 500
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/favorites-complexes')
@manager_required
def get_manager_favorite_complexes():
    """Get manager's favorite complexes for comparison"""
    from models import ManagerFavoriteComplex
    
    try:
        current_manager = current_user
        
        # Get all favorite complexes for this manager
        favorites = ManagerFavoriteComplex.query.filter_by(
            manager_id=current_manager.id
        ).order_by(ManagerFavoriteComplex.created_at.desc()).all()
        
        complexes_data = []
        for fav in favorites:
            from models import ResidentialComplex
            rc = ResidentialComplex.query.filter_by(name=fav.complex_name).first()
            if not rc and fav.complex_id:
                try:
                    rc = ResidentialComplex.query.get(int(fav.complex_id))
                except:
                    pass
            
            def format_price(p):
                if not p: return '–ü–æ –∑–∞–ø—Ä–æ—Å—É'
                try:
                    return f"{int(p):,}".replace(',', ' ') + ' ‚ÇΩ'
                except:
                    return str(p)

            complexes_data.append({
                'id': fav.id,
                'complex_id': fav.complex_id,
                'complex_name': fav.complex_name,
                'developer_name': fav.developer_name,
                'complex_address': fav.complex_address,
                'district': fav.district,
                'min_price': fav.min_price,
                'max_price': fav.max_price,
                'min_price_formatted': format_price(fav.min_price),
                'max_price_formatted': format_price(fav.max_price),
                'complex_image': fav.complex_image,
                'complex_url': fav.complex_url,
                'added_at': fav.created_at.strftime('%d.%m.%Y %H:%M'),
                'object_class_display_name': fav.object_class_display_name,
                'total_buildings': rc.total_buildings if rc else '-',
                'total_apartments': rc.total_apartments if rc else '-',
            })
        
        return jsonify({
            'success': True,
            'complexes': complexes_data,
            'count': len(complexes_data)
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


def get_manager_sidebar_data(current_manager, active_page='dashboard'):
    from models import (ManagerFavoriteProperty, ManagerFavoriteComplex,
                        ManagerComparison, ComparisonComplex, ComparisonProperty,
                        Deal, User, Collection)
    total_clients = User.query.filter_by(assigned_manager_id=current_manager.id).count()
    presentations_count = Collection.query.filter_by(
        created_by_manager_id=current_manager.id,
        collection_type='presentation'
    ).count()
    deals_count = Deal.query.filter_by(manager_id=current_manager.id).count()
    manager_favorites_count = ManagerFavoriteProperty.query.filter_by(manager_id=current_manager.id).count()
    manager_complexes_count = ManagerFavoriteComplex.query.filter_by(manager_id=current_manager.id).count()
    manager_comparison_properties = db.session.query(ComparisonProperty).join(
        ManagerComparison, ComparisonProperty.manager_comparison_id == ManagerComparison.id
    ).filter(ManagerComparison.manager_id == current_manager.id).count()
    manager_comparison_complexes = ComparisonComplex.query.join(
        ManagerComparison, ComparisonComplex.manager_comparison_id == ManagerComparison.id
    ).filter(ManagerComparison.manager_id == current_manager.id).count()
    total_favorites = manager_favorites_count + manager_complexes_count
    total_comparison = manager_comparison_properties + manager_comparison_complexes
    dash_url = url_for('manager_dashboard')
    is_dashboard = (active_page == 'dashboard')
    sidebar_links = [
        {'label': '–ù–∞ –≥–ª–∞–≤–Ω—É—é', 'href': '/', 'page': 'home', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg>'},
        {'label': '–ì–ª–∞–≤–Ω–∞—è', 'href': url_for('manager_dashboard'), 'page': 'dashboard', 'active': active_page == 'dashboard', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M10 2L3 7v11h3v-6h8v6h3V7l-7-5z"/></svg>'},
        {'label': '–ö–ª–∏–µ–Ω—Ç—ã', 'href': '#clients' if is_dashboard else dash_url + '#clients', 'page': 'clients', 'active': active_page == 'clients', 'badge': str(total_clients), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z"/></svg>'},
        {'label': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏', 'href': '#presentations' if is_dashboard else dash_url + '#presentations', 'page': 'presentations', 'active': active_page == 'presentations', 'badge': str(presentations_count), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/></svg>'},
        {'label': '–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –ø–æ–∏—Å–∫–∏', 'href': '#saved-searches' if is_dashboard else dash_url + '#saved-searches', 'page': 'saved-searches', 'active': active_page == 'saved-searches', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd"/></svg>'},
        {'label': '–ò–∑–±—Ä–∞–Ω–Ω–æ–µ', 'href': '#favorites' if is_dashboard else dash_url + '#favorites', 'page': 'favorites', 'active': active_page == 'favorites', 'badge': str(total_favorites), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd"/></svg>'},
        {'label': '–°—Ä–∞–≤–Ω–µ–Ω–∏–µ', 'href': '#comparison' if is_dashboard else dash_url + '#comparison', 'page': 'comparison', 'active': active_page == 'comparison', 'badge': str(total_comparison), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"/></svg>'},
        {'label': '–°–¥–µ–ª–∫–∏', 'href': url_for('manager_deals_kanban'), 'page': 'deals', 'active': active_page == 'deals', 'badge': str(deals_count), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M6 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V7.414A2 2 0 0015.414 6L12 2.586A2 2 0 0010.586 2H6zm5 6a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V8z" clip-rule="evenodd"/></svg>'},
        {'label': '–ê—Ä—Ö–∏–≤ —Å–¥–µ–ª–æ–∫', 'href': url_for('manager_deals_archive'), 'page': 'deals_archive', 'active': active_page == 'deals_archive', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M4 3a2 2 0 100 4h12a2 2 0 100-4H4z"/><path fill-rule="evenodd" d="M3 8h14v7a2 2 0 01-2 2H5a2 2 0 01-2-2V8zm5 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" clip-rule="evenodd"/></svg>'},
        {'label': '–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏', 'href': url_for('manager_employees'), 'page': 'employees', 'active': active_page == 'employees', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z"/></svg>'},
    ]
    user_profile = {
        'name': f"{current_manager.first_name} {current_manager.last_name}".strip() or current_manager.email.split('@')[0],
        'role': current_manager.org_role.name if current_manager.org_role else ('–†–û–ü' if getattr(current_manager, 'is_rop', False) else '–ú–µ–Ω–µ–¥–∂–µ—Ä'),
        'initials': current_manager.first_name[0].upper() if current_manager.first_name else current_manager.email[0].upper(),
        'href': url_for('manager_profile'),
        'avatar': current_manager.profile_image if current_manager.profile_image else None,
    }
    return sidebar_links, user_profile


@app.route('/manager/dashboard')
@manager_required
def manager_dashboard():
    from models import Manager, User, CashbackApplication, Document
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login –≤–º–µ—Å—Ç–æ session
    current_manager = current_user
    print(f"DEBUG: Manager dashboard - current_manager: {current_manager.email if current_manager else None}")
    
    # Resolve city context to preserve city selection
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    
    # Get statistics (–∏—Å–ø–æ–ª—å–∑—É–µ–º current_manager.id)
    print('DEBUG: Starting statistics queries...')
    print('DEBUG: Querying total_clients...')
    total_clients = User.query.filter_by(assigned_manager_id=current_manager.id).count()
    print(f'DEBUG: total_clients = {total_clients}')
    print('DEBUG: Querying new_clients_count...')
    new_clients_count = User.query.filter_by(
        assigned_manager_id=current_manager.id, 
        client_status='–ù–æ–≤—ã–π'
    ).count()
    
    print('DEBUG: Querying pending_applications_count...')
    pending_applications_count = CashbackApplication.query.join(User).filter(
        User.assigned_manager_id == current_manager.id,
        CashbackApplication.status == '–ù–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏'
    ).count()
    
    print('DEBUG: Querying pending_documents_count...')
    pending_documents_count = Document.query.join(User).filter(
        User.assigned_manager_id == current_manager.id,
        Document.status == '–ù–∞ –ø—Ä–æ–≤–µ—Ä–∫–µ'
    ).count()
    
    # Calculate total approved cashback (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ - –∏—Å–ø–æ–ª—å–∑—É–µ–º SQL SUM –≤–º–µ—Å—Ç–æ –∑–∞–≥—Ä—É–∑–∫–∏ –≤ –ø–∞–º—è—Ç—å)
    total_approved_cashback = 0
    try:
        from sqlalchemy import func
        from models import CashbackApplication, User
        total_approved_cashback = db.session.query(
            func.sum(CashbackApplication.cashback_amount)
        ).join(User).filter(
            User.assigned_manager_id == current_manager.id,
            CashbackApplication.status == '–û–¥–æ–±—Ä–µ–Ω–∞'
        ).scalar() or 0
    except Exception as e:
        print(f"Error calculating cashback: {e}")
        total_approved_cashback = 0
    
    # Recent activities (mock data for now)
    recent_activities = [
        {
            'message': '–ù–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç –ò–≤–∞–Ω –ü–µ—Ç—Ä–æ–≤ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª—Å—è',
            'time_ago': '5 –º–∏–Ω—É—Ç –Ω–∞–∑–∞–¥',
            'color': 'blue',
            'icon': 'user-plus'
        },
        {
            'message': '–ó–∞—è–≤–∫–∞ –Ω–∞ –∫–µ—à–±–µ–∫ –æ—Ç –ê–Ω–Ω—ã –°–∏–¥–æ—Ä–æ–≤–æ–π —Ç—Ä–µ–±—É–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏',
            'time_ago': '1 —á–∞—Å –Ω–∞–∑–∞–¥',
            'color': 'yellow',
            'icon': 'file-alt'
        }
    ]
    
    print('DEBUG: About to query collections...')
    # Get collections statistics  
    from models import Collection
    collections_count = Collection.query.filter_by(created_by_manager_id=current_manager.id).count()
    recent_collections = Collection.query.filter_by(created_by_manager_id=current_manager.id).order_by(Collection.created_at.desc()).limit(5).all()
    
    # Get presentations statistics
    presentations_count = Collection.query.filter_by(
        created_by_manager_id=current_manager.id, 
        collection_type='presentation'
    ).count()
    
    # Get deals statistics
    from models import Deal
    deals_count = Deal.query.filter_by(manager_id=current_manager.id).count()
    
    # Load data for manager filters
    districts = get_districts_list()
    developers = get_developers_list()
    
    print(f"DEBUG: Rendering dashboard with manager: {current_manager.full_name}")

    # Sidebar links –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞  
    # Load manager favorites and comparison counts
    from models import ManagerFavoriteProperty, ManagerFavoriteComplex, ManagerComparison, ComparisonComplex, ComparisonProperty
    print("DEBUG: Loading manager favorites counts...")
    manager_favorites_count = ManagerFavoriteProperty.query.filter_by(manager_id=current_manager.id).count()
    manager_complexes_count = ManagerFavoriteComplex.query.filter_by(manager_id=current_manager.id).count()
    manager_comparison_properties = db.session.query(ComparisonProperty).join(
        ManagerComparison, ComparisonProperty.manager_comparison_id == ManagerComparison.id
    ).filter(ManagerComparison.manager_id == current_manager.id).count()
    manager_comparison_complexes = ComparisonComplex.query.join(ManagerComparison, ComparisonComplex.manager_comparison_id == ManagerComparison.id).filter(ManagerComparison.manager_id == current_manager.id).count()
    total_favorites = manager_favorites_count + manager_complexes_count
    total_comparison = manager_comparison_properties + manager_comparison_complexes
    
    print(f"DEBUG: Favorites counts loaded - total_favorites={total_favorites}, total_comparison={total_comparison}")
        # Sidebar links –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞  
    sidebar_links = [
        {'label': '–ù–∞ –≥–ª–∞–≤–Ω—É—é', 'href': '/', 'page': 'home', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg>'},
        {'label': '–ì–ª–∞–≤–Ω–∞—è', 'href': '#dashboard', 'page': 'dashboard', 'active': True, 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M10 2L3 7v11h3v-6h8v6h3V7l-7-5z"/></svg>'},
        {'label': '–ö–ª–∏–µ–Ω—Ç—ã', 'href': '#clients', 'page': 'clients', 'badge': str(total_clients) if total_clients else '0', 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z"/></svg>'},
        {'label': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏', 'href': '#presentations', 'page': 'presentations', 'badge': str(presentations_count), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/></svg>'},
        {'label': '–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –ø–æ–∏—Å–∫–∏', 'href': '#saved-searches', 'page': 'saved-searches', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd"/></svg>'},
        {'label': '–ò–∑–±—Ä–∞–Ω–Ω–æ–µ', 'href': '#favorites', 'page': 'favorites', 'badge': str(total_favorites), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd"/></svg>'},
        {'label': '–°—Ä–∞–≤–Ω–µ–Ω–∏–µ', 'href': '#comparison', 'page': 'comparison', 'badge': str(total_comparison), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z"/></svg>'},
        {'label': '–°–¥–µ–ª–∫–∏', 'href': url_for('manager_deals_kanban'), 'page': 'deals', 'badge': str(deals_count), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M6 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V7.414A2 2 0 0015.414 6L12 2.586A2 2 0 0010.586 2H6zm5 6a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V8z" clip-rule="evenodd"/></svg>'},
        {'label': '–ê—Ä—Ö–∏–≤ —Å–¥–µ–ª–æ–∫', 'href': url_for('manager_deals_archive'), 'page': 'deals_archive', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M4 3a2 2 0 100 4h12a2 2 0 100-4H4z"/><path fill-rule="evenodd" d="M3 8h14v7a2 2 0 01-2 2H5a2 2 0 01-2-2V8zm5 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" clip-rule="evenodd"/></svg>'},
        {'label': '–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏', 'href': url_for('manager_employees'), 'page': 'employees', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z"/></svg>'},
    ]
    
    assigned_manager = None

    user_profile = {'name': f"{current_manager.first_name} {current_manager.last_name}".strip() or current_manager.email.split('@')[0], 'role': current_manager.org_role.name if current_manager.org_role else ('–†–û–ü' if getattr(current_manager, 'is_rop', False) else '–ú–µ–Ω–µ–¥–∂–µ—Ä'), 'initials': current_manager.first_name[0].upper() if current_manager.first_name else current_manager.email[0].upper(), 'href': url_for('manager_profile'), 'avatar': current_manager.profile_image if current_manager.profile_image else None}
    # Profile completion for managers (always 100% since they don't need profile completion)
    profile_completion = 100
    profile_missing_fields = []
    try:
        # Balance data for template (manager doesn't have balance, set defaults)
        user_balance = 0
        balance_transactions = []
        
        print("DEBUG: About to render manager dashboard template")
        response = make_response(render_template('auth/manager_dashboard.html',
                             current_manager=current_manager,
                             current_city=current_city,
                             total_clients=total_clients,
                             new_clients_count=new_clients_count,
                             pending_applications_count=pending_applications_count,
                             pending_documents_count=pending_documents_count,
                             total_approved_cashback=total_approved_cashback,
                             recent_activities=recent_activities,
                             pending_notifications=pending_applications_count + pending_documents_count,
                             collections_count=collections_count,
                             presentations_count=presentations_count,
                             deals_count=deals_count,
                             recent_collections=recent_collections,
                             districts=districts,
                             developers=developers,
                             sidebar_links=sidebar_links,
                             user_profile=user_profile,
                             user_balance=user_balance,
                             balance_transactions=balance_transactions,
                             assigned_manager=assigned_manager,
                             profile_completion=profile_completion,
                             profile_missing_fields=profile_missing_fields))
        # Add anti-cache headers
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        return response
    except Exception as e:
        print(f"DEBUG: Error rendering dashboard: {e}")
        import traceback
        traceback.print_exc()
        return f"Error rendering dashboard: {e}", 500


@app.route('/manager/favorites')
@manager_required
def manager_favorites():
    """Manager favorites page - separate page like user favorites"""
    from models import Manager
    
    current_manager = current_user
    
    return render_template('manager/favorites.html', current_manager=current_manager)


@app.route('/manager/presentation/<int:presentation_id>')
@manager_required
def manager_presentation_view(presentation_id):
    """View presentation page inside manager dashboard"""
    from models import Collection, CollectionProperty, Manager
    
    current_manager = current_user
    print(f"DEBUG: Presentation view - manager_id: {current_manager.id}, presentation_id: {presentation_id}")
    
    # Get presentation data
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_manager.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        print(f"DEBUG: Presentation {presentation_id} not found or access denied")
        flash('–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –Ω–µ–π', 'error')
        return redirect(url_for('manager_dashboard'))
    
    # Get presentation properties
    collection_properties = CollectionProperty.query.filter_by(
        collection_id=presentation_id
    ).order_by(CollectionProperty.order_index).all()
    
    print(f"DEBUG: Found {len(collection_properties)} properties in presentation")
    
    # ‚úÖ MIGRATED: Load presentation properties from PostgreSQL using helper
    try:
        print("DEBUG: Loading presentation data from PostgreSQL...")
        enriched_properties = _load_presentation_properties_from_db(presentation.id)
        print(f"DEBUG: Loaded {len(enriched_properties)} enriched properties")
    except Exception as e:
        print(f"ERROR: Failed to load presentation data: {e}")
        import traceback
        traceback.print_exc()
        enriched_properties = []
    
    # Format presentation data for template
    presentation_data = {
        'id': presentation.id,
        'title': presentation.title,
        'description': presentation.description,
        'client_name': presentation.client_name,
        'client_phone': presentation.client_phone,
        'status': presentation.status,
        'created_at': presentation.created_at,
        'view_count': presentation.view_count,
        'last_viewed_at': presentation.last_viewed_at,
        'properties_count': len(enriched_properties),
        'properties': enriched_properties,
        'unique_url': presentation.unique_url
    }
    
    try:
        return render_template('manager/presentation_view.html',
                             manager=current_manager,
                             presentation=presentation_data)
    except Exception as e:
        print(f"DEBUG: Error rendering presentation view: {e}")
        import traceback
        traceback.print_exc()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏', 'error')
        return redirect(url_for('manager_dashboard'))


# API routes for manager actions
@app.route('/api/manager/clients')
@manager_required
def get_manager_clients_unified():
    """Get ONLY assigned clients for this manager"""
    current_manager = current_user
    
    try:
        print(f"DEBUG: Getting clients for manager {current_manager.id}")
        # Get ALL users assigned to this manager (regardless of role)
        clients = User.query.filter_by(assigned_manager_id=current_manager.id).all()
        print(f"DEBUG: Found {len(clients)} assigned clients for manager {current_manager.id}")
        clients_data = []
        
        for client in clients:
            # Get latest search as preference indicator
            latest_search = SavedSearch.query.filter_by(user_id=client.id).order_by(SavedSearch.last_used.desc()).first()
            
            client_data = {
                'id': client.id,
                'full_name': client.full_name,
                'email': client.email,
                'phone': client.phone or '',
                'profile_image': client.profile_image or '',
                'created_at': client.created_at.isoformat() if client.created_at else None,
                'search_preferences': None,
                'status': 'active'  # Default status
            }
            
            if latest_search:
                # Create readable search description
                prefs = []
                if latest_search.property_type:
                    prefs.append(latest_search.property_type)
                if latest_search.location:
                    prefs.append(f"—Ä–∞–π–æ–Ω {latest_search.location}")
                if latest_search.price_min or latest_search.price_max:
                    price_range = []
                    if latest_search.price_min:
                        price_range.append(f"–æ—Ç {latest_search.price_min:,} ‚ÇΩ")
                    if latest_search.price_max:
                        price_range.append(f"–¥–æ {latest_search.price_max:,} ‚ÇΩ")
                    prefs.append(" ".join(price_range))
                
                client_data['search_preferences'] = ", ".join(prefs) if prefs else "–ü–æ–∏—Å–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω"
            
            clients_data.append(client_data)
        
        print(f"DEBUG: Returning {len(clients_data)} clients data")
        return jsonify({
            'success': True,
            'clients': clients_data
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/update_client_status', methods=['POST'])
@manager_required
def update_client_status():
    from models import User
    
    current_manager = current_user
    
    data = request.get_json()
    client_id = data.get('client_id')
    new_status = data.get('status')
    notes = data.get('notes', '')
    
    client = User.query.get(client_id)
    if not client or client.assigned_manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    try:
        client.client_status = new_status
        if notes:
            client.client_notes = notes
        client.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/approve_cashback', methods=['POST'])
@manager_required
def approve_cashback():
    from models import CashbackApplication, Manager
    
    current_manager = current_user
    
    data = request.get_json()
    application_id = data.get('application_id')
    action = data.get('action')  # approve, reject
    manager_notes = data.get('manager_notes', '')
    
    application = CashbackApplication.query.get(application_id)
    if not application:
        return jsonify({'success': False, 'error': '–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    # Check if client is assigned to this manager
    if application.user.assigned_manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∑–∞—è–≤–∫–µ'}), 403
    
    try:
        if action == 'approve':
            # Check approval limits
            if current_manager and current_manager.max_cashback_approval and application.cashback_amount > current_manager.max_cashback_approval:
                return jsonify({
                    'success': False, 
                    'error': f'–°—É–º–º–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –≤–∞—à –ª–∏–º–∏—Ç –Ω–∞ –æ–¥–æ–±—Ä–µ–Ω–∏–µ ({current_manager.max_cashback_approval:,} ‚ÇΩ)'
                }), 400
            
            application.status = '–û–¥–æ–±—Ä–µ–Ω–∞'
            application.approved_date = datetime.utcnow()
            application.approved_by_manager_id = current_manager.id
            
        elif action == 'reject':
            application.status = '–û—Ç–∫–ª–æ–Ω–µ–Ω–∞'
        
        if manager_notes:
            application.manager_notes = manager_notes
        
        application.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/contact-requests')
@manager_required  
def get_manager_contact_requests():
    """Get contact manager applications for current manager"""
    try:
        from models import Application
        
        # Get all manager contact applications
        applications = Application.query.filter_by(
            application_type='manager_contact'
        ).order_by(Application.created_at.desc()).all()
        
        result = []
        for app in applications:
            result.append({
                'id': app.id,
                'contact_name': app.contact_name,
                'contact_email': app.contact_email,
                'contact_phone': app.contact_phone,
                'message': app.message,
                'preferred_contact_time': app.preferred_contact_time,
                'status': app.status,
                'created_at': app.created_at.isoformat() if app.created_at else None,
                'updated_at': app.updated_at.isoformat() if app.updated_at else None,
                # Property context if available
                'property_id': app.property_id,
                'property_type': app.property_type,
                'budget_min': app.budget_min,
                'budget_max': app.budget_max
            })
        
        return jsonify({
            'success': True,
            'applications': result,
            'total': len(result)
        })
        
    except Exception as e:
        print(f"Error getting manager contact requests: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/applications')
@manager_required
def get_manager_applications():
    from models import CashbackApplication, User
    
    current_manager = current_user
    
    applications = CashbackApplication.query.join(User).filter(
        User.assigned_manager_id == current_manager.id,
        CashbackApplication.status == '–ù–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏'
    ).all()
    
    applications_data = []
    for app in applications:
        applications_data.append({
            'id': app.id,
            'client_name': app.user.full_name,
            'client_email': app.user.email,
            'property_name': app.property_name,
            'complex_name': app.complex_name,
            'cashback_amount': app.cashback_amount,
            'cashback_percent': app.cashback_percent,
            'application_date': app.application_date.strftime('%d.%m.%Y'),
            'status': app.status
        })
    
    return jsonify({'applications': applications_data})

@app.route('/api/manager/documents')
@manager_required
def get_manager_documents():
    from models import Document, User
    
    current_manager = current_user
    
    documents = Document.query.join(User).filter(
        User.assigned_manager_id == current_manager.id,
        Document.status == '–ù–∞ –ø—Ä–æ–≤–µ—Ä–∫–µ'
    ).all()
    
    documents_data = []
    for doc in documents:
        documents_data.append({
            'id': doc.id,
            'client_name': doc.user.full_name,
            'client_email': doc.user.email,
            'document_type': doc.document_type or '–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω',
            'original_filename': doc.original_filename,
            'file_size': doc.file_size,
            'created_at': doc.created_at.strftime('%d.%m.%Y %H:%M'),
            'status': doc.status
        })
    
    return jsonify({'documents': documents_data})

@app.route('/api/manager/document_action', methods=['POST'])
@manager_required
def manager_document_action():
    from models import Document, Manager
    
    current_manager = current_user
    
    data = request.get_json()
    document_id = data.get('document_id')
    action = data.get('action')  # approve, reject
    notes = data.get('notes', '')
    
    document = Document.query.get(document_id)
    
    if not document:
        return jsonify({'success': False, 'error': '–î–æ–∫—É–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    # Check if client is assigned to this manager
    if document.user.assigned_manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –¥–æ–∫—É–º–µ–Ω—Ç—É'}), 403
    
    try:
        if action == 'approve':
            document.status = '–ü—Ä–æ–≤–µ—Ä–µ–Ω'
        elif action == 'reject':
            document.status = '–û—Ç–∫–ª–æ–Ω–µ–Ω'
        
        document.reviewed_by_manager_id = current_manager.id
        document.reviewed_at = datetime.utcnow()
        if notes:
            document.reviewer_notes = notes
        
        document.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/application_action', methods=['POST'])
@manager_required
def manager_application_action():
    from models import CashbackApplication, Manager, User
    
    current_manager = current_user
    
    data = request.get_json()
    application_id = data.get('application_id')
    action = data.get('action')  # approve, reject
    notes = data.get('notes', '')
    
    application = CashbackApplication.query.get(application_id)
    
    if not application:
        return jsonify({'success': False, 'error': '–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    # Check if client is assigned to this manager
    if application.user.assigned_manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∑–∞—è–≤–∫–µ'}), 403
    
    try:
        if action == 'approve':
            application.status = '–û–¥–æ–±—Ä–µ–Ω–∞'
            # Add cashback to user's balance
            user = application.user
            user.total_cashback = (user.total_cashback or 0) + application.cashback_amount
        elif action == 'reject':
            application.status = '–û—Ç–∫–ª–æ–Ω–µ–Ω–∞'
        
        application.reviewed_by_manager_id = current_manager.id
        application.reviewed_at = datetime.utcnow()
        if notes:
            application.manager_notes = notes
        
        application.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collections')
@manager_required
def get_manager_collections():
    from models import Collection, User
    
    current_manager = current_user
    
    collections = Collection.query.filter_by(created_by_manager_id=current_manager.id).all()
    
    collections_data = []
    for collection in collections:
        collections_data.append({
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status,
            'assigned_to_name': collection.assigned_to.full_name if collection.assigned_to else '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–æ',
            'assigned_to_id': collection.assigned_to_user_id,
            'properties_count': len(collection.properties),
            'created_at': collection.created_at.strftime('%d.%m.%Y'),
            'tags': collection.tags
        })
    
    return jsonify({'collections': collections_data})

@app.route('/api/manager/collection/create', methods=['POST'])
@manager_required
def api_create_collection():
    from models import Collection, User
    
    current_manager = current_user
    
    data = request.get_json()
    title = data.get('title')
    description = data.get('description', '')
    assigned_to_user_id = data.get('assigned_to_user_id')
    tags = data.get('tags', '')
    
    if not title:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–¥–±–æ—Ä–∫–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    
    try:
        collection = Collection()
        collection.title = title
        collection.description = description
        collection.created_by_manager_id = current_manager.id
        collection.assigned_to_user_id = assigned_to_user_id if assigned_to_user_id else None
        collection.tags = tags
        collection.status = '–ß–µ—Ä–Ω–æ–≤–∏–∫'
        
        db.session.add(collection)
        db.session.commit()
        
        return jsonify({'success': True, 'collection_id': collection.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collection/<int:collection_id>/properties')
@manager_required
def get_collection_properties(collection_id):
    from models import Collection, CollectionProperty
    
    current_manager = current_user
    
    collection = Collection.query.filter_by(
        id=collection_id,
        created_by_manager_id=current_manager.id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    properties_data = []
    for prop in collection.properties:
        properties_data.append({
            'id': prop.id,
            'property_id': prop.property_id,
            'property_name': prop.property_name,
            'property_price': prop.property_price,
            'complex_name': prop.complex_name,
            'property_type': prop.property_type,
            'property_size': prop.property_size,
            'manager_note': prop.manager_note,
            'order_index': prop.order_index
        })
    
    # Sort by order_index
    properties_data.sort(key=lambda x: x['order_index'])
    
    return jsonify({
        'collection': {
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status
        },
        'properties': properties_data
    })



@app.route('/api/searches/save', methods=['POST'])
@login_required
def api_save_search():
    """Save a search with filters"""
    from models import SavedSearch
    
    data = request.get_json()
    name = data.get('name')
    filters = data.get('filters', {})
    
    if not name:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–∏—Å–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    
    try:
        # Get city_id from request or session
        city_id = data.get('city_id') or session.get('city_id') or 1
        
        search = SavedSearch()
        search.name = name
        search.additional_filters = json.dumps(filters)
        search.user_id = current_user.id
        search.city_id = city_id
        search.created_at = datetime.utcnow()
        
        db.session.add(search)
        db.session.commit()
        
        return jsonify({'success': True, 'search_id': search.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/searches', methods=['POST'])
@manager_required
def api_manager_save_search():
    """Save a search for a manager"""
    from models import ManagerSavedSearch, Manager, SentSearch
    
    current_manager = current_user
    
    data = request.get_json()
    name = data.get('name')
    filters = data.get('filters', {})
    client_email = data.get('client_email', '')
    
    if not name:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–∏—Å–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    
    try:
        # Create saved search
        search = ManagerSavedSearch()
        search.name = name
        search.additional_filters = json.dumps(filters)
        search.manager_id = current_manager.id
        search.created_at = datetime.utcnow()
        
        db.session.add(search)
        db.session.commit()
        
        # If client email provided, also create sent search record and send notification
        if client_email:
            sent_search = SentSearch()
            sent_search.saved_search_id = search.id
            sent_search.recipient_email = client_email
            sent_search.sent_at = datetime.utcnow()
            sent_search.manager_id = current_manager.id
            
            db.session.add(sent_search)
            db.session.commit()
            
            # Send notification to client
            manager_name = current_manager.name if current_manager else "–ú–µ–Ω–µ–¥–∂–µ—Ä"
            
            try:
                send_notification(
                    recipient_email=client_email,
                    subject=f"–ù–æ–≤—ã–π –ø–æ–¥–±–æ—Ä –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –æ—Ç {manager_name}",
                    message=f"–ú–µ–Ω–µ–¥–∂–µ—Ä {manager_name} –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –¥–ª—è –≤–∞—Å –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥–±–æ—Ä –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ '{name}'. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –Ω–∞ —Å–∞–π—Ç–µ InBack.ru",
                    notification_type='saved_search',
                    user_id=None,
                    manager_id=current_manager.id
                )
                return jsonify({'success': True, 'search_id': search.id, 'sent_to_client': True})
            except Exception as email_error:
                print(f"Failed to send email notification: {email_error}")
                return jsonify({'success': True, 'search_id': search.id, 'sent_to_client': False, 'email_error': str(email_error)})
        
        return jsonify({'success': True, 'search_id': search.id, 'sent_to_client': False})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send_recommendation', methods=['POST'])
@manager_required
def api_manager_send_recommendation():
    """Send a recommendation (property or complex) to a client"""
    from models import Recommendation, Manager, User, RecommendationCategory
    from datetime import datetime
    
    current_manager = current_user
    
    data = request.get_json()
    title = data.get('title', '').strip()
    client_id = data.get('client_id')  # Now using client_id instead of email
    client_email = data.get('client_email', '').strip()
    recommendation_type = data.get('recommendation_type')  # 'property' or 'complex'
    item_id = data.get('item_id')
    item_name = data.get('item_name', '').strip()
    description = data.get('description', '').strip()
    manager_notes = data.get('manager_notes', '').strip()
    highlighted_features = data.get('highlighted_features', [])
    priority_level = data.get('priority_level', 'normal')
    category_id = data.get('category_id')  # New field for category
    category_name = data.get('category_name', '').strip()  # For creating new category
    
    # Debug logging (removing verbose logs for production)
    print(f"DEBUG: Recommendation sent - type={recommendation_type}, item_id={item_id}, client_id={client_id}")
    
    # Validation
    missing_fields = []
    if not title:
        missing_fields.append('–∑–∞–≥–æ–ª–æ–≤–æ–∫')
    if not client_id:
        missing_fields.append('–∫–ª–∏–µ–Ω—Ç')
    if not recommendation_type:
        missing_fields.append('—Ç–∏–ø —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏')
    if not item_id:
        missing_fields.append('ID –æ–±—ä–µ–∫—Ç–∞')
    if not item_name:
        missing_fields.append('–Ω–∞–∑–≤–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞')
    
    if missing_fields:
        return jsonify({'success': False, 'error': f'–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è: {", ".join(missing_fields)}'}), 400
    
    if recommendation_type not in ['property', 'complex']:
        return jsonify({'success': False, 'error': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏'}), 400
    
    try:
        # Find client by ID
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 400
        
        # Handle category
        category = None
        if category_id == 'new' and category_name:
            # Create new category
            category = RecommendationCategory(
                name=category_name,
                manager_id=current_manager.id,
                client_id=client_id
            )
            db.session.add(category)
            db.session.flush()  # To get the ID
        elif category_id and category_id != 'new':
            # Use existing category
            category = RecommendationCategory.query.filter_by(
                id=category_id,
                manager_id=current_manager.id,
                client_id=client_id,
                is_active=True
            ).first()
        
        # Create recommendation
        recommendation = Recommendation()
        recommendation.manager_id = current_manager.id
        recommendation.client_id = client.id
        recommendation.title = title
        recommendation.description = description
        recommendation.recommendation_type = recommendation_type
        recommendation.item_id = item_id
        recommendation.item_name = item_name
        recommendation.manager_notes = manager_notes
        recommendation.highlighted_features = json.dumps(highlighted_features) if highlighted_features else None
        recommendation.priority_level = priority_level
        recommendation.item_data = json.dumps(data.get('item_data', {}))  # Store full item details
        recommendation.category_id = category.id if category else None
        
        db.session.add(recommendation)
        
        # Update category statistics
        if category:
            category.recommendations_count += 1
            category.last_used = datetime.utcnow()
        
        db.session.commit()
        
        # Send notification to client
        manager = Manager.query.get(manager_id)
        manager_name = manager.name if manager else "–ú–µ–Ω–µ–¥–∂–µ—Ä"
        
        try:
            # Get priority text for notifications
            priority_texts = {
                'urgent': '–°—Ä–æ—á–Ω–æ',
                'high': '–í—ã—Å–æ–∫–∏–π', 
                'normal': '–û–±—ã—á–Ω—ã–π'
            }
            priority_text = priority_texts.get(priority_level, '–û–±—ã—á–Ω—ã–π')
            
            send_notification(
                recipient_email=client_email,
                subject=f"–ù–æ–≤–∞—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –æ—Ç {manager_name}",
                message=f"–ú–µ–Ω–µ–¥–∂–µ—Ä {manager_name} —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç –≤–∞–º: {title}",
                notification_type='recommendation',
                user_id=client.id,
                manager_id=current_manager.id,
                title=title,
                item_id=item_id,
                item_name=item_name,
                description=description,
                manager_name=manager_name,
                priority_text=priority_text,
                recommendation_type=recommendation_type
            )
            return jsonify({'success': True, 'recommendation_id': recommendation.id, 'sent_to_client': True})
        except Exception as email_error:
            print(f"Failed to send email notification: {email_error}")
            return jsonify({'success': True, 'recommendation_id': recommendation.id, 'sent_to_client': False, 'email_error': str(email_error)})
        
    except Exception as e:
        db.session.rollback()
        import traceback
        error_trace = traceback.format_exc()
        print(f"Error creating recommendation: {str(e)}")
        print(f"Full traceback: {error_trace}")
        return jsonify({'success': False, 'error': str(e), 'traceback': error_trace}), 400

@app.route('/api/manager/recommendations', methods=['GET'])
@manager_required
def api_manager_get_recommendations():
    """Get manager's sent recommendations with filters"""
    from models import Recommendation
    
    current_manager = current_user
    
    try:
        # Start with base query
        query = Recommendation.query.filter_by(manager_id=current_manager.id)
        
        # Apply filters from request params
        client_id = request.args.get('client_id')
        status = request.args.get('status')
        rec_type = request.args.get('type')
        priority = request.args.get('priority')
        
        if client_id:
            query = query.filter(Recommendation.client_id == client_id)
        if status:
            query = query.filter(Recommendation.status == status)
        if rec_type:
            query = query.filter(Recommendation.item_type == rec_type)
        if priority:
            query = query.filter(Recommendation.priority == priority)
        
        recommendations = query.order_by(Recommendation.sent_at.desc()).all()
        
        recommendations_data = []
        stats = {'sent': 0, 'viewed': 0, 'interested': 0, 'scheduled': 0}
        
        for rec in recommendations:
            rec_dict = rec.to_dict()
            rec_dict['client_email'] = rec.client.email
            rec_dict['client_name'] = rec.client.full_name
            recommendations_data.append(rec_dict)
            
            # Update stats
            stats['sent'] += 1
            if rec.status == 'viewed':
                stats['viewed'] += 1
            elif rec.status == 'interested':
                stats['interested'] += 1
            elif rec.status == 'scheduled_viewing':
                stats['scheduled'] += 1
        
        return jsonify({
            'success': True, 
            'recommendations': recommendations_data,
            'stats': stats
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/recommendations/<int:recommendation_id>', methods=['DELETE'])
@manager_required  
def api_manager_delete_recommendation(recommendation_id):
    """Delete a recommendation"""
    from models import Recommendation
    
    current_manager = current_user
    
    try:
        # Find recommendation that belongs to this manager
        recommendation = Recommendation.query.filter_by(
            id=recommendation_id, 
            manager_id=current_manager.id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        db.session.delete(recommendation)
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/clients-list', methods=['GET'])
@manager_required
def api_manager_get_clients_list():
    """Get manager's clients for filters"""
    from models import User
    
    current_manager = current_user
    
    try:
        # Get clients assigned to this manager or all buyers
        clients = User.query.filter_by(role='buyer').order_by(User.full_name).all()
        
        clients_data = []
        for client in clients:
            clients_data.append({
                'id': client.id,
                'full_name': client.full_name or '–ë–µ–∑ –∏–º–µ–Ω–∏',
                'email': client.email
            })
        
        return jsonify({
            'success': True,
            'clients': clients_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/properties/search', methods=['POST'])
@login_required
def api_search_properties():
    """Search properties with filters from dashboard"""
    data = request.get_json()
    filters = data.get('filters', {})
    
    try:
        # Convert collection filters to property filters
        property_filters = {}
        
        if filters.get('priceFrom'):
            property_filters['price_min'] = filters['priceFrom']
        if filters.get('priceTo'):
            property_filters['price_max'] = filters['priceTo']
        if filters.get('rooms'):
            property_filters['rooms'] = filters['rooms']
        if filters.get('districts') and filters['districts']:
            property_filters['district'] = filters['districts'][0]
        if filters.get('developers') and filters['developers']:
            property_filters['developer'] = filters['developers'][0]
        if filters.get('areaFrom'):
            property_filters['area_min'] = filters['areaFrom']
        if filters.get('areaTo'):
            property_filters['area_max'] = filters['areaTo']
        
        # Get filtered properties
        filtered_properties = get_filtered_properties(property_filters)
        
        # Add cashback to each property
        for prop in filtered_properties:
            prop['cashback'] = calculate_cashback(
                prop['price'],
                complex_id=prop.get('complex_id'),
                complex_name=prop.get('residential_complex')
            )
        
        # Sort by price ascending
        filtered_properties = sort_properties(filtered_properties, 'price_asc')
        
        return jsonify({
            'success': True,
            'properties': filtered_properties[:50],  # Limit to 50 results
            'total_count': len(filtered_properties)
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-property', methods=['POST'])
@manager_required
def api_send_property_to_client():
    """Send saved search results to client via email"""
    from models import SavedSearch, User, ClientPropertyRecommendation
    
    data = request.get_json()
    client_id = data.get('client_id')
    search_id = data.get('search_id')
    message = data.get('message', '')
    
    if not client_id or not search_id:
        return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –∏ –ø–æ–∏—Å–∫ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã'}), 400
    
    try:
        # Get the search
        search = SavedSearch.query.get(search_id)
        if not search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Get the client
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Get search filters
        filters = json.loads(search.filters) if search.filters else {}
        
        # Filter properties based on search criteria
        properties = load_properties()
        filtered_properties = filter_properties(properties, filters)
        
        # Create recommendation record
        recommendation = ClientPropertyRecommendation()
        recommendation.client_id = client_id
        recommendation.manager_id = current_user.id
        recommendation.search_name = search.name
        recommendation.search_filters = search.filters
        recommendation.message = message
        recommendation.properties_count = len(filtered_properties)
        recommendation.sent_at = datetime.utcnow()
        
        db.session.add(recommendation)
        db.session.commit()
        
        # Send email with property recommendations
        send_property_email(client, search.name, filtered_properties, message)
        
        return jsonify({'success': True, 'properties_sent': len(filtered_properties)})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

def filter_properties(properties, filters):
    """Filter properties based on search criteria"""
    filtered = []
    
    for prop in properties:
        # Price filter
        if filters.get('priceFrom'):
            try:
                if prop.get('price', 0) < int(filters['priceFrom']):
                    continue
            except (ValueError, TypeError):
                pass
        
        if filters.get('priceTo'):
            try:
                if prop.get('price', 0) > int(filters['priceTo']):
                    continue
            except (ValueError, TypeError):
                pass
        
        # Rooms filter
        if filters.get('rooms'):
            prop_rooms = str(prop.get('rooms', ''))
            if filters['rooms'] == 'studio' and prop_rooms != 'studio':
                continue
            elif filters['rooms'] != 'studio' and prop_rooms != str(filters['rooms']):
                continue
        
        # District filter
        if filters.get('districts') and len(filters['districts']) > 0:
            prop_district = prop.get('district', '')
            if prop_district not in filters['districts']:
                continue
        
        # Area filter
        if filters.get('areaFrom'):
            try:
                if prop.get('area', 0) < int(filters['areaFrom']):
                    continue
            except (ValueError, TypeError):
                pass
        
        if filters.get('areaTo'):
            try:
                if prop.get('area', 0) > int(filters['areaTo']):
                    continue
            except (ValueError, TypeError):
                pass
        
        # Developer filter
        if filters.get('developers') and len(filters['developers']) > 0:
            prop_developer = prop.get('developer', '')
            if prop_developer not in filters['developers']:
                continue
        
        filtered.append(prop)
    
    return filtered

def send_property_email(client, search_name, properties, message):
    """Send email with property recommendations"""
    try:
        subject = f"–ù–æ–≤–∞—è –ø–æ–¥–±–æ—Ä–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {search_name}"
        
        properties_html = ""
        for prop in properties[:10]:  # Limit to first 10 properties
            properties_html += f"""
            <div style="border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                <h3 style="margin: 0 0 8px 0; color: #1f2937;">{prop.get('name', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è')}</h3>
                <p style="margin: 0 0 4px 0; color: #6b7280;">–ñ–ö: {prop.get('complex_name', '–ù–µ —É–∫–∞–∑–∞–Ω')}</p>
                <p style="margin: 0 0 4px 0; color: #6b7280;">–¶–µ–Ω–∞: {prop.get('price', 0):,} ‚ÇΩ</p>
                <p style="margin: 0 0 4px 0; color: #6b7280;">–ü–ª–æ—â–∞–¥—å: {prop.get('area', 0)} –º¬≤</p>
                <p style="margin: 0 0 8px 0; color: #6b7280;">–ö–æ–º–Ω–∞—Ç: {prop.get('rooms', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}</p>
                <a href="https://inback.ru/properties/{prop.get('id', '')}" style="color: #0088cc; text-decoration: none;">–ü–æ–¥—Ä–æ–±–Ω–µ–µ ‚Üí</a>
            </div>
            """
        
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <h2 style="color: #0088cc;">–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–∞—è –ø–æ–¥–±–æ—Ä–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏</h2>
                
                <p>–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {client.full_name}!</p>
                
                <p>–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –¥–ª—è –≤–∞—Å –ø–æ–¥–±–æ—Ä–∫—É –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: <strong>{search_name}</strong></p>
                
                {f'<div style="background: #f3f4f6; padding: 16px; border-radius: 8px; margin: 16px 0;"><p style="margin: 0; font-style: italic;">"{message}"</p></div>' if message else ''}
                
                <h3>–ù–∞–π–¥–µ–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã ({len(properties)} –æ–±—ä–µ–∫—Ç–æ–≤):</h3>
                
                {properties_html}
                
                {f'<p style="color: #6b7280;">–ò –µ—â–µ {len(properties) - 10} –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –ø–æ–ª–Ω–æ–º –∫–∞—Ç–∞–ª–æ–≥–µ...</p>' if len(properties) > 10 else ''}
                
                <div style="margin-top: 32px; padding: 20px; background: #f9fafb; border-radius: 8px; text-align: center;">
                    <h3 style="margin: 0 0 8px 0;">–ù—É–∂–Ω–∞ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—è?</h3>
                    <p style="margin: 0 0 16px 0;">–°–≤—è–∂–∏—Ç–µ—Å—å —Å –≤–∞—à–∏–º –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º</p>
                    <a href="mailto:manager@inback.ru" style="background: #0088cc; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">–ù–∞–ø–∏—Å–∞—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä—É</a>
                </div>
                
                <div style="margin-top: 20px; text-align: center; color: #6b7280; font-size: 14px;">
                    <p>–° —É–≤–∞–∂–µ–Ω–∏–µ–º,<br>–ö–æ–º–∞–Ω–¥–∞ InBack.ru</p>
                </div>
            </div>
        </body>
        </html>
        """
        
        return send_notification(
            client.email,
            subject,
            html_content,
            notification_type="property_recommendation",
            user_id=client.id
        )
    except Exception as e:
        print(f"Error sending property email: {e}")
        return False

@app.route('/api/manager/collection/<int:collection_id>/add_property', methods=['POST'])
@manager_required
def add_property_to_collection(collection_id):
    from models import Collection, CollectionProperty
    import json
    
    current_manager = current_user
    
    data = request.get_json()
    property_id = data.get('property_id')
    manager_note = data.get('manager_note', '')
    
    collection = Collection.query.filter_by(
        id=collection_id,
        created_by_manager_id=current_manager.id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    # Load property data from JSON
    try:
        with open('data/properties.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        property_info = None
        for prop in properties_data:
            if str(prop['id']) == str(property_id):
                property_info = prop
                break
        
        if not property_info:
            return jsonify({'success': False, 'error': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # Check if property already in collection
        existing = CollectionProperty.query.filter_by(
            collection_id=collection_id,
            property_id=str(property_id)
        ).first()
        
        if existing:
            return jsonify({'success': False, 'error': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –ø–æ–¥–±–æ—Ä–∫—É'}), 400
        
        # Get max order_index
        max_order = db.session.query(db.func.max(CollectionProperty.order_index)).filter_by(
            collection_id=collection_id
        ).scalar() or 0
        
        # DUAL WRITE: Get Property object to access both database ID and inner_id
        from models import Property as PropertyModel
        property_obj, canonical_id = resolve_property_by_identifier(property_id)
        if not property_obj:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö'}), 404
        
        collection_property = CollectionProperty()
        collection_property.collection_id = collection_id
        collection_property.property_id = str(property_obj.id)  # Old: database ID
        collection_property.property_inner_id = property_obj.inner_id  # NEW: canonical inner_id
        collection_property.property_name = property_info['title']
        collection_property.property_price = property_info['price']
        collection_property.complex_name = property_info.get('residential_complex', '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω')
        collection_property.property_type = f"{property_info['rooms']}-–∫–æ–º–Ω"
        collection_property.property_size = property_info['area']
        collection_property.manager_note = manager_note
        collection_property.order_index = max_order + 1
        
        db.session.add(collection_property)
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collection/<int:collection_id>/send', methods=['POST'])
@manager_required
def send_collection(collection_id):
    from models import Collection
    
    current_manager = current_user
    
    collection = Collection.query.filter_by(
        id=collection_id,
        created_by_manager_id=current_manager.id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    if not collection.assigned_to_user_id:
        return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω'}), 400
    
    if len(collection.properties) == 0:
        return jsonify({'success': False, 'error': '–í –ø–æ–¥–±–æ—Ä–∫–µ –Ω–µ—Ç –∫–≤–∞—Ä—Ç–∏—Ä'}), 400
    
    try:
        collection.status = '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞'
        collection.sent_at = datetime.utcnow()
        collection.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/properties/search')
@manager_required
def search_properties():
    """Search properties using normalized tables"""
    from repositories.property_repository import PropertyRepository
    
    query = request.args.get('q', '').lower()
    limit = int(request.args.get('limit', 20))
    
    try:
        properties = PropertyRepository.get_all_active(limit=limit * 3)
        
        filtered_properties = []
        for prop in properties:
            prop_type = f"{prop.rooms}-–∫–æ–º–Ω" if prop.rooms > 0 else "–°—Ç—É–¥–∏—è"
            complex_name = prop.residential_complex.name if prop.residential_complex else '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω'
            developer_name = prop.developer.name if prop.developer else ''
            district_name = prop.residential_complex.district if prop.residential_complex else ''
            
            property_title = f"{prop.rooms}-–∫–æ–º–Ω {prop.area} –º¬≤" if prop.rooms > 0 else f"–°—Ç—É–¥–∏—è {prop.area} –º¬≤"
            
            if (query in property_title.lower() or 
                query in complex_name.lower() or 
                query in prop_type.lower() or
                query in developer_name.lower() or
                query in district_name.lower()):
                
                photos_list = []
                if prop.gallery_images:
                    try:
                        if isinstance(prop.gallery_images, list):
                            photos_list = prop.gallery_images
                        elif isinstance(prop.gallery_images, str):
                            photos_list = json.loads(prop.gallery_images)
                    except:
                        pass
                
                main_image = prop.main_image or (photos_list[0] if photos_list else '/static/images/property-placeholder.jpg')
                
                filtered_properties.append({
                    'id': prop.inner_id or prop.id,
                    'title': property_title,
                    'price': prop.price or 0,
                    'complex': complex_name,
                    'type': prop_type,
                    'size': prop.area or 0,
                    'image': main_image
                })
            
            if len(filtered_properties) >= limit:
                break
        
        return jsonify({'properties': filtered_properties})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/client/collections')
@login_required
def get_client_collections():
    """Get collections assigned to current user"""
    from models import Collection, CollectionProperty
    from datetime import datetime
    
    user_id = current_user.id
    
    collections = Collection.query.filter_by(assigned_to_user_id=user_id).all()
    
    collections_data = []
    for collection in collections:
        properties_count = len(collection.properties)
        
        # Mark as viewed if not already
        if collection.status == '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞':
            collection.status = '–ü—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–∞'
            collection.viewed_at = datetime.utcnow()
            db.session.commit()
        
        collections_data.append({
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status,
            'created_by_manager_name': collection.created_by.full_name,
            'properties_count': properties_count,
            'created_at': collection.created_at.strftime('%d.%m.%Y'),
            'sent_at': collection.sent_at.strftime('%d.%m.%Y %H:%M') if collection.sent_at else None,
            'tags': collection.tags
        })
    
    return jsonify({'collections': collections_data})

@app.route('/api/client/collection/<int:collection_id>/properties')
@login_required
def get_client_collection_properties(collection_id):
    """Get properties in a collection for client view"""
    from models import Collection, CollectionProperty
    
    user_id = current_user.id
    
    collection = Collection.query.filter_by(
        id=collection_id,
        assigned_to_user_id=user_id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    properties_data = []
    for prop in collection.properties:
        # Calculate potential cashback (example: 2% of price)
        cashback_percent = 2.0
        cashback_amount = int(prop.property_price * cashback_percent / 100)
        
        properties_data.append({
            'id': prop.id,
            'property_id': prop.property_id,
            'property_name': prop.property_name,
            'property_price': prop.property_price,
            'complex_name': prop.complex_name,
            'property_type': prop.property_type,
            'property_size': prop.property_size,
            'manager_note': prop.manager_note,
            'cashback_amount': cashback_amount,
            'cashback_percent': cashback_percent
        })
    
    # Sort by order_index
    properties_data.sort(key=lambda x: collection.properties[0].order_index if collection.properties else 0)
    
    return jsonify({
        'collection': {
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status,
            'manager_name': collection.created_by.full_name,
            'sent_at': collection.sent_at.strftime('%d.%m.%Y %H:%M') if collection.sent_at else None
        },
        'properties': properties_data
    })

@app.route('/partner')
@login_required
def partner_cabinet():
    """Standalone partner cabinet page"""
    from models import Referral, UserBalance
    if not current_user.referral_code:
        current_user.referral_code = current_user.generate_referral_code()
        db.session.commit()
    referrals = Referral.query.filter_by(referrer_id=current_user.id).order_by(Referral.created_at.desc()).all()
    total_earned = sum(float(r.bonus_amount) for r in referrals)
    user_balance_obj = UserBalance.query.filter_by(user_id=current_user.id).first()
    available_balance = float(user_balance_obj.available_amount) if user_balance_obj and user_balance_obj.available_amount else 0
    referral_link = f"{request.host_url}login?ref={current_user.referral_code}"
    referrals_data = []
    for r in referrals:
        referrals_data.append({
            'id': r.id,
            'referred_name': (r.referred.full_name or '–ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å') if r.referred else '–£–¥–∞–ª—ë–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å',
            'referred_phone': (r.referred.phone[:7] + '***' + r.referred.phone[-2:]) if r.referred and r.referred.phone else '',
            'bonus_amount': float(r.bonus_amount),
            'status': r.status,
            'created_at': r.created_at.strftime('%d.%m.%Y')
        })
    return render_template('auth/partner_cabinet.html',
        referral_code=current_user.referral_code,
        referral_link=referral_link,
        total_referrals=len(referrals),
        total_earned=total_earned,
        available_balance=available_balance,
        referrals=referrals_data
    )

@app.route('/api/user/referrals')
@login_required
def get_user_referrals():
    from models import Referral
    try:
        if not current_user.referral_code:
            current_user.referral_code = current_user.generate_referral_code()
            db.session.commit()
        referrals = Referral.query.filter_by(referrer_id=current_user.id).order_by(Referral.created_at.desc()).all()
        total_earned = sum(r.bonus_amount for r in referrals)
        return jsonify({
            'success': True,
            'referral_code': current_user.referral_code,
            'referral_link': f"{request.host_url}login?ref={current_user.referral_code}",
            'total_referrals': len(referrals),
            'total_earned': float(total_earned),
            'referrals': [{
                'id': r.id,
                'referred_name': (r.referred.full_name or '–ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å') if r.referred else '–£–¥–∞–ª—ë–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å',
                'referred_phone': (r.referred.phone[:7] + '***' + r.referred.phone[-2:]) if r.referred and r.referred.phone else '',
                'bonus_amount': float(r.bonus_amount),
                'status': r.status,
                'created_at': r.created_at.strftime('%d.%m.%Y')
            } for r in referrals]
        })
    except Exception as e:
        logging.error(f"Error in get_user_referrals: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================================
# PARTNER SYSTEM ROUTES
# ============================================================================

@app.route('/partner/login', methods=['GET', 'POST'])
@csrf.exempt
def partner_login():
    from models import Partner
    if request.method == 'POST':
        phone = request.form.get('phone', '').strip()
        password = request.form.get('password', '').strip()
        
        if not phone or not password:
            flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è', 'error')
            return render_template('partner/login.html')
        
        phone_clean = phone.replace("+", "").replace("-", "").replace(" ", "").replace("(", "").replace(")", "")
        
        from sqlalchemy import func as sqlfunc
        partner = Partner.query.filter(
            sqlfunc.replace(sqlfunc.replace(sqlfunc.replace(Partner.phone, "-", ""), " ", ""), "+", "") == phone_clean
        ).first()
        
        if not partner:
            partner = Partner.query.filter_by(email=phone).first()
        
        if not partner or not partner.is_active:
            flash('–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞', 'error')
            return render_template('partner/login.html')
        
        if not partner.check_password(password):
            flash('–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞', 'error')
            return render_template('partner/login.html')
        
        partner.last_login = datetime.utcnow()
        partner.last_ip = request.remote_addr
        partner.last_user_agent = request.headers.get('User-Agent', '')[:500]
        db.session.commit()
        
        login_user(partner, remember=True)
        session.permanent = True
        return redirect(url_for('partner_dashboard'))
    
    ref = request.args.get('ref', '')
    if ref:
        session['partner_referral_code'] = ref
    return render_template('partner/login.html', ref=ref)


@app.route('/partner/register', methods=['GET'])
def partner_register():
    ref = request.args.get('ref', '')
    if ref:
        session['partner_referral_code'] = ref
    return render_template('partner/login.html', ref=ref, open_register=True)


@app.route('/partner/register/send-code', methods=['POST'])
@csrf.exempt
def partner_register_send_code():
    from models import Partner, PhoneVerification
    from sms_service import sms_service
    import logging
    logger = logging.getLogger(__name__)
    
    data = request.get_json() if request.is_json else {}
    phone = data.get('phone', '').strip()
    
    if not phone:
        return jsonify({'success': False, 'message': '–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞'})
    
    phone_clean = phone.replace("+", "").replace("-", "").replace(" ", "").replace("(", "").replace(")", "")
    
    from sqlalchemy import func as sqlfunc
    existing_partner = Partner.query.filter(
        sqlfunc.replace(sqlfunc.replace(sqlfunc.replace(Partner.phone, "-", ""), " ", ""), "+", "") == phone_clean
    ).first()
    
    if existing_partner:
        return jsonify({'success': False, 'message': '–≠—Ç–æ—Ç –Ω–æ–º–µ—Ä —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –∫–∞–∫ –ø–∞—Ä—Ç–Ω—ë—Ä. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—Ö–æ–¥.'})
    
    verification = PhoneVerification.create_code(
        phone=phone_clean,
        ip_address=request.remote_addr,
        user_agent=request.headers.get('User-Agent')
    )
    db.session.add(verification)
    db.session.commit()
    
    result = sms_service.send_verification_code(phone_clean, verification.code)
    
    if result['success']:
        session['partner_registration_phone'] = phone_clean
        return jsonify({'success': True, 'message': '–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω', 'code': verification.code})
    else:
        return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ SMS: {result["message"]}'})


@app.route('/partner/register/verify-code', methods=['POST'])
@csrf.exempt
def partner_register_verify_code():
    from models import PhoneVerification
    
    data = request.get_json() if request.is_json else {}
    phone = data.get('phone', '').strip()
    code = data.get('code', '').strip()
    
    if not phone or not code:
        return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ'})
    
    phone_clean = phone.replace("+", "").replace("-", "").replace(" ", "").replace("(", "").replace(")", "")
    
    verification = PhoneVerification.query.filter_by(
        phone=phone_clean,
        code=code
    ).order_by(PhoneVerification.created_at.desc()).first()
    
    if not verification:
        return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è'})
    
    if not verification.is_valid():
        return jsonify({'success': False, 'message': '–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏—Å—Ç—ë–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π.'})
    
    verification.attempts += 1
    verification.is_verified = True
    verification.verified_at = datetime.utcnow()
    db.session.commit()
    
    session['partner_verified_phone'] = phone_clean
    return jsonify({'success': True, 'message': '–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω'})


@app.route('/partner/register/complete', methods=['POST'])
@csrf.exempt
def partner_register_complete():
    from models import Partner, PartnerReferral
    from sms_service import sms_service
    import secrets
    import string
    import logging
    logger = logging.getLogger(__name__)
    
    data = request.get_json() if request.is_json else {}
    phone = data.get('phone', '').strip()
    first_name = data.get('first_name', '').strip()
    last_name = data.get('last_name', '').strip()
    
    if not phone or not first_name:
        return jsonify({'success': False, 'message': '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –∏–º—è'})
    
    phone_clean = phone.replace("+", "").replace("-", "").replace(" ", "").replace("(", "").replace(")", "")
    
    verified_phone = session.get('partner_verified_phone', '')
    if verified_phone != phone_clean:
        return jsonify({'success': False, 'message': '–¢–µ–ª–µ—Ñ–æ–Ω –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω. –ü—Ä–æ–π–¥–∏—Ç–µ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ.'})
    
    from sqlalchemy import func as sqlfunc
    existing = Partner.query.filter(
        sqlfunc.replace(sqlfunc.replace(sqlfunc.replace(Partner.phone, "-", ""), " ", ""), "+", "") == phone_clean
    ).first()
    if existing:
        return jsonify({'success': False, 'message': '–≠—Ç–æ—Ç –Ω–æ–º–µ—Ä —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω'})
    
    phone_digits = phone_clean.replace("+", "")
    if len(phone_digits) == 11 and phone_digits.startswith('7'):
        phone_formatted = f"+7-{phone_digits[1:4]}-{phone_digits[4:7]}-{phone_digits[7:9]}-{phone_digits[9:11]}"
    else:
        phone_formatted = phone_clean
    
    temp_password = ''.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(8))
    
    ref_code = data.get('ref', '') or session.pop('partner_referral_code', '')
    
    try:
        partner = Partner(
            phone=phone_formatted,
            first_name=first_name,
            last_name=last_name or ''
        )
        partner.set_password(temp_password)
        
        referrer = None
        if ref_code:
            ref_code = ref_code.strip().upper()
            referrer = Partner.query.filter_by(referral_code=ref_code, is_active=True).first()
            if referrer:
                partner.referred_by_id = referrer.id
                partner.level = (referrer.level or 1) + 1
        
        db.session.add(partner)
        db.session.commit()
        db.session.refresh(partner)
        
        if referrer:
            bonus_amount = Decimal('20000.00')
            referral_record = PartnerReferral(
                partner_id=referrer.id,
                referred_partner_id=partner.id,
                bonus_amount=bonus_amount,
                status='credited',
                level=1,
                credited_at=datetime.utcnow()
            )
            db.session.add(referral_record)
            
            referrer.balance = (referrer.balance or Decimal('0.00')) + bonus_amount
            referrer.total_earned = (referrer.total_earned or Decimal('0.00')) + bonus_amount
            referrer.total_referrals = (referrer.total_referrals or 0) + 1
            
            db.session.commit()
            logger.info(f"Partner referral bonus 20000 credited to partner {referrer.id}")
            
            if referrer.referred_by_id:
                level2_referrer = Partner.query.get(referrer.referred_by_id)
                if level2_referrer and level2_referrer.is_active:
                    level2_bonus = Decimal('5000.00')
                    level2_record = PartnerReferral(
                        partner_id=level2_referrer.id,
                        referred_partner_id=partner.id,
                        bonus_amount=level2_bonus,
                        status='credited',
                        level=2,
                        credited_at=datetime.utcnow()
                    )
                    db.session.add(level2_record)
                    level2_referrer.balance = (level2_referrer.balance or Decimal('0.00')) + level2_bonus
                    level2_referrer.total_earned = (level2_referrer.total_earned or Decimal('0.00')) + level2_bonus
                    db.session.commit()
                    logger.info(f"Level 2 partner referral bonus 5000 credited to partner {level2_referrer.id}")
        
        sms_result = sms_service.send_sms(
            phone=phone_clean,
            message=f"–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ –ø–∞—Ä—Ç–Ω—ë—Ä—Å–∫–æ–π –ø—Ä–æ–≥—Ä–∞–º–º–µ InBack! –í–∞—à –ø–∞—Ä–æ–ª—å: {temp_password}. –í–∞—à –ø–∞—Ä—Ç–Ω—ë—Ä—Å–∫–∏–π ID: {partner.partner_id}"
        )
        
        session.pop('partner_verified_phone', None)
        session.pop('partner_registration_phone', None)
        
        login_user(partner, remember=True)
        session.permanent = True
        
        return jsonify({'success': True, 'redirect': url_for('partner_dashboard')})
    
    except Exception as e:
        db.session.rollback()
        logger.error(f"Error creating partner: {str(e)}", exc_info=True)
        return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: {str(e)}'})


@app.route('/partner/logout')
def partner_logout():
    logout_user()
    return redirect(url_for('partner_login'))


@app.route('/partner/dashboard')
@login_required
def partner_dashboard():
    from models import Partner
    if not isinstance(current_user, Partner):
        return redirect(url_for('partner_login'))
    
    referral_link = f"{request.host_url}partner/register?ref={current_user.referral_code}"
    
    return render_template('partner/dashboard.html',
        partner=current_user,
        referral_link=referral_link
    )


@app.route('/partner/api/stats')
@login_required
def partner_api_stats():
    from models import Partner, PartnerReferral
    if not isinstance(current_user, Partner):
        return jsonify({'success': False, 'message': 'Unauthorized'}), 403
    
    direct_referrals = PartnerReferral.query.filter_by(partner_id=current_user.id, level=1).count()
    level2_referrals = PartnerReferral.query.filter_by(partner_id=current_user.id, level=2).count()
    
    return jsonify({
        'success': True,
        'balance': float(current_user.balance or 0),
        'total_earned': float(current_user.total_earned or 0),
        'total_referrals': current_user.total_referrals or 0,
        'direct_referrals': direct_referrals,
        'level2_referrals': level2_referrals,
        'level': current_user.level or 1,
        'partner_id': current_user.partner_id,
        'referral_code': current_user.referral_code
    })


@app.route('/partner/api/referrals')
@login_required
def partner_api_referrals():
    from models import Partner, PartnerReferral
    if not isinstance(current_user, Partner):
        return jsonify({'success': False, 'message': 'Unauthorized'}), 403
    
    referrals = PartnerReferral.query.filter_by(partner_id=current_user.id).order_by(PartnerReferral.created_at.desc()).all()
    
    result = []
    for r in referrals:
        ref_data = {
            'id': r.id,
            'bonus_amount': float(r.bonus_amount),
            'status': r.status,
            'level': r.level,
            'created_at': r.created_at.strftime('%d.%m.%Y') if r.created_at else ''
        }
        if r.referred_partner_id:
            rp = Partner.query.get(r.referred_partner_id)
            if rp:
                ref_data['name'] = rp.full_name
                ref_data['phone'] = rp.phone[:7] + '***' + rp.phone[-2:] if rp.phone and len(rp.phone) > 9 else '***'
            else:
                ref_data['name'] = '–£–¥–∞–ª—ë–Ω–Ω—ã–π –ø–∞—Ä—Ç–Ω—ë—Ä'
                ref_data['phone'] = '***'
        elif r.referred_user_id:
            from models import User
            ru = User.query.get(r.referred_user_id)
            if ru:
                ref_data['name'] = ru.full_name or '–ü–æ–∫—É–ø–∞—Ç–µ–ª—å'
                ref_data['phone'] = ru.phone[:7] + '***' + ru.phone[-2:] if ru.phone and len(ru.phone) > 9 else '***'
            else:
                ref_data['name'] = '–£–¥–∞–ª—ë–Ω–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'
                ref_data['phone'] = '***'
        else:
            ref_data['name'] = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π'
            ref_data['phone'] = '***'
        result.append(ref_data)
    
    return jsonify({'success': True, 'referrals': result})


@app.route('/partner/api/withdrawal', methods=['POST'])
@login_required
@csrf.exempt
def partner_api_withdrawal():
    from models import Partner, PartnerWithdrawal
    if not isinstance(current_user, Partner):
        return jsonify({'success': False, 'message': 'Unauthorized'}), 403
    
    data = request.get_json() if request.is_json else {}
    amount = data.get('amount')
    payment_method = data.get('payment_method', '').strip()
    payment_details = data.get('payment_details', '').strip()
    
    if not amount or not payment_method or not payment_details:
        return jsonify({'success': False, 'message': '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è'})
    
    try:
        amount = Decimal(str(amount))
    except:
        return jsonify({'success': False, 'message': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—É–º–º–∞'})
    
    if amount <= 0:
        return jsonify({'success': False, 'message': '–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ 0'})
    
    if amount < Decimal('1000'):
        return jsonify({'success': False, 'message': '–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –≤—ã–≤–æ–¥–∞: 1 000 ‚ÇΩ'})
    
    current_balance = current_user.balance or Decimal('0.00')
    if amount > current_balance:
        return jsonify({'success': False, 'message': '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –Ω–∞ –±–∞–ª–∞–Ω—Å–µ'})
    
    pending_withdrawals = PartnerWithdrawal.query.filter_by(
        partner_id=current_user.id,
        status='pending'
    ).count()
    
    if pending_withdrawals > 0:
        return jsonify({'success': False, 'message': '–£ –≤–∞—Å —É–∂–µ –µ—Å—Ç—å –∑–∞—è–≤–∫–∞ –Ω–∞ –≤—ã–≤–æ–¥ –≤ –æ–±—Ä–∞–±–æ—Ç–∫–µ'})
    
    withdrawal = PartnerWithdrawal(
        partner_id=current_user.id,
        amount=amount,
        payment_method=payment_method,
        payment_details=payment_details
    )
    db.session.add(withdrawal)
    
    current_user.balance = current_balance - amount
    db.session.commit()
    
    return jsonify({'success': True, 'message': '–ó–∞—è–≤–∫–∞ –Ω–∞ –≤—ã–≤–æ–¥ —Å–æ–∑–¥–∞–Ω–∞'})


@app.route('/partner/api/withdrawals')
@login_required
def partner_api_withdrawals():
    from models import Partner, PartnerWithdrawal
    if not isinstance(current_user, Partner):
        return jsonify({'success': False, 'message': 'Unauthorized'}), 403
    
    withdrawals = PartnerWithdrawal.query.filter_by(partner_id=current_user.id).order_by(PartnerWithdrawal.created_at.desc()).all()
    
    status_labels = {
        'pending': '–ù–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏',
        'approved': '–û–¥–æ–±—Ä–µ–Ω–∞',
        'rejected': '–û—Ç–∫–ª–æ–Ω–µ–Ω–∞',
        'completed': '–í—ã–ø–æ–ª–Ω–µ–Ω–∞'
    }
    
    result = []
    for w in withdrawals:
        result.append({
            'id': w.id,
            'amount': float(w.amount),
            'status': w.status,
            'status_label': status_labels.get(w.status, w.status),
            'payment_method': w.payment_method,
            'payment_details': w.payment_details,
            'created_at': w.created_at.strftime('%d.%m.%Y %H:%M') if w.created_at else '',
            'processed_at': w.processed_at.strftime('%d.%m.%Y %H:%M') if w.processed_at else '',
            'admin_comment': w.admin_comment or ''
        })
    
    return jsonify({'success': True, 'withdrawals': result})


@app.route('/partner/api/structure')
@login_required
def partner_api_structure():
    from models import Partner, PartnerReferral
    if not isinstance(current_user, Partner):
        return jsonify({'success': False, 'message': 'Unauthorized'}), 403
    
    direct = Partner.query.filter_by(referred_by_id=current_user.id).all()
    
    structure = {'level1': [], 'level2': []}
    
    for p in direct:
        p_data = {
            'id': p.id,
            'name': p.full_name,
            'phone': p.phone[:7] + '***' + p.phone[-2:] if p.phone and len(p.phone) > 9 else '***',
            'partner_id': p.partner_id,
            'joined': p.created_at.strftime('%d.%m.%Y') if p.created_at else '',
            'referrals_count': Partner.query.filter_by(referred_by_id=p.id).count()
        }
        structure['level1'].append(p_data)
        
        sub_partners = Partner.query.filter_by(referred_by_id=p.id).all()
        for sp in sub_partners:
            structure['level2'].append({
                'id': sp.id,
                'name': sp.full_name,
                'phone': sp.phone[:7] + '***' + sp.phone[-2:] if sp.phone and len(sp.phone) > 9 else '***',
                'partner_id': sp.partner_id,
                'joined': sp.created_at.strftime('%d.%m.%Y') if sp.created_at else '',
                'parent_name': p.full_name
            })
    
    return jsonify({'success': True, 'structure': structure})


# END PARTNER SYSTEM ROUTES

@app.route('/dashboard')
@login_required
def dashboard():
    """User dashboard - –ò–°–ü–†–ê–í–õ–ï–ù–û: —Ä–µ–¥–∏—Ä–µ–∫—Ç–∏—Ç –∞–¥–º–∏–Ω–æ–≤ –∏ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤"""
    from models import Admin, Manager
    
    # –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    # –ê–¥–º–∏–Ω—ã –∏ –º–µ–Ω–µ–¥–∂–µ—Ä—ã –ù–ï –¥–æ–ª–∂–Ω—ã –ø–æ–ø–∞–¥–∞—Ç—å –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π dashboard
    if isinstance(current_user._get_current_object(), Admin):
        return redirect(url_for('admin_dashboard'))
    elif isinstance(current_user._get_current_object(), Manager):
        return redirect(url_for('manager_dashboard'))
    
    try:
        from models import CashbackApplication, FavoriteProperty, FavoriteComplex, Document, Collection, Recommendation, SentSearch, SavedSearch, UserActivity, Deal, UserBalance, BalanceTransaction
        
        # Get user's data for dashboard
        cashback_apps = CashbackApplication.query.filter_by(user_id=current_user.id).all()
        favorites = FavoriteProperty.query.filter_by(user_id=current_user.id).all()
        complex_favorites = FavoriteComplex.query.filter_by(user_id=current_user.id).all()
        documents = Document.query.filter_by(user_id=current_user.id).all()
        collections = Collection.query.filter_by(assigned_to_user_id=current_user.id).order_by(Collection.created_at.desc()).all()
        
        # Get user's deals (—Å–¥–µ–ª–∫–∏ —Å–æ–∑–¥–∞–Ω–Ω—ã–µ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º –¥–ª—è —ç—Ç–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞)
        deals = Deal.query.filter_by(client_id=current_user.id).order_by(Deal.created_at.desc()).all()
        
        # Get recommendations from managers (exclude dismissed) with categories
        recommendations = Recommendation.query.filter(
            Recommendation.client_id == current_user.id,
            Recommendation.status != 'dismissed'
        ).options(db.joinedload(Recommendation.category)).order_by(Recommendation.created_at.desc()).all()
        
        # Get unique categories for the client (import here to avoid circular imports)
        from models import RecommendationCategory
        categories = RecommendationCategory.query.filter_by(client_id=current_user.id, is_active=True).all()
        
        # –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—ã–µ properties –¥–ª—è recommendations –∏–∑ –ë–î
        from models import Property, ResidentialComplex
        
        # –ü–æ–ª—É—á–∞–µ–º ID –Ω—É–∂–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
        property_ids = [rec.item_id for rec in recommendations if rec.recommendation_type == 'property' and rec.item_id]
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—ã–µ properties —Å JOIN (–æ–¥–Ω–∏–º –∑–∞–ø—Ä–æ—Å–æ–º!)
        properties_dict = {}
        if property_ids:
            properties_query = db.session.query(
                Property,
                ResidentialComplex.name.label('complex_name')
            ).outerjoin(
                ResidentialComplex, Property.complex_id == ResidentialComplex.id
            ).filter(
                Property.inner_id.in_(property_ids),
                Property.is_active == True
            ).all()
            
            for prop, complex_name in properties_query:
                properties_dict[prop.inner_id] = {
                    'id': str(prop.id),
                    'rooms': prop.rooms,
                    'area': prop.area,
                    'floor': prop.floor,
                    'total_floors': prop.total_floors,
                    'price': prop.price,
                    'main_image': prop.main_image,
                    'complex_name': complex_name,
                    'property_type': 'apartment',
                    'property_type_ru': '–ö–≤–∞—Ä—Ç–∏—Ä–∞'
                }
        
        # Enrich recommendations with property details
        for rec in recommendations:
            if rec.recommendation_type == 'property' and rec.item_id:
                try:
                    property_data = properties_dict.get(rec.item_id)
                    if property_data:
                        # Create a simple object to store property details
                        class PropertyDetails:
                            def __init__(self, data):
                                for key, value in data.items():
                                    setattr(self, key, value)
                                self.residential_complex = data.get('complex_name', '–ù–µ —É–∫–∞–∑–∞–Ω')
                        
                        rec.property_details = PropertyDetails(property_data)
                        print(f"‚úÖ Loaded property {rec.item_id}: {property_data.get('rooms')} –∫–æ–º–Ω, –ñ–ö {property_data.get('complex_name')}")
                    else:
                        print(f"Property {rec.item_id} not found in database")
                        rec.property_details = None
                except Exception as e:
                    print(f"Error loading property details for recommendation {rec.id}: {e}")
                    rec.property_details = None
        
        # Get sent searches from managers
        sent_searches = SentSearch.query.filter_by(client_id=current_user.id).order_by(SentSearch.sent_at.desc()).all()
        
        # Get user's saved searches
        saved_searches = SavedSearch.query.filter_by(user_id=current_user.id).order_by(SavedSearch.created_at.desc()).all()
        
        # Calculate totals from DEALS (—Å–¥–µ–ª–∫–∏ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ - —ç—Ç–æ —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ!)
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º Decimal –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏!
        from decimal import Decimal
        
        # –í—ã–ø–ª–∞—á–µ–Ω–Ω—ã–π –∫–µ—à–±–µ–∫ = —Å–¥–µ–ª–∫–∏ —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º "completed"
        total_cashback = sum((deal.cashback_amount for deal in deals if deal.status in ('completed', 'successful')), Decimal('0'))
        
        # –í –æ–±—Ä–∞–±–æ—Ç–∫–µ = —Å–¥–µ–ª–∫–∏ —Å–æ —Å—Ç–∞—Ç—É—Å–∞–º–∏ new, reserved, mortgage (–≤—Å–µ –∫—Ä–æ–º–µ completed –∏ rejected)
        pending_cashback = sum((deal.cashback_amount for deal in deals if deal.status in ['new', 'reserved', 'mortgage']), Decimal('0'))
        
        # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–¥–µ–ª–æ–∫ (–≤—Å–µ –∫—Ä–æ–º–µ completed –∏ rejected)
        active_apps = len([deal for deal in deals if deal.status not in ['completed', 'successful', 'rejected']])
        
        # –¢–∞–∫–∂–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞—è–≤–æ–∫ –Ω–∞ –∫–µ—à–±–µ–∫ (—Å—Ç–∞—Ä–∞—è —Å–∏—Å—Ç–µ–º–∞)
        cashback_applications_count = len(cashback_apps)
        cashback_apps_pending = len([app for app in cashback_apps if app.status in ['–ù–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏', '–¢—Ä–µ–±—É—é—Ç—Å—è –¥–æ–∫—É–º–µ–Ω—Ç—ã']])
        
        # Get developer appointments
        from models import DeveloperAppointment, BalanceTransaction
        appointments = DeveloperAppointment.query.filter_by(user_id=current_user.id).order_by(DeveloperAppointment.appointment_date.desc()).limit(3).all()
        
        # Load data for manager filters
        districts = get_districts_list()
        developers = get_developers_list()
        
        # Get recent user activities
        recent_activities = UserActivity.get_recent_activities(current_user.id, limit=5)
        
        # Load balance data
        # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º available_amount –∏–∑ UserBalance, –∞ –Ω–µ –æ–±—â–∏–π balance
        user_balance_obj = UserBalance.query.filter_by(user_id=current_user.id).first()
        user_balance = float(user_balance_obj.available_amount) if user_balance_obj else 0
        balance_transactions = BalanceTransaction.query.filter_by(user_id=current_user.id).order_by(BalanceTransaction.created_at.desc()).limit(10).all()

        # Load comparison data (properties and complexes)
        from models import ComparisonProperty, ComparisonComplex, Property, UserComparison
        comparison_properties_count = db.session.query(ComparisonProperty).join(
            UserComparison, ComparisonProperty.user_comparison_id == UserComparison.id
        ).filter(UserComparison.user_id == current_user.id).count()
        
        comparison_complexes_count = db.session.query(ComparisonComplex).join(
            UserComparison, ComparisonComplex.user_comparison_id == UserComparison.id
        ).filter(UserComparison.user_id == current_user.id).count()
        
        total_comparison = comparison_properties_count + comparison_complexes_count
        
        # Load favorites with join to Property to exclude orphaned records
        favorites_with_properties = db.session.query(FavoriteProperty).join(
            Property, Property.inner_id == FavoriteProperty.property_id
        ).filter(
            FavoriteProperty.user_id == current_user.id,
            Property.is_active == True
        ).all()

        
        # Query complex favorites
        favorites_complexes = FavoriteComplex.query.filter_by(user_id=current_user.id).all()
        # Count collections (presentations) assigned to user
        collections_count = Collection.query.filter_by(assigned_to_user_id=current_user.id).count()

        # Sidebar links –¥–ª—è –ø–æ–∫—É–ø–∞—Ç–µ–ª—è
        sidebar_links = [
            {'label': '–ì–ª–∞–≤–Ω–∞—è', 'href': '#dashboard', 'page': 'dashboard', 'active': True, 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg>'},
            {'label': '–ò–∑–±—Ä–∞–Ω–Ω–æ–µ', 'href': '#favorites', 'page': 'favorites', 'badge': str(len(favorites_with_properties) + len(favorites_complexes)), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd"/></svg>'},
            {'label': '–°–¥–µ–ª–∫–∏', 'href': '#deals', 'page': 'deals', 'badge': str(len(deals)) if deals else '0', 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z"/></svg>'},
            {'label': '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏', 'href': '#recommendations', 'page': 'recommendations', 'badge': str(collections_count) if collections_count else '0', 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/></svg>'},
            {'label': '–ë–∞–ª–∞–Ω—Å', 'href': '#balance', 'page': 'balance', 'badge': '{:,.0f}'.format(user_balance).replace(',', ' ') + ' ‚ÇΩ' if user_balance else '0 ‚ÇΩ', 'badge_color': 'balance', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M4 4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2H4z"/><path fill-rule="evenodd" d="M18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9zM4 13a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zm5-1a1 1 0 100 2h1a1 1 0 100-2H9z" clip-rule="evenodd"/></svg>'},
            {'label': '–ü–∞—Ä—Ç–Ω—ë—Ä—Å–∫–∞—è –ø—Ä–æ–≥—Ä–∞–º–º–∞', 'href': '/partner', 'page': 'partner', 'external': True, 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z"/></svg>'},
            {'label': '–ù–∞—Å—Ç—Ä–æ–π–∫–∏', 'href': '#settings', 'page': 'settings', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"/></svg>'}
        ]
        user_profile = {
            'name': current_user.full_name if (hasattr(current_user, 'full_name') and current_user.full_name) else (current_user.email.split('@')[0] if current_user.email and '@' in current_user.email else current_user.email[:15] if current_user.email else current_user.phone if hasattr(current_user, 'phone') and current_user.phone else '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'), 
            'role': '–ü–æ–∫—É–ø–∞—Ç–µ–ª—å', 
            'initials': current_user.full_name[0].upper() if (hasattr(current_user, 'full_name') and current_user.full_name) else (current_user.email[0].upper() if current_user.email else 'U'), 
            'href': url_for('profile'), 
            'avatar': current_user.profile_image if hasattr(current_user, 'profile_image') and current_user.profile_image and 'randomuser.me' not in str(current_user.profile_image) else None
        }
        
        
        # Get assigned manager info for settings tab
        
        # Calculate profile completion percentage
        profile_fields = {
            'full_name': bool(current_user.full_name),
            'phone': bool(current_user.phone),
            'email': bool(current_user.email),
            'avatar': bool(current_user.profile_image and 'randomuser.me' not in (current_user.profile_image or '')),
            'date_of_birth': bool(getattr(current_user, 'date_of_birth', None)),
        }
        profile_completion = int(sum(profile_fields.values()) / len(profile_fields) * 100)
        profile_missing_fields = [k for k, v in profile_fields.items() if not v]
        
        assigned_manager = None
        if current_user.assigned_manager_id:
            assigned_manager = Manager.query.get(current_user.assigned_manager_id)
        return render_template('auth/dashboard.html', 
                             cashback_applications=cashback_apps,
                             favorites=favorites,
                             complex_favorites=complex_favorites,
                             documents=documents,
                             collections=collections,
                             appointments=appointments,
                             recommendations=recommendations,
                             categories=categories,
                             sent_searches=sent_searches,
                             saved_searches=saved_searches,
                             deals=deals,
                             total_cashback=total_cashback,
                             pending_cashback=pending_cashback,
                             active_apps=active_apps,
                             districts=districts,
                             developers=developers,
                             recent_activities=recent_activities,
                             sidebar_links=sidebar_links,
                             user_profile=user_profile,
                             user_balance=user_balance,
                             balance=user_balance,
                             balance_transactions=balance_transactions,
                             assigned_manager=assigned_manager,
                             profile_completion=profile_completion,
                             profile_missing_fields=profile_missing_fields)
    except Exception as e:
        print(f"Dashboard error: {str(e)}")
        import traceback
        traceback.print_exc()
        # Return basic dashboard on error
        districts = get_districts_list()
        developers = get_developers_list()
        
        return render_template('auth/dashboard.html', 
                             cashback_applications=[],
                             favorites=[],
                             complex_favorites=[],
                             documents=[],
                             collections=[],
                             appointments=[],
                             recommendations=[],
                             sent_searches=[],
                             saved_searches=[],
                             deals=[],
                             total_cashback=0,
                             pending_cashback=0,
                             active_apps=0,
                             districts=districts,
                             developers=developers,
                             recent_activities=[])



# ==========================================
# PASSWORD RESET ENDPOINTS
# ==========================================

@app.route('/api/send-reset-code', methods=['POST'])
@csrf.exempt
@require_json_csrf
def api_send_reset_code():
    """Send password reset SMS code"""
    from models import PhoneVerification, User
    from sms_service import sms_service
    import logging
    
    logger = logging.getLogger(__name__)
    
    data = request.get_json()
    phone = data.get('phone', '').strip()
    
    if not phone:
        return jsonify({'success': False, 'message': '–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞'})
    
    # Normalize phone number
    phone_clean = ''.join(filter(str.isdigit, phone))
    if phone_clean.startswith('8'):
        phone_clean = '7' + phone_clean[1:]
    elif phone_clean.startswith('9'):
        phone_clean = '7' + phone_clean
    
    # ‚úÖ STRICT VALIDATION: Enforce 11-digit Russian phone format
    if len(phone_clean) != 11 or not phone_clean.startswith('7'):
        return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞'})
    
    # Check if user exists with this phone
    # ‚úÖ FIX: Use SQL-based normalization to match phones with dashes in database
    phone_digits_only = phone_clean.replace("+", "").replace("-", "").replace(" ", "")
    user = User.query.filter(
        sqlfunc.replace(sqlfunc.replace(sqlfunc.replace(User.phone, "-", ""), " ", ""), "+", "") == phone_digits_only
    ).first()
    if not user:
        # For security, don't reveal if user exists or not
        return jsonify({'success': False, 'message': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º –Ω–µ –Ω–∞–π–¥–µ–Ω'})
    
    # Rate limiting check (60 seconds cooldown)
    if not PhoneVerification.can_send_code(phone_clean, rate_limit_seconds=60):
        return jsonify({'success': False, 'message': '–ö–æ–¥ —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É.'})
    
    logger.info('üîê Creating verification code...')
    # Create verification code (4 digits for password reset)
    verification = PhoneVerification.create_code(
        phone=phone_clean,
        purpose='password_reset',
        ip_address=request.remote_addr,
        user_agent=request.headers.get('User-Agent')
    )
    
    db.session.add(verification)
    
    try:
        db.session.commit()
        
        # Send SMS
        result = sms_service.send_sms(
            phone_clean,
            f'–í–∞—à –∫–æ–¥ –¥–ª—è —Å–±—Ä–æ—Å–∞ –ø–∞—Ä–æ–ª—è InBack: {verification.code}. –ö–æ–¥ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 2 –º–∏–Ω—É—Ç—ã.'
        )
        
        if result['success']:
            logger.info(f"‚úÖ Password reset code sent to {phone_clean[:2]}****{phone_clean[-4:]}")
            return jsonify({'success': True, 'message': '–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –≤–∞—à –Ω–æ–º–µ—Ä'})
        else:
            logger.error(f"‚ùå Failed to send reset code: {result['message']}")
            return jsonify({'success': False, 'message': result['message']})
            
    except Exception as e:
        logger.error(f"‚ùå Error sending reset code: {str(e)}", exc_info=True)
        db.session.rollback()
        return jsonify({'success': False, 'message': '–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–¥–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'})


@app.route('/api/verify-reset-code', methods=['POST'])
@csrf.exempt
@require_json_csrf
def api_verify_reset_code():
    """Verify password reset code and generate reset token"""
    from models import PhoneVerification
    import secrets
    import logging
    
    logger = logging.getLogger(__name__)
    
    data = request.get_json()
    phone = data.get('phone', '').strip()
    code = data.get('code', '').strip()
    
    if not phone or not code:
        return jsonify({'success': False, 'message': '–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏ –∫–æ–¥'})
    
    # Normalize phone number
    phone_clean = ''.join(filter(str.isdigit, phone))
    if phone_clean.startswith('8'):
        phone_clean = '7' + phone_clean[1:]
    elif phone_clean.startswith('9'):
        phone_clean = '7' + phone_clean
    
    # Find verification code
    verification = PhoneVerification.query.filter_by(
        phone=phone_clean,
        code=code,
        purpose='password_reset'
    ).order_by(PhoneVerification.created_at.desc()).first()
    
    if not verification:
        return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è'})
    
    # Increment attempts
    verification.increment_attempts()
    db.session.commit()
    
    # Check if valid
    if not verification.is_valid():
        error_msg = '–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏—Å—Ç–µ–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥.'
        if verification.is_verified:
            error_msg = '–ö–æ–¥ —É–∂–µ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω'
        elif not verification.is_expired():
            error_msg = '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –≤–≤–æ–¥–∞ –∫–æ–¥–∞'
        return jsonify({'success': False, 'message': error_msg})
    
    # Mark as verified
    verification.mark_verified()
    db.session.commit()
    
    # Generate reset token
    reset_token = secrets.token_urlsafe(32)
    
    # Save in session
    session['reset_token'] = reset_token
    session['reset_phone'] = phone_clean
    session.modified = True
    
    logger.info(f"‚úÖ Password reset code verified for {phone_clean[:2]}****{phone_clean[-4:]}")
    
    return jsonify({
        'success': True,
        'message': '–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω',
        'redirect': url_for('reset_password')
    })


@app.route('/forgot-password', methods=['GET'])
def forgot_password():
    """Forgot password page"""
    return render_template('auth/forgot_password.html')


@app.route('/reset-password', methods=['GET', 'POST'])
def reset_password():
    """Reset password page"""
    from models import User
    from werkzeug.security import generate_password_hash
    import logging
    
    logger = logging.getLogger(__name__)
    
    # Validate reset token from session
    reset_token = session.get('reset_token')
    reset_phone = session.get('reset_phone')
    
    if not reset_token or not reset_phone:
        flash('–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ –¥–ª—è —Å–±—Ä–æ—Å–∞ –ø–∞—Ä–æ–ª—è', 'error')
        return redirect(url_for('forgot_password'))
    
    if request.method == 'POST':
        password = request.form.get('password', '').strip()
        confirm_password = request.form.get('confirm_password', '').strip()
        
        # Validation
        if not password:
            flash('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –ø–∞—Ä–æ–ª—å', 'error')
            return render_template('auth/reset_password.html')
        
        if len(password) < 6:
            flash('–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ 6 —Å–∏–º–≤–æ–ª–æ–≤', 'error')
            return render_template('auth/reset_password.html')
        
        if password != confirm_password:
            flash('–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
            return render_template('auth/reset_password.html')
        
        # Find user
        # ‚úÖ FIX: Use SQL-based normalization to match phones with dashes in database
        phone_digits_only = reset_phone.replace("+", "").replace("-", "").replace(" ", "")
        user = User.query.filter(
            func.replace(func.replace(func.replace(User.phone, "-", ""), " ", ""), "+", "") == phone_digits_only
        ).first()
        if not user:
            flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω', 'error')
            return redirect(url_for('forgot_password'))
        
        # Update password
        user.password_hash = generate_password_hash(password)
        
        try:
            db.session.commit()
            
            # Clear session tokens
            session.pop('reset_token', None)
            session.pop('reset_phone', None)
            
            # Auto-login user
            login_user(user)
            
            logger.info(f"‚úÖ Password reset successful for user {user.id}")
            flash('–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω!', 'success')
            return redirect(url_for('dashboard'))
            
        except Exception as e:
            logger.error(f"‚ùå Error resetting password: {str(e)}", exc_info=True)
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –ø–∞—Ä–æ–ª—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.', 'error')
            return render_template('auth/reset_password.html')
    
    # GET request - show form
    return render_template('auth/reset_password.html')

@app.route('/logout')
@login_required
def logout():
    """Logout user - –ò–°–ü–†–ê–í–õ–ï–ù–û: –æ—á–∏—â–∞–µ—Ç –í–°–ï —Å–µ—Å—Å–∏–∏"""
    logout_user()  # Flask-Login logout
    
    # –û—á–∏—â–∞–µ–º –≤—Å–µ —Ä—É—á–Ω—ã–µ —Å–µ—Å—Å–∏–∏ (legacy –∫–æ–¥)
    session.pop('manager_id', None)
    session.pop('admin_id', None)
    session.pop('is_manager', None)
    session.pop('is_admin', None)
    session.pop('user_id', None)
    session.pop('temp_user_id', None)
    
    flash('–í—ã —É—Å–ø–µ—à–Ω–æ –≤—ã—à–ª–∏ –∏–∑ —Å–∏—Å—Ç–µ–º—ã', 'success')
    return redirect(url_for('index'))

@app.route('/profile', methods=['GET', 'POST'])
@login_required
def profile():
    """User profile page - now integrated into dashboard settings tab"""
    
    if request.method == 'POST':
        try:
            # Update profile information
            current_user.full_name = request.form.get('full_name', current_user.full_name)
            current_user.phone = request.form.get('phone', current_user.phone)
            current_user.email = request.form.get('email', current_user.email)
            current_user.telegram_id = request.form.get('telegram_id', current_user.telegram_id)
            
            # Update date of birth
            date_of_birth_str = request.form.get('date_of_birth')
            if date_of_birth_str:
                try:
                    from datetime import datetime
                    current_user.date_of_birth = datetime.strptime(date_of_birth_str, '%Y-%m-%d').date()
                except ValueError:
                    pass
            
            # Update password if provided
            new_password = request.form.get('new_password')
            if new_password:
                confirm_password = request.form.get('confirm_password')
                if new_password == confirm_password:
                    current_user.password_hash = generate_password_hash(new_password)
                    flash('–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω', 'success')
                else:
                    flash('–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
                    return redirect(url_for('dashboard') + '#settings')
            
            db.session.commit()
            flash('–ü—Ä–æ—Ñ–∏–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', 'success')
            return redirect(url_for('dashboard') + '#settings')
        except Exception as e:
            db.session.rollback()
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è: {str(e)}', 'error')
            return redirect(url_for('dashboard') + '#settings')
    
    # GET request - redirect to dashboard settings tab
    return redirect(url_for('dashboard') + '#settings')

@app.route('/manager/profile', methods=['GET', 'POST'])
@manager_required
def manager_profile():
    """Manager profile page"""
    from models import Manager
    
    current_manager = current_user
    
    if request.method == 'POST':
        try:
            # Update profile information
            full_name = request.form.get('full_name', '')
            if full_name:
                name_parts = full_name.strip().split(maxsplit=1)
                current_manager.first_name = name_parts[0] if len(name_parts) > 0 else current_manager.first_name
                current_manager.last_name = name_parts[1] if len(name_parts) > 1 else current_manager.last_name
            
            current_manager.phone = request.form.get('phone', current_manager.phone)
            current_manager.email = request.form.get('email', current_manager.email)
            
            years_exp = request.form.get('years_of_experience')
            if years_exp:
                current_manager.years_of_experience = int(years_exp)
            
            # Update password if provided
            new_password = request.form.get('new_password')
            if new_password:
                confirm_password = request.form.get('confirm_password')
                if new_password == confirm_password:
                    current_manager.password_hash = generate_password_hash(new_password)
                    flash('–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω', 'success')
                else:
                    flash('–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
                    return redirect(url_for('manager_profile'))
            
            db.session.commit()
            flash('–ü—Ä–æ—Ñ–∏–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', 'success')
            return redirect(url_for('manager_profile'))
        except Exception as e:
            db.session.rollback()
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è: {str(e)}', 'error')
            return redirect(url_for('manager_profile'))
    
    return render_template('auth/manager_profile.html', 
                         manager=current_manager)

@app.route('/profile/upload-avatar', methods=['POST'])
@login_required
def upload_user_avatar():
    """Upload user avatar"""
    import os
    from werkzeug.utils import secure_filename
    
    if 'avatar' not in request.files:
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    file = request.files['avatar']
    
    if file.filename == '':
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    # Check file extension
    allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    filename = secure_filename(file.filename)
    if '.' not in filename or filename.rsplit('.', 1)[1].lower() not in allowed_extensions:
        return jsonify({'success': False, 'error': '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –†–∞–∑—Ä–µ—à–µ–Ω—ã: PNG, JPG, JPEG, GIF, WEBP'}), 400
    
    # Check file size (max 5MB)
    file.seek(0, os.SEEK_END)
    file_size = file.tell()
    file.seek(0)
    if file_size > 5 * 1024 * 1024:
        return jsonify({'success': False, 'error': '–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç 5MB'}), 400
    
    try:
        # Generate unique filename
        import uuid
        ext = filename.rsplit('.', 1)[1].lower()
        new_filename = f"user_{current_user.id}_{uuid.uuid4().hex[:8]}.{ext}"
        
        # Save file
        upload_folder = os.path.join('static', 'uploads', 'avatars')
        os.makedirs(upload_folder, exist_ok=True)
        filepath = os.path.join(upload_folder, new_filename)
        file.save(filepath)
        
        # Update user profile_image in database
        avatar_url = f"/static/uploads/avatars/{new_filename}"
        current_user.profile_image = avatar_url
        db.session.commit()
        
        return jsonify({'success': True, 'avatar_url': avatar_url})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞: {str(e)}'}), 500



@app.route('/api/profile/request-phone-change', methods=['POST'])
@login_required
def request_phone_change():
    """–ó–∞–ø—Ä–æ—Å –Ω–∞ —Å–º–µ–Ω—É –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —Å SMS –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–µ–π"""
    from models import PhoneChangeRequest, User
    from sms_service import sms_service
    
    try:
        # Validate CSRF for JSON requests
        if not validate_json_csrf():
            return jsonify({'success': False, 'message': '–û—à–∏–±–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏. –û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.'}), 403
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}), 400
        
        new_phone = data.get('new_phone', '').strip()
        if not new_phone:
            return jsonify({'success': False, 'message': '–£–∫–∞–∂–∏—Ç–µ –Ω–æ–≤—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞'}), 400
        
        # Normalize phone number (remove all non-digits except +)
        phone_clean = ''.join(filter(str.isdigit, new_phone))
        if phone_clean.startswith('8'):
            phone_clean = '7' + phone_clean[1:]
        elif phone_clean.startswith('9'):
            phone_clean = '7' + phone_clean
        
        if len(phone_clean) != 11 or not phone_clean.startswith('7'):
            return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞'}), 400
        
        # Check if phone is already in use
        existing_user = User.query.filter(User.phone.like(f'%{phone_clean[-10:]}%'), User.id != current_user.id).first()
        if existing_user:
            return jsonify({'success': False, 'message': '–≠—Ç–æ—Ç –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è'}), 400
        
        # Check rate limiting (60 seconds)
        if not PhoneChangeRequest.can_request_new_code(current_user.id, rate_limit_seconds=60):
            return jsonify({'success': False, 'message': '–ü–æ–¥–æ–∂–¥–∏—Ç–µ 60 —Å–µ–∫—É–Ω–¥ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–æ–π –∫–æ–¥–∞'}), 429
        
        # Expire any pending requests for this user
        pending_requests = PhoneChangeRequest.query.filter_by(user_id=current_user.id, status='pending').all()
        for req in pending_requests:
            req.mark_expired()
        
        # Create new request
        phone_request = PhoneChangeRequest.create_request(current_user.id, phone_clean)
        db.session.add(phone_request)
        db.session.commit()
        
        # Send SMS
        sms_message = f"InBack: –ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å–º–µ–Ω—ã –Ω–æ–º–µ—Ä–∞: {phone_request.verification_code}"
        sms_result = sms_service.send_sms(phone_clean, sms_message)
        
        if sms_result.get('success'):
            logging.info(f"Phone change SMS sent to {phone_clean[:4]}****{phone_clean[-2:]} for user {current_user.id}")
            return jsonify({
                'success': True,
                'message': '–ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –Ω–æ–≤—ã–π –Ω–æ–º–µ—Ä',
                'phone': f'+7 (***) ***-**-{phone_clean[-2:]}'
            })
        else:
            # SMS failed, mark request as expired
            phone_request.mark_expired()
            db.session.commit()
            logging.error(f"Failed to send phone change SMS: {sms_result.get('message')}")
            return jsonify({
                'success': False,
                'message': f'–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ SMS: {sms_result.get("message", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞")}'
            }), 500
            
    except Exception as e:
        db.session.rollback()
        logging.error(f"Error in request_phone_change: {str(e)}")
        return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞: {str(e)}'}), 500


@app.route('/api/profile/verify-phone-change', methods=['POST'])
@login_required
def verify_phone_change():
    """–í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –∫–æ–¥–∞ –∏ —Å–º–µ–Ω–∞ –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
    from models import PhoneChangeRequest
    
    try:
        # Validate CSRF for JSON requests
        if not validate_json_csrf():
            return jsonify({'success': False, 'message': '–û—à–∏–±–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏. –û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.'}), 403
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}), 400
        
        code = data.get('code', '').strip()
        if not code or len(code) != 6:
            return jsonify({'success': False, 'message': '–í–≤–µ–¥–∏—Ç–µ 6-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥'}), 400
        
        # Find the latest pending request for this user
        phone_request = PhoneChangeRequest.query.filter_by(
            user_id=current_user.id,
            status='pending'
        ).order_by(PhoneChangeRequest.created_at.desc()).first()
        
        if not phone_request:
            return jsonify({'success': False, 'message': '–ó–∞–ø—Ä–æ—Å –Ω–∞ —Å–º–µ–Ω—É –Ω–æ–º–µ—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –∫–æ–¥ –∑–∞–Ω–æ–≤–æ.'}), 400
        
        # Check if expired
        if phone_request.is_expired():
            phone_request.mark_expired()
            db.session.commit()
            return jsonify({'success': False, 'message': '–ö–æ–¥ –∏—Å—Ç—ë–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥.'}), 400
        
        # Check attempts
        if phone_request.attempts >= phone_request.max_attempts:
            phone_request.mark_expired()
            db.session.commit()
            return jsonify({'success': False, 'message': '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥.'}), 400
        
        # Increment attempts
        phone_request.increment_attempts()
        
        # Verify code
        if code != phone_request.verification_code:
            remaining = phone_request.max_attempts - phone_request.attempts
            db.session.commit()
            return jsonify({
                'success': False,
                'message': f'–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥. –û—Å—Ç–∞–ª–æ—Å—å –ø–æ–ø—ã—Ç–æ–∫: {remaining}'
            }), 400
        
        # Success! Update user's phone
        phone_request.mark_verified()
        current_user.phone = phone_request.new_phone
        current_user.phone_verified = True
        db.session.commit()
        
        logging.info(f"User {current_user.id} successfully changed phone to {phone_request.new_phone}")
        
        return jsonify({
            'success': True,
            'message': '–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω—ë–Ω',
            'new_phone': phone_request.new_phone
        })
        
    except Exception as e:
        db.session.rollback()
        logging.error(f"Error in verify_phone_change: {str(e)}")
        return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞: {str(e)}'}), 500



@app.route('/api/profile/request-email-change', methods=['POST'])
@login_required
def request_email_change():
    """–ó–∞–ø—Ä–æ—Å –Ω–∞ —Å–º–µ–Ω—É email —Å –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–µ–π —á–µ—Ä–µ–∑ —Å—Å—ã–ª–∫—É"""
    from models import EmailChangeRequest, User
    import re
    
    try:
        if not validate_json_csrf():
            return jsonify({'success': False, 'message': '–û—à–∏–±–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏. –û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.'}), 403
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'message': '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}), 400
        
        new_email = data.get('new_email', '').strip().lower()
        if not new_email:
            return jsonify({'success': False, 'message': '–£–∫–∞–∂–∏—Ç–µ –Ω–æ–≤—ã–π email'}), 400
        
        email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(email_pattern, new_email):
            return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç email'}), 400
        
        if current_user.email and current_user.email.lower() == new_email:
            return jsonify({'success': False, 'message': '–≠—Ç–æ –≤–∞—à —Ç–µ–∫—É—â–∏–π email'}), 400
        
        existing_user = User.query.filter(
            User.email.ilike(new_email),
            User.id != current_user.id
        ).first()
        if existing_user:
            return jsonify({'success': False, 'message': '–≠—Ç–æ—Ç email —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥—Ä—É–≥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º'}), 400
        
        if not EmailChangeRequest.can_request_new_token(current_user.id, rate_limit_seconds=60):
            return jsonify({'success': False, 'message': '–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–¥–æ–∂–¥–∏—Ç–µ –º–∏–Ω—É—Ç—É.'}), 429
        
        EmailChangeRequest.query.filter_by(
            user_id=current_user.id,
            status='pending'
        ).update({'status': 'expired'})
        
        email_request = EmailChangeRequest.create_request(current_user.id, new_email)
        db.session.add(email_request)
        db.session.commit()
        
        base_url = os.environ.get('REPLIT_DEV_DOMAIN')
        if base_url:
            base_url = f"https://{base_url}"
        else:
            base_url = request.host_url.rstrip('/')
        
        verification_url = f"{base_url}/verify-email-change/{email_request.verification_token}"
        
        email_sent = send_email(
            to_email=new_email,
            subject='InBack: –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Å–º–µ–Ω—ã email',
            template_name='emails/email_change_verification.html',
            verification_url=verification_url,
            user=current_user,
            base_url=base_url
        )
        
        if not email_sent:
            logging.warning(f"Email not sent to {new_email}, but request created")
        
        logging.info(f"User {current_user.id} requested email change to {new_email}")
        
        return jsonify({
            'success': True,
            'message': '–°—Å—ã–ª–∫–∞ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π email'
        })
        
    except Exception as e:
        db.session.rollback()
        logging.error(f"Error in request_email_change: {str(e)}")
        return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞: {str(e)}'}), 500


@app.route('/verify-email-change/<token>')
def verify_email_change(token):
    """–í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–∞ –∏ —Å–º–µ–Ω–∞ email"""
    from models import EmailChangeRequest, User
    
    try:
        email_request = EmailChangeRequest.query.filter_by(
            verification_token=token,
            status='pending'
        ).first()
        
        if not email_request:
            flash('–°—Å—ã–ª–∫–∞ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –∏–ª–∏ —É–∂–µ –±—ã–ª–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞', 'error')
            return redirect(url_for('login'))
        
        if email_request.is_expired():
            email_request.mark_expired()
            db.session.commit()
            flash('–°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è —Å—Å—ã–ª–∫–∏ –∏—Å—Ç—ë–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—É—é —Å—Å—ã–ª–∫—É.', 'error')
            return redirect(url_for('profile'))
        
        existing_user = User.query.filter(
            User.email.ilike(email_request.new_email),
            User.id != email_request.user_id
        ).first()
        if existing_user:
            email_request.mark_expired()
            db.session.commit()
            flash('–≠—Ç–æ—Ç email —É–∂–µ –∑–∞–Ω—è—Ç –¥—Ä—É–≥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º', 'error')
            return redirect(url_for('profile'))
        
        user = User.query.get(email_request.user_id)
        if not user:
            flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω', 'error')
            return redirect(url_for('login'))
        
        old_email = user.email
        user.email = email_request.new_email
        email_request.mark_verified()
        db.session.commit()
        
        logging.info(f"User {user.id} changed email from {old_email} to {email_request.new_email}")
        
        flash('Email —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω—ë–Ω!', 'success')
        
        if current_user.is_authenticated and current_user.id == user.id:
            return redirect(url_for('profile'))
        else:
            return redirect(url_for('login'))
        
    except Exception as e:
        db.session.rollback()
        logging.error(f"Error in verify_email_change: {str(e)}")
        flash('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–º–µ–Ω–µ email', 'error')
        return redirect(url_for('login'))

@app.route('/manager/profile/upload-avatar', methods=['POST'])
@manager_required
def upload_manager_avatar():
    """Upload manager avatar"""
    import os
    from werkzeug.utils import secure_filename
    from models import Manager
    
    current_manager = current_user
    
    if 'avatar' not in request.files:
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    file = request.files['avatar']
    
    if file.filename == '':
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    # Check file extension
    allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    filename = secure_filename(file.filename)
    if '.' not in filename or filename.rsplit('.', 1)[1].lower() not in allowed_extensions:
        return jsonify({'success': False, 'error': '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –†–∞–∑—Ä–µ—à–µ–Ω—ã: PNG, JPG, JPEG, GIF, WEBP'}), 400
    
    # Check file size (max 5MB)
    file.seek(0, os.SEEK_END)
    file_size = file.tell()
    file.seek(0)
    if file_size > 5 * 1024 * 1024:
        return jsonify({'success': False, 'error': '–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç 5MB'}), 400
    
    try:
        # Generate unique filename
        import uuid
        ext = filename.rsplit('.', 1)[1].lower()
        new_filename = f"manager_{current_manager.id}_{uuid.uuid4().hex[:8]}.{ext}"
        
        # Save file
        upload_folder = os.path.join('static', 'uploads', 'avatars')
        os.makedirs(upload_folder, exist_ok=True)
        filepath = os.path.join(upload_folder, new_filename)
        file.save(filepath)
        
        # Update manager profile_image in database
        avatar_url = f"/static/uploads/avatars/{new_filename}"
        current_manager.profile_image = avatar_url
        db.session.commit()
        
        return jsonify({'success': True, 'avatar_url': avatar_url})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞: {str(e)}'}), 500

@app.route('/api/search')
def api_search():
    """API endpoint for global search"""
    query = request.args.get('q', '').strip()
    if not query:
        return jsonify([])
    
    results = search_global(query)
    return jsonify(results)

@app.route('/search')
def search_results():
    """Search results page"""
    query = request.args.get('q', '').strip()
    search_type = request.args.get('type', 'all')  # all, residential_complex, district, developer, street
    
    results = []
    if query:
        results = search_global(query)
        
        # Filter by type if specified
        if search_type != 'all':
            results = [r for r in results if r['type'] == search_type]
    
    return render_template('search_results.html', 
                         query=query, 
                         results=results,
                         search_type=search_type)


@app.route('/api/smart-search-suggestions')
def smart_search_suggestions():
    """API endpoint for search suggestions with intelligent keyword matching"""
    query = request.args.get('q', '').strip().lower()
    if not query or len(query) < 1:
        return jsonify({'suggestions': []})
    
    suggestions = []
    
    try:
        # Intelligent room type matching patterns
        room_patterns = {
            # Single room patterns
            ('1', '1-', '1-–∫', '1-–∫–æ', '1-–∫–æ–º', '1 –∫', '1 –∫–æ', '1 –∫–æ–º', '–æ–¥–Ω', '–æ–¥–Ω–æ', '–æ–¥–Ω–æ–∫', '–æ–¥–Ω–æ–∫–æ–º–Ω', '–æ–¥–Ω–æ–∫–æ–º–Ω–∞—Ç', '–æ–¥–Ω–æ–∫–æ–º–Ω–∞—Ç–Ω', '–æ–¥–∏–Ω', '–æ–¥–Ω–æ–π'): ('1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 'rooms', '1'),
            # Two room patterns  
            ('2', '2-', '2-–∫', '2-–∫–æ', '2-–∫–æ–º', '2 –∫', '2 –∫–æ', '2 –∫–æ–º', '–¥–≤—É—Ö', '–¥–≤—É—Ö–∫', '–¥–≤—É—Ö–∫–æ–º', '–¥–≤—É—Ö–∫–æ–º–Ω', '–¥–≤—É—Ö–∫–æ–º–Ω–∞—Ç', '–¥–≤–∞', '–¥–≤–æ–π', '–¥–≤–æ–π–Ω'): ('2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 'rooms', '2'),
            # Three room patterns
            ('3', '3-', '3-–∫', '3-–∫–æ', '3-–∫–æ–º', '3 –∫', '3 –∫–æ', '3 –∫–æ–º', '—Ç—Ä–µ—Ö', '—Ç—Ä—ë—Ö', '—Ç—Ä–µ—Ö–∫', '—Ç—Ä—ë—Ö–∫', '—Ç—Ä–µ—Ö–∫–æ–º', '—Ç—Ä—ë—Ö–∫–æ–º', '—Ç—Ä–∏', '—Ç—Ä–æ–π'): ('3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 'rooms', '3'),
            # Four room patterns
            ('4', '4-', '4-–∫', '4-–∫–æ', '4-–∫–æ–º', '4 –∫', '4 –∫–æ', '4 –∫–æ–º', '—á–µ—Ç—ã—Ä', '—á–µ—Ç—ã—Ä–µ—Ö', '—á–µ—Ç—ã—Ä—ë—Ö', '—á–µ—Ç—ã—Ä–µ—Ö–∫', '—á–µ—Ç—ã—Ä—ë—Ö–∫', '—á–µ—Ç—ã—Ä–µ'): ('4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 'rooms', '4'),
            # Studio patterns
            ('—Å—Ç—É–¥', 'studio', '—Å—Ç—É–¥–∏–π', '—Å—Ç—É–¥–∏—è'): ('–°—Ç—É–¥–∏—è', 'rooms', 'studio'),
        }
        
        # Check room type patterns first
        for patterns, (room_text, type_val, value) in room_patterns.items():
            for pattern in patterns:
                if query.startswith(pattern) or pattern in query:
                    suggestions.append({
                        'text': room_text,
                        'type': type_val,
                        'value': value,
                        'category': '–¢–∏–ø –∫–≤–∞—Ä—Ç–∏—Ä—ã'
                    })
                    break
        
        # Search in regional data first (regions and cities)
        from models import Region, City
        
        # Search regions
        regions = Region.query.filter(Region.name.ilike(f'%{query}%')).limit(5).all()
        for region in regions:
            suggestions.append({
                'text': region.name,
                'type': 'region',
                'value': region.slug,
                'category': '–†–µ–≥–∏–æ–Ω'
            })
        
        # Search cities
        cities = City.query.filter(City.name.ilike(f'%{query}%')).limit(5).all()
        for city in cities:
            suggestions.append({
                'text': f"{city.name} ({city.region.name if city.region else '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ–≥–∏–æ–Ω'})",
                'type': 'city',
                'value': city.slug,
                'category': '–ì–æ—Ä–æ–¥'
            })

        # Search in database categories (districts, developers, complexes)
        cursor = db.session.execute(text("""
            SELECT name, category_type, slug 
            FROM search_categories 
            WHERE LOWER(name) LIKE :query 
            ORDER BY 
                CASE 
                    WHEN LOWER(name) LIKE :exact_start THEN 1
                    WHEN LOWER(name) LIKE :word_start THEN 2
                    ELSE 3
                END,
                LENGTH(name)
            LIMIT 10
        """), {
            'query': f'%{query}%',
            'exact_start': f'{query}%',
            'word_start': f'% {query}%'
        })
        
        category_names = {
            'district': '–†–∞–π–æ–Ω',
            'developer': '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫', 
            'complex': '–ñ–ö',
            'rooms': '–¢–∏–ø –∫–≤–∞—Ä—Ç–∏—Ä—ã',
            'region': '–†–µ–≥–∏–æ–Ω',
            'city': '–ì–æ—Ä–æ–¥'
        }
        
        for row in cursor:
            name, category_type, slug = row
            suggestions.append({
                'text': name,
                'type': category_type,
                'value': slug,
                'category': category_names.get(category_type, category_type.title())
            })
        
        # Remove duplicates while preserving order
        seen = set()
        unique_suggestions = []
        for s in suggestions:
            key = (s['text'], s['type'])
            if key not in seen:
                seen.add(key)
                unique_suggestions.append(s)
        
        return jsonify({'suggestions': unique_suggestions[:12]})
        
    except Exception as e:
        app.logger.error(f"Smart search error: {e}")
        return jsonify({'suggestions': []})

def init_search_data():
    """Initialize search data in database"""
    from models import District, Developer, ResidentialComplex, Street, RoomType
    
    # Districts
    districts_data = [
        ('–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π', 'tsentralnyy'), ('–ó–∞–ø–∞–¥–Ω—ã–π', 'zapadny'), 
        ('–ö–∞—Ä–∞—Å—É–Ω—Å–∫–∏–π', 'karasunsky'), ('–ü—Ä–∏–∫—É–±–∞–Ω—Å–∫–∏–π', 'prikubansky'),
        ('–§–µ—Å—Ç–∏–≤–∞–ª—å–Ω—ã–π', 'festivalny'), ('–Æ–±–∏–ª–µ–π–Ω—ã–π', 'yubileynyy'),
        ('–ì–∏–¥—Ä–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª–µ–π', 'gidrostroitelei'), ('–°–æ–ª–Ω–µ—á–Ω—ã–π', 'solnechny'),
        ('–ü–∞–Ω–æ—Ä–∞–º–∞', 'panorama'), ('–ú—É–∑—ã–∫–∞–ª—å–Ω—ã–π', 'muzykalnyy')
    ]
    
    for name, slug in districts_data:
        if not District.query.filter_by(slug=slug).first():
            district = District(name=name, slug=slug)
            db.session.add(district)
    
    # Room types
    room_types_data = [
        ('–°—Ç—É–¥–∏—è', 0), ('1-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 1), 
        ('2-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 2), ('3-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 3), 
        ('4-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞', 4), ('–ü–µ–Ω—Ç—Ö–∞—É—Å', 5)
    ]
    
    for name, rooms_count in room_types_data:
        if not RoomType.query.filter_by(name=name).first():
            room_type = RoomType(name=name, rooms_count=rooms_count)
            db.session.add(room_type)
    
    # Developers
    developers_data = [
        ('–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä –ò–Ω–≤–µ—Å—Ç', 'krasnodar-invest'),
        ('–Æ–≥–°—Ç—Ä–æ–π–ò–Ω–≤–µ—Å—Ç', 'yugstroyinvest'),
        ('–§–ª–∞–≥–º–∞–Ω', 'flagman'),
        ('–°–æ–ª–Ω–µ—á–Ω—ã–π –≥–æ—Ä–æ–¥', 'solnechny-gorod'),
        ('–ü—Ä–µ–º—å–µ—Ä', 'premier')
    ]
    
    for name, slug in developers_data:
        if not Developer.query.filter_by(slug=slug).first():
            developer = Developer(name=name, slug=slug)
            db.session.add(developer)
    
    # Residential complexes
    complexes_data = [
        ('–°–æ–ª–Ω–µ—á–Ω—ã–π', 'solnechny', 1, 1),
        ('–ü–∞–Ω–æ—Ä–∞–º–∞', 'panorama', 1, 2),
        ('–ì–∞—Ä–º–æ–Ω–∏—è', 'garmoniya', 2, 3),
        ('–ï–≤—Ä–æ–ø–µ–π—Å–∫–∏–π –∫–≤–∞—Ä—Ç–∞–ª', 'evropeyskiy-kvartal', 3, 1),
        ('–§–ª–∞–≥–º–∞–Ω', 'flagman', 4, 4)
    ]
    
    for name, slug, district_id, developer_id in complexes_data:
        if not ResidentialComplex.query.filter_by(slug=slug).first():
            complex = ResidentialComplex(name=name, slug=slug, district_id=district_id, developer_id=developer_id)
            db.session.add(complex)
    
    db.session.commit()


# ==================== ADMIN ROUTES ====================

@app.route('/admin/login', methods=['GET', 'POST'])
@csrf.exempt  # Exempt admin login from CSRF protection
def admin_login():
    """Admin login page - –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Flask-Login"""
    if request.method == 'POST':
        from models import Admin
        email = request.form.get('email')
        password = request.form.get('password')
        
        admin = Admin.query.filter_by(email=email, is_active=True).first()
        
        if admin and admin.check_password(password):
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login –≤–º–µ—Å—Ç–æ —Ä—É—á–Ω—ã—Ö —Å–µ—Å—Å–∏–π
            login_user(admin, remember=True)
            session.permanent = True  # Ensure 30-day session lifetime
            
            # Update last login data for Admin
            now = datetime.utcnow()
            ip = request.remote_addr
            ua = request.headers.get('User-Agent')
            
            admin.last_login = now
            admin.last_ip = ip
            admin.last_user_agent = ua
            
            # Cross-update Manager record with same email if exists
            from models import Manager
            manager = Manager.query.filter_by(email=email).first()
            if manager:
                manager.last_login = now
                manager.last_ip = ip
                manager.last_user_agent = ua
                
            db.session.commit()
            flash('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ø–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞!', 'success')
            return redirect(url_for('admin_dashboard'))
        else:
            flash('–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å', 'error')
    
    return render_template('admin/admin_login.html')

@app.route('/admin/logout')
def admin_logout():
    """Admin logout - –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Flask-Login"""
    logout_user()  # –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login
    flash('–í—ã –≤—ã—à–ª–∏ –∏–∑ –ø–∞–Ω–µ–ª–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞', 'info')
    return redirect(url_for('admin_login'))

def admin_required(f):
    """Decorator to require admin authentication - –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —Ç–∏–ø –º–æ–¥–µ–ª–∏"""
    from functools import wraps
    @wraps(f)
    def decorated_function(*args, **kwargs):
        from models import Admin
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –∏ —ç—Ç–æ Admin
        if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Admin):
            # –î–ª—è API endpoints –≤–æ–∑–≤—Ä–∞—â–∞–µ–º JSON
            if request.path.startswith('/api/'):
                return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞'}), 403
            # –î–ª—è –æ–±—ã—á–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∏—Ü –¥–µ–ª–∞–µ–º redirect
            return redirect(url_for('admin_login'))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/admin')
def admin_base():
    """Base admin route - redirects to dashboard or login - –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —Ç–∏–ø –º–æ–¥–µ–ª–∏"""
    from models import Admin
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –∏ —ç—Ç–æ Admin
    if current_user.is_authenticated and isinstance(current_user._get_current_object(), Admin):
        return redirect(url_for('admin_dashboard'))
    return redirect(url_for('admin_login'))

@app.route('/admin/client-management')
@admin_required
def admin_client_management():
    """Separate page for client-manager assignment"""
    try:
        from models import Admin
        
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
        current_admin = current_user
        if not current_admin:
            flash('–ê–¥–º–∏–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω', 'error')
            return redirect(url_for('admin_login'))
        
        return render_template('admin/client_management.html', admin=current_admin)
        
    except Exception as e:
        print(f"ERROR in admin_client_management: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))

@app.route('/admin/scheduler')
@admin_required
def admin_scheduler():
    current_admin = current_user
    jobs_info = []
    is_running = scheduler.running
    
    import pytz
    moscow_tz = pytz.timezone('Europe/Moscow')
    
    if is_running:
        for job in scheduler.get_jobs():
            next_run = job.next_run_time
            if next_run:
                # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤—Ä–µ–º—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞–ø—É—Å–∫–∞ –≤ –º–æ—Å–∫–æ–≤—Å–∫–æ–µ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                next_run_display = next_run.astimezone(moscow_tz).strftime('%d.%m.%Y %H:%M:%S')
            else:
                next_run_display = '–ù–µ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ'
                
            jobs_info.append({
                'id': job.id,
                'name': job.name,
                'next_run': next_run_display,
                'trigger': str(job.trigger),
            })
    return render_template('admin/scheduler.html', admin=current_admin, 
                         is_running=is_running, jobs=jobs_info)

@app.route('/admin/scheduler/run-job', methods=['POST'])
@admin_required
def admin_scheduler_run_job():
    job_id = request.form.get('job_id')
    job_map = {
        'task_reminders_job': run_task_reminders,
        'overdue_task_alerts_job': run_overdue_task_alerts,
        'instant_alerts_job': run_instant_alerts,
        'daily_digest_job': run_daily_digest,
        'weekly_digest_job': run_weekly_digest,
    }
    func = job_map.get(job_id)
    if func:
        try:
            func()
            flash(f'–ó–∞–¥–∞—á–∞ "{job_id}" –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ', 'success')
        except Exception as e:
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏: {str(e)}', 'error')
    else:
        flash('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∑–∞–¥–∞—á–∞', 'error')
    return redirect(url_for('admin_scheduler'))

@app.route('/admin/deal-stages')
@admin_required
def admin_deal_stages():
    from models import Admin, DealStageConfig
    current_admin = current_user
    DealStageConfig.seed_defaults()
    stages = DealStageConfig.query.order_by(DealStageConfig.sort_order).all()
    return render_template('admin/deal_stages.html', admin=current_admin, stages=stages)

@app.route('/admin/deal-stages/save', methods=['POST'])
@admin_required
def admin_deal_stages_save():
    from models import DealStageConfig
    stage_id = request.form.get('stage_id')
    key = request.form.get('key', '').strip().lower()
    label = request.form.get('label', '').strip()
    color = request.form.get('color', '#6b7280').strip()
    sort_order = int(request.form.get('sort_order', 0))
    is_terminal = 'is_terminal' in request.form
    is_success = 'is_success' in request.form
    is_active = 'is_active' in request.form
    if not key or not label:
        flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –∫–ª—é—á –∏ –Ω–∞–∑–≤–∞–Ω–∏–µ', 'error')
        return redirect(url_for('admin_deal_stages'))
    if stage_id:
        stage = DealStageConfig.query.get(int(stage_id))
        if stage:
            stage.label = label
            stage.color = color
            stage.sort_order = sort_order
            stage.is_terminal = is_terminal
            stage.is_success = is_success
            stage.is_active = is_active
            db.session.commit()
            flash(f'–≠—Ç–∞–ø "{label}" –æ–±–Ω–æ–≤–ª—ë–Ω', 'success')
    else:
        existing = DealStageConfig.query.filter_by(key=key).first()
        if existing:
            flash(f'–≠—Ç–∞–ø —Å –∫–ª—é—á–æ–º "{key}" —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç', 'error')
            return redirect(url_for('admin_deal_stages'))
        stage = DealStageConfig(key=key, label=label, color=color, sort_order=sort_order,
                               is_terminal=is_terminal, is_success=is_success, is_active=is_active)
        db.session.add(stage)
        db.session.commit()
        flash(f'–≠—Ç–∞–ø "{label}" –¥–æ–±–∞–≤–ª–µ–Ω', 'success')
    return redirect(url_for('admin_deal_stages'))

@app.route('/admin/deal-stages/move', methods=['POST'])
@admin_required
def admin_deal_stages_move():
    from models import DealStageConfig
    stage_id = int(request.form.get('stage_id', 0))
    direction = request.form.get('direction', 'up')
    stage = DealStageConfig.query.get(stage_id)
    if not stage:
        flash('–≠—Ç–∞–ø –Ω–µ –Ω–∞–π–¥–µ–Ω', 'error')
        return redirect(url_for('admin_deal_stages'))
    if direction == 'up' and stage.sort_order > 0:
        swap = DealStageConfig.query.filter_by(sort_order=stage.sort_order - 1).first()
        if swap:
            swap.sort_order, stage.sort_order = stage.sort_order, swap.sort_order
    elif direction == 'down':
        swap = DealStageConfig.query.filter_by(sort_order=stage.sort_order + 1).first()
        if swap:
            swap.sort_order, stage.sort_order = stage.sort_order, swap.sort_order
    db.session.commit()
    return redirect(url_for('admin_deal_stages'))



@app.route('/admin/org-tree')
@admin_required
def admin_org_tree():
    from models import Department, OrgRole, Manager
    OrgRole.seed_defaults()
    departments = Department.query.filter_by(is_active=True).order_by(Department.sort_order, Department.name).all()
    roles = OrgRole.query.filter_by(is_active=True).order_by(OrgRole.level.desc()).all()
    managers = Manager.query.filter_by(is_active=True).order_by(Manager.first_name).all()
    return render_template('admin/org_tree.html',
                         admin=current_user,
                         departments=departments,
                         roles=roles,
                         managers=managers)


@app.route('/admin/api/departments', methods=['POST'])
@app.route('/admin/api/departments/<int:dept_id>', methods=['POST'])
@csrf.exempt
@admin_required
def admin_api_departments(dept_id=None):
    from models import Department, Manager
    data = request.get_json()
    if not data or not data.get('name'):
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'})
    
    if dept_id:
        dept = Department.query.get(dept_id)
        if not dept:
            return jsonify({'success': False, 'error': '–û—Ç–¥–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω'})
    else:
        dept = Department()
        db.session.add(dept)
    
    dept.name = data['name'].strip()
    dept.description = data.get('description', '').strip() or None
    dept.parent_id = int(data['parent_id']) if data.get('parent_id') else None
    dept.head_manager_id = int(data['head_manager_id']) if data.get('head_manager_id') else None
    
    db.session.commit()
    return jsonify({'success': True})


@app.route('/admin/api/departments/<int:dept_id>', methods=['DELETE'])
@csrf.exempt
@admin_required
def admin_api_delete_department(dept_id):
    from models import Department, Manager
    dept = Department.query.get(dept_id)
    if not dept:
        return jsonify({'success': False, 'error': '–û—Ç–¥–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω'})
    
    Manager.query.filter_by(department_id=dept_id).update({'department_id': None})
    for child in dept.children.all():
        child.parent_id = dept.parent_id
    
    dept.is_active = False
    db.session.commit()
    return jsonify({'success': True})


@app.route('/admin/api/managers/assign', methods=['POST'])
@csrf.exempt
@admin_required
def admin_api_assign_manager():
    from models import Manager
    data = request.get_json()
    manager_id = data.get('manager_id')
    if not manager_id:
        return jsonify({'success': False, 'error': '–ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ —É–∫–∞–∑–∞–Ω'})
    
    manager = Manager.query.get(int(manager_id))
    if not manager:
        return jsonify({'success': False, 'error': '–ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω'})
    
    manager.department_id = int(data['department_id']) if data.get('department_id') else None
    manager.org_role_id = int(data['org_role_id']) if data.get('org_role_id') else None
    
    from models import OrgRole
    if manager.org_role_id:
        role = OrgRole.query.get(manager.org_role_id)
        if role and role.key == 'rop':
            manager.is_rop = True
        else:
            manager.is_rop = False
    
    db.session.commit()
    return jsonify({'success': True})


@app.route('/admin/api/roles/<int:role_id>', methods=['GET'])
@admin_required
def admin_api_role_get(role_id):
    from models import OrgRole
    role = OrgRole.query.get(role_id)
    if not role:
        return jsonify({'error': 'Not found'}), 404
    return jsonify({
        'id': role.id,
        'name': role.name,
        'key': role.key,
        'level': role.level,
        'can_view_all_deals': role.can_view_all_deals,
        'can_view_department_deals': role.can_view_department_deals,
        'can_view_own_deals': role.can_view_own_deals,
        'can_change_deal_responsible': role.can_change_deal_responsible,
        'can_view_all_archive': role.can_view_all_archive,
        'can_view_department_archive': role.can_view_department_archive,
        'can_view_own_archive': role.can_view_own_archive,
        'can_manage_department': role.can_manage_department,
        'can_view_statistics': role.can_view_statistics,
        'can_manage_managers': role.can_manage_managers,
        'can_receive_leads': role.can_receive_leads
    })

@app.route('/admin/api/roles', methods=['POST'])
@app.route('/admin/api/roles/<int:role_id>', methods=['POST'])
@csrf.exempt
@admin_required
def admin_api_roles(role_id=None):
    from models import OrgRole
    data = request.get_json()
    if not data or not data.get('name') or not data.get('key'):
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –∏ –∫–ª—é—á –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã'})
    
    if role_id:
        role = OrgRole.query.get(role_id)
        if not role:
            return jsonify({'success': False, 'error': '–†–æ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'})
    else:
        existing = OrgRole.query.filter_by(key=data['key']).first()
        if existing:
            return jsonify({'success': False, 'error': '–†–æ–ª—å —Å —Ç–∞–∫–∏–º –∫–ª—é—á–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'})
        role = OrgRole()
        db.session.add(role)
    
    role.name = data['name'].strip()
    role.key = data['key'].strip()
    role.level = int(data.get('level', 10))
    
    perm_fields = ['can_view_all_deals', 'can_view_department_deals', 'can_view_own_deals',
                   'can_change_deal_responsible', 'can_view_all_archive', 'can_view_department_archive',
                   'can_view_own_archive', 'can_manage_department', 'can_view_statistics', 'can_manage_managers',
                   'can_receive_leads']
    for field in perm_fields:
        val = data.get(field)
        if val is not None:
            setattr(role, field, val in (True, 'true', 'on', '1', 1))
    
    db.session.commit()
    return jsonify({'success': True})


@app.route('/admin/deals-archive')
@admin_required
def admin_deals_archive():
    from models import Deal, Manager
    from sqlalchemy import func
    from datetime import timedelta

    manager_id = request.args.get('manager_id', type=int)
    status_filter = request.args.get('status', '')
    period = request.args.get('period', '')

    query = Deal.query.filter(Deal.status.in_(['completed', 'successful', 'rejected']))

    if manager_id:
        query = query.filter(Deal.manager_id == manager_id)
    if status_filter:
        if status_filter == 'completed':
            query = query.filter(Deal.status.in_(['completed', 'successful']))
        else:
            query = query.filter(Deal.status == status_filter)
    if period:
        now = datetime.utcnow()
        if period == 'week':
            query = query.filter(Deal.updated_at >= now - timedelta(days=7))
        elif period == 'month':
            query = query.filter(Deal.updated_at >= now - timedelta(days=30))
        elif period == 'quarter':
            query = query.filter(Deal.updated_at >= now - timedelta(days=90))
        elif period == 'year':
            query = query.filter(Deal.updated_at >= now - timedelta(days=365))

    deals = query.order_by(Deal.updated_at.desc()).all()

    all_closed = Deal.query.filter(Deal.status.in_(['completed', 'successful', 'rejected']))
    if manager_id:
        all_closed = all_closed.filter(Deal.manager_id == manager_id)
    if period:
        now = datetime.utcnow()
        periods_map = {'week': 7, 'month': 30, 'quarter': 90, 'year': 365}
        if period in periods_map:
            all_closed = all_closed.filter(Deal.updated_at >= now - timedelta(days=periods_map[period]))
    all_closed_list = all_closed.all()

    successful = [d for d in all_closed_list if d.status in ('completed', 'successful')]
    rejected_list = [d for d in all_closed_list if d.status == 'rejected']

    total_revenue = sum(float(d.property_price or 0) for d in successful)
    total_cashback = sum(float(d.cashback_amount or 0) for d in successful)
    avg_deal = total_revenue / len(successful) if successful else 0
    conversion = round(len(successful) / len(all_closed_list) * 100, 1) if all_closed_list else 0

    stats = {
        'total': len(all_closed_list),
        'successful': len(successful),
        'rejected': len(rejected_list),
        'conversion': conversion,
        'total_revenue': total_revenue,
        'total_cashback': total_cashback,
        'avg_deal': avg_deal,
    }

    rejection_reasons = {}
    for d in rejected_list:
        reason = d.rejection_reason or '–ù–µ —É–∫–∞–∑–∞–Ω–∞'
        rejection_reasons[reason] = rejection_reasons.get(reason, 0) + 1
    rejection_stats = sorted([{'reason': r, 'count': c} for r, c in rejection_reasons.items()], key=lambda x: -x['count'])

    managers = Manager.query.filter_by(is_active=True).order_by(Manager.first_name).all()

    manager_stats_data = []
    all_managers = Manager.query.filter_by(is_active=True).all()
    for m in all_managers:
        m_deals = [d for d in Deal.query.filter(Deal.manager_id == m.id, Deal.status.in_(['completed', 'successful', 'rejected'])).all()]
        if not m_deals:
            continue
        m_success = [d for d in m_deals if d.status in ('completed', 'successful')]
        m_rejected = [d for d in m_deals if d.status == 'rejected']
        m_revenue = sum(float(d.property_price or 0) for d in m_success)
        m_conv = round(len(m_success) / len(m_deals) * 100, 1) if m_deals else 0
        manager_stats_data.append({
            'name': m.full_name,
            'total': len(m_deals),
            'successful': len(m_success),
            'rejected': len(m_rejected),
            'conversion': m_conv,
            'revenue': m_revenue,
        })
    manager_stats_data.sort(key=lambda x: -x['successful'])

    return render_template('admin/deals_archive.html',
                         admin=current_user,
                         deals=deals, stats=stats,
                         rejection_stats=rejection_stats,
                         managers=managers,
                         manager_stats=manager_stats_data)


@app.route('/admin/dashboard')
@admin_required
def admin_dashboard():
    """Admin dashboard with analytics - –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Flask-Login"""
    from models import Admin, User, Manager, CashbackApplication, CallbackRequest
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    if not current_admin:
        return redirect(url_for('admin_login'))
    
    # Analytics data
    stats = {
        'total_users': User.query.count(),
        'total_managers': Manager.query.count(),
        'total_applications': CashbackApplication.query.count(),
        'pending_applications': CashbackApplication.query.filter_by(status='–ù–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏').count(),
        'approved_applications': CashbackApplication.query.filter_by(status='–û–¥–æ–±—Ä–µ–Ω–∞').count(),
        'paid_applications': CashbackApplication.query.filter_by(status='–í—ã–ø–ª–∞—á–µ–Ω–∞').count(),
        'total_cashback_approved': sum(app.cashback_amount for app in CashbackApplication.query.filter_by(status='–û–¥–æ–±—Ä–µ–Ω–∞').all()),
        'total_cashback_paid': sum(app.cashback_amount for app in CashbackApplication.query.filter_by(status='–í—ã–ø–ª–∞—á–µ–Ω–∞').all()),
        'active_users': User.query.filter_by(is_active=True).count(),
        'active_managers': Manager.query.filter_by(is_active=True).count(),
        'cashback_requests': CallbackRequest.query.filter(CallbackRequest.notes.contains('–∫–µ—à–±–µ–∫')).count(),
        'new_requests': CallbackRequest.query.filter_by(status='–ù–æ–≤–∞—è').count(),
    }
    
    # Recent activity
    recent_applications = CashbackApplication.query.order_by(CashbackApplication.created_at.desc()).limit(10).all()
    recent_users = User.query.order_by(User.created_at.desc()).limit(10).all()
    recent_cashback_requests = CallbackRequest.query.filter(
        CallbackRequest.notes.contains('–∫–µ—à–±–µ–∫')
    ).order_by(CallbackRequest.created_at.desc()).limit(5).all()
    
    return render_template('admin/dashboard.html',
                         admin=current_admin,
                         stats=stats,
                         recent_applications=recent_applications,
                         recent_users=recent_users,
                         recent_cashback_requests=recent_cashback_requests,
                         current_date=datetime.now())

@app.route('/admin/profile', methods=['GET', 'POST'])
@admin_required
def admin_profile():
    from models import Admin
    admin = current_user
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'update_profile':
            admin.full_name = request.form.get('full_name', admin.full_name)
            admin.email = request.form.get('email', admin.email)
            admin.phone = request.form.get('phone', admin.phone)
            
            profile_image = request.form.get('profile_image')
            if profile_image:
                admin.profile_image = profile_image
            
            db.session.commit()
            flash('–î–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω—ã', 'success')
            return redirect(url_for('admin_profile'))
        
        elif action == 'change_password':
            current_password = request.form.get('current_password')
            new_password = request.form.get('new_password')
            confirm_password = request.form.get('confirm_password')
            
            if not admin.check_password(current_password):
                flash('–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–µ–∫—É—â–∏–π –ø–∞—Ä–æ–ª—å', 'error')
            elif new_password != confirm_password:
                flash('–ù–æ–≤—ã–µ –ø–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
            elif len(new_password) < 6:
                flash('–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤', 'error')
            else:
                admin.set_password(new_password)
                db.session.commit()
                flash('–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω—ë–Ω', 'success')
            
            return redirect(url_for('admin_profile'))
    
    return render_template('admin/profile.html', admin=admin)


@app.route('/admin/analytics')
@admin_required
def admin_analytics():
    from models import Deal, DealStageConfig, Manager, Department, User, DealTask
    from sqlalchemy import func, extract
    from datetime import datetime, timedelta
    from decimal import Decimal
    
    current_admin = current_user
    
    total_deals = Deal.query.count()
    active_deals = Deal.query.filter(~Deal.status.in_(['completed', 'successful', 'rejected', 'cancelled'])).count()
    successful_deals = Deal.query.filter(Deal.status.in_(['completed', 'successful'])).count()
    rejected_deals = Deal.query.filter_by(status='rejected').count()
    
    total_cashback = db.session.query(func.coalesce(func.sum(Deal.cashback_amount), 0)).scalar()
    total_revenue = db.session.query(func.coalesce(func.sum(Deal.property_price), 0)).scalar()
    successful_cashback = db.session.query(func.coalesce(func.sum(Deal.cashback_amount), 0)).filter(Deal.status.in_(['completed', 'successful'])).scalar()
    successful_revenue = db.session.query(func.coalesce(func.sum(Deal.property_price), 0)).filter(Deal.status.in_(['completed', 'successful'])).scalar()
    avg_deal_size = db.session.query(func.coalesce(func.avg(Deal.property_price), 0)).filter(Deal.status.in_(['completed', 'successful'])).scalar()
    
    conversion_rate = round((successful_deals / total_deals * 100), 1) if total_deals > 0 else 0
    
    stages = DealStageConfig.query.filter_by(is_active=True).order_by(DealStageConfig.sort_order).all()
    funnel_data = []
    for stage in stages:
        count = Deal.query.filter_by(status=stage.key).count()
        amount = db.session.query(func.coalesce(func.sum(Deal.property_price), 0)).filter_by(status=stage.key).scalar()
        funnel_data.append({'label': stage.label, 'key': stage.key, 'color': stage.color, 'count': count, 'amount': float(amount)})
    
    managers = Manager.query.filter_by(is_active=True).all()
    manager_stats = []
    for m in managers:
        m_deals = Deal.query.filter_by(manager_id=m.id).count()
        m_successful = Deal.query.filter(Deal.manager_id == m.id, Deal.status.in_(['completed', 'successful'])).count()
        m_cashback = db.session.query(func.coalesce(func.sum(Deal.cashback_amount), 0)).filter(Deal.manager_id == m.id, Deal.status.in_(['completed', 'successful'])).scalar()
        m_revenue = db.session.query(func.coalesce(func.sum(Deal.property_price), 0)).filter(Deal.manager_id == m.id, Deal.status.in_(['completed', 'successful'])).scalar()
        m_active = Deal.query.filter(Deal.manager_id == m.id, ~Deal.status.in_(['completed', 'successful', 'rejected', 'cancelled'])).count()
        m_conversion = round((m_successful / m_deals * 100), 1) if m_deals > 0 else 0
        m_pending_tasks = DealTask.query.join(Deal).filter(Deal.manager_id == m.id, DealTask.is_completed == False).count()
        manager_stats.append({
            'id': m.id,
            'name': m.full_name or f"{m.first_name} {m.last_name}".strip(),
            'department': m.department.name if m.department else '\u2014',
            'role': m.org_role.name if m.org_role else '\u041c\u0435\u043d\u0435\u0434\u0436\u0435\u0440',
            'total_deals': m_deals,
            'active_deals': m_active,
            'successful_deals': m_successful,
            'cashback': float(m_cashback),
            'revenue': float(m_revenue),
            'conversion': m_conversion,
            'pending_tasks': m_pending_tasks
        })
    manager_stats.sort(key=lambda x: x['successful_deals'], reverse=True)
    
    departments = Department.query.all()
    dept_stats = []
    for dept in departments:
        dept_manager_ids = [m.id for m in Manager.query.filter_by(department_id=dept.id).all()]
        if not dept_manager_ids:
            continue
        d_deals = Deal.query.filter(Deal.manager_id.in_(dept_manager_ids)).count()
        d_successful = Deal.query.filter(Deal.manager_id.in_(dept_manager_ids), Deal.status.in_(['completed', 'successful'])).count()
        d_cashback = db.session.query(func.coalesce(func.sum(Deal.cashback_amount), 0)).filter(Deal.manager_id.in_(dept_manager_ids), Deal.status.in_(['completed', 'successful'])).scalar()
        d_revenue = db.session.query(func.coalesce(func.sum(Deal.property_price), 0)).filter(Deal.manager_id.in_(dept_manager_ids), Deal.status.in_(['completed', 'successful'])).scalar()
        d_conversion = round((d_successful / d_deals * 100), 1) if d_deals > 0 else 0
        dept_stats.append({
            'name': dept.name,
            'managers_count': len(dept_manager_ids),
            'total_deals': d_deals,
            'successful_deals': d_successful,
            'cashback': float(d_cashback),
            'revenue': float(d_revenue),
            'conversion': d_conversion
        })
    
    now = datetime.utcnow()
    monthly_data = []
    for i in range(5, -1, -1):
        month_start = (now.replace(day=1) - timedelta(days=i*30)).replace(day=1)
        if i > 0:
            next_month = (month_start + timedelta(days=32)).replace(day=1)
        else:
            next_month = now
        month_deals = Deal.query.filter(Deal.created_at >= month_start, Deal.created_at < next_month).count()
        month_successful = Deal.query.filter(Deal.created_at >= month_start, Deal.created_at < next_month, Deal.status.in_(['completed', 'successful'])).count()
        month_names_ru = ['\u042f\u043d\u0432', '\u0424\u0435\u0432', '\u041c\u0430\u0440', '\u0410\u043f\u0440', '\u041c\u0430\u0439', '\u0418\u044e\u043d', '\u0418\u044e\u043b', '\u0410\u0432\u0433', '\u0421\u0435\u043d', '\u041e\u043a\u0442', '\u041d\u043e\u044f', '\u0414\u0435\u043a']
        monthly_data.append({
            'month': month_names_ru[month_start.month - 1],
            'total': month_deals,
            'successful': month_successful
        })
    
    rejection_stats = db.session.query(Deal.rejection_reason, func.count(Deal.id)).filter(Deal.status == 'rejected', Deal.rejection_reason != None).group_by(Deal.rejection_reason).all()
    rejection_data = [{'reason': r[0] or '–ù–µ —É–∫–∞–∑–∞–Ω–∞', 'count': r[1]} for r in rejection_stats]
    
    from models import CallbackRequest, CashbackApplication
    
    total_users = User.query.count()
    total_leads = CallbackRequest.query.count()
    new_leads = CallbackRequest.query.filter_by(status='–ù–æ–≤–∞—è').count()
    processed_leads = CallbackRequest.query.filter_by(status='–û–±—Ä–∞–±–æ—Ç–∞–Ω–∞').count()
    called_leads = CallbackRequest.query.filter(CallbackRequest.status == '–ó–≤–æ–Ω–æ–∫ —Å–æ–≤–µ—Ä—à–µ–Ω').count()
    
    total_applications = CashbackApplication.query.count()
    pending_applications = CashbackApplication.query.filter_by(status='–ù–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏').count()
    approved_applications = CashbackApplication.query.filter_by(status='–û–¥–æ–±—Ä–µ–Ω–∞').count()
    paid_applications = CashbackApplication.query.filter_by(status='–í—ã–ø–ª–∞—á–µ–Ω–∞').count()
    
    lead_to_deal = round((total_deals / total_leads * 100), 1) if total_leads > 0 else 0
    lead_to_registration = round((total_users / total_leads * 100), 1) if total_leads > 0 else 0
    
    reg_sources = db.session.query(User.registration_source, func.count(User.id)).group_by(User.registration_source).all()
    source_data = [{'source': s[0] or '–ù–µ —É–∫–∞–∑–∞–Ω', 'count': s[1]} for s in reg_sources]
    source_data.sort(key=lambda x: x['count'], reverse=True)
    
    monthly_leads = []
    month_names_ru = ['–Ø–Ω–≤', '–§–µ–≤', '–ú–∞—Ä', '–ê–ø—Ä', '–ú–∞–π', '–ò—é–Ω', '–ò—é–ª', '–ê–≤–≥', '–°–µ–Ω', '–û–∫—Ç', '–ù–æ—è', '–î–µ–∫']
    for i in range(5, -1, -1):
        month_start = (now.replace(day=1) - timedelta(days=i*30)).replace(day=1)
        if i > 0:
            next_month = (month_start + timedelta(days=32)).replace(day=1)
        else:
            next_month = now
        m_leads = CallbackRequest.query.filter(CallbackRequest.created_at >= month_start, CallbackRequest.created_at < next_month).count()
        m_regs = User.query.filter(User.created_at >= month_start, User.created_at < next_month).count()
        monthly_leads.append({
            'month': month_names_ru[month_start.month - 1],
            'leads': m_leads,
            'registrations': m_regs
        })
    
    lead_interest_stats = db.session.query(CallbackRequest.interest, func.count(CallbackRequest.id)).filter(CallbackRequest.interest != None, CallbackRequest.interest != '').group_by(CallbackRequest.interest).all()
    interest_data = [{'interest': r[0], 'count': r[1]} for r in lead_interest_stats]
    interest_data.sort(key=lambda x: x['count'], reverse=True)
    
    lead_budget_stats = db.session.query(CallbackRequest.budget, func.count(CallbackRequest.id)).filter(CallbackRequest.budget != None, CallbackRequest.budget != '').group_by(CallbackRequest.budget).all()
    budget_data = [{'budget': r[0], 'count': r[1]} for r in lead_budget_stats]
    budget_data.sort(key=lambda x: x['count'], reverse=True)
    
    return render_template('admin/analytics.html',
        admin=current_admin,
        total_deals=total_deals,
        active_deals=active_deals,
        successful_deals=successful_deals,
        rejected_deals=rejected_deals,
        total_cashback=float(total_cashback),
        total_revenue=float(total_revenue),
        successful_cashback=float(successful_cashback),
        successful_revenue=float(successful_revenue),
        avg_deal_size=float(avg_deal_size),
        conversion_rate=conversion_rate,
        funnel_data=funnel_data,
        manager_stats=manager_stats,
        dept_stats=dept_stats,
        monthly_data=monthly_data,
        rejection_data=rejection_data,
        total_users=total_users,
        total_leads=total_leads,
        new_leads=new_leads,
        processed_leads=processed_leads,
        called_leads=called_leads,
        total_applications=total_applications,
        pending_applications=pending_applications,
        approved_applications=approved_applications,
        paid_applications=paid_applications,
        lead_to_deal=lead_to_deal,
        lead_to_registration=lead_to_registration,
        source_data=source_data,
        monthly_leads=monthly_leads,
        interest_data=interest_data,
        budget_data=budget_data)

@app.route('/admin/balance-management')
@admin_required
def admin_balance_management():
    """Admin panel for balance and withdrawal management"""
    try:
        from models import User, WithdrawalRequest, UserBalance
        from services.withdrawal_service import WithdrawalService
        
        # Get statistics
        total_users_with_balance = db.session.query(UserBalance).filter(
            (UserBalance.available_amount > 0) | (UserBalance.pending_amount > 0)
        ).count()
        
        total_available = db.session.query(db.func.sum(UserBalance.available_amount)).scalar() or 0
        total_pending = db.session.query(db.func.sum(UserBalance.pending_amount)).scalar() or 0
        total_earned = db.session.query(db.func.sum(UserBalance.total_earned)).scalar() or 0
        total_withdrawn = db.session.query(db.func.sum(UserBalance.total_withdrawn)).scalar() or 0
        
        # Pending withdrawals count
        pending_count = WithdrawalRequest.query.filter_by(status='pending').count()
        
        return render_template('admin/balance_management.html',
                             total_users_with_balance=total_users_with_balance,
                             total_available=total_available,
                             total_pending=total_pending,
                             total_earned=total_earned,
                             total_withdrawn=total_withdrawn,
                             pending_count=pending_count)
    except Exception as e:
        app.logger.error(f"Error loading balance management: {str(e)}")
        flash('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø–∞–Ω–µ–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–æ–º', 'error')
        return redirect(url_for('admin_dashboard'))

@app.route('/admin/cashback-requests')
@admin_required
def admin_cashback_requests():
    """View all cashback requests"""
    from models import CallbackRequest
    
    # Get page number
    page = request.args.get('page', 1, type=int)
    per_page = 20
    
    # Filter cashback requests
    cashback_requests = CallbackRequest.query.filter(
        CallbackRequest.notes.contains('–∫–µ—à–±–µ–∫')
    ).order_by(CallbackRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('admin/cashback_requests.html',
                         requests=cashback_requests)

@app.route('/admin/callback-request/<int:request_id>/status', methods=['POST'])
@admin_required
def update_callback_request_status(request_id):
    """Update callback request status"""
    from models import CallbackRequest
    
    try:
        data = request.get_json()
        new_status = data.get('status')
        
        callback_request = CallbackRequest.query.get_or_404(request_id)
        callback_request.status = new_status
        
        if new_status == '–û–±—Ä–∞–±–æ—Ç–∞–Ω–∞':
            callback_request.processed_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–°—Ç–∞—Ç—É—Å –æ–±–Ω–æ–≤–ª–µ–Ω'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/count', methods=['GET'])
def get_favorites_count():
    """Get count of user's favorites - works for both authenticated and guest users"""
    from models import FavoriteProperty, FavoriteComplex, Property
    from services.guest_session import get_guest_favorite_count
    
    try:
        if not current_user.is_authenticated:
            props_count, complexes_count = get_guest_favorite_count()
            return jsonify({
                'success': True,
                'properties_count': props_count,
                'complexes_count': complexes_count,
                'total_count': props_count + complexes_count
            })
        
        favorites = db.session.query(FavoriteProperty).filter_by(user_id=current_user.id).all()
        property_ids = [int(fav.property_id) for fav in favorites if fav.property_id and fav.property_id.isdigit()]
        
        properties_count = db.session.query(Property).filter(
            Property.id.in_(property_ids),
            Property.is_active == True
        ).count() if property_ids else 0
        
        complexes_count = FavoriteComplex.query.filter_by(user_id=current_user.id).count()
        
        return jsonify({
            'success': True,
            'properties_count': properties_count,
            'complexes_count': complexes_count,
            'total_count': properties_count + complexes_count
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/list', methods=['GET'])
def get_favorites_list():
    """Get user's favorite properties with full details - works for both authenticated and guest users
    
    ‚úÖ UPDATED: Now shows ALL properties including sold ones with is_sold flag
    """
    from models import FavoriteProperty, Property, ResidentialComplex, Developer
    from services.property_matcher import PropertyMatcher
    from services.guest_session import get_guest_favorites
    from urllib.parse import urlencode
    
    try:
        if not current_user.is_authenticated:
            guest_fav_ids = get_guest_favorites()
            if not guest_fav_ids:
                return jsonify({'success': True, 'favorites': []})
            
            int_ids = []
            for fid in guest_fav_ids:
                try:
                    int_ids.append(int(fid))
                except (ValueError, TypeError):
                    pass
            
            if not int_ids:
                return jsonify({'success': True, 'favorites': []})
            
            properties_query = db.session.query(
                Property,
                ResidentialComplex.name.label('complex_name'),
                ResidentialComplex.cashback_rate,
                ResidentialComplex.main_image.label('complex_image'),
                Developer.name.label('developer_name')
            ).outerjoin(
                ResidentialComplex, Property.complex_id == ResidentialComplex.id
            ).outerjoin(
                Developer, Property.developer_id == Developer.id
            ).filter(Property.id.in_(int_ids)).all()
            
            favorites_list = []
            for prop, complex_name, cashback_rate, complex_image, developer_name in properties_query:
                rooms_text = f"{prop.rooms}-–∫–æ–º–Ω" if prop.rooms and prop.rooms > 0 else "–°—Ç—É–¥–∏—è"
                favorites_list.append({
                    'id': str(prop.id),
                    'inner_id': prop.inner_id,
                    'title': f"{rooms_text}, {prop.area} –º¬≤, {prop.floor}/{prop.total_floors} —ç—Ç.",
                    'complex': complex_name or '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω',
                    'district': prop.address or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',
                    'price': prop.price or 0,
                    'image': complex_image or prop.main_image or '/static/images/no-photo.jpg',
                    'cashback_rate': cashback_rate or 3.5,
                    'cashback_amount': int((prop.price or 0) * (cashback_rate or 3.5) / 100),
                    'developer': developer_name or '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ —É–∫–∞–∑–∞–Ω',
                    'is_sold': not prop.is_active,
                    'status_label': '–ü–†–û–î–ê–ù' if not prop.is_active else '',
                    'created_at': '–ù–µ–¥–∞–≤–Ω–æ',
                    'viewed': False,
                    'similar_search_url': None
                })
            
            return jsonify({'success': True, 'favorites': favorites_list})
        
        favorites = db.session.query(FavoriteProperty).filter_by(user_id=current_user.id).order_by(FavoriteProperty.created_at.desc()).all()
        
        if not favorites:
            return jsonify({
                'success': True,
                'favorites': []
            })
        
        # –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—ã–µ property_id
        property_ids = [int(fav.property_id) for fav in favorites if fav.property_id and fav.property_id.isdigit()]
        
        if not property_ids:
            return jsonify({
                'success': True,
                'favorites': []
            })
        
        # –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø: –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω—É–∂–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã —Å JOIN (–æ–¥–Ω–∏–º –∑–∞–ø—Ä–æ—Å–æ–º!)
        # ‚úÖ –ò–ó–ú–ï–ù–ï–ù–ò–ï: –£–±—Ä–∞–ª–∏ —Ñ–∏–ª—å—Ç—Ä Property.is_active == True —á—Ç–æ–±—ã –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø—Ä–æ–¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
        properties_query = db.session.query(
            Property,
            ResidentialComplex.name.label('complex_name'),
            ResidentialComplex.cashback_rate,
            ResidentialComplex.main_image.label('complex_image'),
            Developer.name.label('developer_name')
        ).outerjoin(
            ResidentialComplex, Property.complex_id == ResidentialComplex.id
        ).outerjoin(
            Developer, Property.developer_id == Developer.id
        ).filter(
            Property.id.in_(property_ids)
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã, –≤–∫–ª—é—á–∞—è –ø—Ä–æ–¥–∞–Ω–Ω—ã–µ
        ).all()
        
        # –°–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–∞—Ä—å –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
        properties_dict = {}
        for prop, complex_name, cashback_rate, complex_image, developer_name in properties_query:
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º rooms —Ç–µ–∫—Å—Ç
            rooms_text = f"{prop.rooms}-–∫–æ–º–Ω" if prop.rooms and prop.rooms > 0 else "–°—Ç—É–¥–∏—è"
            
            properties_dict[prop.id] = {
                'id': str(prop.id),
                'inner_id': prop.inner_id,  # ‚úÖ –ù–û–í–û–ï –ü–û–õ–ï: –î–æ–±–∞–≤–∏–ª–∏ inner_id –¥–ª—è —Å—Å—ã–ª–æ–∫
                'title': f"{rooms_text}, {prop.area} –º¬≤, {prop.floor}/{prop.total_floors} —ç—Ç.",
                'complex': complex_name or '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω',
                'district': prop.address or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',  # –ü–æ–ª–Ω—ã–π –∞–¥—Ä–µ—Å –∏–∑ –ë–î
                'price': prop.price or 0,
                'image': complex_image or prop.main_image or '/static/images/no-photo.jpg',
                'cashback_rate': cashback_rate or 3.5,
                'cashback_amount': int((prop.price or 0) * (cashback_rate or 3.5) / 100),
                'developer': developer_name or '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ —É–∫–∞–∑–∞–Ω',
                'is_sold': not prop.is_active,  # ‚úÖ –ù–û–í–û–ï –ü–û–õ–ï: –§–ª–∞–≥ –ø—Ä–æ–¥–∞–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
                'status_label': '–ü–†–û–î–ê–ù' if not prop.is_active else '',  # ‚úÖ –ù–û–í–û–ï –ü–û–õ–ï: –ú–µ—Ç–∫–∞ —Å—Ç–∞—Ç—É—Å–∞
            }
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ
        favorites_list = []
        for fav in favorites:
            if not fav.property_id:
                continue
                
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º property_id –≤ int –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ —Å–ª–æ–≤–∞—Ä–µ (–∫–ª—é—á–∏ - integers)
            property_id_int = int(fav.property_id) if fav.property_id.isdigit() else None
            property_data = properties_dict.get(property_id_int) if property_id_int else None
            
            if property_data:
                # –î–æ–±–∞–≤–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –º–µ—Ç–∫—É –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ
                property_data['created_at'] = fav.created_at.strftime('%d.%m.%Y –≤ %H:%M') if fav.created_at else '–ù–µ–¥–∞–≤–Ω–æ'
                property_data['viewed'] = fav.viewed if hasattr(fav, 'viewed') else False
                
                # ‚úÖ –ù–û–í–û–ï: –î–æ–±–∞–≤–ª—è–µ–º URL –¥–ª—è –ø–æ–∏—Å–∫–∞ –∞–Ω–∞–ª–æ–≥–æ–≤ (—Ç–æ–ª—å–∫–æ –¥–ª—è –ø—Ä–æ–¥–∞–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤)
                if property_data.get('is_sold'):
                    search_params = PropertyMatcher.get_property_search_params(property_id_int)
                    if search_params:
                        property_data['similar_search_url'] = f"/properties?{urlencode(search_params)}"
                    else:
                        property_data['similar_search_url'] = "/properties"
                else:
                    property_data['similar_search_url'] = None
                
                favorites_list.append(property_data)
            else:
                # ‚úÖ –û–ë–ù–û–í–õ–ï–ù–û: Fallback –µ—Å–ª–∏ –æ–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —É–¥–∞–ª–µ–Ω
                favorites_list.append({
                    'id': fav.property_id,
                    'inner_id': fav.property_id,
                    'title': f'–û–±—ä–µ–∫—Ç #{fav.property_id}',
                    'complex': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω',
                    'district': '–í–æ–∑–º–æ–∂–Ω–æ, –æ–±—ä–µ–∫—Ç –±—ã–ª —É–¥–∞–ª–µ–Ω',
                    'price': 0,
                    'image': '/static/images/no-photo.jpg',
                    'cashback_amount': 0,
                    'created_at': fav.created_at.strftime('%d.%m.%Y –≤ %H:%M') if fav.created_at else '–ù–µ–¥–∞–≤–Ω–æ',
                    'viewed': False,
                    'is_sold': True,  # ‚úÖ –ù–û–í–û–ï
                    'status_label': '–£–î–ê–õ–ï–ù',  # ‚úÖ –ù–û–í–û–ï
                    'similar_search_url': '/properties'  # ‚úÖ –ù–û–í–û–ï
                })
        
        return jsonify({
            'success': True,
            'favorites': favorites_list
        })
    
    except Exception as e:
        print(f"Error in get_favorites_list: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/mark-viewed/<property_id>', methods=['POST'])
@login_required
@csrf.exempt
def mark_favorite_viewed(property_id):
    """Mark favorite property as viewed (property_id can be database ID or inner_id)"""
    from models import FavoriteProperty, Property
    
    try:
        # Try to find favorite by property_id directly (database ID stored as string)
        favorite = FavoriteProperty.query.filter_by(
            user_id=current_user.id,
            property_id=str(property_id)
        ).first()
        
        # If not found, try by inner_id
        if not favorite:
            property_obj = Property.query.filter_by(inner_id=str(property_id)).first()
            if property_obj:
                favorite = FavoriteProperty.query.filter_by(
                    user_id=current_user.id,
                    property_id=str(property_obj.id)
                ).first()
        
        if favorite:
            favorite.viewed = True
            db.session.commit()
            print(f"‚úÖ Marked property {property_id} as viewed for user {current_user.id}")
            return jsonify({'success': True})
        
        return jsonify({'success': False, 'error': 'Favorite not found'}), 404
    
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Error marking property {property_id} as viewed: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/mark-viewed/<complex_id>', methods=['POST'])
@login_required
@csrf.exempt
def mark_complex_favorite_viewed(complex_id):
    """Mark favorite complex as viewed (complex_id from frontend)"""
    from models import FavoriteComplex
    
    try:
        print(f"üîç Looking for complex_id={complex_id} for user {current_user.id}")
        favorite = FavoriteComplex.query.filter_by(
            user_id=current_user.id,
            complex_id=str(complex_id)
        ).first()
        
        if not favorite:
            print(f"‚ùå Favorite complex {complex_id} not found for user {current_user.id}")
            return jsonify({'success': False, 'error': 'Favorite not found'}), 404
        
        print(f"üìù Before update: viewed={favorite.viewed}")
        favorite.viewed = True
        db.session.flush()
        print(f"üìù After flush: viewed={favorite.viewed}")
        db.session.commit()
        print(f"‚úÖ Marked complex {complex_id} as viewed for user {current_user.id}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏—Å—å
        db.session.refresh(favorite)
        print(f"‚úÖ After refresh: viewed={favorite.viewed}")
        return jsonify({'success': True})
    
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Error marking complex {complex_id} as viewed: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

# Complex Favorites API
@app.route('/api/complexes/favorites', methods=['POST'])
@login_required  
@csrf.exempt  # Disable CSRF for API endpoint
def add_complex_to_favorites():
    """Add residential complex to favorites"""
    from models import FavoriteComplex
    data = request.get_json()
    
    complex_id = data.get('complex_id')
    complex_name = data.get('complex_name', '–ñ–ö')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    # Check if already in favorites
    existing = FavoriteComplex.query.filter_by(
        user_id=current_user.id,
        complex_id=str(complex_id)
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': 'Complex already in favorites'}), 400
    
    try:
        # Create favorite complex record
        favorite = FavoriteComplex(
            user_id=current_user.id,
            complex_id=str(complex_id),
            complex_name=complex_name,
            developer_name=data.get('developer_name', ''),
            complex_address=data.get('address', ''),
            district=data.get('district', ''),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            complex_image=data.get('image', ''),
            complex_url=data.get('url', ''),
            status=data.get('status', '–í –ø—Ä–æ–¥–∞–∂–µ')
        )
        
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/<complex_id>', methods=['DELETE'])
@login_required
@csrf.exempt  # Disable CSRF for API endpoint
def remove_complex_from_favorites(complex_id):
    """Remove residential complex from favorites"""
    from models import FavoriteComplex
    
    favorite = FavoriteComplex.query.filter_by(
        user_id=current_user.id,
        complex_id=str(complex_id)
    ).first()
    
    if not favorite:
        return jsonify({'success': False, 'error': 'Complex not in favorites'}), 404
    
    try:
        db.session.delete(favorite)
        db.session.commit()
        return jsonify({'success': True, 'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/toggle', methods=['POST'])
@csrf.exempt
def toggle_complex_favorite():
    """Toggle favorite status for residential complex - works for both authenticated and guest users"""
    from models import FavoriteComplex
    from services.guest_session import toggle_guest_favorite_complex
    data = request.get_json()
    complex_id = data.get('complex_id')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    if not current_user.is_authenticated:
        action, is_fav = toggle_guest_favorite_complex(complex_id)
        return jsonify({'success': True, 'favorited': is_fav, 'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ' if is_fav else '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
    
    try:
        existing = FavoriteComplex.query.filter_by(
            user_id=current_user.id,
            complex_id=str(complex_id)
        ).first()
        
        if existing:
            # Remove from favorites
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'favorited': False, 'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
        else:
            # Add to favorites
            favorite = FavoriteComplex(
                user_id=current_user.id,
                complex_id=str(complex_id),
                complex_name=data.get('complex_name', '–ñ–ö'),
                developer_name=data.get('developer_name', ''),
                complex_address=data.get('address', ''),  # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: complex_address –≤–º–µ—Å—Ç–æ address_display_name
                district=data.get('district', ''),
                min_price=data.get('min_price'),
                max_price=data.get('max_price'),
                complex_image=data.get('image', ''),
                complex_url=data.get('url', ''),
                status=data.get('status', '–í –ø—Ä–æ–¥–∞–∂–µ')
            )
            
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'favorited': True, 'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/list', methods=['GET'])
def get_user_complex_favorites_list():
    """Get user's favorite complexes with full details from residential_complexes table"""
    from models import FavoriteComplex, ResidentialComplex, Developer, District
    from services.guest_session import get_guest_favorites
    
    try:
        if not current_user.is_authenticated:
            guest_complex_ids = list(session.get('guest_favorite_complexes', []))
            return jsonify({'success': True, 'favorites': [{'complex_id': cid} for cid in guest_complex_ids], 'count': len(guest_complex_ids)})
        
        favorites = FavoriteComplex.query.filter_by(user_id=current_user.id).order_by(FavoriteComplex.created_at.desc()).all()
        
        # –°–æ–±–∏—Ä–∞–µ–º ID –∫–æ–º–ø–ª–µ–∫—Å–æ–≤
        complex_ids_int = []
        for fav in favorites:
            try:
                complex_ids_int.append(int(fav.complex_id))
            except:
                continue
        
        # Batch-–∑–∞–≥—Ä—É–∑–∫–∞ —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏–∑ residential_complexes
        complexes_dict = {}
        if complex_ids_int:
            real_complexes = db.session.query(
                ResidentialComplex.id,
                ResidentialComplex.name,
                ResidentialComplex.address,
                ResidentialComplex.main_image,
                ResidentialComplex.cashback_rate,
                District.name.label('district_name'),
                Developer.name.label('developer_name')
            ).outerjoin(District, ResidentialComplex.district_id == District.id)\
             .outerjoin(Developer, ResidentialComplex.developer_id == Developer.id)\
             .filter(ResidentialComplex.id.in_(complex_ids_int)).all()
            
            for rc in real_complexes:
                complexes_dict[rc.id] = rc
        
        # Batch-–∑–∞–≥—Ä—É–∑–∫–∞ —Ü–µ–Ω –∏ —Ñ–æ—Ç–æ –∏–∑ properties –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ñ–ö
        prices_dict = {}
        if complex_ids_int:
            # –ü–æ–ª—É—á–∞–µ–º min/max —Ü–µ–Ω—ã –∏ —Ñ–æ—Ç–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ñ–ö
            prices_query = text("""
                SELECT 
                    rc.id,
                    MIN(p.price) as min_price,
                    MAX(p.price) as max_price,
                    COALESCE(rc.main_image, rc.gallery_images, MIN(p.gallery_images)) as photos
                FROM residential_complexes rc
                LEFT JOIN properties p ON p.complex_id = rc.id AND p.is_active = true
                WHERE rc.id = ANY(:complex_ids)
                GROUP BY rc.id, rc.main_image, rc.gallery_images
            """)
            
            prices_result = db.session.execute(prices_query, {'complex_ids': complex_ids_int})
            prices_dict = {row[0]: {'min_price': row[1] or 0, 'max_price': row[2] or 0, 'photos': row[3]} for row in prices_result}
        
        # –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ—Ç–≤–µ—Ç–∞
        complexes_data = []
        for fav in favorites:
            try:
                complex_id_int = int(fav.complex_id)
                rc = complexes_dict.get(complex_id_int)
                
                if rc:
                    # –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—ã –∏ —Ñ–æ—Ç–æ –∏–∑ prices_dict
                    complex_prices = prices_dict.get(complex_id_int, {})
                    photos_data = complex_prices.get('photos', '')
                    
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–µ—Ä–≤–æ–µ —Ñ–æ—Ç–æ –∏–∑ JSON –º–∞—Å—Å–∏–≤–∞
                    image_url = '/static/images/no-image.jpg'
                    if photos_data:
                        try:
                            photos_list = json.loads(photos_data) if isinstance(photos_data, str) else photos_data
                            if photos_list and isinstance(photos_list, list) and len(photos_list) > 0:
                                image_url = photos_list[0]
                        except (json.JSONDecodeError, TypeError):
                            if isinstance(photos_data, str) and photos_data.strip():
                                image_url = photos_data
                    
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î
                    complexes_data.append({
                        'id': str(complex_id_int),
                        'name': rc.name or '–ñ–ö',
                        'address': rc.address or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                        'district': rc.district_name or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                        'developer': rc.developer_name or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                        'image': image_url,
                        'cashback_rate': rc.cashback_rate or 5,
                        'min_price': complex_prices.get('min_price', 0),
                        'max_price': complex_prices.get('max_price', 0),
                        'url': f'/residential-complex/{complex_id_int}',
                        'status': '–í –ø—Ä–æ–¥–∞–∂–µ',
                        'created_at': fav.created_at.strftime('%d.%m.%Y –≤ %H:%M')
                    })
                else:
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ –ñ–ö –Ω–µ –Ω–∞–π–¥–µ–Ω
                    complexes_data.append({
                        'id': fav.complex_id,
                        'name': fav.complex_name or '–ñ–ö',
                        'address': fav.complex_address or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                        'district': fav.district or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                        'developer': fav.developer_name or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                        'image': fav.complex_image or '',
                        'cashback_rate': 5,
                        'min_price': fav.min_price or 0,
                        'max_price': fav.max_price or 0,
                        'url': fav.complex_url or '',
                        'status': fav.status or '–í –ø—Ä–æ–¥–∞–∂–µ',
                        'created_at': fav.created_at.strftime('%d.%m.%Y –≤ %H:%M')
                    })
            except Exception as e:
                print(f"Error processing complex {fav.complex_id}: {e}")
                continue
        
        return jsonify({
            'success': True,
            'complexes': complexes_data
        })
    
    except Exception as e:
        print(f"Error in get_user_complex_favorites_list: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/clear-all', methods=['POST'])
@login_required  
@csrf.exempt  # Disable CSRF for API endpoint
def clear_all_favorites():
    """Clear all user's favorite properties"""
    from models import FavoriteProperty
    
    try:
        # Delete all favorites for current user
        deleted_count = db.session.query(FavoriteProperty).filter_by(user_id=current_user.id).delete()
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': f'–£–¥–∞–ª–µ–Ω–æ {deleted_count} –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –∫–≤–∞—Ä—Ç–∏—Ä',
            'deleted_count': deleted_count
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/clear-all', methods=['POST'])
@login_required  
@csrf.exempt  # Disable CSRF for API endpoint
def clear_all_complex_favorites():
    """Clear all user's favorite complexes"""
    from models import FavoriteComplex
    
    try:
        # Delete all complex favorites for current user
        deleted_count = db.session.query(FavoriteComplex).filter_by(user_id=current_user.id).delete()
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': f'–£–¥–∞–ª–µ–Ω–æ {deleted_count} –∏–∑–±—Ä–∞–Ω–Ω—ã—Ö –ñ–ö',
            'deleted_count': deleted_count
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/dashboard/data', methods=['GET'])
@login_required
def get_dashboard_data():
    """–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô ENDPOINT: –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –¥–∞—à–±–æ—Ä–¥–∞ –æ–¥–Ω–∏–º –∑–∞–ø—Ä–æ—Å–æ–º"""
    from models import FavoriteProperty, FavoriteComplex, ComparisonProperty, ComparisonComplex, Recommendation, Collection, UserComparison
    
    try:
        # –í—Å–µ —Å—á–µ—Ç—á–∏–∫–∏ –æ–¥–Ω–∏–º –∑–∞–ø—Ä–æ—Å–æ–º –∫ –ë–î
        favorites_properties_count = FavoriteProperty.query.filter_by(user_id=current_user.id).count()
        favorites_complexes_count = FavoriteComplex.query.filter_by(user_id=current_user.id).count()
        comparison_properties_count = db.session.query(ComparisonProperty).join(
            UserComparison, ComparisonProperty.user_comparison_id == UserComparison.id
        ).filter(UserComparison.user_id == current_user.id).count()
        
        comparison_complexes_count = db.session.query(ComparisonComplex).join(
            UserComparison, ComparisonComplex.user_comparison_id == UserComparison.id
        ).filter(UserComparison.user_id == current_user.id).count()
        recommendations_count = Recommendation.query.filter(
            Recommendation.client_id == current_user.id,
            Recommendation.status != 'dismissed'
        ).count()
        collections_count = Collection.query.filter_by(assigned_to_user_id=current_user.id).count()
        
        return jsonify({
            'success': True,
            'favorites': {
                'properties': favorites_properties_count,
                'complexes': favorites_complexes_count,
                'total': favorites_properties_count + favorites_complexes_count
            },
            'comparison': {
                'properties': comparison_properties_count,
                'complexes': comparison_complexes_count,
                'total': comparison_properties_count + comparison_complexes_count
            },
            'recommendations': recommendations_count,
            'collections': collections_count
        })
    
    except Exception as e:
        print(f"Error in get_dashboard_data: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/notifications', methods=['GET'])
@login_required
def api_get_notifications():
    from models import Notification, UserNotification
    try:
        notifs_1 = Notification.query.filter_by(user_id=current_user.id).order_by(Notification.created_at.desc()).limit(30).all()
        notifs_2 = UserNotification.query.filter_by(user_id=current_user.id).order_by(UserNotification.created_at.desc()).limit(30).all()

        all_notifs = []
        for n in notifs_1:
            all_notifs.append({
                'id': n.id,
                'source': 'notification',
                'title': n.title,
                'message': n.message,
                'type': n.type or 'info',
                'is_read': n.is_read,
                'created_at': n.created_at.isoformat() if n.created_at else None,
            })
        for n in notifs_2:
            all_notifs.append({
                'id': n.id,
                'source': 'user_notification',
                'title': n.title,
                'message': n.message,
                'type': n.notification_type or 'info',
                'is_read': n.is_read,
                'created_at': n.created_at.isoformat() if n.created_at else None,
                'action_url': n.action_url,
            })

        all_notifs.sort(key=lambda x: x['created_at'] or '', reverse=True)
        unread_count = sum(1 for n in all_notifs if not n['is_read'])

        return jsonify({'success': True, 'notifications': all_notifs[:30], 'unread_count': unread_count})
    except Exception as e:
        print(f"Error fetching notifications: {e}")
        return jsonify({'success': False, 'notifications': [], 'unread_count': 0})

@app.route('/api/notifications/mark-read', methods=['POST'])
@login_required
def api_mark_notifications_read():
    from models import Notification, UserNotification
    try:
        data = request.get_json() or {}
        notif_id = data.get('id')
        source = data.get('source')
        mark_all = data.get('all', False)

        if mark_all:
            Notification.query.filter_by(user_id=current_user.id, is_read=False).update({'is_read': True})
            UserNotification.query.filter_by(user_id=current_user.id, is_read=False).update({'is_read': True, 'read_at': datetime.utcnow()})
            db.session.commit()
            return jsonify({'success': True})

        if notif_id and source == 'notification':
            n = Notification.query.filter_by(id=notif_id, user_id=current_user.id).first()
            if n:
                n.is_read = True
                db.session.commit()
        elif notif_id and source == 'user_notification':
            n = UserNotification.query.filter_by(id=notif_id, user_id=current_user.id).first()
            if n:
                n.is_read = True
                n.read_at = datetime.utcnow()
                db.session.commit()

        return jsonify({'success': True})
    except Exception as e:
        print(f"Error marking notification read: {e}")
        db.session.rollback()
        return jsonify({'success': False}), 500

@app.route('/api/manager/notifications', methods=['GET'])
@manager_required
def api_get_manager_notifications():
    from models import ManagerNotification
    try:
        current_manager = current_user
        notifs = ManagerNotification.query.filter_by(
            manager_id=current_manager.id
        ).order_by(ManagerNotification.created_at.desc()).limit(30).all()
        
        notifications = []
        for n in notifs:
            action_url = ''
            if n.presentation_id:
                action_url = f'/manager/presentation/{n.presentation_id}'
            elif n.notification_type == 'task_reminder' and n.extra_data:
                try:
                    import json
                    extra = json.loads(n.extra_data)
                    if extra.get('deal_id'):
                        action_url = f'/manager/deals/{extra["deal_id"]}'
                except Exception:
                    pass
            notifications.append({
                'id': n.id,
                'source': 'manager_notification',
                'title': n.title,
                'message': n.message,
                'type': n.notification_type or 'info',
                'is_read': n.is_read,
                'created_at': n.created_at.isoformat() if n.created_at else None,
                'action_url': action_url,
            })
        
        unread_count = sum(1 for n in notifications if not n['is_read'])
        return jsonify({'success': True, 'notifications': notifications, 'unread_count': unread_count})
    except Exception as e:
        print(f"Error fetching manager notifications: {e}")
        return jsonify({'success': False, 'notifications': [], 'unread_count': 0})

@app.route('/api/manager/notifications/mark-read', methods=['POST'])
@manager_required
def api_mark_manager_notifications_read():
    from models import ManagerNotification
    try:
        current_manager = current_user
        data = request.get_json() or {}
        notif_id = data.get('id')
        mark_all = data.get('all', False)
        
        if mark_all:
            ManagerNotification.query.filter_by(
                manager_id=current_manager.id, is_read=False
            ).update({'is_read': True, 'read_at': datetime.utcnow()})
            db.session.commit()
            return jsonify({'success': True})
        
        if notif_id:
            n = ManagerNotification.query.filter_by(
                id=notif_id, manager_id=current_manager.id
            ).first()
            if n:
                n.is_read = True
                n.read_at = datetime.utcnow()
                db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        print(f"Error marking manager notification read: {e}")
        db.session.rollback()
        return jsonify({'success': False}), 500


@app.route('/api/searches', methods=['GET'])
@login_required
def get_saved_searches():
    """–ó–ê–ì–õ–£–®–ö–ê: –°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –ø–æ–∏—Å–∫–∏ (–ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ)"""
    return jsonify({
        'success': True,
        'searches': []
    })


@app.route('/api/complete-profile', methods=['POST'])
@login_required
@require_json_csrf
def complete_profile():
    """Complete user profile after SMS verification"""
    from models import User
    import logging
    
    logger = logging.getLogger(__name__)
    
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({'success': False, 'message': '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}), 400
        
        full_name = data.get('full_name', '').strip()
        email = data.get('email', '').strip()
        telegram = data.get('telegram', '').strip()
        
        # Validate required field
        if not full_name:
            return jsonify({'success': False, 'message': '–§–ò–û –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        
        # Update user profile
        current_user.full_name = full_name
        
        if email:
            # Check if email already exists (for other users)
            existing_user = User.query.filter(
                User.email == email,
                User.id != current_user.id
            ).first()
            
            if existing_user:
                return jsonify({'success': False, 'message': 'Email —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è'}), 400
            
            current_user.email = email
        
        if telegram:
            current_user.telegram = telegram
        
        # Mark profile as completed
        current_user.profile_completed = True
        
        db.session.commit()
        
        logger.info(f"‚úÖ Profile completed for user {current_user.id}: {full_name}")
        
        return jsonify({
            'success': True,
            'message': '–ü—Ä–æ—Ñ–∏–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω!'
        })
        
    except Exception as e:
        logger.error(f"‚ùå Error completing profile: {str(e)}", exc_info=True)
        db.session.rollback()
        return jsonify({
            'success': False,
            'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è: {str(e)}'
        }), 500


@app.route('/api/user/stats', methods=['GET'])
@login_required
def get_user_stats():
    """–ó–ê–ì–õ–£–®–ö–ê: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ)"""
    return jsonify({
        'success': True,
        'views': 0,
        'favorites': 0,
        'applications': 0
    })

@app.route('/api/favorites/all', methods=['GET'])
@login_required
def get_all_favorites():
    """–û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô: –ü–æ–ª—É—á–∏—Ç—å –í–°–ï –∏–∑–±—Ä–∞–Ω–Ω–æ–µ (–∫–≤–∞—Ä—Ç–∏—Ä—ã + –ñ–ö) –æ–¥–Ω–∏–º –∑–∞–ø—Ä–æ—Å–æ–º"""
    from models import FavoriteProperty, FavoriteComplex, Property, ResidentialComplex, Developer, District
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –∏–∑–±—Ä–∞–Ω–Ω—ã–µ –∫–≤–∞—Ä—Ç–∏—Ä—ã
        favorites = db.session.query(FavoriteProperty).filter_by(user_id=current_user.id).order_by(FavoriteProperty.created_at.desc()).all()
        
        properties_list = []
        if favorites:
            print(f"DEBUG /api/favorites/all: Found {len(favorites)} favorites for user {current_user.id}")
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º property_id –≤ int (–æ–Ω–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è –∫–∞–∫ varchar –≤ –ë–î)
            property_ids = [int(fav.property_id) for fav in favorites if fav.property_id and fav.property_id.isdigit()]
            print(f"DEBUG: property_ids after conversion: {property_ids}")
            
            if property_ids:
                properties_query = db.session.query(
                    Property,
                    ResidentialComplex.name.label('complex_name'),
                    ResidentialComplex.cashback_rate,
                    ResidentialComplex.main_image.label('complex_image'),
                    Developer.name.label('developer_name')
                ).outerjoin(
                    ResidentialComplex, Property.complex_id == ResidentialComplex.id
                ).outerjoin(
                    Developer, Property.developer_id == Developer.id
                ).filter(
                    Property.id.in_(property_ids)  # ‚úÖ –£–±—Ä–∞–ª–∏ is_active —á—Ç–æ–±—ã –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø—Ä–æ–¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
                ).all()
                print(f"DEBUG: properties_query returned {len(properties_query)} results")
                
                properties_dict = {}
                for prop, complex_name, cashback_rate, complex_image, developer_name in properties_query:
                    rooms_text = f"{prop.rooms}-–∫–æ–º–Ω" if prop.rooms and prop.rooms > 0 else "–°—Ç—É–¥–∏—è"
                    properties_dict[prop.id] = {  # –ö–ª—é—á - prop.id (integer)
                        'id': str(prop.id),
                        'title': f"{rooms_text}, {prop.area} –º¬≤, {prop.floor}/{prop.total_floors} —ç—Ç.",
                        'complex': complex_name or '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω',
                        'district': prop.address or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',
                        'price': prop.price or 0,
                        'image': complex_image or prop.main_image or '/static/images/no-photo.jpg',
                        'cashback_rate': cashback_rate or 3.5,
                        'cashback_amount': int((prop.price or 0) * (cashback_rate or 3.5) / 100),
                        'developer': developer_name or '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ —É–∫–∞–∑–∞–Ω',
                        'is_sold': not prop.is_active,  # ‚úÖ –ù–û–í–û–ï –ü–û–õ–ï: –§–ª–∞–≥ –ø—Ä–æ–¥–∞–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
                        'created_at': None,
                        'viewed': False
                    }
                
                for fav in favorites:
                    # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º property_id –≤ int –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ —Å–ª–æ–≤–∞—Ä–µ
                    property_id_int = int(fav.property_id) if fav.property_id and fav.property_id.isdigit() else None
                    if property_id_int and property_id_int in properties_dict:
                        prop_data = properties_dict[property_id_int]
                        prop_data['created_at'] = fav.created_at.strftime('%d.%m.%Y –≤ %H:%M') if fav.created_at else '–ù–µ–¥–∞–≤–Ω–æ'
                        prop_data['viewed'] = fav.viewed if hasattr(fav, 'viewed') else False
                        properties_list.append(prop_data)
        
        print(f"DEBUG: Final properties_list length: {len(properties_list)}")
        
        # –ü–æ–ª—É—á–∞–µ–º –∏–∑–±—Ä–∞–Ω–Ω—ã–µ –ñ–ö
        complex_favorites = FavoriteComplex.query.filter_by(user_id=current_user.id).order_by(FavoriteComplex.created_at.desc()).all()
        
        complexes_list = []
        if complex_favorites:
            complex_ids_int = []
            for fav in complex_favorites:
                try:
                    complex_ids_int.append(int(fav.complex_id))
                except:
                    continue
            
            if complex_ids_int:
                complexes_query = db.session.query(
                    ResidentialComplex.id,
                    ResidentialComplex.name,
                    ResidentialComplex.address,
                    ResidentialComplex.main_image,
                    ResidentialComplex.cashback_rate,
                    District.name.label('district_name'),
                    Developer.name.label('developer_name')
                ).outerjoin(District, ResidentialComplex.district_id == District.id)\
                 .outerjoin(Developer, ResidentialComplex.developer_id == Developer.id)\
                 .filter(ResidentialComplex.id.in_(complex_ids_int)).all()
                
                complexes_dict = {}
                for rc in complexes_query:
                    complexes_dict[rc.id] = rc
                
                # –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—ã
                from sqlalchemy import text, func
                prices_query = text("""
                    SELECT 
                        complex_id,
                        MIN(price) as min_price,
                        MAX(price) as max_price,
                        MIN(main_image) as first_image
                    FROM properties 
                    WHERE complex_id = ANY(:complex_ids) AND is_active = true
                    GROUP BY complex_id
                """)
                prices_result = db.session.execute(prices_query, {"complex_ids": complex_ids_int})
                prices_dict = {row[0]: {'min_price': row[1], 'max_price': row[2], 'first_image': row[3]} for row in prices_result}
                
                for fav in complex_favorites:
                    try:
                        complex_id_int = int(fav.complex_id)
                        rc = complexes_dict.get(complex_id_int)
                        
                        if rc:
                            complex_prices = prices_dict.get(complex_id_int, {})
                            image_url = rc.main_image or complex_prices.get('first_image') or fav.complex_image or ''
                            
                            complexes_list.append({
                                'id': str(complex_id_int),
                                'name': rc.name or fav.complex_name or '–ñ–ö',
                                'address': rc.address or fav.complex_address or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                                'district': rc.district_name or fav.district or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                                'developer': rc.developer_name or fav.developer_name or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                                'image': image_url,
                                'cashback_rate': rc.cashback_rate or 5,
                                'min_price': complex_prices.get('min_price', fav.min_price or 0),
                                'max_price': complex_prices.get('max_price', fav.max_price or 0),
                                'url': f'/residential-complex/{complex_id_int}',
                                'status': '–í –ø—Ä–æ–¥–∞–∂–µ',
                                'created_at': fav.created_at.strftime('%d.%m.%Y –≤ %H:%M'),
                                'viewed': fav.viewed if hasattr(fav, 'viewed') else False
                            })
                    except Exception as e:
                        print(f"Error processing complex {fav.complex_id}: {e}")
                        continue
        
        return jsonify({
            'success': True,
            'properties': properties_list,
            'complexes': complexes_list,
            'total': len(properties_list) + len(complexes_list)
        })
    
    except Exception as e:
        print(f"Error in get_all_favorites: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

# Manager Favorites API - Properties
@app.route('/api/manager/favorites', methods=['POST'])
@manager_required  
def manager_add_to_favorites():
    """Add property to manager's favorites"""
    from models import ManagerFavoriteProperty
    
    current_manager = current_user
    data = request.get_json()
    
    # Check if already in favorites
    existing = ManagerFavoriteProperty.query.filter_by(
        manager_id=current_manager.id,
        property_id=data.get('property_id')
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': '–£–∂–µ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º'})
    
    try:
        favorite = ManagerFavoriteProperty(
            manager_id=current_manager.id,
            property_id=data.get('property_id'),
            property_name=data.get('property_name', ''),
            property_type=data.get('property_type', ''),
            property_size=float(data.get('property_size', 0)),
            property_price=int(data.get('property_price', 0)),
            complex_name=data.get('complex_name', ''),
            developer_name=data.get('developer_name', ''),
            property_image=data.get('property_image'),
            property_url=data.get('property_url'),
            cashback_amount=int(data.get('cashback_amount', 0)),
            cashback_percent=float(data.get('cashback_percent', 0)),
            notes=data.get('notes', ''),
            recommended_for=data.get('recommended_for', '')
        )
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/favorites/<property_id>', methods=['DELETE'])
@manager_required
def manager_remove_from_favorites(property_id):
    """Remove property from manager's favorites"""
    from models import ManagerFavoriteProperty
    
    current_manager = current_user
    
    favorite = ManagerFavoriteProperty.query.filter_by(
        manager_id=current_manager.id,
        property_id=property_id
    ).first()
    
    if favorite:
        try:
            db.session.delete(favorite)
            db.session.commit()
            return jsonify({'success': True, 'message': '–£–¥–∞–ª–µ–Ω–æ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)}), 400
    
    return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–º'}), 404

@app.route('/api/manager/favorites/clear', methods=['DELETE'])
@manager_required
def manager_clear_all_favorites():
    """Clear all properties from manager's favorites"""
    from models import ManagerFavoriteProperty
    
    current_manager = current_user
    
    try:
        # Delete all favorites for this manager
        deleted_count = ManagerFavoriteProperty.query.filter_by(
            manager_id=current_manager.id
        ).delete()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'–£–¥–∞–ª–µ–Ω–æ {deleted_count} –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ',
            'deleted_count': deleted_count
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/favorites/toggle', methods=['POST'])
@manager_required
def manager_toggle_favorite():
    """Toggle favorite status for property"""
    from models import ManagerFavoriteProperty
    
    current_manager = current_user
    
    data = request.get_json()
    property_id = data.get('property_id')
    
    if not property_id:
        return jsonify({'success': False, 'error': 'property_id required'}), 400
    
    print(f"DEBUG: Manager favorites toggle called by manager {current_manager.id} for property {property_id}")
    
    # Check if already in favorites
    existing = ManagerFavoriteProperty.query.filter_by(
        manager_id=current_manager.id,
        property_id=property_id
    ).first()
    
    try:
        if existing:
            # Remove from favorites
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'action': 'removed', 'is_favorite': False, 'message': '–£–¥–∞–ª–µ–Ω–æ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
        else:
            # Add to favorites
            favorite = ManagerFavoriteProperty(
                manager_id=current_manager.id,
                property_id=property_id,
                property_name=data.get('property_name', ''),
                property_type=data.get('property_type', ''),
                property_size=float(data.get('property_size', 0)),
                property_price=int(data.get('property_price', 0)),
                complex_name=data.get('complex_name', ''),
                developer_name=data.get('developer_name', ''),
                property_image=data.get('property_image'),
                property_url=data.get('property_url'),
                cashback_amount=int(data.get('cashback_amount', 0)),
                cashback_percent=float(data.get('cashback_percent', 0)),
                notes=data.get('notes', ''),
                recommended_for=data.get('recommended_for', '')
            )
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'action': 'added', 'is_favorite': True, 'message': '–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/favorites/count', methods=['GET'])
@manager_required  
def manager_get_favorites_count():
    """Get count of manager's favorites"""
    from models import ManagerFavoriteProperty, ManagerFavoriteComplex
    
    current_manager = current_user
    
    try:
        # DEBUG: Log which tables we're querying
        print(f"üîç DEBUG: /api/manager/favorites/count called - querying MANAGER tables for manager {current_manager.id}")
        
        properties_count = ManagerFavoriteProperty.query.filter_by(manager_id=current_manager.id).count()
        complexes_count = ManagerFavoriteComplex.query.filter_by(manager_id=current_manager.id).count()
        
        print(f"‚úÖ Manager favorites count: {properties_count} properties, {complexes_count} complexes from MANAGER tables")
        
        return jsonify({
            'success': True,
            'properties_count': properties_count,
            'complexes_count': complexes_count,
            'total_count': properties_count + complexes_count
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

# Note: Manager Complex Favorites endpoints already exist below - no duplicates needed

@app.route('/api/manager/favorites/list', methods=['GET'])
@manager_required  
def manager_get_favorites_list():
    """Get manager's favorite properties with full details"""
    from models import ManagerFavoriteProperty, Property, ResidentialComplex, Developer
    
    current_manager = current_user
    
    try:
        print(f"üîç DEBUG: /api/manager/favorites/list called for manager {current_manager.id}")
        
        favorites = db.session.query(ManagerFavoriteProperty).filter_by(manager_id=current_manager.id).order_by(ManagerFavoriteProperty.created_at.desc()).all()
        print(f"‚úÖ Found {len(favorites)} favorites in MANAGER_FAVORITE_PROPERTIES")
        
        if not favorites:
            return jsonify({'success': True, 'favorites': []})
        
        # –ü–æ–ª—É—á–∞–µ–º id (serial) –∏–∑ manager_favorite_properties.property_id
        property_ids = [int(fav.property_id) for fav in favorites if fav.property_id]
        print(f"üîç DEBUG: Looking for property IDs: {property_ids[:5]}...")
        
        if not property_ids:
            return jsonify({'success': True, 'favorites': []})
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –ø–æ properties.id (serial)!
        properties_query = db.session.query(
            Property,
            ResidentialComplex.name.label('complex_name'),
            ResidentialComplex.cashback_rate,
            ResidentialComplex.main_image.label('complex_image'),
            Developer.name.label('developer_name')
        ).outerjoin(
            ResidentialComplex, Property.complex_id == ResidentialComplex.id
        ).outerjoin(
            Developer, Property.developer_id == Developer.id
        ).filter(
            Property.id.in_(property_ids)  # ‚úÖ –ò—â–µ–º –ø–æ properties.id!
        ).all()
        
        print(f"üîç DEBUG: SQL returned {len(properties_query)} properties")
        
        # –°–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–∞—Ä—å: –∫–ª—é—á = properties.id
        properties_dict = {}
        for prop, complex_name, cashback_rate, complex_image, developer_name in properties_query:
            rooms_text = f"{prop.rooms}-–∫–æ–º–Ω" if prop.rooms and prop.rooms > 0 else "–°—Ç—É–¥–∏—è"
            
            properties_dict[prop.id] = {  # ‚úÖ –ö–ª—é—á = properties.id
                'id': str(prop.id),
                'inner_id': prop.inner_id,
                'title': f"{rooms_text}, {prop.area} –º¬≤, {prop.floor}/{prop.total_floors} —ç—Ç.",
                'complex': complex_name or '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω',
                'district': prop.address or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',
                'price': prop.price or 0,
                'image': complex_image or prop.main_image or '/static/images/no-photo.jpg',
                'cashback_rate': cashback_rate or 3.5,
                'cashback_amount': int((prop.price or 0) * (cashback_rate or 3.5) / 100),
                'developer': developer_name or '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ —É–∫–∞–∑–∞–Ω'
            }
        
        print(f"üîç DEBUG: Created dict with {len(properties_dict)} entries")
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫
        favorites_list = []
        for fav in favorites:
            property_id_int = int(fav.property_id)
            property_data = properties_dict.get(property_id_int)  # ‚úÖ –ò—â–µ–º –ø–æ properties.id
            
            if property_data:
                property_data['created_at'] = fav.created_at.strftime('%d.%m.%Y –≤ %H:%M') if fav.created_at else '–ù–µ–¥–∞–≤–Ω–æ'
                favorites_list.append(property_data)
            else:
                print(f"‚ö†Ô∏è Property {fav.property_id} not found in database")
        
        print(f"‚úÖ Returning {len(favorites_list)} favorites")
        
        return jsonify({
            'success': True,
            'favorites': favorites_list
        })
    
    except Exception as e:
        print(f"‚ùå ERROR in manager_get_favorites_list: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

    """Add residential complex to manager's favorites"""
    from models import ManagerFavoriteComplex
    
    current_manager = current_user
    data = request.get_json()
    
    complex_id = data.get('complex_id')
    complex_name = data.get('complex_name', '–ñ–ö')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    # Check if already in favorites
    existing = ManagerFavoriteComplex.query.filter_by(
        manager_id=current_manager.id,
        complex_id=str(complex_id)
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': 'Complex already in favorites'}), 400
    
    try:
        # Create favorite complex record
        favorite = ManagerFavoriteComplex(
            manager_id=current_manager.id,
            complex_id=str(complex_id),
            complex_name=complex_name,
            developer_name=data.get('developer_name', ''),
            complex_address=data.get('address', ''),
            district=data.get('district', ''),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            complex_image=data.get('image', ''),
            complex_url=data.get('url', ''),
            status=data.get('status', '–í –ø—Ä–æ–¥–∞–∂–µ'),
            object_class_display_name=data.get('object_class_display_name', ''),
            notes=data.get('notes', ''),
            recommended_for=data.get('recommended_for', '')
        )
        
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/complexes/favorites/<complex_id>', methods=['DELETE'])
@manager_required
def manager_remove_complex_from_favorites(complex_id):
    """Remove residential complex from manager's favorites"""
    from models import ManagerFavoriteComplex
    
    current_manager = current_user
    
    favorite = ManagerFavoriteComplex.query.filter_by(
        manager_id=current_manager.id,
        complex_id=str(complex_id)
    ).first()
    
    if not favorite:
        return jsonify({'success': False, 'error': 'Complex not in favorites'}), 404
    
    try:
        db.session.delete(favorite)
        db.session.commit()
        return jsonify({'success': True, 'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/complexes/favorites/clear', methods=['DELETE'])
@manager_required
def manager_clear_all_complex_favorites():
    """Clear all complexes from manager's favorites"""
    from models import ManagerFavoriteComplex
    
    current_manager = current_user
    
    try:
        # Delete all complex favorites for this manager
        deleted_count = ManagerFavoriteComplex.query.filter_by(
            manager_id=current_manager.id
        ).delete()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'–£–¥–∞–ª–µ–Ω–æ {deleted_count} –ñ–ö –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ',
            'deleted_count': deleted_count
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/complexes/favorites/toggle', methods=['POST'])
@manager_required
def manager_toggle_complex_favorite():
    """Toggle favorite status for residential complex"""
    from models import ManagerFavoriteComplex
    
    current_manager = current_user
    
    data = request.get_json()
    complex_id = data.get('complex_id')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    try:
        existing = ManagerFavoriteComplex.query.filter_by(
            manager_id=current_manager.id,
            complex_id=str(complex_id)
        ).first()
        
        if existing:
            # Remove from favorites
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'favorited': False, 'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ'})
        else:
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ñ–ö –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            real_complex_name = '–ñ–ö –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'
            real_developer_name = '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_address = '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_district = '–†–∞–π–æ–Ω –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_min_price = 0
            real_max_price = 0
            real_image = '/static/images/no-photo.jpg'
            real_status = '–í –ø—Ä–æ–¥–∞–∂–µ'
            real_object_class = ''
            
            try:
                # ‚úÖ MIGRATED: –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ normalized schema –ø–æ complex_id
                from sqlalchemy import text
                complex_query = text("""
                    SELECT 
                        rc.name as complex_name,
                        d.name as developer_name,
                        rc.address AS address_display_name,
                        dist.name AS address_locality_name,
                        MIN(p.price) as min_price,
                        MAX(p.price) as max_price,
                        (SELECT p2.gallery_images FROM properties p2 
                         WHERE p2.complex_id = rc.id 
                         AND p2.gallery_images IS NOT NULL 
                         ORDER BY p2.price DESC LIMIT 1) AS photos,
                        rc.object_class_display_name
                    FROM residential_complexes rc
                    LEFT JOIN developers d ON rc.developer_id = d.id
                    LEFT JOIN districts dist ON rc.district_id = dist.id
                    LEFT JOIN properties p ON p.complex_id = rc.id
                    WHERE rc.id = :complex_id
                    GROUP BY rc.name, d.name, rc.address, dist.name, rc.id
                    LIMIT 1
                """)
                
                result = db.session.execute(complex_query, {'complex_id': str(complex_id)})
                row = result.fetchone()
                
                if row:
                    real_complex_name = row[0] or real_complex_name
                    real_developer_name = row[1] or real_developer_name  
                    real_address = row[2] or real_address
                    real_district = row[3] or real_district
                    real_min_price = int(row[4]) if row[4] else 0
                    real_max_price = int(row[5]) if row[5] else 0
                    real_object_class = row[7] or real_object_class
                    
                    # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ –∏–∑ JSON
                    if row[6]:
                        try:
                            import json
                            photos = json.loads(row[6]) if isinstance(row[6], str) else row[6]
                            if photos and isinstance(photos, list) and len(photos) > 0:
                                real_image = photos[0]  # –ü–µ—Ä–≤–æ–µ —Ñ–æ—Ç–æ –∫–∞–∫ –æ—Å–Ω–æ–≤–Ω–æ–µ
                        except Exception as photo_error:
                            print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                    
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ –≥–æ–¥—É —Å–¥–∞—á–∏
                    from datetime import datetime
                    current_year = datetime.now().year
                    
                    try:
                        # ‚úÖ MIGRATED: –ó–∞–ø—Ä–æ—Å —Å—Ç–∞—Ç—É—Å–∞ –∏–∑ normalized schema
                        status_query = text("""
                            SELECT end_build_year AS complex_building_end_build_year
                            FROM residential_complexes 
                            WHERE id = :complex_id 
                            AND end_build_year IS NOT NULL
                            LIMIT 1
                        """)
                        status_result = db.session.execute(status_query, {'complex_id': str(complex_id)})
                        status_row = status_result.fetchone()
                        
                        if status_row and status_row[0]:
                            build_year = int(status_row[0])
                            real_status = '–°–¥–∞–Ω' if build_year <= current_year else '–°—Ç—Ä–æ–∏—Ç—Å—è'
                    except:
                        pass
                        
            except Exception as e:
                print(f"Error loading real complex data for {complex_id}: {e}")
                # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å fallback –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
                pass
            
            # Add to favorites with REAL DATA
            favorite = ManagerFavoriteComplex(
                manager_id=current_manager.id,
                complex_id=str(complex_id),
                complex_name=real_complex_name,
                developer_name=real_developer_name,
                complex_address=real_address,
                district=real_district,
                min_price=real_min_price,
                max_price=real_max_price,
                complex_image=real_image,
                complex_url=data.get('url', f'/zk/{complex_id}'),
                status=real_status,
                object_class_display_name=real_object_class,
                notes=data.get('notes', ''),
                recommended_for=data.get('recommended_for', '')
            )
            
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'favorited': True, 'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/complexes/favorites/list', methods=['GET'])
@manager_required
def manager_get_complex_favorites_list():
    """Get manager's favorite complexes with full details"""
    from models import ManagerFavoriteComplex, ResidentialComplex, Developer, District
    from sqlalchemy.orm import joinedload, selectinload
    from sqlalchemy import or_
    
    current_manager = current_user
    
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑–±—Ä–∞–Ω–Ω–æ–µ –±–µ–∑ broken relationship
        favorites = db.session.query(ManagerFavoriteComplex)\
            .filter_by(manager_id=current_manager.id)\
            .order_by(ManagerFavoriteComplex.created_at.desc()).all()
        
        # –°–æ–±–∏—Ä–∞–µ–º ID –∫–æ–º–ø–ª–µ–∫—Å–æ–≤ –¥–ª—è batch-–∑–∞–≥—Ä—É–∑–∫–∏
        complex_ids_str = [fav.complex_id for fav in favorites if fav.complex_id]
        complex_ids_int = []
        for cid in complex_ids_str:
            try:
                complex_ids_int.append(int(cid))
            except (ValueError, TypeError):
                pass
        
        # BYPASSING broken favorites data - use direct ResidentialComplex lookup since FK is broken
        # Get complex names from ResidentialComplex table using favorites complex_id (if exists)
        complex_names = []
        for fav in favorites:
            if fav.complex_id:
                try:
                    complex_int_id = int(fav.complex_id)
                    rc = ResidentialComplex.query.get(complex_int_id)
                    if rc and rc.name:
                        complex_names.append(rc.name)
                except (ValueError, TypeError):
                    pass
        
        # Fallback: If no matches found, use all residential complexes for demo
        if not complex_names:
            all_complexes = ResidentialComplex.query.limit(10).all()
            complex_names = [rc.name for rc in all_complexes if rc.name]
        
        # ENSURE we include ALL favorite complex names even if not in excel_data
        # This prevents missing complexes in comparison
        for fav in favorites:
            if fav.complex_id:
                try:
                    complex_int_id = int(fav.complex_id)
                    rc = ResidentialComplex.query.get(complex_int_id)
                    if rc and rc.name and rc.name not in complex_names:
                        complex_names.append(rc.name)
                        print(f"DEBUG: Added missing favorite complex to search: {rc.name}")
                except (ValueError, TypeError):
                    pass
        excel_data = {}
        
        if complex_names:
            # SQL aggregation with proper expanding bind and name normalization
            from sqlalchemy import text, bindparam
            
            # Normalize names for matching
            normalized_names = tuple({n.strip().lower().replace('¬´','"').replace('¬ª','"') 
                                    for n in complex_names if n})
            
            stmt = text("""
            SELECT 
                rc.name as complex_name,
                MIN(p.price) as min_price,
                MAX(p.price) as max_price,
                COUNT(p.id) as apartments_count,
                rc.address AS address_display_name,
                (SELECT p2.gallery_images FROM properties p2 
                 WHERE p2.complex_id = rc.id AND p2.gallery_images IS NOT NULL 
                 LIMIT 1) AS photos
            FROM residential_complexes rc
            LEFT JOIN properties p ON p.complex_id = rc.id
            WHERE lower(rc.name) IN :names
            GROUP BY rc.id, rc.name, rc.address
            """).bindparams(bindparam('names', expanding=True))
            
            result = db.session.execute(stmt, {'names': normalized_names})
            for row in result:
                # Store with original complex name for mapping
                for original_name in complex_names:
                    if original_name and original_name.strip().lower().replace('¬´','"').replace('¬ª','"') == row.complex_name.lower():
                        excel_data[original_name] = {
                            'min_price': int(row.min_price) if row.min_price else 0,
                            'max_price': int(row.max_price) if row.max_price else 0,
                            'apartments_count': int(row.apartments_count) if row.apartments_count else 0,
                            'sample_address': row.address_display_name or '',
                            'photos': row.photos
                        }
                        break
            
            print(f"DEBUG: Searched {len(normalized_names)} names, found {len(excel_data)} matches")
            print(f"DEBUG: excel_data keys: {list(excel_data.keys())[:2]}")  # First 2 keys
        
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –∫–æ–º–ø–ª–µ–∫—Å—ã —Å—Ä–∞–∑—É —Å joined –¥–∞–Ω–Ω—ã–º–∏  
        complexes_data = {}
        if complex_ids_str:
            complexes_query = db.session.query(ResidentialComplex)\
                .options(
                    joinedload(ResidentialComplex.developer), 
                    joinedload(ResidentialComplex.district),
                    selectinload(ResidentialComplex.buildings)
                )\
                .filter(or_(
                    ResidentialComplex.id.in_(complex_ids_int),
                    ResidentialComplex.complex_id.in_(complex_ids_str)
                ))
            
            for complex_data in complexes_query:
                complexes_data[str(complex_data.id)] = complex_data
                if complex_data.complex_id:
                    complexes_data[str(complex_data.complex_id)] = complex_data
        
        favorites_list = []
        for fav in favorites:
            # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—â–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ ResidentialComplex —Ç–∞–±–ª–∏—Ü–µ –∏ excel_properties
            real_complex_name = '–ñ–ö –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'
            real_developer_name = '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_address = '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_district = '–†–∞–π–æ–Ω –Ω–µ —É–∫–∞–∑–∞–Ω'
            real_min_price = 0
            real_max_price = 0
            real_image = '/static/images/no-photo.jpg'
            real_status = '–í –ø—Ä–æ–¥–∞–∂–µ'
            real_apartments_count = 0
            real_buildings_count = 1
            real_delivery_date = '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
            
                # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ SQL —á—Ç–æ –∏ /residential-complexes –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º ID
            try:
                complex_db = None
                print(f"DEBUG: Searching for complex with fav.complex_id: {fav.complex_id}")
                
                if fav.complex_id:
                    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –≤ residential_complexes (–¥–ª—è —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π)
                    try:
                        complex_int_id = int(fav.complex_id)
                        complex_db = ResidentialComplex.query.get(complex_int_id)
                        print(f"DEBUG: Found by id {complex_int_id}: {complex_db.name if complex_db else 'None'}")
                    except (ValueError, TypeError):
                        pass
                
                if complex_db and complex_db.name:
                    # –ù–∞–π–¥–µ–Ω–æ –≤ residential_complexes - –∏—Å–ø–æ–ª—å–∑—É–µ–º —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ
                    real_complex_name = complex_db.name
                    real_developer_name = complex_db.developer.name if complex_db.developer else real_developer_name
                    real_district = complex_db.district.name if complex_db.district else real_district
                    # –ê–¥—Ä–µ—Å –±–µ—Ä–µ–º –∏–∑ sales_address –∏–ª–∏ –æ—Å—Ç–∞–≤–ª—è–µ–º placeholder –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑ excel_properties
                    real_address = complex_db.sales_address if hasattr(complex_db, 'sales_address') and complex_db.sales_address else real_address
                    real_image = complex_db.main_image if hasattr(complex_db, 'main_image') and complex_db.main_image else real_image
                    print(f"DEBUG: ‚úÖ Using residential_complexes data: {real_complex_name}")
                else:
                    # ‚úÖ MIGRATED: Complex not found in residential_complexes table
                    # With normalized schema, all complexes should exist in residential_complexes
                    # If not found, will use default values set above
                    print(f"DEBUG: ‚ö†Ô∏è Complex with ID {fav.complex_id} not found in residential_complexes")
                
                # ‚úÖ MIGRATED: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –¥–∞–Ω–Ω—ã—Ö –≤ normalized schema –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –ñ–ö (–≤—Å–µ–≥–¥–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è)
                if real_complex_name != '–ñ–ö –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è':
                    from sqlalchemy import text
                    excel_query = text("""
                        SELECT 
                            MIN(p.price) as min_price,
                            MAX(p.price) as max_price,
                            COUNT(p.id) as apartments_count,
                            COUNT(DISTINCT b.id) as buildings_count,
                            rc.end_build_year AS complex_building_end_build_year,
                            rc.end_build_quarter AS complex_building_end_build_quarter,
                            (SELECT p2.gallery_images FROM properties p2 
                             WHERE p2.complex_id = rc.id AND p2.gallery_images IS NOT NULL 
                             LIMIT 1) AS photos,
                            rc.address AS address_display_name,
                            dist.name AS address_locality_name,
                            d.name as developer_name
                        FROM residential_complexes rc
                        LEFT JOIN properties p ON p.complex_id = rc.id
                        LEFT JOIN buildings b ON b.complex_id = rc.id
                        LEFT JOIN developers d ON rc.developer_id = d.id
                        LEFT JOIN districts dist ON rc.district_id = dist.id
                        WHERE rc.name = :complex_name
                        GROUP BY rc.id, rc.end_build_year, rc.end_build_quarter, rc.address, dist.name, d.name
                        LIMIT 1
                    """)
                    
                    # Use exact match on complex name (no LIKE pattern needed)
                    print(f"DEBUG: Searching normalized schema for complex: {real_complex_name}")
                    result = db.session.execute(excel_query, {'complex_name': real_complex_name})
                    row = result.fetchone()
                    
                    print(f"DEBUG: Normalized schema query result - found: {row is not None}, has price: {row[0] if row else 'N/A'}")
                    if row:
                        print(f"DEBUG: Normalized data - address: {row[7]}, district: {row[8]}, developer: {row[9]}")
                    
                    if row and row[0]:  # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ
                        real_min_price = int(row[0]) if row[0] else 0
                        real_max_price = int(row[1]) if row[1] else 0
                        real_apartments_count = int(row[2]) if row[2] else 0
                        # Determine real buildings count
                        real_buildings_count = max(int(row[3]) if row[3] else 1, 1)
                        
                        # FINAL OVERRIDE: Check if the residential_complexes table has a buildings_count field to override
                        if complex_db:
                            if hasattr(complex_db, 'buildings_count') and complex_db.buildings_count:
                                real_buildings_count = complex_db.buildings_count
                            elif hasattr(complex_db, 'total_buildings') and complex_db.total_buildings:
                                real_buildings_count = complex_db.total_buildings
                            elif hasattr(complex_db, 'buildings') and complex_db.buildings:
                                b_count = len(complex_db.buildings)
                                if b_count > 0:
                                    real_buildings_count = b_count
                        
                        # –ü–∞—Ä—Å–∏–º —Ñ–æ—Ç–æ –∏–∑ JSON
                        if row[6]:
                            try:
                                import json
                                photos = json.loads(row[6]) if isinstance(row[6], str) else row[6]
                                if photos and isinstance(photos, list) and len(photos) > 0:
                                    # –ë–µ—Ä–µ–º —Ñ–æ—Ç–æ –ñ–ö, –ø—Ä–æ–ø—É—Å–∫–∞—è –∏–Ω—Ç–µ—Ä—å–µ—Ä—ã –∫–≤–∞—Ä—Ç–∏—Ä
                                    start_index = min(len(photos) // 4, 5) if len(photos) > 8 else 1
                                    real_image = photos[start_index] if len(photos) > start_index else photos[0]
                            except Exception as photo_error:
                                print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                        
                        # Fix price display and metadata
                        price_from_val = int(row[0]) if row[0] else 0
                        
                        complex_data = {
                            'id': row[4],
                            'name': row[5],
                            'price_from': price_from_val,
                            'min_price': price_from_val,
                            'real_price_from': price_from_val,
                            'apartments_count': real_apartments_count,
                            'buildings_count': real_buildings_count,
                            'photos': photos,
                            'address': row[7],
                            'district': row[8],
                            'developer': row[9]
                        }
                        
                        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∏ –¥–∞—Ç—É —Å–¥–∞—á–∏
                        if row[4] and row[5]:  # end_build_year –∏ end_build_quarter
                            build_year = int(row[4])
                            build_quarter = int(row[5])
                            quarter_names = {1: 'I', 2: 'II', 3: 'III', 4: 'IV'}
                            quarter = quarter_names.get(build_quarter, build_quarter)
                            real_delivery_date = f"{quarter} –∫–≤. {build_year} –≥."
                            
                            from datetime import datetime
                            current_year = datetime.now().year
                            real_status = '–°–¥–∞–Ω' if build_year <= current_year else '–°—Ç—Ä–æ–∏—Ç—Å—è'
                        elif row[4]:  # —Ç–æ–ª—å–∫–æ –≥–æ–¥
                            build_year = int(row[4])
                            real_delivery_date = f"{build_year} –≥."
                            from datetime import datetime
                            real_status = '–°–¥–∞–Ω' if build_year <= datetime.now().year else '–°—Ç—Ä–æ–∏—Ç—Å—è'
                                
            except Exception as e:
                print(f"Error loading complex data for {fav.complex_id}: {e}")
                pass
            
            # –ò—â–µ–º –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ñ–ö (ResidentialComplex)
            complex_data = complexes_data.get(str(fav.complex_id))
            
            # –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —Å–ø–æ—Å–æ–± —Å–æ–∑–¥–∞–Ω–∏—è slug —Å fallback
            try:
                url = f"/zk/{create_slug(real_complex_name)}" if real_complex_name and real_complex_name != '–ñ–ö –±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è' else '#'
            except:
                url = '#'
            
            # ‚úÖ –ü–æ–¥—Ç—è–≥–∏–≤–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫ –∏–∑ ResidentialComplex –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            cashback_rate = 5.0
            real_housing_class = '–ö–æ–º—Ñ–æ—Ä—Ç'
            if complex_data:
                real_cashback_rate = complex_data.cashback_rate if complex_data.cashback_rate else 5.0
                real_housing_class = complex_data.object_class_display_name if complex_data.object_class_display_name else '–ö–æ–º—Ñ–æ—Ä—Ç'
            
            # ‚úÖ –ò–°–ü–û–õ–¨–ó–£–ï–ú –¢–û–õ–¨–ö–û –†–ï–ê–õ–¨–ù–´–ï –î–ê–ù–ù–´–ï - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å—Ç–∞—Ä—ã–µ placeholder
            favorites_list.append({
                'id': str(fav.complex_id),
                'name': real_complex_name,
                'developer': real_developer_name,
                'address': real_address,
                'district': real_housing_class,  # ‚úÖ –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–ª–∞—Å—Å –∂–∏–ª—å—è –≤–º–µ—Å—Ç–æ —Ä–∞–π–æ–Ω–∞
                'housing_class': real_housing_class,  # ‚úÖ –ö–ª–∞—Å—Å –∂–∏–ª—å—è
                'min_price': real_min_price,
                'max_price': real_max_price,
                'apartments_count': real_apartments_count,
                'buildings_count': real_buildings_count,
                'image': real_image,
                'url': url,
                'status': real_status,
                'delivery_date': real_delivery_date,
                'notes': fav.notes or '',
                'recommended_for': fav.recommended_for or '',
                'created_at': fav.created_at.strftime('%d.%m.%Y –≤ %H:%M') if fav.created_at else '–ù–µ–¥–∞–≤–Ω–æ',
                'cashback_rate': real_cashback_rate  # ‚úÖ –†–µ–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
            })
        
        print(f"Found {len(favorites)} favorite complexes for manager {current_manager.id}")
        if favorites:
            print(f"First complex: {favorites_list[0]}")
        
        return jsonify({
            'success': True,
            'complexes': favorites_list,
            'favorite_complexes': favorites_list,  # –¥–æ–±–∞–≤–∏—Ç—å alias
            'favorites': favorites_list  # –¥–æ–±–∞–≤–∏—Ç—å alias
        })
    
    except Exception as e:
        print(f"Error loading favorite complexes: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

# User Management Routes
@app.route('/admin/users')
@admin_required
def admin_users():
    """User management page"""
    try:
        from models import Admin, User
        
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
        current_admin = current_user
        
        page = request.args.get('page', 1, type=int)
        search = request.args.get('search', '', type=str)
        status = request.args.get('status', '', type=str)
        
        query = User.query
        
        if search:
            query = query.filter(User.email.contains(search) | User.full_name.contains(search))
        
        if status == 'active':
            query = query.filter_by(is_active=True)
        elif status == 'inactive':
            query = query.filter_by(is_active=False)
        elif status == 'verified':
            query = query.filter_by(is_verified=True)
        elif status == 'unverified':
            query = query.filter_by(is_verified=False)
        
        users = query.order_by(User.created_at.desc()).paginate(
            page=page, per_page=20, error_out=False
        )
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–∞—Ç
        from datetime import datetime
        for user in users.items:
            if user.created_at is None:
                # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –±–µ–∑ –¥–∞—Ç—ã —Å–æ–∑–¥–∞–Ω–∏—è
                user.created_at = datetime.now()
        
        print(f"DEBUG: Loading admin_users page - Found {users.total} users")
        
        return render_template('admin/users.html', 
                             admin=current_admin, 
                             users=users,
                             search=search,
                             status=status)
                             
    except Exception as e:
        print(f"ERROR in admin_users: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))

@app.route('/admin/users/<int:user_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_user(user_id):
    """Edit user details"""
    from models import Admin, User, Manager
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    user = User.query.get_or_404(user_id)
    managers = Manager.query.filter_by(is_active=True).all()
    
    if request.method == 'POST':
        user.email = request.form.get('email')
        user.full_name = request.form.get('full_name')
        user.phone = request.form.get('phone')
        user.client_status = request.form.get('client_status')
        user.client_notes = request.form.get('client_notes')
        user.is_active = 'is_active' in request.form
        user.is_verified = 'is_verified' in request.form
        
        assigned_manager_id = request.form.get('assigned_manager_id')
        if assigned_manager_id and assigned_manager_id.isdigit():
            user.assigned_manager_id = int(assigned_manager_id)
        else:
            user.assigned_manager_id = None
        
        try:
            db.session.commit()
            flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', 'success')
            return redirect(url_for('admin_users'))
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', 'error')
    
    return render_template('admin/edit_user.html', 
                         admin=current_admin, 
                         user=user,
                         managers=managers)

@app.route('/admin/users/<int:user_id>/toggle-status', methods=['POST'])
@admin_required
def admin_toggle_user_status(user_id):
    """Toggle user active status (block/activate)"""
    from models import User, Admin
    
    user = User.query.get_or_404(user_id)
    current_admin = current_user
    
    try:
        # Toggle the status
        user.is_active = not user.is_active
        status_text = "–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω" if user.is_active else "–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω"
        
        db.session.commit()
        
        # Log the action
        print(f"ADMIN ACTION: {current_admin.full_name} (ID: {current_admin.id}) {'activated' if user.is_active else 'blocked'} user {user.full_name} (ID: {user.id}, Email: {user.email})")
        
        flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.full_name} —É—Å–ø–µ—à–Ω–æ {status_text}', 'success')
    except Exception as e:
        db.session.rollback()
        print(f"ERROR in admin_toggle_user_status: {str(e)}")
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}', 'error')
    
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/delete', methods=['POST'])
@admin_required
def admin_delete_user(user_id):
    """Delete user"""
    from models import User
    
    user = User.query.get_or_404(user_id)
    
    try:
        from sqlalchemy import text
        uid = user.id

        deal_ids_result = db.session.execute(
            text("SELECT id FROM deals WHERE client_id = :uid"), {'uid': uid}
        ).fetchall()
        deal_ids = [r[0] for r in deal_ids_result]

        if deal_ids:
            db.session.execute(text("DELETE FROM deal_history WHERE deal_id = ANY(:ids)"), {'ids': deal_ids})
            db.session.execute(text("DELETE FROM deal_comments WHERE deal_id = ANY(:ids)"), {'ids': deal_ids})
            db.session.execute(text("DELETE FROM deal_tasks WHERE deal_id = ANY(:ids)"), {'ids': deal_ids})
            db.session.execute(text("DELETE FROM balance_transactions WHERE deal_id = ANY(:ids)"), {'ids': deal_ids})
            db.session.execute(text("DELETE FROM deals WHERE id = ANY(:ids)"), {'ids': deal_ids})

        cleanup_tables = [
            ("user_notifications", "user_id"),
            ("balance_transactions", "user_id"),
            ("withdrawal_requests", "user_id"),
            ("cashback_records", "user_id"),
            ("cashback_applications", "user_id"),
            ("cashback_payouts", "user_id"),
            ("applications", "user_id"),
            ("favorites", "user_id"),
            ("favorite_properties", "user_id"),
            ("favorite_complexes", "user_id"),
            ("saved_searches", "user_id"),
            ("user_balances", "user_id"),
            ("documents", "user_id"),
            ("blog_comments", "user_id"),
            ("developer_appointments", "user_id"),
            ("client_property_recommendations", "client_id"),
            ("search_analytics", "user_id"),
        ]
        from sqlalchemy import inspect as sa_inspect
        existing_tables = sa_inspect(db.engine).get_table_names()
        for table_name, col_name in cleanup_tables:
            if table_name in existing_tables:
                try:
                    nested = db.session.begin_nested()
                    db.session.execute(text(f"DELETE FROM {table_name} WHERE {col_name} = :uid"), {'uid': uid})
                    nested.commit()
                except Exception:
                    nested.rollback()

        try:
            nested = db.session.begin_nested()
            db.session.execute(text("UPDATE collections SET assigned_to_user_id = NULL WHERE assigned_to_user_id = :uid"), {'uid': uid})
            nested.commit()
        except Exception:
            nested.rollback()

        db.session.delete(user)
        db.session.commit()
        flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω', 'success')
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting user {user_id}: {e}")
        import traceback
        traceback.print_exc()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}', 'error')
    
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/reset-password', methods=['POST'])
@admin_required
def admin_reset_user_password(user_id):
    """Admin reset user password - generates new password and sends via SMS"""
    from models import User
    from werkzeug.security import generate_password_hash
    import secrets
    import string
    
    user = User.query.get_or_404(user_id)
    
    try:
        # Generate new random password
        alphabet = string.ascii_letters + string.digits
        new_password = ''.join(secrets.choice(alphabet) for _ in range(8))
        
        # Update user password
        user.password_hash = generate_password_hash(new_password)
        db.session.commit()
        
        # Send SMS with new password if user has phone
        if user.phone:
            phone_clean = ''.join(filter(str.isdigit, user.phone))
            if phone_clean.startswith('8'):
                phone_clean = '7' + phone_clean[1:]
            elif not phone_clean.startswith('7'):
                phone_clean = '7' + phone_clean
            
            sms_message = f"InBack: –í–∞—à –Ω–æ–≤—ã–π –ø–∞—Ä–æ–ª—å: {new_password}"
            
            try:
                from sms_service import RedSMSService; sms_service = RedSMSService()
                sms_result = sms_service.send_sms(phone_clean, sms_message)
                if sms_result.get('success'):
                    flash(f'–ù–æ–≤—ã–π –ø–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω {user.phone}', 'success')
                else:
                    error_msg = sms_result.get('message', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞')
                    flash(f'–ü–∞—Ä–æ–ª—å –∏–∑–º–µ–Ω—ë–Ω, –Ω–æ SMS –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å ({error_msg}). –ù–æ–≤—ã–π –ø–∞—Ä–æ–ª—å: {new_password}', 'warning')
            except Exception as e:
                print(f"Error sending SMS: {e}")
                flash(f'–ü–∞—Ä–æ–ª—å –∏–∑–º–µ–Ω—ë–Ω, –Ω–æ SMS –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å. –ù–æ–≤—ã–π –ø–∞—Ä–æ–ª—å: {new_password}', 'warning')
        else:
            flash(f'–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ—Ç —Ç–µ–ª–µ—Ñ–æ–Ω–∞. –ù–æ–≤—ã–π –ø–∞—Ä–æ–ª—å: {new_password}', 'warning')
            
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±—Ä–æ—Å–µ –ø–∞—Ä–æ–ª—è: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/toggle-role', methods=['POST'])
@admin_required 
def admin_toggle_user_role(user_id):
    """Admin change user role"""
    from models import User
    
    user = User.query.get_or_404(user_id)
    new_role = request.form.get('role')
    
    # Validate role
    valid_roles = ['buyer', 'manager', 'admin', None]
    if new_role == '':
        new_role = None
    
    if new_role not in valid_roles:
        flash('–ù–µ–≤–µ—Ä–Ω–∞—è —Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        old_role = user.role or '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∞'
        user.role = new_role
        db.session.commit()
        
        new_role_display = new_role or '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∞'
        flash(f'–†–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.email} –∏–∑–º–µ–Ω–µ–Ω–∞ —Å "{old_role}" –Ω–∞ "{new_role_display}"', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–æ–ª–∏: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/bulk-role', methods=['POST'])
@admin_required
def admin_bulk_assign_role():
    """Bulk assign role to users"""
    from models import User
    
    user_ids = request.form.getlist('user_ids')
    new_role = request.form.get('role')
    
    if new_role == '':
        new_role = None
    
    valid_roles = ['buyer', 'manager', 'admin', None]
    if new_role not in valid_roles:
        flash('–ù–µ–≤–µ—Ä–Ω–∞—è —Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', 'error')
        return redirect(url_for('admin_users'))
    
    if not user_ids:
        flash('–ù–µ –≤—ã–±—Ä–∞–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        users = User.query.filter(User.id.in_(user_ids)).all()
        role_display = new_role or '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∞'
        updated_count = 0
        
        for user in users:
            user.role = new_role
            updated_count += 1
        
        db.session.commit()
        flash(f'–†–æ–ª—å "{role_display}" –Ω–∞–∑–Ω–∞—á–µ–Ω–∞ –¥–ª—è {updated_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –º–∞—Å—Å–æ–≤–æ–º –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–∏ —Ä–æ–ª–∏: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/bulk-status', methods=['POST'])
@admin_required
def admin_bulk_toggle_status():
    """Bulk toggle user status"""
    from models import User
    
    user_ids = request.form.getlist('user_ids')
    
    if not user_ids:
        flash('–ù–µ –≤—ã–±—Ä–∞–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        users = User.query.filter(User.id.in_(user_ids)).all()
        activated_count = 0
        deactivated_count = 0
        
        for user in users:
            if user.is_active:
                user.is_active = False
                deactivated_count += 1
            else:
                user.is_active = True
                activated_count += 1
        
        db.session.commit()
        
        if activated_count > 0 and deactivated_count > 0:
            flash(f'–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ: {activated_count}, –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ: {deactivated_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π', 'success')
        elif activated_count > 0:
            flash(f'–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ {activated_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π', 'success')
        else:
            flash(f'–î–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ {deactivated_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –º–∞—Å—Å–æ–≤–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/bulk-delete', methods=['POST'])
@admin_required
def admin_bulk_delete_users():
    """Bulk delete users"""
    from models import User
    
    user_ids = request.form.getlist('user_ids')
    
    if not user_ids:
        flash('–ù–µ –≤—ã–±—Ä–∞–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        from sqlalchemy import text
        from sqlalchemy import inspect as sa_inspect

        users = User.query.filter(User.id.in_(user_ids)).all()
        deleted_count = len(users)
        uid_list = [u.id for u in users]

        deal_ids_result = db.session.execute(
            text("SELECT id FROM deals WHERE client_id = ANY(:uids)"), {'uids': uid_list}
        ).fetchall()
        deal_ids = [r[0] for r in deal_ids_result]
        if deal_ids:
            db.session.execute(text("DELETE FROM deal_history WHERE deal_id = ANY(:ids)"), {'ids': deal_ids})
            db.session.execute(text("DELETE FROM deal_comments WHERE deal_id = ANY(:ids)"), {'ids': deal_ids})
            db.session.execute(text("DELETE FROM deal_tasks WHERE deal_id = ANY(:ids)"), {'ids': deal_ids})
            db.session.execute(text("DELETE FROM balance_transactions WHERE deal_id = ANY(:ids)"), {'ids': deal_ids})
            db.session.execute(text("DELETE FROM deals WHERE id = ANY(:ids)"), {'ids': deal_ids})

        cleanup_tables = [
            ("user_notifications", "user_id"),
            ("balance_transactions", "user_id"),
            ("withdrawal_requests", "user_id"),
            ("cashback_records", "user_id"),
            ("cashback_applications", "user_id"),
            ("cashback_payouts", "user_id"),
            ("applications", "user_id"),
            ("favorites", "user_id"),
            ("favorite_properties", "user_id"),
            ("favorite_complexes", "user_id"),
            ("saved_searches", "user_id"),
            ("user_balances", "user_id"),
            ("documents", "user_id"),
            ("blog_comments", "user_id"),
            ("developer_appointments", "user_id"),
            ("client_property_recommendations", "client_id"),
            ("search_analytics", "user_id"),
        ]
        existing_tables = sa_inspect(db.engine).get_table_names()
        for table_name, col_name in cleanup_tables:
            if table_name in existing_tables:
                try:
                    nested = db.session.begin_nested()
                    db.session.execute(text(f"DELETE FROM {table_name} WHERE {col_name} = ANY(:uids)"), {'uids': uid_list})
                    nested.commit()
                except Exception:
                    nested.rollback()

        try:
            nested = db.session.begin_nested()
            db.session.execute(text("UPDATE collections SET assigned_to_user_id = NULL WHERE assigned_to_user_id = ANY(:uids)"), {'uids': uid_list})
            nested.commit()
        except Exception:
            nested.rollback()

        for user in users:
            db.session.delete(user)
        
        db.session.commit()
        flash(f'–£–¥–∞–ª–µ–Ω–æ {deleted_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –º–∞—Å—Å–æ–≤–æ–º —É–¥–∞–ª–µ–Ω–∏–∏: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/create', methods=['GET', 'POST'])
@csrf.exempt
@admin_required
def admin_create_user():
    """Create new user by admin"""
    from models import Admin, User, Manager
    import re
    import secrets
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    managers = Manager.query.filter_by(is_active=True).all()
    
    if request.method == 'POST':
        # Validate required fields
        full_name = request.form.get('full_name', '').strip()
        email = request.form.get('email', '').strip().lower()
        phone = request.form.get('phone', '').strip()
        
        if not all([full_name, email, phone]):
                flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è', 'error')
                return render_template('admin/create_user.html', 
                                     admin=current_admin, 
                                     managers=managers)
        
        # Validate email format
        if not re.match(r'^[^\s@]+@[^\s@]+\.[^\s@]+$', email):
                flash('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç email', 'error')
                return render_template('admin/create_user.html', 
                                     admin=current_admin, 
                                     managers=managers)
        
        try:
            logger.info('üîç Executing user lookup query...')
            existing_user = User.query.filter(
                    (User.email == email) | (User.phone == phone)
            ).first()
            
            if existing_user:
                    flash('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email –∏–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç', 'error')
                    return render_template('admin/create_user.html', 
                                         admin=current_admin, 
                                         managers=managers)
            
            phone_clean = re.sub(r'[^\d]', '', phone)
            if len(phone_clean) == 11 and phone_clean.startswith('8'):
                    phone_clean = '7' + phone_clean[1:]
            elif len(phone_clean) == 10:
                    phone_clean = '7' + phone_clean
            
            if len(phone_clean) != 11 or not phone_clean.startswith('7'):
                    flash('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ç–µ–ª–µ—Ñ–æ–Ω–∞', 'error')
                    return render_template('admin/create_user.html', 
                                         admin=current_admin, 
                                         managers=managers)
            
            temp_password = secrets.token_urlsafe(12)
            
            user = User(
                    email=email,
                    full_name=full_name,
                    phone=phone_clean,
                    client_status=request.form.get('client_status', '–ù–æ–≤—ã–π'),
                    client_notes=request.form.get('client_notes', ''),
                    is_active='is_active' in request.form,
                    is_verified='is_verified' in request.form,
                    temp_password_hash=temp_password,
                    created_by_admin=True
            )
            
            assigned_manager_id = request.form.get('assigned_manager_id')
            if assigned_manager_id and assigned_manager_id.isdigit():
                    user.assigned_manager_id = int(assigned_manager_id)
            
            user.set_password(temp_password)
            user.must_change_password = True
            
            db.session.add(user)
            db.session.commit()
            
            try:
                from sms_service import RedSMSService; sms_service = RedSMSService()
                sms_message = f"InBack.ru - –í–∞—à –ø–∞—Ä–æ–ª—å –¥–ª—è –≤—Ö–æ–¥–∞: {temp_password}"
                sms_result = sms_service.send_sms(phone_clean, sms_message)
                if sms_result.get('success'):
                    flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {full_name} —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω! SMS —Å –ø–∞—Ä–æ–ª–µ–º –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ {phone_clean}', 'success')
                else:
                    flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {full_name} —Å–æ–∑–¥–∞–Ω, –Ω–æ SMS –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ. –í—Ä–µ–º–µ–Ω–Ω—ã–π –ø–∞—Ä–æ–ª—å: {temp_password}', 'warning')
            except Exception as sms_error:
                print(f"SMS send error: {sms_error}")
                flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {full_name} —Å–æ–∑–¥–∞–Ω. –í—Ä–µ–º–µ–Ω–Ω—ã–π –ø–∞—Ä–æ–ª—å: {temp_password}', 'warning')
            
            return redirect(url_for('admin_users'))
            
        except Exception as e:
            db.session.rollback()
            print(f"Error creating user: {str(e)}")
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}', 'error')
            return render_template('admin/create_user.html', 
                                     admin=current_admin, 
                                     managers=managers)
    
    return render_template('admin/create_user.html', 
                         admin=current_admin, 
                         managers=managers)

@app.route('/admin/users/<int:user_id>/verify', methods=['POST'])
@admin_required
def admin_verify_user(user_id):
    """Verify user account manually"""
    from models import User, Admin
    
    try:
        user = User.query.get_or_404(user_id)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω
        if user.is_verified:
            flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.full_name} —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω', 'info')
            return redirect(url_for('admin_users'))
        
        # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user.is_verified = True
        
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –∞–¥–º–∏–Ω–∞
        current_admin = current_user
        admin_name = current_admin.full_name if current_admin else '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–¥–º–∏–Ω'
        
        print(f"ADMIN ACTION: {admin_name} (ID: {current_admin.id}) verified user {user.full_name} (ID: {user.id}, Email: {user.email})")
        
        db.session.commit()
        flash(f'–ê–∫–∫–∞—É–Ω—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.full_name} —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω', 'success')
        
        # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ AJAX –∑–∞–ø—Ä–æ—Å–æ–≤
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': True,
                'message': f'–ê–∫–∫–∞—É–Ω—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.full_name} –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω',
                'user_id': user.id,
                'verified': True
            })
            
    except Exception as e:
        db.session.rollback()
        error_message = f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}'
        print(f"Error verifying user {user_id}: {str(e)}")
        flash(error_message, 'error')
        
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': False,
                'error': error_message
            }), 500
    
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/unverify', methods=['POST'])
@admin_required 
def admin_unverify_user(user_id):
    """Unverify user account manually"""
    from models import User, Admin
    
    try:
        user = User.query.get_or_404(user_id)
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω
        if not user.is_verified:
            flash(f'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.full_name} —É–∂–µ –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω', 'info')
            return redirect(url_for('admin_users'))
        
        # –û—Ç–º–µ–Ω—è–µ–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
        user.is_verified = False
        
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
        # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è –∞–¥–º–∏–Ω–∞
        current_admin = current_user
        admin_name = current_admin.full_name if current_admin else '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–¥–º–∏–Ω'
        
        print(f"ADMIN ACTION: {admin_name} (ID: {current_admin.id}) unverified user {user.full_name} (ID: {user.id}, Email: {user.email})")
        
        db.session.commit()
        flash(f'–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.full_name} –æ—Ç–º–µ–Ω–µ–Ω–æ', 'warning')
        
        # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ AJAX –∑–∞–ø—Ä–æ—Å–æ–≤
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': True,
                'message': f'–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞ {user.full_name} –æ—Ç–º–µ–Ω–µ–Ω–æ',
                'user_id': user.id,
                'verified': False
            })
            
    except Exception as e:
        db.session.rollback()
        error_message = f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è: {str(e)}'
        print(f"Error unverifying user {user_id}: {str(e)}")
        flash(error_message, 'error')
        
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': False,
                'error': error_message
            }), 500
    
    return redirect(url_for('admin_users'))


# Property Management Routes
@app.route('/admin/property/<int:property_id>/mark-sold', methods=['POST'])
@admin_required
def admin_mark_property_sold(property_id):
    """
    Mark a property as sold and notify all users who have it in:
    - favorites
    - comparisons
    - presentations/collections
    """
    from models import Property
    from services.alert_service import AlertService
    
    try:
        property = Property.query.get_or_404(property_id)
        
        if not property.is_active:
            return jsonify({
                'success': False,
                'message': '–û–±—ä–µ–∫—Ç —É–∂–µ –ø–æ–º–µ—á–µ–Ω –∫–∞–∫ –ø—Ä–æ–¥–∞–Ω–Ω—ã–π'
            }), 400
        
        # Mark property as sold (inactive)
        property.is_active = False
        property.status = '–ü—Ä–æ–¥–∞–Ω'
        
        db.session.commit()
        
        # Send notifications to all affected users
        logger.info(f"Property {property_id} marked as sold, sending notifications...")
        notification_result = AlertService.notify_property_sold(property_id)
        
        flash(f'–û–±—ä–µ–∫—Ç "{property.title}" –ø–æ–º–µ—á–µ–Ω –∫–∞–∫ –ø—Ä–æ–¥–∞–Ω–Ω—ã–π. –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã.', 'success')
        
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç –ø–æ–º–µ—á–µ–Ω –∫–∞–∫ –ø—Ä–æ–¥–∞–Ω–Ω—ã–π, —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã',
            'property_id': property_id,
            'notifications_sent': notification_result
        })
        
    except Exception as e:
        db.session.rollback()
        error_message = f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–º–µ—Ç–∫–µ –æ–±—ä–µ–∫—Ç–∞ –∫–∞–∫ –ø—Ä–æ–¥–∞–Ω–Ω–æ–≥–æ: {str(e)}'
        logger.error(error_message)
        flash(error_message, 'error')
        
        return jsonify({
            'success': False,
            'error': error_message
        }), 500

# Manager Management Routes
@app.route('/admin/managers')
@admin_required
def admin_managers():
    """Manager management page"""
    from models import Admin, Manager
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    page = request.args.get('page', 1, type=int)
    search = request.args.get('search', '', type=str)
    status = request.args.get('status', '', type=str)
    
    query = Manager.query
    
    if search:
        query = query.filter(Manager.email.contains(search) | Manager.first_name.contains(search) | Manager.last_name.contains(search))
    
    if status == 'active':
        query = query.filter_by(is_active=True)
    elif status == 'inactive':
        query = query.filter_by(is_active=False)
    
    managers = query.order_by(Manager.created_at.desc()).paginate(
        page=page, per_page=20, error_out=False
    )
    
    all_managers = Manager.query.filter_by(is_active=True).order_by(Manager.first_name).all()
    
    return render_template('admin/managers.html', 
                         admin=current_admin, 
                         managers=managers,
                         all_managers=all_managers,
                         search=search,
                         status=status)

@app.route('/admin/api/manager/<int:manager_id>/deal-count')
@admin_required
def admin_api_manager_deal_count(manager_id):
    from models import Deal
    count = Deal.query.filter_by(manager_id=manager_id).count()
    return jsonify({'deal_count': count})

@app.route('/admin/managers/<int:manager_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_manager(manager_id):
    """Edit manager details"""
    from models import Admin, Manager
    
    try:
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
        current_admin = current_user
        manager = Manager.query.get(manager_id)
        
        if not manager:
            flash(f'–ú–µ–Ω–µ–¥–∂–µ—Ä —Å ID {manager_id} –Ω–µ –Ω–∞–π–¥–µ–Ω', 'error')
            return redirect(url_for('admin_managers'))
            
        print(f"DEBUG: Found manager {manager_id}: {manager.email}")
    except Exception as e:
        print(f"ERROR in admin_edit_manager: {e}")
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–µ–Ω–µ–¥–∂–µ—Ä–∞', 'error')
        return redirect(url_for('admin_managers'))
    
    if request.method == 'POST':
        manager.email = request.form.get('email')
        manager.first_name = request.form.get('first_name')
        manager.last_name = request.form.get('last_name')
        manager.phone = request.form.get('phone')
        manager.position = request.form.get('position')
        manager.is_active = 'is_active' in request.form
        
        new_password = request.form.get('new_password')
        if new_password:
            manager.set_password(new_password)
        
        try:
            db.session.commit()
            flash('–ú–µ–Ω–µ–¥–∂–µ—Ä —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', 'success')
            return redirect(url_for('admin_managers'))
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞', 'error')
    
    from datetime import datetime
    
    return render_template('admin/edit_manager.html', 
                         admin=current_admin, 
                         manager=manager,
                         current_date=datetime.utcnow())



# Blog Management Routes
@app.route('/admin/blog')
@admin_required
def admin_blog():
    """Blog management page"""
    from models import Admin, BlogPost
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    page = request.args.get('page', 1, type=int)
    search = request.args.get('search', '', type=str)
    status = request.args.get('status', '', type=str)
    category_id = request.args.get('category_id', '', type=str)
    
    query = BlogPost.query
    
    if search:
        query = query.filter(BlogPost.title.contains(search) | BlogPost.content.contains(search))
    
    if status:
        query = query.filter_by(status=status)
    
    if category_id:
        query = query.filter_by(category_id=int(category_id))
    
    posts = query.order_by(BlogPost.created_at.desc()).paginate(
        page=page, per_page=10, error_out=False
    )
    
    # Get categories for filter from Category table
    from models import Category
    categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
    
    return render_template('admin/blog.html', 
                         admin=current_admin, 
                         posts=posts,
                         search=search,
                         status=status,
                         category_id=category_id,
                         categories=categories)

@app.route('/admin/blog/create', methods=['GET', 'POST'])
@admin_required
# @csrf.exempt  # CSRF disabled  # –í—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º CSRF –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
def admin_create_post():
    """Create new blog post with full TinyMCE integration"""
    from models import Admin, BlogPost, Category
    from datetime import datetime
    import re
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    if request.method == 'GET':
        # Load categories for the form
        categories = Category.query.order_by(Category.name).all()
        return render_template('admin/create_article.html', admin=current_admin, categories=categories)
    
    if request.method == 'POST':
        try:
            title = request.form.get('title')
            content = request.form.get('content')
            excerpt = request.form.get('excerpt')
            category_id = request.form.get('category_id')
            
            # Handle featured image upload
            featured_image_url = request.form.get('featured_image', '')
            uploaded_file = request.files.get('featured_image_file')
            
            if uploaded_file and uploaded_file.filename:
                # Secure filename and save
                from werkzeug.utils import secure_filename
                import os
                filename = secure_filename(uploaded_file.filename)
                
                # Create upload directory if it doesn't exist
                upload_dir = 'static/uploads/blog'
                os.makedirs(upload_dir, exist_ok=True)
                
                # Save file with unique name
                import uuid
                unique_filename = f"{uuid.uuid4()}_{filename}"
                file_path = os.path.join(upload_dir, unique_filename)
                uploaded_file.save(file_path)
                
                # Set the URL for the database
                featured_image_url = f"/{file_path}"
            
            if not title or not content or not category_id:
                flash('–ó–∞–≥–æ–ª–æ–≤–æ–∫, —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã', 'error')
                categories = Category.query.order_by(Category.name).all()
                return render_template('admin/create_article.html', admin=current_admin, categories=categories)
            
            # Get category name from category_id
            category = Category.query.get(int(category_id))
            if not category:
                flash('–í—ã–±—Ä–∞–Ω–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
                categories = Category.query.order_by(Category.name).all()
                return render_template('admin/create_article.html', admin=current_admin, categories=categories)
            
            # Generate slug from title
            slug = request.form.get('slug', '')
            if not slug:
                # Auto-generate slug from title
                def transliterate(text):
                    rus_to_eng = {
                        '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo', '–∂': 'zh', '–∑': 'z',
                        '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm', '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r',
                        '—Å': 's', '—Ç': 't', '—É': 'u', '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
                        '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
                    }
                    return ''.join(rus_to_eng.get(char.lower(), char) for char in text)
                
                slug = transliterate(title.lower())
                slug = re.sub(r'[^\w\s-]', '', slug)
                slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure unique slug
            original_slug = slug
            counter = 1
            while BlogPost.query.filter_by(slug=slug).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            post = BlogPost(
                title=title,
                slug=slug,
                content=content,
                excerpt=excerpt,
                meta_title=request.form.get('meta_title'),
                meta_description=request.form.get('meta_description'),
                meta_keywords=request.form.get('meta_keywords'),
                category_id=category.id,  # Store category ID for proper relation
                category=category.name,  # Store category name for compatibility
                tags=request.form.get('tags'),
                featured_image=featured_image_url,
                status=request.form.get('status', 'draft'),
                author_id=current_admin.id,
                created_at=datetime.utcnow()
            )
            
            if post.status == 'published':
                post.published_at = datetime.utcnow()
            
            db.session.add(post)
            db.session.commit()
            
            # Update category article count
            if post.status == 'published':
                category.articles_count = BlogPost.query.filter_by(category=category.name, status='published').count()
                db.session.commit()
            
            flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
            return redirect(url_for('admin_blog'))
            
        except Exception as e:
            db.session.rollback()
            print(f'ERROR creating blog post: {str(e)}')
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
            categories = Category.query.order_by(Category.name).all()
            return render_template('admin/create_article.html', admin=current_admin, categories=categories)


@app.route('/admin/blog/<int:post_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_post(post_id):
    """Edit blog post"""
    from models import Admin, BlogPost, Category
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    try:
        post = BlogPost.query.get_or_404(post_id)
    except Exception as e:
        flash(f'–°—Ç–∞—Ç—å—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: {str(e)}', 'error')
        return redirect(url_for('admin_blog'))
    
    if request.method == 'POST':
        post.title = request.form.get('title')
        post.content = request.form.get('content')
        post.excerpt = request.form.get('excerpt')
        post.meta_title = request.form.get('meta_title')
        post.meta_description = request.form.get('meta_description')
        post.meta_keywords = request.form.get('meta_keywords')
        post.category = request.form.get('category')
        post.tags = request.form.get('tags')
        post.featured_image = request.form.get('featured_image')
        
        old_status = post.status
        post.status = request.form.get('status', 'draft')
        
        # Handle publishing
        if post.status == 'published' and old_status != 'published':
            post.published_at = datetime.utcnow()
        elif post.status != 'published':
            post.published_at = None
        
        try:
            db.session.commit()
            flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞', 'success')
            return redirect(url_for('admin_blog'))
        except Exception as e:
            db.session.rollback()
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
    
    # Get categories for dropdown
    try:
        categories = Category.query.order_by(Category.name).all()
    except Exception as e:
        print(f'Error loading categories: {e}')
        categories = []
    
    return render_template('admin/blog_post_create.html', 
                         admin=current_admin, 
                         post=post, 
                         categories=categories)

@app.route('/admin/blog/<int:post_id>/delete', methods=['POST'])
@admin_required
def admin_delete_post(post_id):
    """Delete blog post"""
    from models import BlogPost
    
    post = BlogPost.query.get_or_404(post_id)
    
    try:
        db.session.delete(post)
        db.session.commit()
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—å–∏', 'error')
    
    return redirect(url_for('admin_blog'))

# Analytics Routes
@app.route('/admin/analytics/cashback')
@admin_required
def admin_cashback_analytics():
    """Cashback analytics page"""
    from models import Admin, CashbackApplication
    from sqlalchemy import func
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    # Monthly cashback stats
    monthly_stats = db.session.query(
        func.date_trunc('month', CashbackApplication.created_at).label('month'),
        func.count(CashbackApplication.id).label('count'),
        func.sum(CashbackApplication.cashback_amount).label('total_amount')
    ).group_by(func.date_trunc('month', CashbackApplication.created_at)).order_by('month').all()
    
    # Status breakdown
    status_stats = db.session.query(
        CashbackApplication.status,
        func.count(CashbackApplication.id).label('count'),
        func.sum(CashbackApplication.cashback_amount).label('total_amount')
    ).group_by(CashbackApplication.status).all()
    
    # Recent large cashbacks
    large_cashbacks = CashbackApplication.query.filter(
        CashbackApplication.cashback_amount >= 100000
    ).order_by(CashbackApplication.created_at.desc()).limit(10).all()
    
    return render_template('admin/cashback_analytics.html',
                         admin=current_admin,
                         monthly_stats=monthly_stats,
                         status_stats=status_stats,
                         large_cashbacks=large_cashbacks)

# Admin Blog Management Routes

@app.route('/admin/blog/<int:article_id>/edit', methods=['GET', 'POST'])
@admin_required  
def admin_edit_article(article_id):
    """Edit blog article"""
    from models import Admin, BlogPost
    import re
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    article = BlogPost.query.get_or_404(article_id)
    
    if request.method == 'POST':
        article.title = request.form.get('title')
        article.slug = request.form.get('slug')
        article.content = request.form.get('content')
        article.excerpt = request.form.get('excerpt')
        article.category = request.form.get('category')
        article.tags = request.form.get('tags')
        article.featured_image = request.form.get('featured_image')
        article.meta_title = request.form.get('meta_title')
        article.meta_description = request.form.get('meta_description')
        article.meta_keywords = request.form.get('meta_keywords')
        action = request.form.get('action', 'save')
        
        # Auto-generate slug if empty
        if not article.slug:
            slug = re.sub(r'[^\w\s-]', '', article.title.lower())
            slug = re.sub(r'[\s_-]+', '-', slug)
            article.slug = slug.strip('-')
        
        # Set status based on action
        if action == 'publish':
            article.status = 'published'
            if not article.published_at:
                article.published_at = datetime.now()
        else:
            article.status = request.form.get('status', 'draft')
        
        # Handle scheduled posts
        if article.status == 'scheduled':
            scheduled_str = request.form.get('scheduled_for')
            if scheduled_str:
                try:
                    article.scheduled_for = datetime.fromisoformat(scheduled_str)
                except:
                    pass
        else:
            article.scheduled_for = None
            
        article.updated_at = datetime.now()
        
        try:
            db.session.commit()
            flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞', 'success')
            return redirect(url_for('admin_blog'))
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—å–∏', 'error')
    
    return render_template('admin/create_article.html', admin=current_admin, article=article)

@app.route('/admin/blog/<int:article_id>/delete', methods=['POST'])
@admin_required
def admin_delete_article(article_id):
    """Delete blog article"""
    from models import BlogPost
    
    article = BlogPost.query.get_or_404(article_id)
    
    try:
        db.session.delete(article)
        db.session.commit()
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—å–∏', 'error')
    
    return redirect(url_for('admin_blog'))

@app.route('/admin/blog/<int:article_id>/publish', methods=['POST'])
@admin_required
def admin_publish_article(article_id):
    """Publish blog article"""
    from models import BlogPost
    
    article = BlogPost.query.get_or_404(article_id)
    article.status = 'published'
    article.published_at = datetime.now()
    article.updated_at = datetime.now()
    
    try:
        db.session.commit()
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–∞', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ —Å—Ç–∞—Ç—å–∏', 'error')
    
    return redirect(url_for('admin_blog'))


# ==========================================
# ADMIN OFFERS MANAGEMENT ROUTES
# ==========================================

@app.route('/admin/complexes-offers')
@csrf.exempt
@admin_required
def admin_complexes_offers():
    """List all residential complexes for managing their offers"""
    from models import ResidentialComplex, Developer, Offer
    
    # Get search parameter
    search = request.args.get('search', '').strip()
    page = request.args.get('page', 1, type=int)
    per_page = 50
    
    # Build query with developer info
    query = ResidentialComplex.query.join(Developer, isouter=True)
    
    # Apply search filter if provided
    if search:
        query = query.filter(ResidentialComplex.name.ilike(f'%{search}%'))
    
    # Order by name
    query = query.order_by(ResidentialComplex.name)
    
    # Paginate results
    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    complexes = pagination.items
    
    # Count active offers for each complex
    for complex in complexes:
        complex.offers_count = Offer.query.filter_by(
            residential_complex_id=complex.id, 
            is_active=True
        ).count()
    
    return render_template('admin/complexes_offers_list.html',
                         admin=current_user,
                         complexes=complexes,
                         pagination=pagination,
                         search=search)

@app.route('/admin/complex/<int:complex_id>/offers')
@csrf.exempt
@admin_required
def admin_complex_offers(complex_id):
    """List all offers for a residential complex"""
    from models import ResidentialComplex, Offer
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    offers = Offer.query.filter_by(residential_complex_id=complex_id).order_by(Offer.sort_order, Offer.created_at.desc()).all()
    
    return render_template('admin/complex_offers.html',
                         admin=current_user,
                         complex=complex,
                         offers=offers)

@app.route('/admin/complex/<int:complex_id>/offer/new')
@csrf.exempt
@admin_required
def admin_new_offer(complex_id):
    """Form to create new offer"""
    from models import ResidentialComplex
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    
    return render_template('admin/complex_offers.html',
                         admin=current_user,
                         complex=complex,
                         offers=[],
                         show_form=True,
                         edit_offer=None)

@app.route('/admin/complex/<int:complex_id>/offer/create', methods=['POST'])
@admin_required
def admin_create_offer(complex_id):
    """Create new offer with image upload"""
    from models import ResidentialComplex, Offer
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    
    try:
        # Get form data
        title = request.form.get('title', '').strip()
        description = request.form.get('description', '').strip()
        is_active = request.form.get('is_active') == 'on'
        sort_order = int(request.form.get('sort_order', 0))
        
        # Validate title
        if not title:
            flash('–ù–∞–∑–≤–∞–Ω–∏–µ –∞–∫—Ü–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ', 'error')
            return redirect(url_for('admin_complex_offers', complex_id=complex_id))
        
        # Handle image upload
        image_file = request.files.get('image')
        if not image_file or image_file.filename == '':
            flash('–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –Ω–æ–≤–æ–π –∞–∫—Ü–∏–∏', 'error')
            return redirect(url_for('admin_complex_offers', complex_id=complex_id))
        
        # Validate file type
        allowed_extensions = {'.jpg', '.jpeg', '.png', '.webp'}
        filename = secure_filename(image_file.filename)
        file_ext = os.path.splitext(filename)[1].lower()
        
        if file_ext not in allowed_extensions:
            flash('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ JPG, PNG –∏–ª–∏ WEBP', 'error')
            return redirect(url_for('admin_complex_offers', complex_id=complex_id))
        
        # Generate unique filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_filename = f"{timestamp}_{filename}"
        
        # Save file
        upload_folder = 'static/uploads/offers'
        os.makedirs(upload_folder, exist_ok=True)
        file_path = os.path.join(upload_folder, unique_filename)
        image_file.save(file_path)
        
        # Store relative path in database
        image_url = f'/static/uploads/offers/{unique_filename}'
        
        # Create offer
        offer = Offer(
            residential_complex_id=complex_id,
            title=title,
            description=description,
            image_url=image_url,
            is_active=is_active,
            sort_order=sort_order
        )
        
        db.session.add(offer)
        db.session.commit()
        
        flash('–ê–∫—Ü–∏—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∞–∫—Ü–∏–∏: {str(e)}', 'error')
    
    return redirect(url_for('admin_complex_offers', complex_id=complex_id))

@app.route('/api/admin/complex/<int:complex_id>/offer/add', methods=['POST'])
@admin_required
def api_admin_add_offer(complex_id):
    """
    API endpoint for adding offers from residential complex detail page.
    
    Accepts:
        - title (required): Offer title
        - description (optional): Offer description
        - sort_order (optional): Sort order (default 0)
        - image (required): Image file (max 5MB, jpg/jpeg/png/webp)
    
    Returns:
        JSON: {"success": True/False, "message"/"error": str}
    """
    from models import ResidentialComplex, Offer
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    try:
        # Check if complex exists
        complex = ResidentialComplex.query.get(complex_id)
        if not complex:
            return jsonify({'success': False, 'error': '–ñ–∏–ª–æ–π –∫–æ–º–ø–ª–µ–∫—Å –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Get form data
        title = request.form.get('title', '').strip()
        description = request.form.get('description', '').strip()
        sort_order = request.form.get('sort_order', '0')
        
        # Validate title (required)
        if not title:
            return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –∞–∫—Ü–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        
        # Validate and parse sort_order
        try:
            sort_order = int(sort_order)
        except (ValueError, TypeError):
            sort_order = 0
        
        # Validate image file (required)
        image_file = request.files.get('image')
        if not image_file or image_file.filename == '':
            return jsonify({'success': False, 'error': '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        
        # Validate file size (max 5MB)
        image_file.seek(0, os.SEEK_END)
        file_size = image_file.tell()
        image_file.seek(0)
        
        max_size = 5 * 1024 * 1024  # 5MB in bytes
        if file_size > max_size:
            return jsonify({'success': False, 'error': '–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç 5 –ú–ë'}), 400
        
        # Validate file type
        allowed_extensions = {'.jpg', '.jpeg', '.png', '.webp'}
        filename = secure_filename(image_file.filename)
        file_ext = os.path.splitext(filename)[1].lower()
        
        if file_ext not in allowed_extensions:
            return jsonify({'success': False, 'error': '–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ JPG, JPEG, PNG –∏–ª–∏ WEBP'}), 400
        
        # Generate unique filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_filename = f"{timestamp}_{filename}"
        
        # Save file to static/uploads/offers/
        upload_folder = 'static/uploads/offers'
        os.makedirs(upload_folder, exist_ok=True)
        file_path = os.path.join(upload_folder, unique_filename)
        image_file.save(file_path)
        
        # Store relative path in database (with leading slash)
        image_url = f'/static/uploads/offers/{unique_filename}'
        
        # Create offer record
        offer = Offer(
            residential_complex_id=complex_id,
            title=title,
            description=description if description else None,
            image_url=image_url,
            is_active=True,  # Set active by default
            sort_order=sort_order
        )
        
        db.session.add(offer)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ê–∫—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∞',
            'offer': {
                'id': offer.id,
                'title': offer.title,
                'description': offer.description,
                'image_url': offer.image_url,
                'is_active': offer.is_active,
                'sort_order': offer.sort_order
            }
        }), 201
        
    except Exception as e:
        db.session.rollback()
        # Log the error for debugging
        print(f"Error creating offer: {str(e)}")
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∞–∫—Ü–∏–∏: {str(e)}'}), 500

@app.route('/api/admin/complex/<int:complex_id>/material/add', methods=['POST'])
@admin_required
def api_admin_add_material(complex_id):
    """API endpoint for adding marketing materials from residential complex detail page."""
    from models import ResidentialComplex, MarketingMaterial
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    try:
        # 1. Check if complex exists
        complex = ResidentialComplex.query.get(complex_id)
        if not complex:
            return jsonify({'success': False, 'error': '–ñ–∏–ª–æ–π –∫–æ–º–ø–ª–µ–∫—Å –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # 2. Get and validate form data
        title = request.form.get('title', '').strip()
        description = request.form.get('description', '').strip()
        material_type = request.form.get('material_type', '').strip()
        sort_order = request.form.get('sort_order', '0')
        
        # Validate title (required)
        if not title:
            return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        
        # 3. Validate material_type
        allowed_material_types = ["–ë—É–∫–ª–µ—Ç", "–§–æ—Ç–æ", "–†–µ–Ω–¥–µ—Ä", "–î—Ä—É–≥–æ–µ"]
        if not material_type or material_type not in allowed_material_types:
            return jsonify({'success': False, 'error': f'–¢–∏–ø –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑: {", ".join(allowed_material_types)}'}), 400
        
        # Validate and parse sort_order
        try:
            sort_order = int(sort_order)
        except (ValueError, TypeError):
            sort_order = 0
        
        # 4. Get and validate file (required)
        file = request.files.get('file')
        if not file or file.filename == '':
            return jsonify({'success': False, 'error': '–§–∞–π–ª –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'}), 400
        
        # 6. Validate file extension
        allowed_extensions = {'.pdf', '.jpg', '.jpeg', '.png', '.webp'}
        filename = secure_filename(file.filename)
        file_ext = os.path.splitext(filename)[1].lower()
        
        if file_ext not in allowed_extensions:
            return jsonify({'success': False, 'error': '–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ PDF, JPG, JPEG, PNG –∏–ª–∏ WEBP'}), 400
        
        # Auto-detect file_type from extension
        if file_ext == '.pdf':
            file_type = 'pdf'
            max_size = 10 * 1024 * 1024  # 10MB
        else:
            file_type = 'image'
            max_size = 5 * 1024 * 1024  # 5MB
        
        # 5. Check file size based on type
        file.seek(0, os.SEEK_END)
        file_size = file.tell()
        file.seek(0)
        
        if file_size > max_size:
            max_size_mb = max_size / (1024 * 1024)
            return jsonify({'success': False, 'error': f'–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç {max_size_mb:.0f} –ú–ë'}), 400
        
        # 7. Generate unique filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_filename = f"{timestamp}_{filename}"
        
        # 8. Save to static/uploads/marketing_materials/
        upload_folder = 'static/uploads/marketing_materials'
        os.makedirs(upload_folder, exist_ok=True)
        file_path = os.path.join(upload_folder, unique_filename)
        file.save(file_path)
        
        # Store relative path in database (with leading slash)
        file_url = f'/static/uploads/marketing_materials/{unique_filename}'
        
        # 9. Create MarketingMaterial record
        material = MarketingMaterial(
            residential_complex_id=complex_id,
            title=title,
            description=description if description else None,
            file_url=file_url,
            file_type=file_type,
            material_type=material_type,
            is_active=True,
            sort_order=sort_order
        )
        
        db.session.add(material)
        db.session.commit()
        
        # 10. Return JSON success response
        return jsonify({
            'success': True,
            'message': '–ú–∞—Ç–µ—Ä–∏–∞–ª —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω',
            'material': {
                'id': material.id,
                'title': material.title,
                'file_url': material.file_url,
                'file_type': material.file_type,
                'material_type': material.material_type
            }
        }), 201
        
    except Exception as e:
        db.session.rollback()
        # Log the error for debugging
        print(f"Error creating marketing material: {str(e)}")
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º–∞—Ç–µ—Ä–∏–∞–ª–∞: {str(e)}'}), 500



@app.route('/admin/offer/<int:offer_id>/edit')
@csrf.exempt
@admin_required
def admin_edit_offer(offer_id):
    """Form to edit offer"""
    from models import Offer
    
    offer = Offer.query.get_or_404(offer_id)
    complex_id = offer.residential_complex_id
    
    from models import ResidentialComplex
    complex = ResidentialComplex.query.get_or_404(complex_id)
    offers = Offer.query.filter_by(residential_complex_id=complex_id).order_by(Offer.sort_order, Offer.created_at.desc()).all()
    
    return render_template('admin/complex_offers.html',
                         admin=current_user,
                         complex=complex,
                         offers=offers,
                         show_form=True,
                         edit_offer=offer)

@app.route('/admin/offer/<int:offer_id>/update', methods=['POST'])
@admin_required
def admin_update_offer(offer_id):
    """Update offer"""
    from models import Offer
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    offer = Offer.query.get_or_404(offer_id)
    complex_id = offer.residential_complex_id
    
    try:
        # Update form data
        offer.title = request.form.get('title', '').strip()
        offer.description = request.form.get('description', '').strip()
        offer.is_active = request.form.get('is_active') == 'on'
        offer.sort_order = int(request.form.get('sort_order', 0))
        
        # Validate title
        if not offer.title:
            flash('–ù–∞–∑–≤–∞–Ω–∏–µ –∞–∫—Ü–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ', 'error')
            return redirect(url_for('admin_complex_offers', complex_id=complex_id))
        
        # Handle image upload (optional for update)
        image_file = request.files.get('image')
        if image_file and image_file.filename != '':
            # Validate file type
            allowed_extensions = {'.jpg', '.jpeg', '.png', '.webp'}
            filename = secure_filename(image_file.filename)
            file_ext = os.path.splitext(filename)[1].lower()
            
            if file_ext not in allowed_extensions:
                flash('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ JPG, PNG –∏–ª–∏ WEBP', 'error')
                return redirect(url_for('admin_complex_offers', complex_id=complex_id))
            
            # Delete old image if exists
            if offer.image_url:
                old_image_path = offer.image_url.lstrip('/')
                if os.path.exists(old_image_path):
                    try:
                        os.remove(old_image_path)
                    except:
                        pass
            
            # Generate unique filename with timestamp
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            unique_filename = f"{timestamp}_{filename}"
            
            # Save file
            upload_folder = 'static/uploads/offers'
            os.makedirs(upload_folder, exist_ok=True)
            file_path = os.path.join(upload_folder, unique_filename)
            image_file.save(file_path)
            
            # Update image URL
            offer.image_url = f'/static/uploads/offers/{unique_filename}'
        
        offer.updated_at = datetime.utcnow()
        db.session.commit()
        
        flash('–ê–∫—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∞–∫—Ü–∏–∏: {str(e)}', 'error')
    
    return redirect(url_for('admin_complex_offers', complex_id=complex_id))

@app.route('/admin/offer/<int:offer_id>/delete', methods=['POST'])
@admin_required
def admin_delete_offer(offer_id):
    """Delete offer"""
    from models import Offer
    import os
    
    offer = Offer.query.get_or_404(offer_id)
    complex_id = offer.residential_complex_id
    
    try:
        # Delete image file if exists
        if offer.image_url:
            image_path = offer.image_url.lstrip('/')
            if os.path.exists(image_path):
                try:
                    os.remove(image_path)
                except:
                    pass
        
        db.session.delete(offer)
        db.session.commit()
        
        flash('–ê–∫—Ü–∏—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∞–∫—Ü–∏–∏: {str(e)}', 'error')
    
    return redirect(url_for('admin_complex_offers', complex_id=complex_id))

# ==========================================
# Admin Marketing Materials Management Routes
# ==========================================

@app.route('/admin/complexes-materials')
@csrf.exempt
@admin_required
def admin_complexes_materials():
    """List all residential complexes for managing their marketing materials"""
    try:
        import logging
        from models import ResidentialComplex, Developer, MarketingMaterial
        from sqlalchemy import func
        from sqlalchemy.orm import joinedload
        
        logging.debug("Starting admin_complexes_materials")
        page = request.args.get('page', 1, type=int)
        per_page = 20
        
        logging.debug("Creating material_counts subquery")
        material_counts = db.session.query(
            MarketingMaterial.residential_complex_id,
            func.count(MarketingMaterial.id).label('materials_count')
        ).group_by(MarketingMaterial.residential_complex_id).subquery()
        
        logging.debug("Creating complexes_query")
        complexes_query = db.session.query(ResidentialComplex).options(
            joinedload(ResidentialComplex.developer)
        ).outerjoin(
            material_counts,
            ResidentialComplex.id == material_counts.c.residential_complex_id
        ).add_columns(
            func.coalesce(material_counts.c.materials_count, 0).label('materials_count')
        ).order_by(ResidentialComplex.name)
        
        logging.debug("Getting pagination")
        pagination = complexes_query.paginate(page=page, per_page=per_page, error_out=False)
        logging.debug(f"Pagination total: {pagination.total}, items: {len(pagination.items)}")
        
        complexes = []
        for i, row in enumerate(pagination.items):
            logging.debug(f"Processing row {i}: type={type(row)}, value={row}")
            complex_obj = row[0]
            materials_count = row[1]
            
            complexes.append({
                'id': complex_obj.id,
                'name': complex_obj.name,
                'address': complex_obj.address,
                'main_image': complex_obj.main_image,
                'developer': complex_obj.developer,
                'developer_name': complex_obj.developer.name if complex_obj.developer else '–ù–µ —É–∫–∞–∑–∞–Ω',
                'materials_count': materials_count
            })
        
        logging.debug(f"Rendering template with {len(complexes)} complexes")
        return render_template('admin/complexes_materials_list.html',
                             admin=current_user,
                             complexes=complexes,
                             pagination=pagination)
    except Exception as e:
        import traceback
        import logging
        logging.error(f"ERROR in admin_complexes_materials: {str(e)}")
        logging.error(traceback.format_exc())
        return render_template('500.html'), 500



@app.route('/admin/complex/<int:complex_id>/materials')
@csrf.exempt
@admin_required
def admin_complex_materials(complex_id):
    """Manage marketing materials for a specific residential complex"""
    from models import ResidentialComplex, MarketingMaterial
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    materials = MarketingMaterial.query.filter_by(
        residential_complex_id=complex_id
    ).order_by(MarketingMaterial.sort_order, MarketingMaterial.created_at.desc()).all()
    
    return render_template('admin/complex_materials.html',
                         admin=current_user,
                         complex=complex,
                         materials=materials)


@app.route('/admin/complex/<int:complex_id>/material/create', methods=['POST'])
@admin_required
def admin_create_material(complex_id):
    """Create new marketing material with file upload"""
    from models import ResidentialComplex, MarketingMaterial
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    
    try:
        # Get form data
        title = request.form.get('title', '').strip()
        description = request.form.get('description', '').strip()
        material_type = request.form.get('material_type', 'other').strip()
        is_active = request.form.get('is_active') == 'on'
        sort_order = int(request.form.get('sort_order', 0))
        
        # Validate title
        if not title:
            flash('–ù–∞–∑–≤–∞–Ω–∏–µ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Validate material type
        allowed_material_types = ['brochure', 'photo', 'render', 'other']
        if material_type not in allowed_material_types:
            flash('–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø –º–∞—Ç–µ—Ä–∏–∞–ª–∞', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Handle file upload
        file = request.files.get('file')
        if not file or file.filename == '':
            flash('–§–∞–π–ª –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω –¥–ª—è –Ω–æ–≤–æ–≥–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Validate file type and size
        filename = secure_filename(file.filename)
        file_ext = os.path.splitext(filename)[1].lower()
        
        # Determine file type and validate
        if file_ext == '.pdf':
            file_type = 'pdf'
            max_size = 10 * 1024 * 1024  # 10MB
        elif file_ext in ['.jpg', '.jpeg', '.png', '.webp']:
            file_type = 'image'
            max_size = 5 * 1024 * 1024  # 5MB
        else:
            flash('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ PDF, JPG, PNG –∏–ª–∏ WEBP', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Check file size
        file.seek(0, os.SEEK_END)
        file_size = file.tell()
        file.seek(0)
        
        if file_size > max_size:
            max_size_mb = max_size / (1024 * 1024)
            flash(f'–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–π ({max_size_mb}MB)', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Generate unique filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_filename = f"{timestamp}_{filename}"
        
        # Save file
        upload_folder = 'static/uploads/marketing_materials'
        os.makedirs(upload_folder, exist_ok=True)
        file_path = os.path.join(upload_folder, unique_filename)
        file.save(file_path)
        
        # Store relative path in database
        file_url = f'/static/uploads/marketing_materials/{unique_filename}'
        
        # Create marketing material
        material = MarketingMaterial(
            residential_complex_id=complex_id,
            title=title,
            description=description,
            file_url=file_url,
            file_type=file_type,
            material_type=material_type,
            is_active=is_active,
            sort_order=sort_order
        )
        
        db.session.add(material)
        db.session.commit()
        
        flash('–ú–∞—Ç–µ—Ä–∏–∞–ª —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º–∞—Ç–µ—Ä–∏–∞–ª–∞: {str(e)}', 'error')
    
    return redirect(url_for('admin_complex_materials', complex_id=complex_id))


@app.route('/admin/material/<int:material_id>/update', methods=['POST'])
@admin_required
def admin_update_material(material_id):
    """Update marketing material"""
    from models import MarketingMaterial
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    material = MarketingMaterial.query.get_or_404(material_id)
    complex_id = material.residential_complex_id
    
    try:
        # Get form data
        title = request.form.get('title', '').strip()
        description = request.form.get('description', '').strip()
        material_type = request.form.get('material_type', 'other').strip()
        is_active = request.form.get('is_active') == 'on'
        sort_order = int(request.form.get('sort_order', 0))
        
        # Validate title
        if not title:
            flash('–ù–∞–∑–≤–∞–Ω–∏–µ –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Validate material type
        allowed_material_types = ['brochure', 'photo', 'render', 'other']
        if material_type not in allowed_material_types:
            flash('–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø –º–∞—Ç–µ—Ä–∏–∞–ª–∞', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Update basic fields
        material.title = title
        material.description = description
        material.material_type = material_type
        material.is_active = is_active
        material.sort_order = sort_order
        
        # Handle file replacement (optional)
        file = request.files.get('file')
        if file and file.filename != '':
            filename = secure_filename(file.filename)
            file_ext = os.path.splitext(filename)[1].lower()
            
            # Determine file type and validate
            if file_ext == '.pdf':
                file_type = 'pdf'
                max_size = 10 * 1024 * 1024  # 10MB
            elif file_ext in ['.jpg', '.jpeg', '.png', '.webp']:
                file_type = 'image'
                max_size = 5 * 1024 * 1024  # 5MB
            else:
                flash('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ PDF, JPG, PNG –∏–ª–∏ WEBP', 'error')
                return redirect(url_for('admin_complex_materials', complex_id=complex_id))
            
            # Check file size
            file.seek(0, os.SEEK_END)
            file_size = file.tell()
            file.seek(0)
            
            if file_size > max_size:
                max_size_mb = max_size / (1024 * 1024)
                flash(f'–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–π ({max_size_mb}MB)', 'error')
                return redirect(url_for('admin_complex_materials', complex_id=complex_id))
            
            # Delete old file if exists
            if material.file_url:
                old_file_path = material.file_url.lstrip('/')
                if os.path.exists(old_file_path):
                    try:
                        os.remove(old_file_path)
                    except:
                        pass
            
            # Generate unique filename with timestamp
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            unique_filename = f"{timestamp}_{filename}"
            
            # Save new file
            upload_folder = 'static/uploads/marketing_materials'
            os.makedirs(upload_folder, exist_ok=True)
            file_path = os.path.join(upload_folder, unique_filename)
            file.save(file_path)
            
            # Update file info in database
            material.file_url = f'/static/uploads/marketing_materials/{unique_filename}'
            material.file_type = file_type
        
        db.session.commit()
        flash('–ú–∞—Ç–µ—Ä–∏–∞–ª —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –º–∞—Ç–µ—Ä–∏–∞–ª–∞: {str(e)}', 'error')
    
    return redirect(url_for('admin_complex_materials', complex_id=complex_id))


@app.route('/admin/material/<int:material_id>/delete', methods=['POST'])
@admin_required
def admin_delete_material(material_id):
    """Delete marketing material"""
    from models import MarketingMaterial
    import os
    
    material = MarketingMaterial.query.get_or_404(material_id)
    complex_id = material.residential_complex_id
    
    try:
        # Delete file if exists
        if material.file_url:
            file_path = material.file_url.lstrip('/')
            if os.path.exists(file_path):
                try:
                    os.remove(file_path)
                except:
                    pass
        
        db.session.delete(material)
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–ú–∞—Ç–µ—Ä–∏–∞–ª —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


# Admin Complex Cashback Management Routes
@app.route('/admin/complexes/cashback')
@csrf.exempt  # CSRF disabled for admin routes
@admin_required
def admin_complex_cashback():
    """Complex cashback management page"""
    from models import Admin, ResidentialComplex
    from flask import request
    from sqlalchemy import and_, or_
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    # DEPRECATED: Auto-sync removed - all data now in normalized schema (Developers ‚Üí ResidentialComplexes ‚Üí Properties)
    # The auto-sync code that previously inserted residential complexes from excel_properties table
    # has been removed because we now use a fully normalized database schema where all data
    # is properly stored in: Developers, ResidentialComplexes, and Properties tables.
    
    # Get filter parameters
    search = request.args.get('search', '')
    district = request.args.get('district', '')
    status = request.args.get('status', '')
    page = int(request.args.get('page', 1))
    per_page = 20
    
    # Build query
    query = ResidentialComplex.query
    
    # Apply filters
    if search:
        query = query.filter(or_(
            ResidentialComplex.name.contains(search),
            ResidentialComplex.developer.has(name=search)
        ))
    
    if district:
        query = query.filter(ResidentialComplex.district.has(name=district))
    
    if status == 'active':
        query = query.filter(ResidentialComplex.is_active == True)
    elif status == 'inactive':
        query = query.filter(ResidentialComplex.is_active == False)
    
    # Paginate results
    complexes = query.order_by(ResidentialComplex.name).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('admin/complex_cashback.html',
                         admin=current_admin,
                         complexes=complexes,
                         search=search,
                         district=district,
                         status=status)

@app.route('/admin/complex-cashback/<int:complex_id>/update-cashback', methods=['POST'])
@csrf.exempt  # CSRF disabled for admin routes
@admin_required
def update_complex_cashback(complex_id):
    """API endpoint to update complex cashback rate"""
    from models import ResidentialComplex
    
    try:
        complex = ResidentialComplex.query.get_or_404(complex_id)
        
        data = request.get_json()
        cashback_percent = data.get('cashback_percent')
        
        if cashback_percent is None:
            return jsonify({'success': False, 'message': '–ù–µ —É–∫–∞–∑–∞–Ω –ø—Ä–æ—Ü–µ–Ω—Ç –∫–µ—à–±–µ–∫–∞'})
        
        # Validate percentage
        try:
            cashback_percent = float(cashback_percent)
            if cashback_percent < 0 or cashback_percent > 15:
                return jsonify({'success': False, 'message': '–ü—Ä–æ—Ü–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 0% –¥–æ 15%'})
        except (ValueError, TypeError):
            return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø—Ä–æ—Ü–µ–Ω—Ç–∞'})
        
        # Update cashback rate
        complex.cashback_rate = cashback_percent
        complex.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': '–ö–µ—à–±–µ–∫ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω',
            'cashback_percent': cashback_percent,
            'complex_name': complex.name
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error updating complex cashback: {e}")
        return jsonify({'success': False, 'message': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'})

@app.route('/admin/complexes/cashback/create', methods=['GET', 'POST'])
@admin_required
def admin_create_complex_cashback():
    """Create new complex cashback settings"""
    from models import Admin, ResidentialComplex, District, Developer
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    if request.method == 'POST':
        name = request.form.get('name')
        developer_id = request.form.get('developer_id')
        district_id = request.form.get('district_id') 
        cashback_rate = request.form.get('cashback_rate', 5.0)
        
        try:
            # Create new complex
            complex = ResidentialComplex(
                name=name,
                slug=name.lower().replace(' ', '-'),
                developer_id=int(developer_id) if developer_id else None,
                district_id=int(district_id) if district_id else None,
                cashback_rate=float(cashback_rate),
                is_active=True,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            
            db.session.add(complex)
            db.session.commit()
            
            flash('–ñ–ö —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω', 'success')
            return redirect(url_for('admin_complex_cashback'))
            
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ñ–ö', 'error')
    
    # Load data for form
    developers = Developer.query.filter_by(is_active=True).order_by(Developer.name).all()
    districts = District.query.filter_by(is_active=True).order_by(District.name).all()
    
    return render_template('admin/create_complex_cashback.html',
                         admin=current_admin,
                         developers=developers,
                         districts=districts)

@app.route('/admin/complexes/cashback/<int:complex_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_complex_cashback(complex_id):
    """Edit complex cashback settings"""
    from models import ResidentialComplex, District, Developer
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    complex_item = ResidentialComplex.query.get_or_404(complex_id)
    
    if request.method == 'POST':
        complex_item.name = request.form.get('name') or request.form.get('complex_name')
        complex_item.developer_id = int(request.form.get('developer_id')) if request.form.get('developer_id') else None
        complex_item.district_id = int(request.form.get('district_id')) if request.form.get('district_id') else None
        
        # Handle cashback_rate
        try:
            cashback_rate = request.form.get('cashback_rate')
            if cashback_rate:
                complex_item.cashback_rate = float(cashback_rate.replace(',', '.'))
        except (ValueError, TypeError):
            pass

        complex_item.is_active = request.form.get('is_active') == 'on' or request.form.get('is_active') == '1'
        complex_item.updated_at = datetime.utcnow()
        
        try:
            db.session.commit()
            flash('–ñ–ö —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω', 'success')
            return redirect(url_for('admin_complex_cashback'))
        except Exception as e:
            db.session.rollback()
            print(f"Error updating complex {complex_id}: {e}")
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ñ–ö: {str(e)}', 'error')
    
    # Load data for form
    developers = Developer.query.filter_by(is_active=True).order_by(Developer.name).all()
    districts = District.query.filter_by(is_active=True).order_by(District.name).all()
    
    return render_template('admin/edit_complex_cashback.html',
                         admin=current_admin,
                         complex=complex_item,
                         developers=developers,
                         districts=districts)

@app.route('/admin/complexes/cashback/<int:complex_id>/delete', methods=['POST'])
@admin_required
def admin_delete_complex_cashback(complex_id):
    """Delete complex cashback settings"""
    from models import ResidentialComplex
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    
    try:
        db.session.delete(complex)
        db.session.commit()
        flash('–ñ–ö —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ñ–ö', 'error')
    
    return redirect(url_for('admin_complex_cashback'))

# Helper function for secure image validation
def validate_image_file(file):
    """
    Validate uploaded image file for security.
    Returns (is_valid, error_message, file_extension)
    """
    ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.webp'}
    ALLOWED_MIME_TYPES = {'image/jpeg', 'image/png', 'image/webp'}
    
    if not file or not file.filename:
        return False, '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω', None
    
    # Check file extension
    import os
    file_ext = os.path.splitext(file.filename)[1].lower()
    
    if file_ext not in ALLOWED_EXTENSIONS:
        return False, f'–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –†–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ: JPG, PNG, WebP', None
    
    # Verify MIME type by reading file header
    file.seek(0)
    header = file.read(12)
    file.seek(0)
    
    # Check magic bytes for common image formats
    is_valid_mime = False
    detected_type = None
    
    # JPEG: FF D8 FF
    if header[:3] == b'\xff\xd8\xff':
        is_valid_mime = True
        detected_type = 'image/jpeg'
    # PNG: 89 50 4E 47 0D 0A 1A 0A
    elif header[:8] == b'\x89\x50\x4e\x47\x0d\x0a\x1a\x0a':
        is_valid_mime = True
        detected_type = 'image/png'
    # WebP: RIFF....WEBP
    elif header[:4] == b'RIFF' and header[8:12] == b'WEBP':
        is_valid_mime = True
        detected_type = 'image/webp'
    
    if not is_valid_mime:
        return False, '–§–∞–π–ª –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –¥–æ–ø—É—Å—Ç–∏–º—ã–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º. –í–æ–∑–º–æ–∂–Ω–∞ –ø–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Ä–µ–¥–æ–Ω–æ—Å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞.', None
    
    # Verify extension matches detected type
    if file_ext in ['.jpg', '.jpeg'] and detected_type != 'image/jpeg':
        return False, '–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É', None
    if file_ext == '.png' and detected_type != 'image/png':
        return False, '–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É', None
    if file_ext == '.webp' and detected_type != 'image/webp':
        return False, '–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É', None
    
    return True, None, file_ext

# Admin Manager Management Routes  


@app.route('/admin/complex/<int:complex_id>/update-nearby', methods=['POST'])
@login_required
def admin_update_complex_nearby(complex_id):
    """–û–±–Ω–æ–≤–∏—Ç—å –±–ª–∏–∑–ª–µ–∂–∞—â–∏–µ –æ–±—ä–µ–∫—Ç—ã –¥–ª—è –ñ–ö —á–µ—Ä–µ–∑ OpenStreetMap API"""
    if not current_user.is_admin:
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –ñ–ö –∏–∑ –ë–î
        complex = db.session.query(ResidentialComplex).get(complex_id)
        if not complex:
            return jsonify({'success': False, 'error': '–ñ–ö –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        if not complex.latitude or not complex.longitude:
            return jsonify({
                'success': False,
                'error': '–£ –ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã. –î–æ–±–∞–≤—å—Ç–µ —à–∏—Ä–æ—Ç—É –∏ –¥–æ–ª–≥–æ—Ç—É –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–∏—Å–∫–∞.'
            }), 400
        
        # –ü–æ–ª—É—á–∞–µ–º –±–ª–∏–∑–ª–µ–∂–∞—â–∏–µ –æ–±—ä–µ–∫—Ç—ã —á–µ—Ä–µ–∑ Overpass API
        print(f"Fetching nearby places for {complex.name} at {complex.latitude}, {complex.longitude}")
        nearby_data = nearby_places.fetch_nearby_places(
            latitude=float(complex.latitude),
            longitude=float(complex.longitude),
            radius_meters=3000
        )
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î
        complex.nearby = json.dumps(nearby_data, ensure_ascii=False)
        complex.nearby_updated_at = datetime.utcnow()
        db.session.commit()
        
        # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
        total_found = sum(len(nearby_data.get(cat, [])) for cat in ['transport', 'shopping', 'education', 'healthcare', 'leisure'])
        
        return jsonify({
            'success': True,
            'message': f'–ë–ª–∏–∑–ª–µ–∂–∞—â–∏–µ –æ–±—ä–µ–∫—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω—ã. –ù–∞–π–¥–µ–Ω–æ –æ–±—ä–µ–∫—Ç–æ–≤: {total_found}',
            'data': {
                'transport': len(nearby_data.get('transport', [])),
                'shopping': len(nearby_data.get('shopping', [])),
                'education': len(nearby_data.get('education', [])),
                'healthcare': len(nearby_data.get('healthcare', [])),
                'leisure': len(nearby_data.get('leisure', [])),
                'total': total_found
            }
        })
    
    except Exception as e:
        print(f"Error updating nearby places: {e}")


@app.route('/admin/nearby/auto-update', methods=['POST'])
@login_required  
def admin_auto_update_nearby():
    """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–∏—Ç—å nearby –¥–ª—è –ñ–ö –±–µ–∑ –¥–∞–Ω–Ω—ã—Ö (–¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø–∞—Ä—Å–µ—Ä–æ–º)"""
    if not current_user.is_admin:
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        import nearby_auto_updater
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        batch_size = int(request.form.get('batch_size', 5))
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
        stats = nearby_auto_updater.process_batch(
            batch_size=batch_size,
            delay_between=2
        )
        
        return jsonify({
            'success': True,
            'stats': stats,
            'message': f"–û–±–Ω–æ–≤–ª–µ–Ω–æ {stats['success']} –∏–∑ {stats['total']} –ñ–ö. –ù–∞–π–¥–µ–Ω–æ {stats['objects_total']} –æ–±—ä–µ–∫—Ç–æ–≤."
        })
    
    except Exception as e:
        print(f"Error in auto-update: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/admin/nearby/status', methods=['GET'])
@login_required
def admin_nearby_status():
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ nearby –¥–∞–Ω–Ω—ã–º"""
    if not current_user.is_admin:
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        from datetime import timedelta
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        total_complexes = db.session.query(ResidentialComplex).filter(
            ResidentialComplex.latitude.isnot(None),
            ResidentialComplex.longitude.isnot(None)
        ).count()
        
        with_nearby = db.session.query(ResidentialComplex).filter(
            ResidentialComplex.nearby.isnot(None),
            ResidentialComplex.nearby_updated_at.isnot(None)
        ).count()
        
        without_nearby = db.session.query(ResidentialComplex).filter(
            ResidentialComplex.latitude.isnot(None),
            ResidentialComplex.longitude.isnot(None),
            db.or_(
                ResidentialComplex.nearby.is_(None),
                ResidentialComplex.nearby_updated_at.is_(None)
            )
        ).count()
        
        six_months_ago = datetime.utcnow() - timedelta(days=180)
        outdated = db.session.query(ResidentialComplex).filter(
            ResidentialComplex.nearby_updated_at < six_months_ago
        ).count()
        
        return jsonify({
            'success': True,
            'stats': {
                'total_with_coordinates': total_complexes,
                'with_nearby_data': with_nearby,
                'without_nearby_data': without_nearby,
                'outdated': outdated,
                'completion_rate': round((with_nearby / total_complexes * 100) if total_complexes > 0 else 0, 1)
            }
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


        import traceback


@app.route('/admin/nearby-manager')
@login_required
def admin_nearby_manager():
    """–°—Ç—Ä–∞–Ω–∏—Ü–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º nearby –¥–∞–Ω–Ω—ã—Ö"""
    if not current_user.is_admin:
        abort(403)
    
    from datetime import timedelta
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    total_complexes = db.session.query(ResidentialComplex).filter(
        ResidentialComplex.latitude.isnot(None),
        ResidentialComplex.longitude.isnot(None)
    ).count()
    
    with_nearby = db.session.query(ResidentialComplex).filter(
        ResidentialComplex.nearby.isnot(None),
        ResidentialComplex.nearby_updated_at.isnot(None)
    ).count()
    
    without_nearby = db.session.query(ResidentialComplex).filter(
        ResidentialComplex.latitude.isnot(None),
        ResidentialComplex.longitude.isnot(None),
        db.or_(
            ResidentialComplex.nearby.is_(None),
            ResidentialComplex.nearby_updated_at.is_(None)
        )
    ).all()
    
    six_months_ago = datetime.utcnow() - timedelta(days=180)
    outdated = db.session.query(ResidentialComplex).filter(
        ResidentialComplex.nearby_updated_at < six_months_ago
    ).all()
    
    stats = {
        'total': total_complexes,
        'with_data': with_nearby,
        'without_data_count': len(without_nearby),
        'without_data': without_nearby[:10],  # –ü–æ–∫–∞–∑–∞—Ç—å –ø–µ—Ä–≤—ã–µ 10
        'outdated_count': len(outdated),
        'outdated': outdated[:10],
        'completion_rate': round((with_nearby / total_complexes * 100) if total_complexes > 0 else 0, 1)
    }
    
    return render_template('admin/nearby_manager.html', stats=stats)




@app.route('/admin/managers/create', methods=['GET', 'POST'])
@admin_required
def admin_create_manager():
    """Create new manager"""
    from models import Admin, Manager
    from werkzeug.security import generate_password_hash
    import json
    import random
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    if request.method == 'POST':
        full_name = request.form.get('full_name', '')
        email = request.form.get('email')
        phone = request.form.get('phone')
        position = request.form.get('position', '–ú–µ–Ω–µ–¥–∂–µ—Ä')
        password = request.form.get('password', 'demo123')  # Default password
        password_confirm = request.form.get('password_confirm', 'demo123')
        is_active = request.form.get('is_active') != 'False'  # Default True
        
        # Handle profile image (file upload or URL)
        profile_image = None
        profile_image_file = request.files.get('profile_image_file')
        profile_image_url = request.form.get('profile_image_url')
        
        if profile_image_file and profile_image_file.filename:
            # Validate and save uploaded file with security checks
            try:
                import os
                import uuid
                from werkzeug.utils import secure_filename
                
                # SECURITY: Validate file type and MIME type
                is_valid, error_message, file_ext = validate_image_file(profile_image_file)
                
                if not is_valid:
                    flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {error_message}', 'error')
                    return render_template('admin/create_manager.html', admin=current_admin)
                
                # Create upload directory if not exists
                upload_dir = 'static/uploads/managers'
                os.makedirs(upload_dir, exist_ok=True)
                
                # Generate unique filename with validated extension
                unique_filename = f"{uuid.uuid4().hex}{file_ext}"
                filepath = os.path.join(upload_dir, unique_filename)
                
                # Save file
                profile_image_file.save(filepath)
                profile_image = f'/{filepath}'
                
            except Exception as e:
                flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: {str(e)}', 'error')
                profile_image = 'https://randomuser.me/api/portraits/men/1.jpg'
        elif profile_image_url:
            profile_image = profile_image_url
        else:
            profile_image = 'https://randomuser.me/api/portraits/men/1.jpg'
        
        # Split full name into first and last name
        name_parts = full_name.split(' ', 1)
        first_name = name_parts[0] if name_parts else '–ò–º—è'
        last_name = name_parts[1] if len(name_parts) > 1 else '–§–∞–º–∏–ª–∏—è'
        
        # Validate passwords
        if password != password_confirm:
            flash('–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç', 'error')
            return render_template('admin/create_manager.html', admin=current_admin)
        
        if not password:
            password = 'demo123'  # Default password
        
        # Check if email already exists
        if email:
            existing_manager = Manager.query.filter_by(email=email).first()
            if existing_manager:
                flash('–ú–µ–Ω–µ–¥–∂–µ—Ä —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç', 'error')
                return render_template('admin/create_manager.html', admin=current_admin)
        
        # Create manager
        manager = Manager()
        manager.email = email or f'manager{random.randint(1000,9999)}@inback.ru'
        manager.first_name = first_name
        manager.last_name = last_name
        manager.phone = phone
        manager.position = position
        manager.profile_image = profile_image or 'https://randomuser.me/api/portraits/men/1.jpg'
        manager.set_password(password)
        manager.is_active = is_active
        
        try:
            db.session.add(manager)
            db.session.commit()
            flash('–ú–µ–Ω–µ–¥–∂–µ—Ä —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω', 'success')
            return redirect(url_for('admin_managers'))
        except Exception as e:
            db.session.rollback()
            print(f"ERROR creating manager: {str(e)}")
            import traceback
            traceback.print_exc()
            flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {str(e)}', 'error')
    
    return render_template('admin/create_manager.html', admin=current_admin)

@app.route('/admin/managers/<int:manager_id>/delete', methods=['POST'])
@admin_required
def admin_delete_manager(manager_id):
    """Delete manager with option to reassign deals"""
    from models import (Manager, ManagerFavoriteProperty, ManagerFavoriteComplex,
                        ManagerSavedSearch, ManagerComparison, Collection, User,
                        Deal, DealComment, DealTask, DealHistory, ManagerNotification,
                        ManagerCheckin, Department)
    
    manager = Manager.query.get_or_404(manager_id)
    reassign_to_id = request.form.get('reassign_to', '', type=str)
    reassign_manager = None
    
    if reassign_to_id:
        reassign_manager = Manager.query.get(int(reassign_to_id))
    
    try:
        if reassign_manager:
            Deal.query.filter_by(manager_id=manager_id).update(
                {'manager_id': reassign_manager.id}, synchronize_session=False)
            DealComment.query.filter_by(author_id=manager_id).update(
                {'author_id': reassign_manager.id}, synchronize_session=False)
            DealTask.query.filter_by(author_id=manager_id).update(
                {'author_id': reassign_manager.id}, synchronize_session=False)
            DealHistory.query.filter_by(author_id=manager_id).update(
                {'author_id': reassign_manager.id}, synchronize_session=False)
            User.query.filter_by(assigned_manager_id=manager_id).update(
                {'assigned_manager_id': reassign_manager.id}, synchronize_session=False)
            Collection.query.filter_by(created_by_manager_id=manager_id).update(
                {'created_by_manager_id': reassign_manager.id}, synchronize_session=False)
        else:
            deals = Deal.query.filter_by(manager_id=manager_id).all()
            deal_ids = [d.id for d in deals]
            if deal_ids:
                DealHistory.query.filter(DealHistory.deal_id.in_(deal_ids)).delete(synchronize_session=False)
                DealComment.query.filter(DealComment.deal_id.in_(deal_ids)).delete(synchronize_session=False)
                DealTask.query.filter(DealTask.deal_id.in_(deal_ids)).delete(synchronize_session=False)
                Deal.query.filter(Deal.id.in_(deal_ids)).delete(synchronize_session=False)
            User.query.filter_by(assigned_manager_id=manager_id).update(
                {'assigned_manager_id': None}, synchronize_session=False)
            Collection.query.filter_by(created_by_manager_id=manager_id).delete(synchronize_session=False)

        ManagerFavoriteProperty.query.filter_by(manager_id=manager_id).delete(synchronize_session=False)
        ManagerFavoriteComplex.query.filter_by(manager_id=manager_id).delete(synchronize_session=False)
        ManagerSavedSearch.query.filter_by(manager_id=manager_id).delete(synchronize_session=False)
        ManagerComparison.query.filter_by(manager_id=manager_id).delete(synchronize_session=False)
        
        try:
            ManagerNotification.query.filter_by(manager_id=manager_id).delete(synchronize_session=False)
        except Exception:
            pass
        try:
            ManagerCheckin.query.filter_by(manager_id=manager_id).delete(synchronize_session=False)
        except Exception:
            pass
        try:
            Department.query.filter_by(head_manager_id=manager_id).update(
                {'head_manager_id': None}, synchronize_session=False)
        except Exception:
            pass
        
        db.session.delete(manager)
        db.session.commit()
        
        if reassign_manager:
            flash(f'–ú–µ–Ω–µ–¥–∂–µ—Ä —É–¥–∞–ª–µ–Ω. –°–¥–µ–ª–∫–∏ –∏ –∫–ª–∏–µ–Ω—Ç—ã –ø–µ—Ä–µ–¥–∞–Ω—ã: {reassign_manager.full_name}', 'success')
        else:
            flash('–ú–µ–Ω–µ–¥–∂–µ—Ä —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω', 'success')
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting manager: {e}")
        import traceback
        traceback.print_exc()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {str(e)}', 'error')
    
    return redirect(url_for('admin_managers'))

@app.route('/admin/managers/<int:manager_id>/toggle-status', methods=['POST'])
@admin_required
def admin_toggle_manager_status(manager_id):
    """Toggle manager active status"""
    from models import Manager
    
    manager = Manager.query.get_or_404(manager_id)
    manager.is_active = not manager.is_active
    
    try:
        db.session.commit()
        status = '–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω' if manager.is_active else '–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω'
        flash(f'–ú–µ–Ω–µ–¥–∂–µ—Ä {status}', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –º–µ–Ω–µ–¥–∂–µ—Ä–∞', 'error')
    
    return redirect(url_for('admin_managers'))

# Additional Pages Routes
@app.route('/careers')
def careers():
    """Careers page with dynamic data"""
    from models import Job, JobCategory, Admin
    
    try:
        # Check if current user is admin
        is_admin = False
        current_admin = None
        if 'admin_id' in session:
            admin_id = session.get('admin_id')
            current_admin = Admin.query.get(admin_id)
            is_admin = current_admin is not None
        
        # Get all active job categories
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        
        # Get all active jobs with their categories (excluding paused jobs)
        jobs = Job.query.filter(Job.is_active == True, Job.status == 'active').order_by(Job.is_featured.desc(), Job.created_at.desc()).all()
        
        return render_template('careers.html', 
                             categories=categories, 
                             jobs=jobs,
                             is_admin=is_admin,
                             admin=current_admin)
        
    except Exception as e:
        print(f"Error loading careers page: {e}")
        # Fallback to static page if database fails
        return render_template('careers.html', 
                             categories=[], 
                             jobs=[],
                             is_admin=False,
                             admin=None)

@app.route('/security')
def security():
    """Security page"""
    return render_template('security.html')





# Initialize logger for scheduler
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

# ============= APScheduler Configuration =============
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger
from apscheduler.triggers.interval import IntervalTrigger
import pytz

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–æ—Å–∫–æ–≤—Å–∫–æ–≥–æ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞ –¥–ª—è –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
moscow_tz = pytz.timezone('Europe/Moscow')
scheduler = BackgroundScheduler(daemon=True, timezone=moscow_tz)

def run_instant_alerts():
    """Background job: Check for new properties and send instant alerts every 5 minutes"""
    with app.app_context():
        try:
            logger.info("üîî Running instant alerts check...")
            sent_count = AlertService.send_instant_alerts()
            logger.info(f"‚úÖ Instant alerts job completed: {sent_count} alerts sent")
        except Exception as e:
            logger.error(f"‚ùå Error in instant alerts job: {e}", exc_info=True)

def run_daily_digest():
    """Background job: Send daily digest at 8:00 AM"""
    with app.app_context():
        try:
            logger.info("üìß Running daily digest job...")
            sent_count = AlertService.send_daily_digest()
            logger.info(f"‚úÖ Daily digest job completed: {sent_count} digests sent")
        except Exception as e:
            logger.error(f"‚ùå Error in daily digest job: {e}", exc_info=True)

def run_weekly_digest():
    """Background job: Send weekly digest every Monday at 8:00 AM"""
    with app.app_context():
        try:
            logger.info("üìÜ Running weekly digest job...")
            sent_count = AlertService.send_weekly_digest()
            logger.info(f"‚úÖ Weekly digest job completed: {sent_count} digests sent")
        except Exception as e:
            logger.error(f"‚ùå Error in weekly digest job: {e}", exc_info=True)

def run_task_reminders():
    """Background job: Check for tasks due in 30 minutes and create notifications"""
    with app.app_context():
        try:
            from models import DealTask, Deal, ManagerNotification
            from datetime import datetime, timedelta
            import json
            try:
                from zoneinfo import ZoneInfo
            except ImportError:
                from backports.zoneinfo import ZoneInfo
            
            now = datetime.now(ZoneInfo('Europe/Moscow')).replace(tzinfo=None)
            reminder_window_start = now + timedelta(minutes=25)
            reminder_window_end = now + timedelta(minutes=35)
            
            upcoming_tasks = DealTask.query.filter(
                DealTask.is_completed == False,
                DealTask.due_date != None,
                DealTask.due_date >= reminder_window_start,
                DealTask.due_date <= reminder_window_end
            ).all()
            
            created_count = 0
            for task in upcoming_tasks:
                deal = Deal.query.get(task.deal_id)
                if not deal:
                    continue
                existing = ManagerNotification.query.filter_by(
                    manager_id=deal.manager_id,
                    notification_type='task_reminder'
                ).filter(
                    db.or_(
                        ManagerNotification.extra_data.like(f'%"task_id": {task.id},%'),
                        ManagerNotification.extra_data.like(f'%"task_id": {task.id}}}%')
                    ),
                    ManagerNotification.created_at >= now - timedelta(hours=2)
                ).first()
                if existing:
                    continue
                    
                minutes_left = int((task.due_date - now).total_seconds() / 60)
                notif = ManagerNotification(
                    manager_id=deal.manager_id,
                    title=f'‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: {task.title}',
                    message=f'–ó–∞–¥–∞—á–∞ –ø–æ —Å–¥–µ–ª–∫–µ {deal.deal_number} —á–µ—Ä–µ–∑ ~{minutes_left} –º–∏–Ω. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: {task.priority_label}',
                    notification_type='task_reminder',
                    presentation_id=None,
                    extra_data=json.dumps({'task_id': task.id, 'deal_id': deal.id, 'deal_number': deal.deal_number}, ensure_ascii=False)
                )
                db.session.add(notif)
                created_count += 1
            
            if created_count > 0:
                db.session.commit()
                logger.info(f"üîî Task reminders: {created_count} notifications created")
        except Exception as e:
            db.session.rollback()
            logger.error(f"‚ùå Error in task reminders job: {e}", exc_info=True)

def run_overdue_task_alerts():
    """Background job: Check for overdue tasks and create notifications"""
    with app.app_context():
        try:
            from models import DealTask, Deal, ManagerNotification
            from datetime import datetime, timedelta
            import json
            try:
                from zoneinfo import ZoneInfo
            except ImportError:
                from backports.zoneinfo import ZoneInfo
            
            now = datetime.now(ZoneInfo('Europe/Moscow')).replace(tzinfo=None)
            
            overdue_tasks = DealTask.query.filter(
                DealTask.is_completed == False,
                DealTask.due_date != None,
                DealTask.due_date < now
            ).all()
            
            created_count = 0
            for task in overdue_tasks:
                deal = Deal.query.get(task.deal_id)
                if not deal:
                    continue
                existing = ManagerNotification.query.filter_by(
                    manager_id=deal.manager_id,
                    notification_type='task_overdue'
                ).filter(
                    db.or_(
                        ManagerNotification.extra_data.like(f'%"task_id": {task.id},%'),
                        ManagerNotification.extra_data.like(f'%"task_id": {task.id}}}%')
                    ),
                    ManagerNotification.created_at >= now - timedelta(hours=24)
                ).first()
                if existing:
                    continue
                
                overdue_minutes = int((now - task.due_date).total_seconds() / 60)
                if overdue_minutes < 60:
                    overdue_text = f'{overdue_minutes} –º–∏–Ω.'
                elif overdue_minutes < 1440:
                    overdue_text = f'{overdue_minutes // 60} —á.'
                else:
                    overdue_text = f'{overdue_minutes // 1440} –¥–Ω.'
                    
                notif = ManagerNotification(
                    manager_id=deal.manager_id,
                    title=f'üî¥ –ü—Ä–æ—Å—Ä–æ—á–µ–Ω–∞: {task.title}',
                    message=f'–ó–∞–¥–∞—á–∞ –ø–æ —Å–¥–µ–ª–∫–µ {deal.deal_number} –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–∞ –Ω–∞ {overdue_text}. –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: {task.priority_label}',
                    notification_type='task_overdue',
                    presentation_id=None,
                    extra_data=json.dumps({'task_id': task.id, 'deal_id': deal.id, 'deal_number': deal.deal_number}, ensure_ascii=False)
                )
                db.session.add(notif)
                created_count += 1
            
            if created_count > 0:
                db.session.commit()
                logger.info(f"üî¥ Overdue task alerts: {created_count} notifications created")
        except Exception as e:
            db.session.rollback()
            logger.error(f"‚ùå Error in overdue task alerts job: {e}", exc_info=True)

# Schedule background jobs
# Instant alerts: every 5 minutes
scheduler.add_job(
    func=run_instant_alerts,
    trigger=IntervalTrigger(minutes=5),
    id='instant_alerts_job',
    name='–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –º–≥–Ω–æ–≤–µ–Ω–Ω—ã—Ö –æ–ø–æ–≤–µ—â–µ–Ω–∏–π',
    replace_existing=True
)

# Daily digest: every day at 8:00 AM
scheduler.add_job(
    func=run_daily_digest,
    trigger=CronTrigger(hour=8, minute=0),
    id='daily_digest_job',
    name='–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Å–≤–æ–¥–∫–∞ –ø–æ –æ–±—ä–µ–∫—Ç–∞–º',
    replace_existing=True
)

# Weekly digest: every Monday at 8:00 AM
scheduler.add_job(
    func=run_weekly_digest,
    trigger=CronTrigger(day_of_week='mon', hour=8, minute=0),
    id='weekly_digest_job',
    name='–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–∞—è —Å–≤–æ–¥–∫–∞ –ø–æ –æ–±—ä–µ–∫—Ç–∞–º',
    replace_existing=True
)

# Task reminders: every 5 minutes
scheduler.add_job(
    func=run_task_reminders,
    trigger=IntervalTrigger(minutes=5),
    id='task_reminders_job',
    name='–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ –ø—Ä–µ–¥—Å—Ç–æ—è—â–∏—Ö –∑–∞–¥–∞—á–∞—Ö',
    replace_existing=True
)

# Overdue task alerts: every 10 minutes
scheduler.add_job(
    func=run_overdue_task_alerts,
    trigger=IntervalTrigger(minutes=10),
    id='overdue_task_alerts_job',
    name='–û–ø–æ–≤–µ—â–µ–Ω–∏—è –æ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á–∞—Ö',
    replace_existing=True
)

# Start scheduler only in main process (avoid duplication under Gunicorn)
if os.environ.get('ENABLE_SCHEDULER', 'false').lower() == 'true':
    scheduler.start()
    logger.info("‚úÖ APScheduler started - Background jobs configured:")
    logger.info("   üîî Instant alerts: Every 5 minutes")
    logger.info("   üìß Daily digest: Every day at 8:00 AM")
    logger.info("   üìÜ Weekly digest: Every Monday at 8:00 AM")
    logger.info("   ‚è∞ Task reminders: Every 5 minutes")
    logger.info("   üî¥ Overdue task alerts: Every 10 minutes")
else:
    logger.info("‚è∏Ô∏è  APScheduler skipped - Set ENABLE_SCHEDULER=true to run background jobs")

# Register shutdown only if scheduler is running
import atexit
if scheduler.running:
    atexit.register(lambda: scheduler.shutdown())

# ==================== DASHBOARD BOOTSTRAP API ====================

@app.route('/api/dashboard/bootstrap', methods=['GET'])
@login_required
def api_dashboard_bootstrap():
    """
    Single endpoint that returns ALL dashboard data in one request.
    Eliminates 6 sequential API calls that caused 30+ second load times.
    
    Returns: favorites, comparisons, balance, cities, recommendations, collections
    """
    from models import (FavoriteProperty, FavoriteComplex, Property, ResidentialComplex, 
                       Developer, UserComparison, ComparisonProperty, ComparisonComplex,
                       Recommendation, SentSearch, Collection, City)
    from services.balance_service import BalanceService
    from services.withdrawal_service import WithdrawalService
    from decimal import Decimal
    from sqlalchemy import func
    import json
    
    result = {
        'success': True,
        'favorites': {'properties': [], 'complexes': []},
        'comparisons': {'properties': [], 'complexes': [], 'properties_count': 0, 'complexes_count': 0},
        'balance': {},
        'cities': [],
        'recommendations': [],
        'collections': []
    }
    
    try:
        # ============ FAVORITES ============
        # Properties favorites
        prop_favorites = db.session.query(FavoriteProperty).filter_by(user_id=current_user.id).order_by(FavoriteProperty.created_at.desc()).all()
        property_ids = [int(fav.property_id) for fav in prop_favorites if fav.property_id and fav.property_id.isdigit()]
        
        if property_ids:
            properties_query = db.session.query(
                Property,
                ResidentialComplex.name.label('complex_name'),
                ResidentialComplex.cashback_rate,
                ResidentialComplex.main_image.label('complex_image'),
                Developer.name.label('developer_name')
            ).outerjoin(
                ResidentialComplex, Property.complex_id == ResidentialComplex.id
            ).outerjoin(
                Developer, Property.developer_id == Developer.id
            ).filter(Property.id.in_(property_ids)).all()
            
            properties_dict = {}
            for prop, complex_name, cashback_rate, complex_image, developer_name in properties_query:
                rooms_text = f"{prop.rooms}-–∫–æ–º–Ω" if prop.rooms and prop.rooms > 0 else "–°—Ç—É–¥–∏—è"
                properties_dict[prop.id] = {
                    'id': str(prop.id),
                    'inner_id': prop.inner_id,
                    'title': f"{rooms_text}, {prop.area} –º¬≤, {prop.floor}/{prop.total_floors} —ç—Ç.",
                    'complex': complex_name or '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω',
                    'district': prop.address or '–ê–¥—Ä–µ—Å –Ω–µ —É–∫–∞–∑–∞–Ω',
                    'price': prop.price or 0,
                    'image': complex_image or prop.main_image or '/static/images/no-photo.jpg',
                    'cashback_rate': cashback_rate or 3.5,
                    'cashback_amount': int((prop.price or 0) * (cashback_rate or 3.5) / 100),
                    'developer': developer_name or '–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ –Ω–µ —É–∫–∞–∑–∞–Ω',
                    'is_sold': not prop.is_active,
                }
            
            for fav in prop_favorites:
                if fav.property_id:
                    property_id_int = int(fav.property_id) if fav.property_id.isdigit() else None
                    property_data = properties_dict.get(property_id_int)
                    if property_data:
                        property_data['created_at'] = fav.created_at.strftime('%d.%m.%Y –≤ %H:%M') if fav.created_at else '–ù–µ–¥–∞–≤–Ω–æ'
                        result['favorites']['properties'].append(property_data)
        
        # Complex favorites 
        complex_favorites = db.session.query(FavoriteComplex).filter_by(user_id=current_user.id).all()
        result['favorites']['complexes'] = [{'id': str(fc.complex_id)} for fc in complex_favorites]
        
        # ============ COMPARISONS ============
        user_comparison = UserComparison.query.filter_by(user_id=current_user.id, is_active=True).first()
        if user_comparison:
            comp_properties = ComparisonProperty.query.filter_by(user_comparison_id=user_comparison.id).all()
            comp_complexes = ComparisonComplex.query.filter_by(user_comparison_id=user_comparison.id).all()
            
            result['comparisons']['properties'] = [{'id': str(cp.property_id)} for cp in comp_properties if cp.property_id]
            result['comparisons']['complexes'] = [{'id': str(cc.complex_id)} for cc in comp_complexes if cc.complex_id]
            result['comparisons']['properties_count'] = len(result['comparisons']['properties'])
            result['comparisons']['complexes_count'] = len(result['comparisons']['complexes'])
        
        # ============ BALANCE ============
        balance_info = BalanceService.get_balance(current_user.id)
        registration_bonus_amount = WithdrawalService._get_transaction_sum_by_type(current_user.id, 'registration_bonus')
        cashback_earned_amount = WithdrawalService._get_transaction_sum_by_type(current_user.id, 'cashback_earned')
        available_amount = Decimal(str(balance_info['available_amount']))
        
        if cashback_earned_amount == 0 and registration_bonus_amount > 0:
            withdrawable_amount = max(Decimal('0'), available_amount - registration_bonus_amount)
        else:
            withdrawable_amount = available_amount
        
        result['balance'] = {
            'available_amount': balance_info['available_amount'],
            'pending_amount': balance_info['pending_amount'],
            'total_earned': balance_info['total_earned'],
            'total_withdrawn': balance_info['total_withdrawn'],
            'currency': balance_info['currency'],
            'registration_bonus_amount': float(registration_bonus_amount),
            'cashback_earned_amount': float(cashback_earned_amount),
            'withdrawable_amount': float(withdrawable_amount)
        }
        
        # ============ CITIES ============
        cities_with_counts = db.session.query(
            City, func.count(Property.id).label('property_count')
        ).outerjoin(
            Property, (Property.city_id == City.id) & (Property.is_active == True)
        ).filter(City.is_active == True).group_by(City.id).order_by(func.count(Property.id).desc()).all()
        
        for city, property_count in cities_with_counts:
            if property_count == 0 and not city.is_default:
                continue
            result['cities'].append({
                'id': city.id,
                'name': city.name,
                'slug': city.slug,
                'is_default': city.is_default,
                'address_position_lat': city.latitude,
                'address_position_lon': city.longitude,
                'zoom_level': city.zoom_level,
                'property_count': property_count
            })
        
        # ============ RECOMMENDATIONS ============
        recommendations = Recommendation.query.filter_by(client_id=current_user.id).order_by(Recommendation.sent_at.desc()).all()
        for rec in recommendations:
            rec_data = rec.to_dict()
            rec_data['manager_name'] = f"{rec.manager.first_name} {rec.manager.last_name}" if rec.manager else '–ú–µ–Ω–µ–¥–∂–µ—Ä'
            result['recommendations'].append(rec_data)
        
        sent_searches = SentSearch.query.filter_by(client_id=current_user.id).order_by(SentSearch.sent_at.desc()).all()
        for search in sent_searches:
            result['recommendations'].append({
                'id': f'search_{search.id}',
                'title': f'–ü–æ–¥–±–æ—Ä –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {search.name}',
                'description': search.description or '–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥–±–æ—Ä –æ—Ç –≤–∞—à–µ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
                'recommendation_type': 'search',
                'item_id': str(search.id),
                'status': search.status,
                'manager_name': search.manager.name if search.manager else '–ú–µ–Ω–µ–¥–∂–µ—Ä',
                'created_at': search.sent_at.isoformat() if search.sent_at else None,
            })
        result['recommendations'].sort(key=lambda x: x.get('created_at', ''), reverse=True)
        
        # ============ COLLECTIONS ============
        collections = Collection.query.filter_by(assigned_to_user_id=current_user.id).order_by(Collection.created_at.desc()).all()
        for collection in collections:
            manager = collection.created_by
            manager_name = manager.full_name if manager else '–ú–µ–Ω–µ–¥–∂–µ—Ä'
            if manager and manager.profile_image and 'randomuser.me' not in manager.profile_image:
                if manager.profile_image.startswith('http'):
                    manager_avatar = manager.profile_image
                else:
                    base_url = request.host_url.rstrip('/')
                    manager_avatar = f"{base_url}{manager.profile_image}"
            else:
                manager_avatar = manager_name[0].upper() if manager_name else '–ú'

            from zoneinfo import ZoneInfo
            formatted_date = ''
            if collection.created_at:
                try:
                    formatted_date = collection.created_at.replace(tzinfo=ZoneInfo('UTC')).astimezone(ZoneInfo('Europe/Moscow')).strftime('%d.%m.%Y –≤ %H:%M')
                except Exception:
                    formatted_date = collection.created_at.isoformat()

            properties_data = []
            for prop in (collection.properties or [])[:4]:
                property_obj = Property.query.filter_by(inner_id=prop.property_id).first()
                if not property_obj:
                    property_obj = PropertyRepository.get_by_id(prop.property_id)
                if property_obj:
                    image_url = ''
                    if property_obj.gallery_images:
                        try:
                            photos_list = json.loads(property_obj.gallery_images) if isinstance(property_obj.gallery_images, str) else property_obj.gallery_images
                            image_url = photos_list[0] if photos_list and len(photos_list) > 0 else ''
                        except Exception:
                            pass
                    rooms_text = f"{property_obj.rooms}-–∫–æ–º–Ω" if property_obj.rooms and property_obj.rooms > 0 else "–°—Ç—É–¥–∏—è"
                    area_text = f"{property_obj.area} –º¬≤" if property_obj.area else ""
                    properties_data.append({
                        'id': prop.property_id,
                        'image': image_url,
                        'title': f"{rooms_text}, {area_text}".strip(', ')
                    })

            result['collections'].append({
                'id': collection.id,
                'title': collection.title,
                'description': collection.description,
                'status': collection.status,
                'manager_name': manager_name,
                'manager_avatar': manager_avatar,
                'properties_count': len(collection.properties) if collection.properties else 0,
                'properties': properties_data,
                'unique_url': collection.unique_url,
                'created_at': formatted_date,
            })
        
        print(f"üöÄ Dashboard bootstrap: user={current_user.id}, favorites={len(result['favorites']['properties'])}, "
              f"comparisons={result['comparisons']['properties_count']}, recommendations={len(result['recommendations'])}, "
              f"collections={len(result['collections'])}")
        
        return jsonify(result)
        
    except Exception as e:
        import traceback
        app.logger.error(f"Dashboard bootstrap error: {str(e)}\n{traceback.format_exc()}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ==================== BALANCE AND WITHDRAWAL API ENDPOINTS ====================

# User endpoints (require @login_required)
@app.route('/api/balance', methods=['GET'])
@login_required
def api_get_balance():
    """Get current balance for authenticated user with withdrawal restrictions"""
    try:
        from services.balance_service import BalanceService
        from services.withdrawal_service import WithdrawalService
        from decimal import Decimal
        
        balance_info = BalanceService.get_balance(current_user.id)
        
        # Calculate registration bonus and cashback amounts
        registration_bonus_amount = WithdrawalService._get_transaction_sum_by_type(
            current_user.id, 'registration_bonus'
        )
        cashback_earned_amount = WithdrawalService._get_transaction_sum_by_type(
            current_user.id, 'cashback_earned'
        )
        
        # Calculate withdrawable amount based on cashback restriction
        available_amount = Decimal(str(balance_info['available_amount']))
        
        if cashback_earned_amount == 0 and registration_bonus_amount > 0:
            # User has not received cashback yet - cannot withdraw registration bonus
            withdrawable_amount = max(Decimal('0'), available_amount - registration_bonus_amount)
        else:
            # User has received cashback - can withdraw everything
            withdrawable_amount = available_amount
        
        app.logger.debug(f"üí∞ Balance API for user {current_user.id}: "
                        f"available={available_amount}‚ÇΩ, "
                        f"registration_bonus={registration_bonus_amount}‚ÇΩ, "
                        f"cashback_earned={cashback_earned_amount}‚ÇΩ, "
                        f"withdrawable={withdrawable_amount}‚ÇΩ")
        
        return jsonify({
            'success': True,
            'available_amount': balance_info['available_amount'],
            'pending_amount': balance_info['pending_amount'],
            'total_earned': balance_info['total_earned'],
            'total_withdrawn': balance_info['total_withdrawn'],
            'currency': balance_info['currency'],
            # New fields for withdrawal restriction
            'registration_bonus_amount': float(registration_bonus_amount),
            'cashback_earned_amount': float(cashback_earned_amount),
            'withdrawable_amount': float(withdrawable_amount)
        })
    except Exception as e:
        app.logger.error(f"Error getting balance for user {current_user.id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/balance/transactions', methods=['GET'])
@login_required
def api_get_transactions():
    """Get transaction history for authenticated user"""
    try:
        from services.balance_service import BalanceService
        
        limit = int(request.args.get('limit', 50))
        offset = int(request.args.get('offset', 0))
        
        transactions = BalanceService.get_transaction_history(current_user.id, limit, offset)
        total_count = BalanceService.get_transaction_count(current_user.id)
        
        # Format transactions with ISO dates
        formatted_transactions = []
        for t in transactions:
            formatted_transactions.append({
                'id': t.id,
                'amount': float(t.amount),
                'type': t.transaction_type,
                'description': t.description,
                'created_at': t.created_at.isoformat() if t.created_at else None,
                'balance_before': float(t.balance_before),
                'balance_after': float(t.balance_after)
            })
        
        return jsonify({
            'success': True,
            'transactions': formatted_transactions,
            'total': total_count
        })
    except Exception as e:
        app.logger.error(f"Error getting transactions for user {current_user.id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400



@app.route('/api/admin/balance/transactions/<int:user_id>', methods=['GET'])
@admin_required
def api_admin_get_user_transactions(user_id):
    """Get transaction history for a specific user (admin only)"""
    try:
        from services.balance_service import BalanceService
        from models import User
        
        # Check if user exists
        user = User.query.get(user_id)
        if not user:
            return jsonify({'success': False, 'error': 'User not found'}), 404
        
        limit = request.args.get('limit', 50, type=int)
        offset = request.args.get('offset', 0, type=int)
        
        transactions = BalanceService.get_transaction_history(user_id, limit=limit, offset=offset)
        total_count = BalanceService.get_transaction_count(user_id)
        
        transactions_data = []
        for tx in transactions:
            transactions_data.append({
                'id': tx.id,
                'amount': float(tx.amount),
                'transaction_type': tx.transaction_type,
                'description': tx.description,
                'balance_before': float(tx.balance_before),
                'balance_after': float(tx.balance_after),
                'status': tx.status,
                'created_at': tx.created_at.strftime('%d.%m.%Y %H:%M'),
                'processed_at': tx.processed_at.strftime('%d.%m.%Y %H:%M') if tx.processed_at else None
            })
        
        return jsonify({
            'success': True,
            'transactions': transactions_data,
            'total_count': total_count,
            'user': {
                'id': user.id,
                'email': user.email,
                'full_name': user.full_name
            }
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/withdrawals', methods=['POST'])
@login_required
def api_create_withdrawal():
    """Create withdrawal request for authenticated user"""
    try:
        from services.withdrawal_service import WithdrawalService
        
        data = request.get_json()
        
        amount = data.get('amount')
        payout_method = data.get('payout_method')
        payout_details = data.get('payout_details')
        
        # Validation
        if not amount or float(amount) <= 0:
            return jsonify({'success': False, 'error': 'amount must be greater than 0'}), 400
        
        if not payout_method:
            return jsonify({'success': False, 'error': 'payout_method is required'}), 400
        
        if not payout_details:
            return jsonify({'success': False, 'error': 'payout_details is required'}), 400
        
        withdrawal_request = WithdrawalService.create_withdrawal_request(
            user_id=current_user.id,
            amount=amount,
            payout_method=payout_method,
            payout_details_dict=payout_details
        )
        
        app.logger.info(f"‚úÖ Created withdrawal request #{withdrawal_request.id} for user {current_user.id}")
        
        return jsonify({
            'success': True,
            'request_id': withdrawal_request.id,
            'message': 'Withdrawal request created successfully'
        })
    except ValueError as e:
        app.logger.warning(f"Validation error creating withdrawal for user {current_user.id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        app.logger.error(f"Error creating withdrawal for user {current_user.id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/withdrawals', methods=['GET'])
@login_required
def api_get_withdrawals():
    """Get withdrawal requests for authenticated user"""
    try:
        from services.withdrawal_service import WithdrawalService
        import json
        
        status = request.args.get('status')
        limit = int(request.args.get('limit', 50))
        offset = int(request.args.get('offset', 0))
        
        requests_list = WithdrawalService.get_withdrawal_requests(
            user_id=current_user.id,
            status=status,
            limit=limit,
            offset=offset
        )
        total_count = WithdrawalService.get_withdrawal_request_count(
            user_id=current_user.id,
            status=status
        )
        
        # Format requests with ISO dates
        formatted_requests = []
        for r in requests_list:
            formatted_requests.append({
                'id': r.id,
                'amount': float(r.amount),
                'status': r.status,
                'payout_method': r.payout_method,
                'payout_details_dict': json.loads(r.payout_details) if r.payout_details else {},
                'created_at': r.created_at.isoformat() if r.created_at else None,
                'processed_at': r.processed_at.isoformat() if r.processed_at else None,
                'paid_at': r.paid_at.isoformat() if r.paid_at else None
            })
        
        return jsonify({
            'success': True,
            'requests': formatted_requests,
            'total': total_count
        })
    except Exception as e:
        app.logger.error(f"Error getting withdrawals for user {current_user.id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


# Admin endpoints (require @admin_required)
@app.route('/api/admin/balance/credit', methods=['POST'])
@admin_required
def api_admin_credit_balance():
    """Credit balance for a user (admin only)"""
    try:
        from services.balance_service import BalanceService
        from models import User
        
        data = request.get_json()
        
        user_id = data.get('user_id')
        amount = data.get('amount')
        description = data.get('description')
        transaction_type = data.get('transaction_type', 'bonus')
        deal_id = data.get('deal_id')
        
        # Validation
        if not user_id:
            return jsonify({'success': False, 'error': 'user_id is required'}), 400
        
        if not amount or float(amount) <= 0:
            return jsonify({'success': False, 'error': 'amount must be greater than 0'}), 400
        
        if not description:
            return jsonify({'success': False, 'error': 'description is required'}), 400
        
        # Check user exists
        user = User.query.get(user_id)
        if not user:
            return jsonify({'success': False, 'error': f'User {user_id} not found'}), 400
        
        transaction = BalanceService.credit_balance(
            user_id=user_id,
            amount=amount,
            description=description,
            transaction_type=transaction_type,
            deal_id=deal_id,
            created_by_id=current_user.id
        )
        
        app.logger.info(f"‚úÖ Admin {current_user.id} credited {amount}‚ÇΩ to user {user_id}")
        
        return jsonify({
            'success': True,
            'transaction_id': transaction.id
        })
    except ValueError as e:
        app.logger.warning(f"Validation error in admin credit: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        app.logger.error(f"Error in admin credit: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/admin/withdrawals', methods=['GET'])
@admin_required
def api_admin_get_withdrawals():
    """Get all withdrawal requests (admin only)"""
    try:
        from services.withdrawal_service import WithdrawalService
        import json
        
        status = request.args.get('status')
        limit = int(request.args.get('limit', 50))
        offset = int(request.args.get('offset', 0))
        
        requests_list = WithdrawalService.get_withdrawal_requests(
            user_id=None,  # Get all requests
            status=status,
            limit=limit,
            offset=offset
        )
        total_count = WithdrawalService.get_withdrawal_request_count(
            user_id=None,
            status=status
        )
        
        # Format requests with ISO dates and user info
        formatted_requests = []
        for r in requests_list:
            # Safe JSON parsing with error handling
            try:
                payout_details_dict = json.loads(r.payout_details) if (r.payout_details and r.payout_details.strip()) else {}
            except (ValueError, TypeError, json.JSONDecodeError):
                payout_details_dict = {}
            
            formatted_requests.append({
                'id': r.id,
                'user_id': r.user_id,
                'user_name': r.user.full_name if hasattr(r.user, 'full_name') and r.user.full_name else r.user.email,
                'user_email': r.user.email,
                'amount': float(r.amount),
                'status': r.status,
                'payout_method': r.payout_method,
                'payout_details_dict': payout_details_dict,
                'created_at': r.created_at.isoformat() if r.created_at else None,
                'processed_at': r.processed_at.isoformat() if r.processed_at else None,
                'paid_at': r.paid_at.isoformat() if r.paid_at else None,
                'rejection_reason': r.rejection_reason
            })
        
        return jsonify({
            'success': True,
            'requests': formatted_requests,
            'total': total_count
        })
    except Exception as e:
        app.logger.error(f"Error getting admin withdrawals: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/admin/withdrawals/<int:request_id>/approve', methods=['POST'])
@admin_required
def api_admin_approve_withdrawal(request_id):
    """Approve withdrawal request (admin only)"""
    try:
        from services.withdrawal_service import WithdrawalService
        
        withdrawal_request = WithdrawalService.approve_withdrawal(
            request_id=request_id,
            admin_id=current_user.id
        )
        
        app.logger.info(f"‚úÖ Admin {current_user.id} approved withdrawal request #{request_id}")
        
        return jsonify({
            'success': True,
            'message': 'Withdrawal request approved successfully'
        })
    except ValueError as e:
        app.logger.warning(f"Validation error approving withdrawal {request_id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        app.logger.error(f"Error approving withdrawal {request_id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/admin/withdrawals/<int:request_id>/reject', methods=['POST'])
@admin_required
def api_admin_reject_withdrawal(request_id):
    """Reject withdrawal request (admin only)"""
    try:
        from services.withdrawal_service import WithdrawalService
        
        data = request.get_json()
        rejection_reason = data.get('rejection_reason')
        
        if not rejection_reason:
            return jsonify({'success': False, 'error': 'rejection_reason is required'}), 400
        
        withdrawal_request = WithdrawalService.reject_withdrawal(
            request_id=request_id,
            admin_id=current_user.id,
            rejection_reason=rejection_reason
        )
        
        app.logger.info(f"‚úÖ Admin {current_user.id} rejected withdrawal request #{request_id}")
        
        return jsonify({
            'success': True,
            'message': 'Withdrawal request rejected successfully'
        })
    except ValueError as e:
        app.logger.warning(f"Validation error rejecting withdrawal {request_id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        app.logger.error(f"Error rejecting withdrawal {request_id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/admin/withdrawals/<int:request_id>/mark-paid', methods=['POST'])
@admin_required
def api_admin_mark_withdrawal_paid(request_id):
    """Mark withdrawal request as paid (admin only)"""
    try:
        from services.withdrawal_service import WithdrawalService
        
        withdrawal_request = WithdrawalService.mark_as_paid(
            request_id=request_id,
            admin_id=current_user.id
        )
        
        app.logger.info(f"‚úÖ Admin {current_user.id} marked withdrawal request #{request_id} as paid")
        
        return jsonify({
            'success': True,
            'message': 'Withdrawal request marked as paid successfully'
        })
    except ValueError as e:
        app.logger.warning(f"Validation error marking withdrawal {request_id} as paid: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        app.logger.error(f"Error marking withdrawal {request_id} as paid: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/admin/users-with-balance')
@admin_required
def api_admin_users_with_balance():
    """Get all users with balance (admin only)"""
    try:
        from models import User, UserBalance
        
        users_with_balance = db.session.query(
            User.id.label('user_id'),
            User.email,
            User.full_name,
            UserBalance.available_amount.label('available'),
            UserBalance.pending_amount.label('pending'),
            UserBalance.total_earned,
            UserBalance.total_withdrawn
        ).join(UserBalance, User.id == UserBalance.user_id).filter(
            (UserBalance.available_amount > 0) | 
            (UserBalance.pending_amount > 0) |
            (UserBalance.total_earned > 0)
        ).all()
        
        users_list = [{
            'user_id': u.user_id,
            'email': u.email,
            'full_name': u.full_name,
            'available': float(u.available),
            'pending': float(u.pending),
            'total_earned': float(u.total_earned),
            'total_withdrawn': float(u.total_withdrawn)
        } for u in users_with_balance]
        
        return jsonify({'success': True, 'users': users_list})
    except Exception as e:
        app.logger.error(f"Error getting users with balance: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/admin/search-users')
@admin_required
def api_admin_search_users():
    """Search users by email or name (admin only)"""
    try:
        from models import User
        
        query = request.args.get('q', '').strip()
        if len(query) < 3:
            return jsonify({'success': True, 'users': []})
        
        users = User.query.filter(
            db.or_(
                User.email.ilike(f'%{query}%'),
                User.full_name.ilike(f'%{query}%')
            )
        ).limit(10).all()
        
        users_list = [{
            'id': u.id,
            'email': u.email,
            'full_name': u.full_name
        } for u in users]
        
        return jsonify({'success': True, 'users': users_list})
    except Exception as e:
        app.logger.error(f"Error searching users: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
if __name__ == '__main__':
    with app.app_context():
        from models import User, Manager, SavedSearch, SentSearch, CashbackRecord, Application, Favorite, Notification, District, Developer, ResidentialComplex, Street, RoomType, Admin, BlogPost, City, Offer, MarketingMaterial, ManagerCheckin
        db.create_all()
        
        # Initialize cities
        try:
            init_cities()
            print("Cities initialized successfully")
        except Exception as e:
            print(f"Error initializing cities: {e}")
            db.session.rollback()
        
        # Initialize search data
        try:
            init_search_data()
            print("Search data initialized successfully")
        except Exception as e:
            print(f"Error initializing search data: {e}")
            db.session.rollback()

# Collection routes for clients
@app.route('/collections')
@login_required
def client_collections():
    """Show all collections assigned to current user"""
    from models import Collection
    collections = Collection.query.filter_by(assigned_to_user_id=current_user.id).order_by(Collection.created_at.desc()).all()
    return render_template('auth/client_collections.html', collections=collections)

@app.route('/collection/<int:collection_id>')
@login_required
def view_collection(collection_id):
    """View specific collection details"""
    from models import Collection
    collection = Collection.query.filter_by(id=collection_id, assigned_to_user_id=current_user.id).first()
    if not collection:
        flash('–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
        return redirect(url_for('client_collections'))
    
    # Mark as viewed
    if collection.status == '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞':
        collection.status = '–ü—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–∞'
        collection.viewed_at = datetime.utcnow()
        db.session.commit()
    
    return render_template('auth/view_collection.html', collection=collection)

@app.route('/collection/<int:collection_id>/mark-viewed', methods=['POST'])
@login_required
def mark_collection_viewed(collection_id):
    """Mark collection as viewed"""
    from models import Collection
    collection = Collection.query.filter_by(id=collection_id, assigned_to_user_id=current_user.id).first()
    if collection and collection.status == '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞':
        collection.status = '–ü—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–∞'
        collection.viewed_at = datetime.utcnow()
        db.session.commit()
    return jsonify({'success': True})

# Manager collection routes
@app.route('/manager/collections')
@manager_required
def manager_collections():
    """Manager collections list"""
    from models import Collection, Manager
    current_manager = current_user
    collections = Collection.query.filter_by(created_by_manager_id=current_manager.id).order_by(Collection.created_at.desc()).all()
    return render_template('manager/collections.html', collections=collections, manager=current_manager)

@app.route('/manager/collections/new')
@manager_required
def manager_create_collection():
    """Create new collection"""
    from models import Manager, User
    current_manager = current_user
    # Get all clients assigned to this manager
    clients = User.query.filter_by(assigned_manager_id=current_manager.id).all()
    return render_template('manager/create_collection.html', manager=current_manager, clients=clients)

@app.route('/manager/collections/new', methods=['POST'])
@manager_required
def save_collection():
    """Save new collection"""
    from models import Collection, CollectionProperty, Manager
    
    current_manager = current_user
    
    title = request.form.get('title')
    description = request.form.get('description', '')
    assigned_to_user_id = request.form.get('assigned_to_user_id')
    tags = request.form.get('tags', '')
    action = request.form.get('action')
    property_ids = request.form.getlist('property_ids[]')
    property_notes = request.form.getlist('property_notes[]')
    
    if not title or not assigned_to_user_id:
        flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è', 'error')
        return render_template('manager/create_collection.html', manager=current_manager)
    
    try:
        # Create collection
        collection = Collection(
            title=title,
            description=description,
            created_by_manager_id=current_manager.id,
            assigned_to_user_id=int(assigned_to_user_id),
            tags=tags,
            status='–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞' if action == 'send' else '–ß–µ—Ä–Ω–æ–≤–∏–∫',
            sent_at=datetime.utcnow() if action == 'send' else None
        )
        
        db.session.add(collection)
        db.session.flush()  # Get collection ID
        
        # Add properties to collection
        import json
        with open('data/properties.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        properties_dict = {prop['id']: prop for prop in properties_data}
        
        for i, prop_id in enumerate(property_ids):
            if prop_id in properties_dict:
                prop_data = properties_dict[prop_id]
                note = property_notes[i] if i < len(property_notes) else ''
                
                # DUAL WRITE: Resolve property to get both IDs
                property_obj, canonical_id = resolve_property_by_identifier(prop_id)
                if not property_obj:
                    continue  # Skip properties that don't exist in database
                
                collection_property = CollectionProperty(
                    collection_id=collection.id,
                    property_id=str(property_obj.id),  # Old: database ID
                    property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
                    property_name=prop_data['title'],
                    property_price=prop_data['price'],
                    complex_name=prop_data.get('residential_complex', ''),
                    property_type=f"{prop_data['rooms']}-–∫–æ–º–Ω",
                    property_size=prop_data.get('area'),
                    manager_note=note,
                    order_index=i
                )
                db.session.add(collection_property)
        
        db.session.commit()
        
        action_text = '–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∫–ª–∏–µ–Ω—Ç—É' if action == 'send' else '—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –∫–∞–∫ —á–µ—Ä–Ω–æ–≤–∏–∫'
        flash(f'–ü–æ–¥–±–æ—Ä–∫–∞ "{title}" —É—Å–ø–µ—à–Ω–æ {action_text}', 'success')
        return redirect(url_for('manager_collections'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –ø–æ–¥–±–æ—Ä–∫–∏: {str(e)}', 'error')
        return render_template('manager/create_collection.html', manager=current_manager)

@app.route('/manager/analytics')
@manager_required
def manager_analytics():
    """Manager analytics page"""
    from models import Manager, User, Collection, CashbackApplication
    from sqlalchemy import func
    
    current_manager = current_user
    
    # Manager stats
    clients_count = User.query.filter_by(assigned_manager_id=current_manager.id).count()
    collections_count = Collection.query.filter_by(created_by_manager_id=current_manager.id).count()
    sent_collections = Collection.query.filter_by(created_by_manager_id=current_manager.id, status='–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞').count()
    
    # Monthly collection stats
    monthly_collections = db.session.query(
        func.date_trunc('month', Collection.created_at).label('month'),
        func.count(Collection.id).label('count')
    ).filter_by(created_by_manager_id=current_manager.id).group_by(
        func.date_trunc('month', Collection.created_at)
    ).order_by('month').all()
    
    # Client activity stats
    client_stats = db.session.query(
        User.client_status,
        func.count(User.id).label('count')
    ).filter_by(assigned_manager_id=current_manager.id).group_by(User.client_status).all()
    
    # Recent activity
    recent_collections = Collection.query.filter_by(
        created_by_manager_id=current_manager.id
    ).order_by(Collection.created_at.desc()).limit(5).all()
    
    return render_template('manager/analytics.html',
                         manager=current_manager,
                         clients_count=clients_count,
                         collections_count=collections_count,
                         sent_collections=sent_collections,
                         monthly_collections=monthly_collections,
                         client_stats=client_stats,
                         recent_collections=recent_collections)

@app.route('/manager/search-properties', methods=['POST'])
@manager_required
def manager_search_properties():
    """Search properties for collection"""
    import json
    
    data = request.get_json()
    min_price = data.get('min_price')
    max_price = data.get('max_price')
    rooms = data.get('rooms')
    
    try:
        with open('data/properties.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        filtered_properties = []
        for prop in properties_data:
            # Apply filters
            if min_price and prop['price'] < int(min_price):
                continue
            if max_price and prop['price'] > int(max_price):
                continue
            if rooms and str(prop['rooms']) != str(rooms):
                continue
                
            filtered_properties.append({
                'id': prop_orm.inner_id or str(prop_orm.id),
                'title': f"{prop.get('rooms', 0)}-–∫–æ–º–Ω {prop.get('area', 0)} –º¬≤" if prop.get('rooms', 0) > 0 else f"–°—Ç—É–¥–∏—è {prop.get('area', 0)} –º¬≤",
                'price': prop['price'],
                'complex_name': prop.get('residential_complex', '–ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω'),
                'rooms': prop['rooms'],
                'size': prop.get('area', 0)
            })
        
        return jsonify({'properties': filtered_properties[:50]})
    except Exception as e:
        return jsonify({'error': str(e)}), 400

# Additional API routes for collection management
@app.route('/api/manager/collection/<int:collection_id>/send', methods=['POST'])
@manager_required
def api_send_collection(collection_id):
    """Send collection to client"""
    from models import Collection
    
    current_manager = current_user
    collection = Collection.query.filter_by(id=collection_id, created_by_manager_id=current_manager.id).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    if not collection.assigned_to_user_id:
        return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω'}), 400
    
    try:
        collection.status = '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞'
        collection.sent_at = datetime.utcnow()
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collection/<int:collection_id>/delete', methods=['DELETE'])
@manager_required 
def api_delete_collection(collection_id):
    """Delete collection"""
    from models import Collection
    
    current_manager = current_user
    collection = Collection.query.filter_by(id=collection_id, created_by_manager_id=current_manager.id).first()
    
    if not collection:
        return jsonify({'success': False, 'error': '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    try:
        db.session.delete(collection)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# Manager Saved Searches API routes
@app.route('/api/manager/saved-searches')
@manager_required
def get_manager_saved_searches():
    """Get manager's saved searches"""
    from models import ManagerSavedSearch
    
    current_manager = current_user
    try:
        searches = ManagerSavedSearch.query.filter_by(manager_id=current_manager.id).order_by(ManagerSavedSearch.last_used.desc()).all()
        searches_list = [search.to_dict() for search in searches]
        
        return jsonify({
            'success': True,
            'searches': searches_list,
            'count': len(searches_list)
        })
    except Exception as e:
        print(f"Error loading manager saved searches: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/saved-searches', methods=['POST'])
@manager_required
@csrf.exempt  # Temporarily disabled for debugging
def create_manager_saved_search():
    """Create a new saved search for manager"""
    from models import ManagerSavedSearch
    import json
    
    print(f"DEBUG: ===== create_manager_saved_search API CALLED =====")
    print(f"DEBUG: Method: {request.method}")
    print(f"DEBUG: Path: {request.path}")
    # Log safe headers only (no cookies/tokens)
    safe_headers = {k: v for k, v in request.headers.items() if k.lower() not in ['cookie', 'authorization']}
    print(f"DEBUG: Headers: {safe_headers}")
    
    current_manager = current_user
    print(f"DEBUG: Manager ID: {current_manager.id}")
    
    data = request.get_json()
    print(f"DEBUG: Raw request JSON: {data}")
    print(f"DEBUG: JSON type: {type(data)}")
    
    try:
        # Extract filters from the request
        filters = data.get('filters', {})
        print(f"DEBUG: Creating manager search with filters: {filters}")
        print(f"DEBUG: Full request data: {data}")
        print(f"DEBUG: Filters type: {type(filters)}")
        print(f"DEBUG: Filters empty check: {bool(filters)}")
        
        # Test if filters is actually empty - force some test data if needed
        if not filters or not any(filters.values()):
            print("DEBUG: Filters are empty, checking raw JSON...")
            raw_json = request.get_data(as_text=True)
            print(f"DEBUG: Raw request body: {raw_json}")
        
        filters_json = json.dumps(filters) if filters else None
        print(f"DEBUG: Filters JSON: {filters_json}")
        
        # Create new search
        search = ManagerSavedSearch(
            manager_id=current_manager.id,
            name=data.get('name'),
            description=data.get('description'),
            search_type=data.get('search_type', 'properties'),
            additional_filters=filters_json,
            is_template=data.get('is_template', False)
        )
        
        db.session.add(search)
        db.session.commit()
        print(f"DEBUG: Saved search with ID: {search.id}, additional_filters: {search.additional_filters}")
        
        # Verify the saved data
        db.session.refresh(search)
        print(f"DEBUG: Refreshed search additional_filters: {search.additional_filters}")
        
        return jsonify({
            'success': True,
            'search': search.to_dict(),
            'message': '–ü–æ–∏—Å–∫ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω—ë–Ω'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Error creating manager saved search: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-search', methods=['POST'])
@manager_required
@csrf.exempt  # Temporarily disabled for debugging
def send_search_to_client():
    """Send manager's saved search to a client"""
    from models import ManagerSavedSearch, SentSearch, User, SavedSearch, UserNotification
    from email_service import send_notification
    import json
    
    current_manager = current_user
    data = request.get_json()
    
    try:
        search_id = data.get('search_id')
        client_id = data.get('client_id')
        message = data.get('message', '')
        
        # Get manager search
        manager_search = ManagerSavedSearch.query.filter_by(id=search_id, manager_id=current_manager.id).first()
        if not manager_search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
            
        # Get client
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
            
        # Create SavedSearch for client (copy ALL fields from manager search)
        # Parse additional_filters JSON to extract individual filter fields
        parsed_filters = {}
        if manager_search.additional_filters:
            try:
                parsed_filters = json.loads(manager_search.additional_filters)
            except (json.JSONDecodeError, TypeError):
                parsed_filters = {}
        
        # Extract values: prefer dedicated columns, fall back to additional_filters JSON
        def get_filter(field, json_keys=None, cast_type=None):
            val = getattr(manager_search, field, None)
            if val is not None:
                return val
            if json_keys:
                for key in json_keys:
                    v = parsed_filters.get(key)
                    if v is not None and v != '' and v != []:
                        if cast_type:
                            try:
                                return cast_type(v)
                            except (ValueError, TypeError):
                                pass
                        return v
            return None
        
        # Get rooms/property_type from filters
        rooms = parsed_filters.get('rooms', [])
        rooms_str = None
        if rooms:
            if isinstance(rooms, list):
                rooms_str = ','.join(str(r) for r in rooms)
            else:
                rooms_str = str(rooms)
        
        client_search = SavedSearch(
            user_id=client_id,
            name=f"–û—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {manager_search.name}",
            description=f"{manager_search.description or ''}\n\n{message}".strip(),
            search_type=manager_search.search_type or 'properties',
            location=get_filter('location', ['location', 'district']),
            property_type=rooms_str or get_filter('property_type', ['property_type']),
            price_min=get_filter('price_min', ['price_min', 'priceMin'], int),
            price_max=get_filter('price_max', ['price_max', 'priceMax'], int),
            size_min=get_filter('size_min', ['size_min', 'areaMin', 'area_min'], float),
            size_max=get_filter('size_max', ['size_max', 'areaMax', 'area_max'], float),
            developer=get_filter('developer', ['developer', 'developers']),
            complex_name=get_filter('complex_name', ['complex_name', 'residential_complex']),
            floor_min=get_filter('floor_min', ['floor_min', 'floorMin'], int),
            floor_max=get_filter('floor_max', ['floor_max', 'floorMax'], int),
            cashback_min=get_filter('cashback_min', ['cashback_min'], int),
            additional_filters=manager_search.additional_filters,
            notify_new_matches=True
        )
        
        db.session.add(client_search)
        db.session.flush()  # Get the ID before final commit
        
        # Create sent search record
        sent_search = SentSearch(
            manager_id=current_manager.id,
            client_id=client_id,
            manager_search_id=search_id,
            name=manager_search.name,
            description=manager_search.description,
            additional_filters=manager_search.additional_filters,
            status='sent'
        )
        
        db.session.add(sent_search)
        db.session.flush()  # Get sent_search ID
        
        # Note: client_search is now created and linked via sent_search record
        
        # Update usage count
        manager_search.usage_count = (manager_search.usage_count or 0) + 1
        manager_search.last_used = datetime.utcnow()
        
        # Create notification for client
        notification = UserNotification(
            user_id=client_id,
            title="–ù–æ–≤—ã–π –ø–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞",
            message=f"–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä –æ—Ç–ø—Ä–∞–≤–∏–ª –≤–∞–º –ø–æ–∏—Å–∫: {manager_search.name}",
            notification_type='info',
            icon='fas fa-search',
            action_url='/dashboard'
        )
        
        db.session.add(notification)
        
        # –õ–æ–≥–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É –ø–æ–∏—Å–∫–∞
        from models import UserActivity
        UserActivity.log_activity(
            user_id=client_id,
            activity_type='search_received',
            description=f'–ü–æ–ª—É—á–µ–Ω –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {manager_search.name}'
        )
        
        db.session.commit()
        
        # Send email notification
        try:
            send_notification(
                client.email,
                f"–ù–æ–≤—ã–π –ø–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {manager_search.name}",
                f"–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä –æ—Ç–ø—Ä–∞–≤–∏–ª –≤–∞–º –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏.\n\n"
                f"–ù–∞–∑–≤–∞–Ω–∏–µ: {manager_search.name}\n"
                f"–û–ø–∏—Å–∞–Ω–∏–µ: {manager_search.description or '–ë–µ–∑ –æ–ø–∏—Å–∞–Ω–∏—è'}\n\n"
                f"{message}\n\n"
                f"–í–æ–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞: https://{request.host}/dashboard",
                user_id=client_id,
                notification_type='search_received'
            )
        except Exception as e:
            print(f"Error sending email notification: {e}")
        
        return jsonify({
            'success': True,
            'message': '–ü–æ–∏—Å–∫ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∫–ª–∏–µ–Ω—Ç—É'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error sending search to client: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/saved-search/<int:search_id>', methods=['DELETE'])
@manager_required
@csrf.exempt
def delete_manager_saved_search(search_id):
    """Delete manager's saved search"""
    from models import ManagerSavedSearch
    
    current_manager = current_user
    
    try:
        search = ManagerSavedSearch.query.filter_by(id=search_id, manager_id=current_manager.id).first()
        if not search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
            
        db.session.delete(search)
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–ü–æ–∏—Å–∫ —É–¥–∞–ª—ë–Ω'})
        
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting manager saved search: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

# Developer appointment routes
@app.route('/book-appointment', methods=['GET', 'POST'])
@login_required
def book_appointment():
    """Book appointment with developer"""
    if request.method == 'POST':
        from models import DeveloperAppointment, BalanceTransaction
        from datetime import datetime
        
        property_id = request.form.get('property_id')
        developer_name = request.form.get('developer_name')
        complex_name = request.form.get('complex_name')
        appointment_date = request.form.get('appointment_date')
        appointment_time = request.form.get('appointment_time')
        client_name = request.form.get('client_name')
        client_phone = request.form.get('client_phone')
        notes = request.form.get('notes', '')
        
        try:
            appointment = DeveloperAppointment(
                user_id=current_user.id,
                property_id=property_id,
                developer_name=developer_name,
                complex_name=complex_name,
                appointment_date=datetime.strptime(appointment_date, '%Y-%m-%d'),
                appointment_time=appointment_time,
                client_name=client_name,
                client_phone=client_phone,
                notes=notes
            )
            
            db.session.add(appointment)
            db.session.commit()
            
            flash('–ó–∞–ø–∏—Å—å –∫ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫—É —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞! –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.', 'success')
            return redirect(url_for('dashboard'))
            
        except Exception as e:
            db.session.rollback()
            flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞–ø–∏—Å–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.', 'error')
    
    # Get property data if property_id provided
    property_data = None
    property_id = request.args.get('property_id')
    if property_id:
        properties = load_properties()
        for prop in properties:
            if str(prop.get('id')) == property_id:
                property_data = prop
                break
    
    return render_template('book_appointment.html', property_data=property_data)

@app.route('/api/manager/client/<int:client_id>/send-credentials', methods=['POST'])
@manager_required
def api_send_client_credentials(client_id):
    import secrets
    import string
    from werkzeug.security import generate_password_hash

    try:
        current_manager = current_user
        data = request.get_json() or {}
        method = data.get('method', 'email')

        user = User.query.get(client_id)
        if not user:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404

        if user.assigned_manager_id != current_manager.id:
            role = current_manager.org_role
            can_all = role.can_view_all_deals if role else False
            if not can_all:
                return jsonify({'success': False, 'error': '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –∫–ª–∏–µ–Ω—Ç—É'}), 403

        temp_password = ''.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(8))

        login_url = f"{request.url_root.rstrip('/')}/login"
        manager_name = current_manager.full_name or '–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä'
        client_name = user.full_name or '–£–≤–∞–∂–∞–µ–º—ã–π –∫–ª–∏–µ–Ω—Ç'
        email_login = user.email or ''
        phone_login = user.phone or ''
        login_identifier = email_login or phone_login

        sent = False
        error_msg = ''

        if method == 'email':
            if not user.email:
                return jsonify({'success': False, 'error': '–£ –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω email'}), 400
            try:
                from email_service import send_email
                subject = "–î–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç InBack.ru"
                sent = send_email(
                    to_email=user.email,
                    subject=subject,
                    template_name='emails/credentials.html',
                    client_name=client_name,
                    email_login=email_login,
                    temp_password=temp_password,
                    login_url=login_url,
                    manager_name=manager_name
                )
                if not sent:
                    error_msg = '–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å email'
            except Exception as e:
                print(f"Error sending credentials email: {e}")
                error_msg = f'–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ email: {str(e)}'

        elif method == 'sms':
            if not user.phone:
                return jsonify({'success': False, 'error': '–£ –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω —Ç–µ–ª–µ—Ñ–æ–Ω'}), 400
            try:
                from sms_service import sms_service
                sms_message = f"InBack.ru - –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞:\n–õ–æ–≥–∏–Ω: {login_identifier}\n–ü–∞—Ä–æ–ª—å: {temp_password}\n–í—Ö–æ–¥: {login_url}"
                sms_result = sms_service.send_sms(user.phone, sms_message)
                sent = sms_result.get('success', False)
                if not sent:
                    error_msg = sms_result.get('message', '–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å SMS')
            except Exception as e:
                print(f"Error sending credentials SMS: {e}")
                error_msg = f'–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ SMS: {str(e)}'
        else:
            return jsonify({'success': False, 'error': '–ù–µ–≤–µ—Ä–Ω—ã–π –º–µ—Ç–æ–¥ –æ—Ç–ø—Ä–∞–≤–∫–∏'}), 400

        if sent:
            user.set_password(temp_password)
            user.must_change_password = True
            db.session.commit()
            method_label = 'email' if method == 'email' else 'SMS'
            return jsonify({
                'success': True,
                'message': f'–î–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –∫–ª–∏–µ–Ω—Ç—É —á–µ—Ä–µ–∑ {method_label}'
            })
        else:
            return jsonify({
                'success': False,
                'error': error_msg or '–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ. –ü–∞—Ä–æ–ª—å –Ω–µ –±—ã–ª –∏–∑–º–µ–Ω—ë–Ω.'
            }), 500

    except Exception as e:
        db.session.rollback()
        print(f"Error in send_client_credentials: {e}")
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}'}), 500


@app.route('/api/manager/add-client-old', methods=['POST'])
@manager_required
def add_client():
    """Add new client (old version - deprecated)"""
    from models import User
    import re
    from werkzeug.security import generate_password_hash
    import secrets
    
    data = request.get_json()
    first_name = data.get('first_name')
    last_name = data.get('last_name') 
    email = data.get('email')
    phone = data.get('phone')
    
    if not all([first_name, last_name, email]):
        return jsonify({'success': False, 'error': '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è'}), 400
    
    # Check if user exists by email
    existing_user = User.query.filter_by(email=email).first()
    if existing_user:
        return jsonify({'success': False, 'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'}), 400
    
    # Check if phone already exists (normalized comparison like registration)
    if phone:
        from sqlalchemy import func as sqlfunc
        phone_digits = re.sub(r'[^0-9]', '', phone) if phone else ''
        if phone_digits:
            existing_phone_user = User.query.filter(
                sqlfunc.replace(sqlfunc.replace(sqlfunc.replace(User.phone, "-", ""), " ", ""), "+", "") == phone_digits
            ).first()
            if existing_phone_user:
                return jsonify({'success': False, 'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'}), 400
    
    try:
        # Generate user ID and password
        user_id = secrets.token_hex(4).upper()
        password = 'demo123'  # Default password
        password_hash = generate_password_hash(password)
        
        current_manager = current_user
        
        user = User(
            is_verified=True,  # Auto-verify
            first_name=first_name,
            last_name=last_name,
            email=email,
            phone=phone,
            password_hash=password_hash,
            user_id=user_id,
            assigned_manager_id=current_manager.id,
            client_status='–ù–æ–≤—ã–π'
        )
        
        db.session.add(user)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'user': {
                'id': user.id,
                'full_name': user.full_name,
                'email': user.email,
                'phone': user.phone,
                'user_id': user.user_id,
                'password': password,
                'client_status': user.client_status
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/request-payout', methods=['POST'])
@login_required
def api_request_payout():
    """Request cashback payout"""
    from models import User, CashbackPayout
    from datetime import datetime
    
    try:
        user_id = current_user.id
        
        # Check if user has available cashback
        user = User.query.get(user_id)
        if not user:
            return jsonify({'success': False, 'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω'})
        
        # For demo purposes, assume available cashback of 125,000
        available_cashback = 125000
        
        if available_cashback <= 0:
            return jsonify({'success': False, 'error': '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –∫–µ—à–±–µ–∫–∞ –¥–ª—è –≤—ã–ø–ª–∞—Ç—ã'})
        
        # Create payout request
        payout = CashbackPayout(
            user_id=user_id,
            amount=available_cashback,
            status='–ó–∞–ø—Ä–æ—à–µ–Ω–∞',
            requested_at=datetime.utcnow()
        )
        
        db.session.add(payout)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ó–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–ø–ª–∞—Ç—É —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω',
            'amount': available_cashback
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)})



# Error handlers
@app.errorhandler(404)
def not_found_error(error):
    """Handle 404 errors"""
    return render_template('errors/404.html'), 404

@app.errorhandler(500)
def internal_error(error):
    """Handle 500 errors"""
    db.session.rollback()
    return render_template('errors/500.html'), 500

@app.errorhandler(Exception)
def handle_exception(e):
    """Handle all other exceptions"""
    db.session.rollback()
    return render_template('errors/500.html'), 500

# City management API endpoints
@app.route('/api/change-city', methods=['POST'])
def change_city():
    """API endpoint to change current city"""
    try:
        from models import City
        
        data = request.get_json()
        city_slug = data.get('city_slug')
        city_name = data.get('city_name')
        
        if not city_slug:
            return jsonify({'success': False, 'message': 'Missing city data'})
        
        # Validate city exists in database
        city = City.query.filter_by(slug=city_slug, is_active=True).first()
        if not city:
            return jsonify({'success': False, 'message': 'City not found or inactive'})
        
        # Store city data in session
        session['city_id'] = city.id
        session['city_slug'] = city.slug
        session['city_name'] = city.name
        # Keep backward compatibility with old session keys
        session['current_city'] = city.name
        session['current_city_slug'] = city.slug
        
        return jsonify({
            'success': True,
            'message': f'City changed to {city.name}',
            'city': {
                'id': city.id,
                'name': city.name,
                'slug': city.slug
            }
        })
        
    except Exception as e:
        return jsonify({'success': False, 'message': 'Error changing city'})


@app.route('/api/cities')
def get_cities():
    """Get available cities with property counts, hide cities without properties"""
    try:
        from models import City, Property
        from sqlalchemy import func
        
        # Get cities with property counts
        cities_with_counts = db.session.query(
            City,
            func.count(Property.id).label('property_count')
        ).outerjoin(
            Property, 
            (Property.city_id == City.id) & (Property.is_active == True)
        ).filter(
            City.is_active == True
        ).group_by(
            City.id
        ).order_by(
            func.count(Property.id).desc()
        ).all()
        
        logging.debug(f"Found {len(cities_with_counts)} cities in database")
        
        cities_data = []
        for city, property_count in cities_with_counts:
            # Skip cities without properties (but always include default city)
            if property_count == 0 and not city.is_default:
                logging.debug(f"Skipping city {city.name} - no properties")
                continue
                
            cities_data.append({
                'id': city.id,
                'name': city.name,
                'slug': city.slug,
                'is_default': city.is_default,
                'address_position_lat': city.latitude,
                'address_position_lon': city.longitude,
                'zoom_level': city.zoom_level,
                'property_count': property_count
            })
            
            logging.debug(f"Added city: {city.name} (id={city.id}, properties={property_count})")
        logging.debug(f"Returning {len(cities_data)} cities to client")
        return jsonify({'cities': cities_data})
        
    except Exception as e:
        logging.error(f"Error fetching cities: {str(e)}", exc_info=True)
        # Fallback data if database not set up yet
        return jsonify({
            'cities': [
                {
                    'id': 1,
                    'name': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
                    'slug': 'krasnodar',
                    'is_default': True,
                    'address_position_lat': 45.0355,
                    'address_position_lon': 38.9753,
                    'zoom_level': 12
                }
            ]
        })



@app.route('/api/districts/<int:city_id>')
def get_districts_by_city(city_id):
    """Get all districts for a specific city from District reference table"""
    try:
        from models import District
        
        # Build query with city filter
        query = District.query.filter_by(city_id=city_id)
        
        # Special filtering for Sochi (city_id=2) - only admin districts
        # Other cities get ALL districts (admin + micro)
        if city_id == 2:
            query = query.filter_by(district_type='admin')
        
        districts = query.order_by(District.name).all()
        
        district_type_msg = "admin only" if city_id == 2 else "all (admin + micro)"
        logging.debug(f"‚úÖ Found {len(districts)} districts ({district_type_msg}) for city {city_id}")
        
        return jsonify({
            'success': True,
            'count': len(districts),
            'districts': [d.name for d in districts]
        })
        
    except Exception as e:
        logging.error(f"‚ùå Error fetching districts for city {city_id}: {str(e)}", exc_info=True)
        return jsonify({
            'success': False,
            'districts': [],
            'count': 0,
            'error': str(e)
        }), 500

        
def init_cities():
    """Initialize default cities in database"""
    try:
        from models import City
        
        # Check if cities already exist
        if City.query.count() == 0:
            cities_data = [
                {
                    'name': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä',
                    'slug': 'krasnodar',
                    'is_active': True,
                    'is_default': True,
                    'phone': '8 (862) 266-62-16',
                    'email': 'krasnodar@inback.ru',
                    'address': '–≥. –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä, —É–ª. –ö—Ä–∞—Å–Ω–∞—è, 32',
                    'address_position_lat': 45.0355,
                    'address_position_lon': 38.9753,
                    'zoom_level': 12,
                    'description': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–µ',
                    'meta_title': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–µ | InBack.ru',
                    'meta_description': '–ü–æ–ª—É—á–∏—Ç–µ –¥–æ 10% –∫—ç—à–±–µ–∫–∞ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä–µ. –ü—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∏, —é—Ä–∏–¥–∏—á–µ—Å–∫–æ–µ —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ.'
                },
                {
                    'name': '–ú–æ—Å–∫–≤–∞',
                    'slug': 'moscow',
                    'is_active': False,
                    'is_default': False,
                    'phone': '8 (862) 266-62-16',
                    'email': 'moscow@inback.ru',
                    'address': '–≥. –ú–æ—Å–∫–≤–∞, —É–ª. –¢–≤–µ—Ä—Å–∫–∞—è, 1',
                    'address_position_lat': 55.7558,
                    'address_position_lon': 37.6176,
                    'zoom_level': 11,
                    'description': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –ú–æ—Å–∫–≤–µ (—Å–∫–æ—Ä–æ)',
                    'meta_title': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –ú–æ—Å–∫–≤–µ | InBack.ru',
                    'meta_description': '–°–∫–æ—Ä–æ: –∫—ç—à–±–µ–∫ —Å–µ—Ä–≤–∏—Å –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –Ω–æ–≤–æ—Å—Ç—Ä–æ–µ–∫ –≤ –ú–æ—Å–∫–≤–µ.'
                },
                {
                    'name': '–°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥',
                    'slug': 'spb',
                    'is_active': False,
                    'is_default': False,
                    'phone': '8 (862) 266-62-16',
                    'email': 'spb@inback.ru',
                    'address': '–≥. –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥, –ù–µ–≤—Å–∫–∏–π –ø—Ä., 1',
                    'address_position_lat': 59.9311,
                    'address_position_lon': 30.3609,
                    'zoom_level': 11,
                    'description': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥–µ (—Å–∫–æ—Ä–æ)',
                    'meta_title': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –°–ü–± | InBack.ru',
                    'meta_description': '–°–∫–æ—Ä–æ: –∫—ç—à–±–µ–∫ —Å–µ—Ä–≤–∏—Å –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –Ω–æ–≤–æ—Å—Ç—Ä–æ–µ–∫ –≤ –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥–µ.'
                },
                {
                    'name': '–°–æ—á–∏',
                    'slug': 'sochi',
                    'is_active': False,
                    'is_default': False,
                    'phone': '8 (862) 266-62-16',
                    'email': 'sochi@inback.ru',
                    'address': '–≥. –°–æ—á–∏, —É–ª. –ö—É—Ä–æ—Ä—Ç–Ω—ã–π –ø—Ä., 1',
                    'address_position_lat': 43.6028,
                    'address_position_lon': 39.7342,
                    'zoom_level': 12,
                    'description': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –°–æ—á–∏ (—Å–∫–æ—Ä–æ)',
                    'meta_title': '–ö—ç—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏ –≤ –°–æ—á–∏ | InBack.ru',
                    'meta_description': '–°–∫–æ—Ä–æ: –∫—ç—à–±–µ–∫ —Å–µ—Ä–≤–∏—Å –¥–ª—è –ø–æ–∫—É–ø–∫–∏ –Ω–æ–≤–æ—Å—Ç—Ä–æ–µ–∫ –≤ –°–æ—á–∏.'
                }
            ]
            
            for city_data in cities_data:
                city = City(**city_data)
                db.session.add(city)
            
            db.session.commit()
            print("Cities initialized successfully")
            
    except Exception as e:
        print(f"Error initializing cities: {e}")

# Legacy API route removed - using Blueprint version instead

@api_bp.route('/searches', methods=['POST'])
def save_search():
    """Save user search parameters with manager-to-client sharing functionality"""
    from models import SavedSearch, User
    data = request.get_json()
    
    # Check authentication using helper function
    auth_info = check_api_authentication()
    if not auth_info:
        return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    
    user_id = auth_info['user_id']
    user_role = auth_info['type']
    current_logged_user = auth_info['user']
    
    try:
        client_email = data.get('client_email')  # For managers
        
        print(f"DEBUG: Saving search with raw data: {data}")
        
        # Create filter object from submitted data
        filters = {}
        
        # Check if filters are nested in 'filters' object
        filter_data = data.get('filters', {}) if 'filters' in data else data
        
        # Extract filters from the data (new format)
        if 'rooms' in filter_data and filter_data['rooms']:
            if isinstance(filter_data['rooms'], list):
                room_list = [r for r in filter_data['rooms'] if r]  # Remove empty strings
                if room_list:
                    filters['rooms'] = room_list
            elif filter_data['rooms']:
                filters['rooms'] = [filter_data['rooms']]
                
        if 'districts' in filter_data and filter_data['districts']:
            if isinstance(filter_data['districts'], list):
                district_list = [d for d in filter_data['districts'] if d]  # Remove empty strings
                if district_list:
                    filters['districts'] = district_list
            elif filter_data['districts']:
                filters['districts'] = [filter_data['districts']]
                
        if 'developers' in filter_data and filter_data['developers']:
            if isinstance(filter_data['developers'], list):
                developer_list = [d for d in filter_data['developers'] if d]  # Remove empty strings
                if developer_list:
                    filters['developers'] = developer_list
            elif filter_data['developers']:
                filters['developers'] = [filter_data['developers']]
                
        if 'completion' in filter_data and filter_data['completion']:
            if isinstance(filter_data['completion'], list):
                completion_list = [c for c in filter_data['completion'] if c]  # Remove empty strings
                if completion_list:
                    filters['completion'] = completion_list
            elif filter_data['completion']:
                filters['completion'] = [filter_data['completion']]
                
        if 'priceFrom' in filter_data and filter_data['priceFrom'] and str(filter_data['priceFrom']) not in ['0', '']:
            filters['priceFrom'] = str(filter_data['priceFrom'])
        if 'priceTo' in filter_data and filter_data['priceTo'] and str(filter_data['priceTo']) not in ['0', '']:
            filters['priceTo'] = str(filter_data['priceTo'])
        if 'areaFrom' in filter_data and filter_data['areaFrom'] and str(filter_data['areaFrom']) not in ['0', '']:
            filters['areaFrom'] = str(filter_data['areaFrom'])
        if 'areaTo' in filter_data and filter_data['areaTo'] and str(filter_data['areaTo']) not in ['0', '']:
            filters['areaTo'] = str(filter_data['areaTo'])
            
        print(f"DEBUG: Extracted filters from {filter_data}: {filters}")

        # Create search with new format
        search = SavedSearch(
            user_id=user_id,
            name=data['name'],
            description=data.get('description'),
            search_type='properties',
            additional_filters=json.dumps(filters),
            notify_new_matches=data.get('notify_new_matches', True)
        )

        # Also save in legacy format for backwards compatibility
        if 'rooms' in data and data['rooms']:
            if isinstance(data['rooms'], list) and len(data['rooms']) > 0:
                search.property_type = data['rooms'][0]  # Use first room type
            else:
                search.property_type = data['rooms']
        if 'priceTo' in data and data['priceTo']:
            try:
                search.price_max = int(float(data['priceTo']) * 1000000)  # Convert millions to rubles
            except (ValueError, TypeError):
                pass
        if 'priceFrom' in data and data['priceFrom']:
            try:
                search.price_min = int(float(data['priceFrom']) * 1000000)  # Convert millions to rubles
            except (ValueError, TypeError):
                pass
        
        db.session.add(search)
        db.session.commit()
        
        # If manager specified client email, send search to client  
        if user_role == 'manager' and client_email:
            try:
                # Check if client exists
                client = User.query.filter_by(email=client_email).first()
                
                # If client exists, also save search to their account
                if client:
                    client_search = SavedSearch(
                        user_id=client.id,
                        name=data['name'] + ' (–æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞)',
                        description=data.get('description'),
                        search_type='properties',
                        location=data.get('location'),
                        property_type=data.get('property_type'),
                        price_min=data.get('price_min'),
                        price_max=data.get('price_max'),
                        size_min=data.get('size_min'),
                        size_max=data.get('size_max'),
                        developer=data.get('developer'),
                        complex_name=data.get('complex_name'),
                        floor_min=data.get('floor_min'),
                        floor_max=data.get('floor_max'),
                        additional_filters=json.dumps(filters),
                        notify_new_matches=True
                    )
                    db.session.add(client_search)
                    db.session.commit()
                
                # Prepare search URL for client properties page  
                search_params = []
                
                # Convert manager filter format to client filter format
                if data.get('location'):
                    search_params.append(f"district={data['location']}")
                if data.get('developer'):
                    search_params.append(f"developer={data['developer']}")
                if data.get('property_type'):
                    search_params.append(f"rooms={data['property_type']}")
                if data.get('complex_name'):
                    search_params.append(f"complex={data['complex_name']}")
                if data.get('price_min'):
                    search_params.append(f"priceFrom={data['price_min'] / 1000000}")
                if data.get('price_max'):
                    search_params.append(f"priceTo={data['price_max'] / 1000000}")
                if data.get('size_min'):
                    search_params.append(f"areaFrom={data['size_min']}")
                if data.get('size_max'):
                    search_params.append(f"areaTo={data['size_max']}")
                
                search_url = f"{request.url_root}properties"
                if search_params:
                    search_url += "?" + "&".join(search_params)
                
                # Email content for client
                subject = f"–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {data['name']}"
                
                # Generate filter description for email
                filter_descriptions = []
                if data.get('property_type'):
                    filter_descriptions.append(f"–¢–∏–ø: {data['property_type']}")
                if data.get('location'):
                    filter_descriptions.append(f"–†–∞–π–æ–Ω: {data['location']}")
                if data.get('developer'):
                    filter_descriptions.append(f"–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫: {data['developer']}")
                if data.get('price_min') or data.get('price_max'):
                    price_min = f"{(data.get('price_min', 0) / 1000000):.1f}" if data.get('price_min') else "0"
                    price_max = f"{(data.get('price_max', 0) / 1000000):.1f}" if data.get('price_max') else "‚àû"
                    filter_descriptions.append(f"–¶–µ–Ω–∞: {price_min}-{price_max} –º–ª–Ω ‚ÇΩ")
                if data.get('size_min') or data.get('size_max'):
                    area_min = str(data.get('size_min', 0)) if data.get('size_min') else "0"
                    area_max = str(data.get('size_max', 0)) if data.get('size_max') else "‚àû"
                    filter_descriptions.append(f"–ü–ª–æ—â–∞–¥—å: {area_min}-{area_max} –º¬≤")
                
                filter_text = "<br>".join([f"‚Ä¢ {desc}" for desc in filter_descriptions])
                
                html_content = f"""
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2 style="color: #0088CC;">–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –æ—Ç InBack</h2>
                    
                    <p>–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ!</p>
                    
                    <p>–ú–µ–Ω–µ–¥–∂–µ—Ä <strong>{current_user.full_name or current_user.username}</strong> –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –¥–ª—è –≤–∞—Å –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—É—é –ø–æ–¥–±–æ—Ä–∫—É –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏.</p>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h3 style="margin: 0 0 15px 0; color: #333;">–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞: {data['name']}</h3>
                        <div style="color: #666; line-height: 1.6;">
                            {filter_text}
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin: 30px 0;">
                        <a href="{search_url}" style="display: inline-block; background: #0088CC; color: white; padding: 15px 30px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                            –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ–¥–±–æ—Ä–∫—É
                        </a>
                    </div>
                    
                    <p style="color: #666; font-size: 14px;">
                        –ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å—ã, —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –≤–∞—à–∏–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º:<br>
                        <strong>{current_logged_user.full_name if hasattr(current_logged_user, 'full_name') else current_logged_user.email}</strong><br>
                        Email: {current_logged_user.email}
                    </p>
                    
                    <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
                    <p style="color: #999; font-size: 12px; text-align: center;">
                        InBack - –≤–∞—à –Ω–∞–¥–µ–∂–Ω—ã–π –ø–∞—Ä—Ç–Ω–µ—Ä –≤ –ø–æ–∏—Å–∫–µ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏
                    </p>
                </div>
                """
                
                # Send email using existing email service
                from email_service import send_email
                email_sent = send_email(
                    to_email=client_email,
                    subject=subject,
                    html_content=html_content,
                    template_name='collection'
                )
                
                if email_sent:
                    return jsonify({
                        'success': True, 
                        'search_id': search.id, 
                        'search': search.to_dict(),
                        'message': f'–ü–æ–∏—Å–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∫–ª–∏–µ–Ω—Ç—É –Ω–∞ {client_email}',
                        'email_sent': True
                    })
                else:
                    return jsonify({
                        'success': True, 
                        'search_id': search.id, 
                        'search': search.to_dict(),
                        'message': '–ü–æ–∏—Å–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å email –∫–ª–∏–µ–Ω—Ç—É',
                        'email_sent': False
                    })
                    
            except Exception as email_error:
                # Still return success for saved search even if email fails
                print(f"Email sending error: {email_error}")
                return jsonify({
                    'success': True, 
                    'search_id': search.id, 
                    'search': search.to_dict(),
                    'message': '–ü–æ–∏—Å–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω, –Ω–æ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ email',
                    'email_sent': False,
                    'email_error': str(email_error)
                })
        
        return jsonify({'success': True, 'search_id': search.id, 'search': search.to_dict()})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

def check_api_authentication():
    """Helper function to check API authentication for both users and managers"""
    # Check if manager is logged in
    if 'manager_id' in session:
        from models import Manager
        manager = Manager.query.get(session['manager_id'])
        if manager:
            return {'type': 'manager', 'user_id': manager.id, 'user': manager}
    
    # Check if regular user is logged in  
    if current_user and hasattr(current_user, 'is_authenticated') and current_user.is_authenticated:
        return {'type': 'user', 'user_id': current_user.id, 'user': current_user}
    
    # Also check session for user_id (alternative authentication method)
    if 'user_id' in session:
        from models import User
        user = User.query.get(session['user_id'])
        if user:
            return {'type': 'user', 'user_id': user.id, 'user': user}
    
    return None

@app.route('/api/searches', methods=['GET', 'POST'])
@csrf.exempt
def saved_searches_endpoint():
    """Get or create user's saved searches"""
    from models import SavedSearch
    
    # Check authentication using helper function
    auth_info = check_api_authentication()
    if not auth_info:
        return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    
    if request.method == 'GET':
        # Get saved searches for the authenticated user (manager or regular user) 
        searches = SavedSearch.query.filter_by(user_id=auth_info['user_id']).order_by(SavedSearch.created_at.desc()).all()
        
        return jsonify({
            'success': True,
            'searches': [search.to_dict() for search in searches]
        })
    
    elif request.method == 'POST':
        # Create new saved search
        data = request.get_json()
        name = data.get('name')
        description = data.get('description', '')
        notify_new_matches = data.get('notify_new_matches', False)
        search_type = data.get('search_type', 'properties')
        
        if not name:
            return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–∏—Å–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        
        try:
            # Extract search parameters (exclude metadata fields)
            exclude_fields = {'name', 'description', 'notify_new_matches', 'search_type'}
            search_params = {k: v for k, v in data.items() if k not in exclude_fields and v}
            
            search = SavedSearch()
            search.name = name
            search.description = description
            search.notify_new_matches = notify_new_matches
            search.search_type = search_type
            search.user_id = auth_info['user_id']
            search.created_at = datetime.utcnow()
            
            # Store search parameters as additional_filters JSON
            search.additional_filters = json.dumps(search_params)
            
            # Also set individual fields if they exist in the model
            for key, value in search_params.items():
                if hasattr(search, key):
                    setattr(search, key, value)
            
            db.session.add(search)
            db.session.commit()
            
            return jsonify({'success': True, 'search_id': search.id, 'message': '–ü–æ–∏—Å–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω'})
        except Exception as e:
            db.session.rollback()
            print(f"Error saving search: {e}")
            return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/saved-searches')
@login_required
def get_user_saved_searches():
    """Get user's saved searches"""
    from models import SavedSearch
    
    try:
        searches = SavedSearch.query.filter_by(user_id=current_user.id)\
            .order_by(SavedSearch.created_at.desc()).all()
        
        return jsonify({
            'success': True,
            'searches': [search.to_dict() for search in searches]
        })
    except Exception as e:
        print(f"Error loading user saved searches: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/saved-searches', methods=['POST'])
@login_required
@csrf.exempt
def create_user_saved_search():
    """Create a new saved search for user"""
    from models import SavedSearch
    import json
    
    data = request.get_json()
    
    try:
        filters = data.get('filters', {})
        
        if not filters:
            filter_keys = ['rooms', 'districts', 'developers', 'completion', 'object_classes', 
                          'renovation', 'features', 'building_released', 'floor_options',
                          'regions', 'cities',
                          'price_min', 'price_max', 'area_min', 'area_max', 
                          'floor_min', 'floor_max', 'building_floors_min', 'building_floors_max',
                          'priceFrom', 'priceTo', 'areaFrom', 'areaTo', 'floorFrom', 'floorTo',
                          'property_type', 'search_url']
            filters = {k: v for k, v in data.items() if k in filter_keys and v}
        
        search_url = data.get('search_url') or filters.get('search_url', '')
        if search_url:
            filters['search_url'] = search_url
        
        filters_json = json.dumps(filters) if filters else None
        print(f"DEBUG create_user_saved_search: search_url={search_url}")
        
        # Get current city from session or data
        city_id = data.get('city_id') or session.get('city_id') or 1  # Default to city 1 (Sochi)
        
        search = SavedSearch(
            user_id=current_user.id,
            city_id=city_id,
            name=data.get('name'),
            description=data.get('description'),
            search_type=data.get('search_type', 'properties'),
            additional_filters=filters_json,
            notify_new_matches=data.get('notify_new_matches', False)
        )
        
        db.session.add(search)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'search': search.to_dict(),
            'message': '–ü–æ–∏—Å–∫ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω—ë–Ω'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Error creating user saved search: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/saved-searches/<int:search_id>', methods=['DELETE'])
@login_required
@csrf.exempt
def delete_user_saved_search(search_id):
    """Delete user's saved search"""
    from models import SavedSearch
    
    try:
        search = SavedSearch.query.filter_by(id=search_id, user_id=current_user.id).first()
        
        if not search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        db.session.delete(search)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ü–æ–∏—Å–∫ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª—ë–Ω'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting user saved search: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/searches/<int:search_id>/apply', methods=['POST'])
@login_required
def apply_saved_search(search_id):
    """Apply saved search - returns filters for redirect"""
    from models import SavedSearch
    import json
    from datetime import datetime
    
    try:
        search = SavedSearch.query.filter_by(id=search_id, user_id=current_user.id).first()
        if not search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Get filters from the saved search (using additional_filters field)
        filters = {}
        if search.additional_filters:
            try:
                filters = json.loads(search.additional_filters) if isinstance(search.additional_filters, str) else search.additional_filters
            except:
                filters = {}
        
        # Ensure property_type is captured
        if search.property_type and 'property_type' not in filters:
            filters['property_type'] = search.property_type
        elif 'property_type' not in filters:
            # Fallback to a default or check search_url if exists
            pass
            
        # Standardize object_classes vs object_class
        if 'object_class' in filters and 'object_classes' not in filters:
            filters['object_classes'] = filters['object_class']
            
        # Update last_used timestamp
        search.last_used = datetime.utcnow()
        db.session.commit()
        
        # Get city from saved search or filters (handle legacy nested data including lists)
        city_slug = 'sochi'  # default
        if search.city_id:
            from models import City
            city_obj = City.query.get(search.city_id)
            if city_obj:
                city_slug = city_obj.slug
        elif filters.get('city'):
            city_value = filters.get('city')
            if isinstance(city_value, list) and len(city_value) > 0:
                first_item = city_value[0]
                if isinstance(first_item, dict):
                    city_slug = first_item.get('slug') or first_item.get('name') or 'sochi'
                elif isinstance(first_item, str):
                    city_slug = first_item
            elif isinstance(city_value, dict):
                city_slug = city_value.get('slug') or city_value.get('name') or 'sochi'
            elif isinstance(city_value, str):
                city_slug = city_value
        
        search_url = filters.get('search_url', '')
        
        # Ensure array parameters are lists
        for key in ['rooms', 'districts', 'developers', 'object_classes', 'renovation', 'features']:
            if key in filters and not isinstance(filters[key], list):
                filters[key] = [filters[key]]
        
        return jsonify({
            'success': True,
            'filters': filters,
            'city': city_slug,
            'search_url': search_url
        })
    except Exception as e:
        print(f"Error applying saved search: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400
@app.route('/api/user/saved-searches/count')
@login_required
def get_user_saved_searches_count():
    """Get count of user's saved searches"""
    from models import SavedSearch
    
    try:
        count = SavedSearch.query.filter_by(user_id=current_user.id).count()
        return jsonify({
            'success': True,
            'count': count
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400


# ==========================================
# USER NOTIFICATION SETTINGS API ENDPOINTS
# ==========================================

@app.route('/api/user/alert-settings', methods=['GET'])
@login_required
def get_user_alert_settings():
    """Get all user's saved searches with alert settings"""
    from models import SavedSearch, PropertyAlert
    
    searches = db.session.query(SavedSearch)\
        .filter_by(user_id=current_user.id)\
        .order_by(SavedSearch.last_used.desc())\
        .all()
    
    # Enrich each search with alert count
    result = []
    for search in searches:
        search_dict = search.to_dict()
        alert_count = db.session.query(PropertyAlert)\
            .filter_by(saved_search_id=search.id)\
            .count()
        search_dict['alert_count'] = alert_count
        result.append(search_dict)
    
    return jsonify({'success': True, 'searches': result})

@app.route('/api/user/alert-settings', methods=['POST'])
@login_required
@require_json_csrf
def update_user_alert_settings():
    """Update alert settings for a specific saved search"""
    data = request.get_json()
    search_id = data.get('search_id')
    
    if not search_id:
        return jsonify({'success': False, 'error': 'search_id required'}), 400
    
    search = db.session.query(SavedSearch)\
        .filter_by(id=search_id, user_id=current_user.id)\
        .first()
    
    if not search:
        return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    # Update fields
    if 'alert_enabled' in data:
        search.alert_enabled = bool(data['alert_enabled'])
    
    if 'alert_frequency' in data:
        freq = data['alert_frequency']
        if freq not in ['instant', 'daily', 'weekly', 'never']:
            return jsonify({'success': False, 'error': 'Invalid frequency'}), 400
        search.alert_frequency = freq
    
    if 'alert_channels' in data:
        channels = data['alert_channels']
        if not isinstance(channels, list):
            return jsonify({'success': False, 'error': 'Channels must be array'}), 400
        import json
        search.alert_channels = json.dumps(channels)
    
    db.session.commit()
    return jsonify({'success': True, 'search': search.to_dict()})

@app.route('/api/user/unsubscribe/<token>', methods=['GET'])
def unsubscribe_from_alerts(token):
    """Unsubscribe from alerts using token"""
    import jwt
    from models import SavedSearch
    
    try:
        payload = jwt.decode(token, app.secret_key, algorithms=['HS256'])
        user_id = payload.get('user_id')
        search_id = payload.get('search_id')
        
        search = db.session.query(SavedSearch)\
            .filter_by(id=search_id, user_id=user_id)\
            .first()
        
        if search:
            search.alert_enabled = False
            db.session.commit()
            return render_template('unsubscribe_success.html', search_name=search.name)
        
        return render_template('unsubscribe_error.html', error='–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'), 404
        
    except Exception as e:
        return render_template('unsubscribe_error.html', error='–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞'), 400



@app.route('/api/user/alert-history', methods=['GET'])
@login_required
def get_alert_history():
    """Get user's alert history with pagination"""
    try:
        limit = int(request.args.get('limit', 20))
        offset = int(request.args.get('offset', 0))
        
        # Ensure limits are reasonable
        limit = min(limit, 100)
        offset = max(offset, 0)
        
        history_data = AlertService.get_alert_history(
            user_id=current_user.id,
            limit=limit,
            offset=offset
        )
        
        # Enrich with property details
        from models import Property
        for alert in history_data['alerts']:
            property = Property.query.get(alert.get('property_id'))
            if property:
                alert['property'] = {
                    'title': property.title,
                    'rooms': property.rooms,
                    'area': property.area,
                    'price': property.price,
                    'main_image': property.main_image,
                    'complex_name': property.residential_complex.name if property.residential_complex else None
                }
        
        return jsonify({
            'success': True,
            **history_data
        })
        
    except Exception as e:
        logger.error(f"Error getting alert history: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@login_required 
def get_saved_search(search_id):
    """Get saved search by ID - supports both user searches and manager shared searches"""
    try:
        from models import SavedSearch, SentSearch
        
        # First try user's own saved search
        search = SavedSearch.query.filter_by(id=search_id, user_id=current_user.id).first()
        
        # If not found, try manager shared search via SentSearch table
        if not search:
            sent_search = SentSearch.query.filter_by(
                client_id=current_user.id
            ).join(SavedSearch, SentSearch.manager_search_id == SavedSearch.id).filter(
                SavedSearch.id == search_id
            ).first()
            
            if sent_search:
                search = SavedSearch.query.get(search_id)
                # Use the additional_filters from sent_search if available
                if sent_search.additional_filters:
                    search._temp_filters = sent_search.additional_filters
        
        # If still not found, check if it's a global search available to all users
        if not search:
            search = SavedSearch.query.get(search_id)
            if search and not search.user_id:  # Global searches have no user_id
                pass  # Allow access
            else:
                search = None
        
        if not search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'})
        
        # Parse filters - check for temp filters from sent search first
        filters = {}
        if hasattr(search, '_temp_filters') and search._temp_filters:
            try:
                filters = json.loads(search._temp_filters)
            except:
                filters = {}
        elif search.additional_filters:
            try:
                filters = json.loads(search.additional_filters)
            except:
                filters = {}
        
        return jsonify({
            'success': True,
            'id': search.id,
            'name': search.name,
            'description': search.description,
            'search_filters': filters,
            'created_at': search.created_at.isoformat() if search.created_at else None
        })
        
    except Exception as e:
        print(f"Error getting saved search: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'})

@app.route('/api/searches/<int:search_id>', methods=['DELETE'])
@csrf.exempt
def delete_saved_search(search_id):
    """Delete saved search"""
    from models import SavedSearch
    
    # Check authentication using helper function
    auth_info = check_api_authentication()
    if not auth_info:
        return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    
    user_id = auth_info['user_id']
    
    search = SavedSearch.query.filter_by(id=search_id, user_id=user_id).first()
    
    if not search:
        return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    try:
        db.session.delete(search)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-property', methods=['POST'])
@login_required
def send_property_to_client_endpoint():
    """Send property search to client"""
    if current_user.role != 'manager':
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        data = request.get_json()
        client_id = data.get('client_id')
        search_id = data.get('search_id')
        message = data.get('message', '')
        
        if not client_id or not search_id:
            return jsonify({'success': False, 'error': 'Client ID and Search ID are required'}), 400
        
        # Verify client exists and is a buyer
        client = User.query.filter_by(id=client_id, role='buyer').first()
        if not client:
            return jsonify({'success': False, 'error': 'Client not found'}), 404
        
        # Verify search exists and belongs to manager
        search = SavedSearch.query.filter_by(id=search_id, user_id=current_user.id).first()
        if not search:
            return jsonify({'success': False, 'error': 'Search not found'}), 404
        
        # Create recommendation record
        from models import ClientPropertyRecommendation
        recommendation = ClientPropertyRecommendation(
            manager_id=current_user.id,
            client_id=client_id,
            search_id=search_id,
            message=message
        )
        
        db.session.add(recommendation)
        db.session.commit()
        
        # Send notification to client (email)
        try:
            subject = f"–ü–æ–¥–±–æ—Ä–∫–∞ –∫–≤–∞—Ä—Ç–∏—Ä –æ—Ç {current_user.full_name}"
            text_message = f"""
–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {client.full_name}!

–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä {current_user.full_name} –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –¥–ª—è –≤–∞—Å –ø–æ–¥–±–æ—Ä–∫—É –∫–≤–∞—Ä—Ç–∏—Ä: {search.name}

{message if message else ''}

–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –Ω–∞ —Å–∞–π—Ç–µ InBack.ru, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ–¥–±–æ—Ä–∫—É.

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,
–ö–æ–º–∞–Ω–¥–∞ InBack.ru
            """
            
            from email_service import send_email
            send_email(
                to_email=client.email,
                subject=subject,
                text_content=text_message.strip(),
                template_name='recommendation'
            )
        except Exception as e:
            app.logger.warning(f"Failed to send email notification: {str(e)}")
        
        return jsonify({
            'success': True,
            'message': 'Property recommendation sent successfully'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# Property API routes for manager search
@app.route('/api/search/properties')
def search_properties_api():
    """Search properties for manager collection creation using normalized tables"""
    from repositories.property_repository import PropertyRepository
    
    try:
        district = request.args.get('district')
        developer = request.args.get('developer') 
        rooms = request.args.get('rooms')
        prop_type = request.args.get('type')
        price_min = request.args.get('price_min')
        price_max = request.args.get('price_max')
        area_min = request.args.get('area_min')
        
        filters = {}
        if price_min:
            filters['min_price'] = int(price_min)
        if price_max:
            filters['max_price'] = int(price_max)
        if area_min:
            filters['min_area'] = float(area_min)
        if rooms and rooms.isdigit():
            filters['rooms'] = [int(rooms)]
        if prop_type:
            filters['deal_type'] = prop_type
        
        properties = PropertyRepository.get_all_active(filters=filters, limit=100)
        
        filtered_properties = []
        for prop in properties:
            complex_obj = prop.residential_complex
            developer_obj = prop.developer
            
            district_name = complex_obj.district if complex_obj else ''
            developer_name = developer_obj.name if developer_obj else ''
            
            if district and district_name.lower() != district.lower():
                continue
            if developer and developer_name.lower() != developer.lower():
                continue
            if prop_type and prop.deal_type and prop.deal_type.lower() != prop_type.lower():
                continue
            
            price = prop.price or 0
            cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 5.0
            cashback = int(price * cashback_rate / 100)
            
            filtered_properties.append({
                'id': prop.inner_id or prop.id,
                'complex_name': complex_obj.name if complex_obj else '',
                'district': district_name,
                'developer': developer_name,
                'rooms': prop.rooms or 0,
                'price': price,
                'cashback': cashback,
                'area': prop.area or 0,
                'floor': f"{prop.floor}/{prop.total_floors}" if prop.floor and prop.total_floors else '',
                'type': prop.deal_type or '–ü–µ—Ä–≤–∏—á–∫–∞'
            })
        
        filtered_properties = filtered_properties[:20]
        
        return jsonify({
            'success': True,
            'properties': filtered_properties
        })
    except Exception as e:
        print(f"Error searching properties: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/search/apartments')
def search_apartments_api():
    """Search apartments with full filtering using normalized tables"""
    from repositories.property_repository import PropertyRepository, ResidentialComplexRepository
    
    try:
        district = request.args.get('district')
        developer = request.args.get('developer') 
        rooms = request.args.get('rooms')
        complex_id = request.args.get('complex')
        price_min = request.args.get('price_min')
        price_max = request.args.get('price_max')
        area_min = request.args.get('area_min')
        area_max = request.args.get('area_max')
        floor_min = request.args.get('floor_min')
        floor_max = request.args.get('floor_max')
        status = request.args.get('status')
        finishing = request.args.get('finishing')
        
        filters = {}
        if price_min:
            filters['min_price'] = int(price_min)
        if price_max:
            filters['max_price'] = int(price_max)
        if area_min:
            filters['min_area'] = float(area_min)
        if area_max:
            filters['max_area'] = float(area_max)
        if complex_id:
            filters['complex_id'] = int(complex_id)
        if rooms and rooms != '—Å—Ç—É–¥–∏—è':
            if rooms.isdigit():
                filters['rooms'] = [int(rooms)]
        
        properties = PropertyRepository.get_all_active(filters=filters, limit=200)
        
        filtered_apartments = []
        for prop in properties:
            complex_obj = prop.residential_complex
            developer_obj = prop.developer
            
            district_name = complex_obj.district if complex_obj else ''
            developer_name = developer_obj.name if developer_obj else ''
            
            if district and district_name.lower() != district.lower():
                continue
            if developer and developer_name.lower() != developer.lower():
                continue
            
            if rooms == '—Å—Ç—É–¥–∏—è' and prop.rooms != 0:
                continue
            
            prop_floor = prop.floor if prop.floor else 0
            if floor_min and prop_floor < int(floor_min):
                continue
            if floor_max and prop_floor > int(floor_max):
                continue
            
            price = prop.price or 0
            cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 5.0
            cashback = int(price * cashback_rate / 100)
            
            photos_list = []
            if prop.gallery_images:
                try:
                    if isinstance(prop.gallery_images, list):
                        photos_list = prop.gallery_images
                    elif isinstance(prop.gallery_images, str):
                        photos_list = json.loads(prop.gallery_images)
                except:
                    pass
            
            filtered_apartments.append({
                'id': prop.inner_id or prop.id,
                'complex_name': complex_obj.name if complex_obj else '',
                'complex_id': prop.complex_id,
                'district': district_name,
                'developer': developer_name,
                'rooms': '—Å—Ç—É–¥–∏—è' if prop.rooms == 0 else prop.rooms,
                'price': price,
                'cashback': cashback,
                'area': prop.area or 0,
                'floor': prop.floor if prop.floor else '',
                'max_floor': prop.total_floors if prop.total_floors else '',
                'type': '—Å—Ç—É–¥–∏—è' if prop.rooms == 0 else f'{prop.rooms}-–∫–æ–º–Ω',
                'status': '—Å–¥–∞–Ω',
                'finishing': prop.renovation_type or '',
                'images': photos_list,
                'description': prop.description or '',
                'features': []
            })
        
        filtered_apartments.sort(key=lambda x: x['price'])
        filtered_apartments = filtered_apartments[:50]
        
        complexes = ResidentialComplexRepository.get_all_active() if not city_id_filter else [
            c for c in ResidentialComplexRepository.get_all_active() 
            if c.city_id == city_id_filter
        ]
        complexes_data = {c.id: {'name': c.name, 'district': c.district} for c in complexes}
        
        return jsonify({
            'success': True,
            'apartments': filtered_apartments,
            'complexes': complexes_data
        })
    except Exception as e:
        print(f"Error searching apartments: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/complexes')
def get_complexes_api():
    """Get list of residential complexes for filter"""
    try:
        with open('data/residential_complexes.json', 'r', encoding='utf-8') as f:
            complexes_data = json.load(f)
        
        complexes_list = [
            {'id': complex_item.get('id'), 'name': complex_item.get('name', '')}
            for complex_item in complexes_data
        ]
        
        return jsonify({
            'success': True,
            'complexes': complexes_list
        })
    except Exception as e:
        print(f"Error loading complexes: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@csrf.exempt
@app.route('/api/properties/<property_id>')

@app.route('/api/properties/find-similar/<property_id>', methods=['GET'])
@login_required
def find_similar_properties(property_id):
    """Find similar properties for a given property (inner_id or database id)
    
    Returns similar properties based on:
    - Same city
    - Same number of rooms
    - Similar area (¬±15%)
    - Similar price (¬±20%)
    - Preferably same developer
    
    Usage:
        GET /api/properties/find-similar/1999611557?limit=10
    """
    from services.property_matcher import PropertyMatcher
    from models import Property
    
    try:
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º inner_id –≤ database id
        property_obj = Property.query.filter_by(inner_id=str(property_id)).first()
        
        if not property_obj:
            # Try as database ID if inner_id lookup fails
            try:
                property_obj = Property.query.get(int(property_id))
            except (ValueError, TypeError):
                pass
        
        if not property_obj:
            return jsonify({
                'success': False,
                'error': 'Property not found'
            }), 404
        
        # Get limit from query params
        limit = request.args.get('limit', 10, type=int)
        limit = min(max(1, limit), 50)  # Clamp between 1 and 50
        
        # Find similar properties
        similar = PropertyMatcher.find_similar_properties(
            property_id=property_obj.id,
            limit=limit,
            city_id=property_obj.city_id
        )
        
        return jsonify({
            'success': True,
            'similar_properties': similar,
            'count': len(similar),
            'original_property': {
                'id': property_obj.id,
                'inner_id': property_obj.inner_id,
                'rooms': property_obj.rooms,
                'area': property_obj.area,
                'price': property_obj.price
            }
        })
    
    except Exception as e:
        print(f"Error finding similar properties: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/complexes/filter', methods=['POST'])
def filter_complexes_by_apartments():
    """Filter residential complexes based on apartment parameters"""
    from models import Property
    from repositories.property_repository import PropertyRepository, ResidentialComplexRepository
    
    try:
        filters = request.json or {}
        
        # Extract filters
        rooms = filters.get('rooms', [])  # e.g., ["1-–∫–æ–º–Ω", "2-–∫–æ–º–Ω"]
        price_from = filters.get('priceFrom')  # –í –º–ª–Ω
        price_to = filters.get('priceTo')  # –í –º–ª–Ω
        developers = filters.get('developers', [])
        completion = filters.get('completion', [])
        housing_class = filters.get('housingClass', [])
        area_from = filters.get('areaFrom')
        area_to = filters.get('areaTo')
        
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∫–æ–º–ø–ª–µ–∫—Å—ã —Å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏
        complexes_data = ResidentialComplexRepository.get_with_coordinates()
        property_stats = PropertyRepository.get_all_property_stats()
        
        filtered_complex_ids = set()
        
        # –ï—Å–ª–∏ –µ—Å—Ç—å —Ñ–∏–ª—å—Ç—Ä –ø–æ –∫–æ–º–Ω–∞—Ç–∞–º, —Ü–µ–Ω–µ –∏–ª–∏ –ø–ª–æ—â–∞–¥–∏ - –∏—â–µ–º —á–µ—Ä–µ–∑ –∫–≤–∞—Ä—Ç–∏—Ä—ã
        if rooms or price_from or price_to or area_from or area_to:
            # –°—Ç—Ä–æ–∏–º SQL –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–≤–∞—Ä—Ç–∏—Ä
            query = Property.query
            
            # –§–∏–ª—å—Ç—Ä –ø–æ –∫–æ–º–Ω–∞—Ç–∞–º
            if rooms:
                # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º "2-–∫–æ–º–Ω" -> 2
                room_numbers = []
                for r in rooms:
                    if '—Å—Ç—É–¥–∏—è' in r.lower():
                        room_numbers.append(0)
                    else:
                        try:
                            room_numbers.append(int(r.split('-')[0]))
                        except:
                            pass
                if room_numbers:
                    query = query.filter(Property.rooms.in_(room_numbers))
            
            # –§–∏–ª—å—Ç—Ä –ø–æ —Ü–µ–Ω–µ (–º–ª–Ω —Ä—É–±–ª–µ–π)
            if price_from:
                query = query.filter(Property.price >= price_from * 1000000)
            if price_to:
                query = query.filter(Property.price <= price_to * 1000000)
            
            # –§–∏–ª—å—Ç—Ä –ø–æ –ø–ª–æ—â–∞–¥–∏
            if area_from:
                query = query.filter(Property.area >= area_from)
            if area_to:
                query = query.filter(Property.area <= area_to)
            
            # –ü–æ–ª—É—á–∞–µ–º ID –∫–æ–º–ø–ª–µ–∫—Å–æ–≤ —Å –ø–æ–¥—Ö–æ–¥—è—â–∏–º–∏ –∫–≤–∞—Ä—Ç–∏—Ä–∞–º–∏
            matching_properties = query.all()
            filtered_complex_ids = {p.complex_id for p in matching_properties if p.complex_id}
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        residential_complexes = []
        current_year = 2025
        
        for row in complexes_data:
            complex_id = row.id
            
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ –Ω—É–∂–Ω–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –∫–≤–∞—Ä—Ç–∏—Ä–∞–º –∏ –∫–æ–º–ø–ª–µ–∫—Å –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç
            if (rooms or price_from or price_to or area_from or area_to) and complex_id not in filtered_complex_ids:
                continue
            
            stats = property_stats.get(complex_id, {})
            
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∫–æ–º–ø–ª–µ–∫—Å—ã –±–µ–∑ –∫–≤–∞—Ä—Ç–∏—Ä
            if not stats or stats.get('total_count', 0) == 0:
                continue
            
            # –§–∏–ª—å—Ç—Ä –ø–æ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫—É
            if developers and row.developer_name not in developers:
                continue
            
            # –§–∏–ª—å—Ç—Ä –ø–æ –∫–ª–∞—Å—Å—É –∂–∏–ª—å—è
            if housing_class and row.object_class_display_name and row.object_class_display_name not in housing_class:
                continue
            
            # –°—Ç–∞—Ç—É—Å –∏ –¥–∞—Ç–∞ —Å–¥–∞—á–∏
            end_build_year = row.end_build_year
            end_build_quarter = row.end_build_quarter
            status = '–ù–µ —É–∫–∞–∑–∞–Ω'
            completion_date = '–ù–µ —É–∫–∞–∑–∞–Ω'
            
            if end_build_year:
                if end_build_year <= current_year:
                    status = '–°–¥–∞–Ω'
                else:
                    status = '–°—Ç—Ä–æ–∏—Ç—Å—è'
                if end_build_quarter:
                    completion_date = f"{end_build_quarter} –∫–≤. {end_build_year}"
                else:
                    completion_date = str(end_build_year)
            
            # –§–∏–ª—å—Ç—Ä –ø–æ —Å–¥–∞—á–µ/—Å—Ç–∞—Ç—É—Å—É
            if completion:
                match_found = False
                for filter_val in completion:
                    if filter_val == '–°–¥–∞–Ω' and status == '–°–¥–∞–Ω':
                        match_found = True
                        break
                    elif completion_date and filter_val in completion_date:
                        match_found = True
                        break
                if not match_found:
                    continue
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–º–ø–ª–µ–∫—Å –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            residential_complexes.append({
                'id': complex_id,
                'name': row.name or '',
                'developer': row.developer_name or '',
                'address': '',  # Not in get_with_coordinates()
                'district': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π',
                'apartments_count': stats.get('total_count', 0),
                'price_from': int(stats.get('min_price', 0)),
                'coordinates': {
                    'lat': float(row.latitude),
                    'lng': float(row.longitude)
                } if row.latitude and row.longitude else None,
                'completion_date': completion_date,
                'status': status,
                'cashback_percent': float(row.cashback_rate or 3.5),
                'main_image': row.main_image or '/static/images/no-photo.jpg',
                'description': f'–ñ–∏–ª–æ–π –∫–æ–º–ø–ª–µ–∫—Å {row.name}',
                'object_class': row.object_class_display_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
                'housing_class': row.object_class_display_name or '–ö–æ–º—Ñ–æ—Ä—Ç',
                'max_floors': 0,
                'url': f'/zk/{row.slug}' if row.slug else '#',
                'type': 'complex'
            })
        
        print(f"‚úÖ Filtered {len(residential_complexes)} complexes (from {len(complexes_data)} total)")
        
        return jsonify({
            'success': True,
            'complexes': residential_complexes,
            'total': len(residential_complexes)
        })
        
    except Exception as e:
        print(f"‚ùå Error filtering complexes: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 400
def get_property_details(property_id):
    """Get detailed property information using normalized tables"""
    from repositories.property_repository import PropertyRepository
    
    try:
        prop = PropertyRepository.get_by_id(property_id)
        
        if not prop:
            return jsonify({'success': False, 'error': 'Property not found'}), 404
        
        complex_obj = prop.residential_complex
        developer_obj = prop.developer
        
        price = prop.price or 0
        cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 5.0
        cashback = int(price * cashback_rate / 100)
        
        property_info = {
            'id': prop.inner_id or prop.id,
            'complex_name': complex_obj.name if complex_obj else '',
            'district': complex_obj.district if complex_obj else '',
            'developer': developer_obj.name if developer_obj else '',
            'rooms': prop.rooms or 0,
            'price': price,
            'cashback': cashback,
            'area': prop.area or 0,
            'floor': f"{prop.floor}/{prop.total_floors}" if prop.floor and prop.total_floors else '',
            'type': prop.deal_type or '–ü–µ—Ä–≤–∏—á–∫–∞',
            'description': prop.description or '',
            'features': []
        }
        
        return jsonify({
            'success': True,
            'property': property_info
        })
    except Exception as e:
        print(f"Error getting property details: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collections', methods=['POST'])
@manager_required
def create_collection_api():
    """Create a new property collection"""
    try:
        current_manager = current_user
            
        from models import Collection, CollectionProperty
        
        data = request.get_json()
        name = data.get('name')
        client_id = data.get('client_id')
        property_ids = data.get('property_ids', [])
        
        if not name or not client_id or not property_ids:
            return jsonify({'success': False, 'error': 'Missing required fields'}), 400
        
        # Create collection
        collection = Collection(
            title=name,
            assigned_to_user_id=client_id,
            created_by_manager_id=current_manager.id,
            status='–°–æ–∑–¥–∞–Ω–∞',
            description=f'–ü–æ–¥–±–æ—Ä–∫–∞ –∏–∑ {len(property_ids)} –æ–±—ä–µ–∫—Ç–æ–≤'
        )
        
        db.session.add(collection)
        db.session.flush()  # Get collection ID
        
        # Add properties to collection
        for prop_id in property_ids:
            # DUAL WRITE: Resolve property to get both IDs
            property_obj, canonical_id = resolve_property_by_identifier(prop_id)
            if not property_obj:
                continue  # Skip properties that don't exist
            
            collection_property = CollectionProperty(
                collection_id=collection.id,
                property_id=str(property_obj.id),  # Old: database ID
                property_inner_id=property_obj.inner_id  # NEW: canonical inner_id
            )
            db.session.add(collection_property)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'collection_id': collection.id,
            'message': '–ü–æ–¥–±–æ—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error creating collection: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-collection', methods=['POST'])
@manager_required
def send_collection_to_client():
    """Send property collection to client via email"""
    try:
        current_manager = current_user
            
        from models import User, Manager
        
        data = request.get_json()
        
        # TODO: Implement collection sending logic
        return jsonify({'success': True, 'message': '–§—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ'})
        
    except Exception as e:
        print(f"Error sending collection: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

# ========== –ü–†–ï–ó–ï–ù–¢–ê–¶–ò–ò API ==========

@app.route('/api/manager/presentations', methods=['GET'])
@manager_required
def get_manager_presentations():
    """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞"""
    try:
        from models import Collection
        
        current_manager = current_user
        
        presentations = Collection.query.filter_by(
            created_by_manager_id=current_manager.id,
            collection_type='presentation'
        ).order_by(Collection.created_at.desc()).all()
        
        presentations_data = []
        for presentation in presentations:
            presentations_data.append(presentation.to_dict())
        
        return jsonify({
            'success': True,
            'presentations': presentations_data
        })
        
    except Exception as e:
        print(f"Error loading presentations: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/presentation/create', methods=['POST'])
@manager_required
# @require_json_csrf  # CSRF disabled
def create_presentation():
    """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é"""
    from models import Collection
    from flask_login import current_user
    
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    title = data.get('title')
    description = data.get('description', '')
    client_name = data.get('client_name', '')
    client_phone = data.get('client_phone', '')
    
    if not title:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    
    try:
        current_manager = current_user
            
        presentation = Collection(
            title=title,
            description=description,
            created_by_manager_id=current_manager.id,
            collection_type='presentation',
            client_name=client_name,
            client_phone=client_phone,
            status='–ß–µ—Ä–Ω–æ–≤–∏–∫'
        )
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É
        presentation.generate_unique_url()
        
        db.session.add(presentation)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'presentation': presentation.to_dict(),
            'message': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400


def _load_presentation_properties_from_db(presentation_id):
    """
    ‚úÖ Helper function: Load presentation properties from PostgreSQL
    Used by both manager view and public view to avoid code duplication.
    Returns enriched_properties list with all property data.
    """
    from models import CollectionProperty, Property
    from sqlalchemy.orm import joinedload
    
    # Get presentation properties
    collection_properties = CollectionProperty.query.filter_by(
        collection_id=presentation_id
    ).order_by(CollectionProperty.order_index).all()
    
    print(f"DEBUG: Found {len(collection_properties)} properties in presentation {presentation_id}")
    
    # ‚úÖ Load property data directly from PostgreSQL with eager loading
    enriched_properties = []
    for cp in collection_properties:
        # ‚úÖ FIXED: Smart search - try inner_id first, then database ID
        # cp.property_id can be either inner_id OR database ID (legacy data)
        property_obj = Property.query.options(
            joinedload(Property.residential_complex),
            joinedload(Property.developer),
            joinedload(Property.district)
        ).filter_by(inner_id=cp.property_id).first()
        
        # If not found by inner_id, try as database primary key
        if not property_obj:
            try:
                property_id_int = int(cp.property_id)
                property_obj = Property.query.options(
                    joinedload(Property.residential_complex),
                    joinedload(Property.developer),
                    joinedload(Property.district)
                ).get(property_id_int)
                if property_obj:
                    print(f"DEBUG: Found property {property_id_int} by database ID")
            except (ValueError, TypeError):
                print(f"DEBUG: Could not parse property_id {cp.property_id} as int")
        
        if property_obj:
            # ‚úÖ Parse gallery_images JSON field properly
            main_image = 'https://via.placeholder.com/400x300?text=No+Photo'
            images = []
            
            if property_obj.gallery_images:
                try:
                    # Parse JSON array
                    if isinstance(property_obj.gallery_images, str):
                        photos = json.loads(property_obj.gallery_images)
                    else:
                        photos = property_obj.gallery_images
                    
                    if photos and isinstance(photos, list) and len(photos) > 0:
                        main_image = photos[0]
                        images = photos
                except (json.JSONDecodeError, TypeError) as e:
                    print(f"DEBUG: Error parsing gallery_images for property {property_id_int}: {e}")
            
            # Use main_image field if gallery is empty
            if not images and property_obj.main_image:
                main_image = property_obj.main_image
                images = [main_image]
            
            # ‚úÖ Get data from relationships (same pattern as /properties route)
            complex_name = property_obj.residential_complex.name if property_obj.residential_complex else '–ù–µ —É–∫–∞–∑–∞–Ω'
            developer_name = property_obj.developer.name if property_obj.developer else '–ù–µ —É–∫–∞–∑–∞–Ω'
            district_name = property_obj.district.name if property_obj.district else '–ù–µ —É–∫–∞–∑–∞–Ω'
            
            # ‚úÖ Calculate cashback from residential_complex.cashback_rate
            cashback = 0
            cashback_rate = 0
            if property_obj.residential_complex and property_obj.residential_complex.cashback_rate:
                cashback_rate = float(property_obj.residential_complex.cashback_rate)
                cashback = int(property_obj.price * (cashback_rate / 100)) if property_obj.price else 0
            
            # Build room description
            rooms = property_obj.rooms or 0
            if rooms == 0:
                room_type = "–°—Ç—É–¥–∏—è"
            else:
                room_type = f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"
            
            # Build title (same format as /properties route)
            floor_text = f"{property_obj.floor}/{property_obj.total_floors} —ç—Ç." if property_obj.floor and property_obj.total_floors else ""
            title = f"{room_type}, {property_obj.area} –º¬≤"
            if floor_text:
                title += f", {floor_text}"
            
            # ‚úÖ Build enriched_property dict from Property ORM attributes
            enriched_property = {
                'id': property_obj.inner_id or property_obj.id,
                'property_id': property_obj.id,  # ‚úÖ database ID for API calls
                'inner_id': property_obj.inner_id,  # ‚úÖ inner_id for external refs
                'manager_note': cp.manager_note,  # ‚úÖ Keep manager_note from CollectionProperty
                'order_index': cp.order_index,
                'rooms': rooms,
                'price': property_obj.price or 0,
                'area': property_obj.area or 0,
                'floor': property_obj.floor or 0,
                'total_floors': property_obj.total_floors or 0,
                'complex_name': complex_name,
                'property_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
                'images': images,
                'main_image': main_image,
                'layout_image': None,
                'address': property_obj.address or '',
                'latitude': float(property_obj.latitude) if property_obj.latitude else None,
                'longitude': float(property_obj.longitude) if property_obj.longitude else None,
                'description': property_obj.description or '',
                'features': [],
                'developer': developer_name,
                'district': district_name,
                'cashback': cashback,
                'cashback_available': bool(cashback > 0),
                'cashback_rate': cashback_rate,
                'price_per_sqm': property_obj.price_per_sqm or 0,
                'status': property_obj.status or 'available',
                'title': title,
                'url': f"/object/{property_obj.inner_id or property_obj.id}"
            }
            enriched_properties.append(enriched_property)
        else:
            print(f"DEBUG: Property {cp.property_id} not found in database")
    
    print(f"DEBUG: Enriched {len(enriched_properties)} properties from PostgreSQL")
    return enriched_properties

@app.route('/api/manager/presentation/<int:presentation_id>', methods=['GET'])
@manager_required
def get_presentation_data(presentation_id):
    """‚úÖ FIXED: Load property data from PostgreSQL instead of Excel cache"""
    from models import Collection, CollectionProperty, Manager, Property
    from sqlalchemy.orm import joinedload
    
    current_manager = current_user
    print(f"DEBUG: Get presentation data - manager_id: {current_manager.id}, presentation_id: {presentation_id}")
    
    # Get presentation data
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_manager.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –¥–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω'}), 404
    
    # Get presentation properties
    collection_properties = CollectionProperty.query.filter_by(
        collection_id=presentation_id
    ).order_by(CollectionProperty.order_index).all()
    
    print(f"DEBUG: Found {len(collection_properties)} properties in presentation")
    
    # ‚úÖ FIXED: Load property data directly from PostgreSQL instead of Excel cache
    enriched_properties = []
    for cp in collection_properties:
        # ‚úÖ FIXED: Smart search - try inner_id first, then database ID
        # cp.property_id can be either inner_id OR database ID (legacy data)
        property_obj = Property.query.options(
            joinedload(Property.residential_complex),
            joinedload(Property.developer),
            joinedload(Property.district)
        ).filter_by(inner_id=cp.property_id).first()
        
        # If not found by inner_id, try as database primary key
        if not property_obj:
            try:
                property_id_int = int(cp.property_id)
                property_obj = Property.query.options(
                    joinedload(Property.residential_complex),
                    joinedload(Property.developer),
                    joinedload(Property.district)
                ).get(property_id_int)
                if property_obj:
                    print(f"DEBUG: Found property {property_id_int} by database ID")
            except (ValueError, TypeError):
                print(f"DEBUG: Could not parse property_id {cp.property_id} as int")
        
        if property_obj:
            # ‚úÖ Parse gallery_images JSON field properly
            main_image = 'https://via.placeholder.com/400x300?text=No+Photo'
            images = []
            
            if property_obj.gallery_images:
                try:
                    # Parse JSON array
                    if isinstance(property_obj.gallery_images, str):
                        photos = json.loads(property_obj.gallery_images)
                    else:
                        photos = property_obj.gallery_images
                    
                    if photos and isinstance(photos, list) and len(photos) > 0:
                        main_image = photos[0]
                        images = photos
                except (json.JSONDecodeError, TypeError) as e:
                    print(f"DEBUG: Error parsing gallery_images for property {property_id_int}: {e}")
            
            # Use main_image field if gallery is empty
            if not images and property_obj.main_image:
                main_image = property_obj.main_image
                images = [main_image]
            
            # ‚úÖ Get data from relationships (same pattern as /properties route)
            complex_name = property_obj.residential_complex.name if property_obj.residential_complex else '–ù–µ —É–∫–∞–∑–∞–Ω'
            developer_name = property_obj.developer.name if property_obj.developer else '–ù–µ —É–∫–∞–∑–∞–Ω'
            district_name = property_obj.district.name if property_obj.district else '–ù–µ —É–∫–∞–∑–∞–Ω'
            
            # ‚úÖ Calculate cashback from residential_complex.cashback_rate
            cashback = 0
            cashback_rate = 0
            if property_obj.residential_complex and property_obj.residential_complex.cashback_rate:
                cashback_rate = float(property_obj.residential_complex.cashback_rate)
                cashback = int(property_obj.price * (cashback_rate / 100)) if property_obj.price else 0
            
            # Build room description
            rooms = property_obj.rooms or 0
            if rooms == 0:
                room_type = "–°—Ç—É–¥–∏—è"
            else:
                room_type = f"{rooms}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è –∫–≤–∞—Ä—Ç–∏—Ä–∞"
            
            # Build title (same format as /properties route)
            floor_text = f"{property_obj.floor}/{property_obj.total_floors} —ç—Ç." if property_obj.floor and property_obj.total_floors else ""
            title = f"{room_type}, {property_obj.area} –º¬≤"
            if floor_text:
                title += f", {floor_text}"
            
            # ‚úÖ Build enriched_property dict from Property ORM attributes
            enriched_property = {
                'id': property_obj.inner_id or property_obj.id,
                'property_id': property_obj.id,  # ‚úÖ database ID for API calls
                'inner_id': property_obj.inner_id,  # ‚úÖ inner_id for external refs
                'manager_note': cp.manager_note,  # ‚úÖ Keep manager_note from CollectionProperty
                'order_index': cp.order_index,
                'rooms': rooms,
                'price': property_obj.price or 0,
                'area': property_obj.area or 0,
                'floor': property_obj.floor or 0,
                'total_floors': property_obj.total_floors or 0,
                'complex_name': complex_name,
                'property_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',
                'images': images,
                'main_image': main_image,
                'layout_image': None,
                'address': property_obj.address or '',
                'latitude': float(property_obj.latitude) if property_obj.latitude else None,
                'longitude': float(property_obj.longitude) if property_obj.longitude else None,
                'description': property_obj.description or '',
                'features': [],
                'developer': developer_name,
                'district': district_name,
                'cashback': cashback,
                'cashback_available': bool(cashback > 0),
                'cashback_rate': cashback_rate,
                'price_per_sqm': property_obj.price_per_sqm or 0,
                'status': property_obj.status or 'available',
                'title': title,
                'url': f"/object/{property_obj.inner_id or property_obj.id}"
            }
            enriched_properties.append(enriched_property)
        else:
            print(f"DEBUG: Property {cp.property_id} not found in database")
    
    print(f"DEBUG: Enriched {len(enriched_properties)} properties from PostgreSQL")
    
    # Format presentation data for JSON response
    presentation_data = {
        'id': presentation.id,
        'title': presentation.title,
        'description': presentation.description,
        'client_name': presentation.client_name,
        'client_phone': presentation.client_phone,
        'status': presentation.status,
        'created_at': presentation.created_at.isoformat() if presentation.created_at else None,
        'view_count': presentation.view_count,
        'last_viewed_at': presentation.last_viewed_at.isoformat() if presentation.last_viewed_at else None,
        'properties_count': len(enriched_properties),
        'properties': enriched_properties,
        'unique_url': presentation.unique_url,
        'assigned_to_user_id': presentation.assigned_to_user_id
    }
    
    return jsonify({
        'success': True,
        'presentation': presentation_data
    })

@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def add_property_to_presentation(presentation_id):
    """–î–æ–±–∞–≤–∏—Ç—å –∫–≤–∞—Ä—Ç–∏—Ä—É –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    property_id = data.get('property_id')
    manager_note = data.get('manager_note', '')
    
    if not property_id:
        return jsonify({'success': False, 'error': 'ID –æ–±—ä–µ–∫—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
    
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_user.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –ª–∏ —É–∂–µ —ç—Ç–∞ –∫–≤–∞—Ä—Ç–∏—Ä–∞
    existing = CollectionProperty.query.filter_by(
        collection_id=presentation_id,
        property_id=property_id
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é'}), 400
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–≤–∞—Ä—Ç–∏—Ä–µ –∏–∑ JSON
        properties = load_properties()
        property_info = None
        
        for prop in properties:
            if str(prop.get('id')) == str(property_id):
                property_info = prop
                break
        
        if not property_info:
            return jsonify({'success': False, 'error': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # DUAL WRITE: Resolve property to get both IDs
        property_obj, canonical_id = resolve_property_by_identifier(property_id)
        if not property_obj:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö'}), 404
        
        collection_property = CollectionProperty(
            collection_id=presentation_id,
            property_id=str(property_obj.id),  # Old: database ID
            property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
            property_name=property_info.get('title', '–ö–≤–∞—Ä—Ç–∏—Ä–∞'),
            property_price=int(property_info.get('price', 0)) if property_info.get('price') else None,
            complex_name=property_info.get('residential_complex', ''),
            property_type=f"{property_info.get('rooms', 0)}-–∫–æ–º–Ω–∞—Ç–Ω–∞—è" if property_info.get('rooms', 0) > 0 else '–°—Ç—É–¥–∏—è',
            property_size=float(property_info.get('area', 0)) if property_info.get('area') else None,
            manager_note=manager_note,
            order_index=len(presentation.properties) + 1
        )
        
        db.session.add(collection_property)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é',
            'property': {
                'id': collection_property.id,
                'property_name': collection_property.property_name,
                'complex_name': collection_property.complex_name,
                'property_price': collection_property.property_price,
                'manager_note': collection_property.manager_note
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# –ù–û–í–´–ï API –≠–ù–î–ü–û–ò–ù–¢–´ –î–õ–Ø –ü–†–ï–ó–ï–ù–¢–ê–¶–ò–ô

@app.route('/api/manager/presentation/<int:presentation_id>/add-property', methods=['POST'])
@csrf.exempt
@manager_required
def add_property_to_presentation_fixed(presentation_id):
    """
    ‚úÖ MIGRATED TO NORMALIZED TABLES (Property ‚Üí ResidentialComplex ‚Üí Developer)
    –î–æ–±–∞–≤–∏—Ç—å –æ–±—ä–µ–∫—Ç –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é (–±–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤–µ—Ä—Å–∏—è)
    Uses ONLY direct SQLAlchemy database queries with eager loading.
    """
    from models import Collection, CollectionProperty, Property
    from sqlalchemy.orm import joinedload
    from flask_login import current_user
    
    try:
        print(f"üéØ DEBUG: add_property_to_presentation_fixed called for presentation {presentation_id}")
        
        # 1. Validate input data
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
            
        property_id = data.get('property_id')
        if not property_id:
            return jsonify({'success': False, 'error': 'ID –æ–±—ä–µ–∫—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400

        # Convert to int if it's a string, keep as int if already int
        try:
            property_id_int = int(property_id) if isinstance(property_id, str) else property_id
        except (ValueError, TypeError):
            return jsonify({'success': False, 'error': '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π ID –æ–±—ä–µ–∫—Ç–∞'}), 400
        
        # Convert to string for VARCHAR column in CollectionProperty table
        property_id = str(property_id_int)
        
        current_manager = current_user
            
        # 2. Strict check for presentation ownership
        presentation = Collection.query.filter_by(
            id=presentation_id,
            created_by_manager_id=current_manager.id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404
        
        # 3. Check for duplicates
        existing = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=property_id
        ).first()
        
        if existing:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é'}), 400
        
        # 4. Load property from database with eager loading for relationships
        property_obj = Property.query.options(
            joinedload(Property.residential_complex)
        ).get(property_id_int)
        
        print(f"üéØ DEBUG: DB lookup for property {property_id_int}, found: {property_obj is not None}")
        
        if not property_obj:
            print(f"‚ùå ERROR: Property {property_id_int} not found in database")
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        print(f"‚úÖ Property found in database: {property_obj.title}")
        
        # 5. Create CollectionProperty from database Property object
        # Format room type
        rooms = int(property_obj.rooms or 0)
        property_type = "–°—Ç—É–¥–∏—è" if rooms == 0 else f"{rooms}-–∫–æ–º–Ω"
        
        # Get complex name safely (relationship already loaded via joinedload)
        complex_name = property_obj.residential_complex.name if property_obj.residential_complex else ''
        
        # Generate property name
        property_name = property_obj.title or f"{property_type} –≤ {complex_name}"
        
        collection_property = CollectionProperty(
            collection_id=presentation_id,
            property_id=str(property_obj.id),  # Old: database ID
            property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
            property_name=property_name,
            property_price=int(property_obj.price) if property_obj.price else None,
            complex_name=complex_name,
            property_type=property_type,
            property_size=float(property_obj.area) if property_obj.area else None,
            order_index=len(presentation.properties) + 1
        )
        
        # 6. Save to database (ONCE only!)
        db.session.add(collection_property)
        db.session.commit()
        
        print(f"‚úÖ Property {property_id_int} successfully added to presentation {presentation_id}")
        
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é',
            'property': {
                'id': collection_property.id,
                'property_name': collection_property.property_name,
                'complex_name': collection_property.complex_name,
                'property_price': collection_property.property_price
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå ERROR in add_property_to_presentation_fixed: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/presentation/<int:presentation_id>/property/<int:property_id>/comment', methods=['PUT'])
@csrf.exempt
@manager_required
def update_property_comment_in_presentation(presentation_id, property_id):
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    manager_note = data.get('manager_note', '').strip()
    
    current_manager = current_user
        
    # –°—Ç—Ä–æ–≥–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–Ω–∏—è –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–µ–π
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_manager.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404    # ‚úÖ FIXED: Use helper to resolve property by inner_id OR database ID
    property_obj, canonical_id = resolve_property_by_identifier(property_id)
    if not property_obj:
        return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    # Search CollectionProperty using property_inner_id or property_id (database ID as string)
    from sqlalchemy import or_
    collection_property = CollectionProperty.query.filter(
        CollectionProperty.collection_id == presentation_id,
        or_(
            CollectionProperty.property_inner_id == property_obj.inner_id,
            CollectionProperty.property_id == str(property_obj.id),
            CollectionProperty.property_id == str(property_obj.inner_id)
        )
    ).first()
    
    if not collection_property:
        return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏'}), 404
    
    try:
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
        collection_property.manager_note = manager_note
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ–±–Ω–æ–≤–ª–µ–Ω',
            'property': {
                'id': collection_property.property_inner_id,
                'manager_note': collection_property.manager_note
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/presentation/<int:presentation_id>/status', methods=['PUT'])
@manager_required
# @require_json_csrf  # CSRF disabled
def update_presentation_status(presentation_id):
    """–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –º–µ–∂–¥—É –ß–µ—Ä–Ω–æ–≤–∏–∫ –∏ –û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ"""
    from models import Collection
    from flask_login import current_user
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    new_status = data.get('status', '').strip()
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è —Å—Ç–∞—Ç—É—Å–∞
    if new_status not in ['–ß–µ—Ä–Ω–æ–≤–∏–∫', '–û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ']:
        return jsonify({'success': False, 'error': '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Å—Ç–∞—Ç—É—Å'}), 400
    
    # –ù–∞–π—Ç–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_user.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404
    
    try:
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∏ —Ñ–ª–∞–≥ –ø—É–±–ª–∏—á–Ω–æ—Å—Ç–∏
        presentation.status = new_status
        presentation.is_public = (new_status == '–û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ')
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'–°—Ç–∞—Ç—É—Å –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ "{new_status}"',
            'status': presentation.status,
            'is_public': presentation.is_public
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# ===== PDF AND PRINT ENDPOINTS =====

def fetch_pdf_context(property_id, presentation_id=None):
    """
    ‚úÖ MIGRATED TO NORMALIZED SCHEMA (Property ‚Üí ResidentialComplex ‚Üí Developer)
    
    Fetch comprehensive context for PDF generation including:
    - Property details and images from properties table
    - Residential complex details and characteristics
    - Manager contact information
    
    FIXED: Uses SQLAlchemy text() with bindparams for SQLite compatibility
    FIXED: Added safe resource handling and division by zero protection
    MIGRATED: Uses normalized tables (properties, residential_complexes, developers)
    """
    import json
    from models import Collection, CollectionProperty, ResidentialComplex, Manager
    from sqlalchemy import text
    
    try:
        # Get property data using normalized schema with JOINs
        property_query = text("""
        SELECT p.inner_id, p.gallery_images as photos, rc.name as complex_name, p.complex_id,
               rc.object_class_display_name as complex_object_class_display_name, 
               rc.end_build_year as complex_building_end_build_year,
               rc.end_build_quarter as complex_building_end_build_quarter, 
               rc.has_big_check as complex_has_big_check,
               rc.financing_sber as complex_financing_sber, 
               rc.has_green_mortgage as complex_has_green_mortgage,
               p.rooms as object_rooms, p.area as object_area, 
               p.floor as object_min_floor, p.total_floors as object_max_floor,
               p.price, p.address as address_display_name, 
               p.latitude as address_position_lat, p.longitude as address_position_lon,
               d.name as developer_name, p.renovation_type as renovation_display_name
        FROM properties p
        LEFT JOIN residential_complexes rc ON p.complex_id = rc.id
        LEFT JOIN developers d ON p.developer_id = d.id
        WHERE p.inner_id = CAST(:property_id AS TEXT) OR p.id = :property_id_int
        """)
        
        # Use SQLAlchemy session with proper error handling
        try:
            property_id_int_val = int(property_id)
        except (ValueError, TypeError):
            property_id_int_val = -1
        result = db.session.execute(property_query, {'property_id': str(property_id), 'property_id_int': property_id_int_val})
        property_row = result.fetchone()
        
        if not property_row:
            print(f"DEBUG: fetch_pdf_context - property not found for id={property_id}")
            return None
            
        # Convert to dictionary using _mapping for SQLAlchemy compatibility
        property_data = dict(property_row._mapping)
        
        # Parse photos JSON with safe error handling
        property_images = {'photos': [], 'plans': []}
        if property_data.get('photos'):
            try:
                photos_list = json.loads(property_data['photos'])
                if photos_list and isinstance(photos_list, list):
                    # First 6 images as main photos, 6-8 as plans (fixed logic)
                    property_images['photos'] = photos_list[:6]
                    property_images['plans'] = photos_list[6:8] if len(photos_list) > 6 else []
            except (json.JSONDecodeError, TypeError, ValueError):
                property_images['photos'] = []
                property_images['plans'] = []
        
        # Get residential complex data if available
        complex_data = {}
        complex_images = {'facade': [], 'territory': [], 'infrastructure': [], 'construction': []}
        complex_photos = []
        
        if property_data.get('complex_name'):
            try:
                # Load basic complex data from residential_complexes table
                complex_query = text("""
                SELECT name, slug, district_id, developer_id, cashback_rate,
                       object_class_display_name, start_build_year, start_build_quarter,
                       end_build_year, end_build_quarter, has_accreditation,
                       has_green_mortgage, has_big_check, with_renovation, financing_sber
                FROM residential_complexes 
                WHERE name = :complex_name
                """)
                complex_result = db.session.execute(complex_query, {'complex_name': property_data['complex_name']})
                complex_row = complex_result.fetchone()
                
                if complex_row:
                    complex_data = dict(complex_row._mapping)
                
                # Load complex photos from properties table using complex_id
                photos_query = text("""
                SELECT gallery_images AS photos FROM properties 
                WHERE complex_id = (SELECT id FROM residential_complexes WHERE name = :complex_name LIMIT 1) 
                AND gallery_images IS NOT NULL
                LIMIT 1
                """)
                photos_result = db.session.execute(photos_query, {'complex_name': property_data['complex_name']})
                photos_row = photos_result.fetchone()
                
                if photos_row and photos_row[0]:
                    try:
                        photos_data = json.loads(photos_row[0])
                        if isinstance(photos_data, list):
                            complex_photos = photos_data[:9]  # Take first 9 photos for 3x3 grid
                        elif isinstance(photos_data, dict):
                            # If photos are organized by categories  
                            all_photos = []
                            for category, photos_list in photos_data.items():
                                if isinstance(photos_list, list):
                                    all_photos.extend(photos_list)
                            complex_photos = all_photos[:9]  # Take first 9 photos for 3x3 grid
                    except (json.JSONDecodeError, TypeError):
                        complex_photos = []
                        
            except Exception as e:
                print(f"Error loading complex data: {e}")
        
        # Get manager information if presentation_id provided
        manager_data = {}
        if presentation_id:
            try:
                presentation = Collection.query.get(presentation_id)
                if presentation and presentation.created_by_manager_id:
                    manager = Manager.query.get(presentation.created_by_manager_id)
                    if manager:
                        manager_data = {
                            'name': manager.full_name or '–ú–µ–Ω–µ–¥–∂–µ—Ä',
                            'email': manager.email or '',
                            'phone': manager.phone or '+7 (XXX) XXX-XX-XX',
                            'photo_url': None  # Add if available
                        }
            except Exception as e:
                print(f"Error loading manager data: {e}")
        
        # Safe type conversion with defaults (using corrected column names)
        area = float(property_data.get('object_area') or 0)
        price = int(property_data.get('price') or 0)  # Fixed column name
        rooms = int(property_data.get('object_rooms') or 0)
        floor = int(property_data.get('object_min_floor') or 0)  # Fixed column name
        total_floors = int(property_data.get('object_max_floor') or 0)
        
        # Calculate price per sqm with division by zero protection
        price_per_sqm = 0
        if area > 0 and price > 0:
            try:
                price_per_sqm = int(price / area)
            except (ZeroDivisionError, ValueError):
                price_per_sqm = 0
        
        # Get cashback from complex data (loaded from residential_complexes table)
        cashback_rate = complex_data.get('cashback_rate', 5.0) if complex_data else 5.0
        cashback_amount = int(price * cashback_rate / 100) if price > 0 else 0
        
        # Construct full context with safe data types
        context = {
            'property': {
                'id': property_data.get('inner_id'),
                'rooms': rooms,
                'area': area,
                'floor': floor,
                'total_floors': total_floors,
                'price': price,
                'price_per_sqm': price_per_sqm,
                'finishing': property_data.get('renovation_display_name') or '–ù–µ —É–∫–∞–∑–∞–Ω',
                'status': '–ê–∫—Ç–∏–≤–µ–Ω',  # Default since column doesn't exist
                'address': property_data.get('address_display_name') or '–ê–¥—Ä–µ—Å —É—Ç–æ—á–Ω—è–µ—Ç—Å—è',
                'cashback_percent': cashback_rate,
                'cashback_amount': cashback_amount,
                'latitude': property_data.get('address_position_lat'),
                'longitude': property_data.get('address_position_lon'),
                'object_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',  # Default since column doesn't exist
                'developer_name': property_data.get('developer_name') or '',
                'jk_name': property_data.get('complex_name') or '',
                'property_type': '–ö–≤–∞—Ä—Ç–∏—Ä–∞',  # Default since column doesn't exist
                'completion_date': None  # Will be set from complex data if available
            },
            'property_images': property_images,
            'complex': {
                'id': property_data.get('complex_id'),
                'name': property_data.get('complex_name') or '',
                'class': property_data.get('complex_object_class_display_name') or '',
                'completion_year': property_data.get('complex_building_end_build_year'),
                'completion_quarter': property_data.get('complex_building_end_build_quarter'),
                'has_big_check': bool(property_data.get('complex_has_big_check')),
                'financing_sber': bool(property_data.get('complex_financing_sber')),
                'has_green_mortgage': bool(property_data.get('complex_has_green_mortgage')),
                'developer': property_data.get('developer_name') or '',
                'photos': complex_photos,  # Added complex photos from database
                'features': []
            },
            'complex_images': complex_images,
            'manager': manager_data,
            'generated_at': property_data  # Full raw data for backwards compatibility
        }
        
        # Add completion date to property if available
        if context['complex']['completion_quarter'] and context['complex']['completion_year']:
            context['property']['completion_date'] = f"{context['complex']['completion_quarter']} –∫–≤. {context['complex']['completion_year']} –≥."
        
        # Add complex features list with safe checks
        features = []
        if complex_data.get('has_accreditation'):
            features.append('–ê–∫–∫—Ä–µ–¥–∏—Ç–æ–≤–∞–Ω –±–∞–Ω–∫–∞–º–∏')
        if complex_data.get('has_green_mortgage') or property_data.get('complex_has_green_mortgage'):
            features.append('–õ—å–≥–æ—Ç–Ω–∞—è –∏–ø–æ—Ç–µ–∫–∞')  
        if complex_data.get('with_renovation'):
            features.append('–° –æ—Ç–¥–µ–ª–∫–æ–π')
        if complex_data.get('financing_sber') or property_data.get('complex_financing_sber'):
            features.append('–§–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏–µ –°–±–µ—Ä–±–∞–Ω–∫')
        if complex_data.get('has_big_check') or property_data.get('complex_has_big_check'):
            features.append('–ë–æ–ª—å—à–æ–π —á–µ–∫')
        
        context['complex']['features'] = features
        
        return context
        
    except Exception as e:
        print(f"Error in fetch_pdf_context: {e}")
        import traceback
        traceback.print_exc()
        return None

@app.route('/api/presentation/<int:presentation_id>/property/<string:property_id>/print')
@manager_required
def print_property(presentation_id, property_id):
    """–û—Ç–∫—Ä—ã—Ç—å –≤–µ—Ä—Å–∏—é –æ–±—ä–µ–∫—Ç–∞ –¥–ª—è –ø–µ—á–∞—Ç–∏ —Å –ø–æ–ª–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –∏–∑ –±–∞–∑—ã"""
    from models import Collection, CollectionProperty, Property as PropertyModel
    
    # Find presentation
    presentation = Collection.query.get_or_404(presentation_id)
    
    # Resolve property identifier (could be inner_id or database ID)
    prop_obj, canonical_id = resolve_property_by_identifier(property_id)
    if not prop_obj:
        abort(404, description="–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
    
    # Search in CollectionProperty using property_id or property_inner_id
    property_obj = CollectionProperty.query.filter(
        CollectionProperty.collection_id == presentation_id,
        db.or_(
            CollectionProperty.property_id == str(prop_obj.inner_id),
            CollectionProperty.property_id == str(prop_obj.id),
            CollectionProperty.property_id == str(property_id),
            CollectionProperty.property_inner_id == str(prop_obj.inner_id)
        )
    ).first()
    
    if not property_obj:
        return "Property not found in presentation", 404
    
    # Get comprehensive context using new function
    context = fetch_pdf_context(property_id, presentation_id)
    
    if not context:
        return "Property data not found", 404
    
    # Render print template with full context
    return render_template('print_property.html', 
                         property=context['property'],
                         property_images=context['property_images'],
                         complex=context['complex'],
                         complex_images=context['complex_images'],
                         manager=context['manager'],
                         presentation=presentation,
                         manager_note=getattr(property_obj, 'manager_note', None),
                         context=context)  # Full context for backwards compatibility

@app.route('/api/manager/presentation/<int:presentation_id>/download-all')
@manager_required
def download_all_properties(presentation_id):
    """–°–∫–∞—á–∞—Ç—å –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –≤ ZIP –∞—Ä—Ö–∏–≤–µ"""
    from models import Collection, CollectionProperty
    from weasyprint import HTML, CSS
    import zipfile
    from io import BytesIO
    import tempfile
    
    try:
        # Find presentation
        presentation = Collection.query.get_or_404(presentation_id)
        
        # Check ownership
        current_manager = current_user
        if presentation.created_by_manager_id != current_manager.id:
            return jsonify({'success': False, 'error': 'Access denied'}), 403
        
        # Get all properties in presentation
        properties = CollectionProperty.query.filter_by(
            collection_id=presentation_id
        ).all()
        
        print(f"DEBUG: Found {len(properties)} properties in presentation {presentation_id}")
        for prop in properties:
            print(f"DEBUG: Property ID: {prop.property_id}")
        
        if not properties:
            return jsonify({'success': False, 'error': 'No properties in presentation'}), 400
        
        # Create ZIP archive
        zip_buffer = BytesIO()
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for prop in properties:
                # Get property details from database using raw SQL for compatibility
                try:
                    query = text("""
                        SELECT 
                            p.inner_id AS id,
                            CAST(p.area AS FLOAT) AS area,
                            CAST(p.price AS INTEGER) AS price,
                            CAST(p.floor AS INTEGER) AS floor,
                            CAST(p.total_floors AS INTEGER) AS total_floors,
                            CAST(p.rooms AS INTEGER) AS rooms,
                            '–ö–≤–∞—Ä—Ç–∏—Ä–∞' AS property_type,
                            p.address AS address_display_name,
                            rc.name AS jk_name,
                            d.name AS developer_name,
                            NULL AS completion_date
                        FROM properties p
                        LEFT JOIN residential_complexes rc ON p.complex_id = rc.id
                        LEFT JOIN developers d ON p.developer_id = d.id
                        WHERE p.inner_id = CAST(:prop_id AS TEXT) OR p.id = :prop_id_int
                    """)
                    
                    try:
                        prop_id_int_val = int(prop.property_id)
                    except (ValueError, TypeError):
                        prop_id_int_val = -1
                    result = db.session.execute(query, {'prop_id': str(prop.property_id), 'prop_id_int': prop_id_int_val}).fetchone()
                    
                    if not result:
                        print(f"Property {prop.property_id} not found in database")
                        continue  # Skip if property not found
                        
                    # Convert row to object and compute safe values
                    from types import SimpleNamespace
                    row_dict = dict(result._mapping)
                    
                    # Ensure safe types and compute price per sqm
                    row_dict['price'] = int(row_dict['price'] or 0)
                    row_dict['area'] = float(row_dict['area'] or 0)
                    row_dict['rooms'] = int(row_dict['rooms'] or 0)
                    
                    # Compute price per sqm safely
                    if row_dict['area'] and row_dict['area'] > 0:
                        row_dict['price_per_sqm'] = int(row_dict['price'] / row_dict['area'])
                    else:
                        row_dict['price_per_sqm'] = 0
                        
                    property_item = SimpleNamespace(**row_dict)
                    property_data = [property_item]
                except Exception as e:
                    print(f"Database error for property {prop.property_id}: {e}")
                    continue
                
                if property_data:
                    property_item = property_data[0]
                    
                    # Use fetch_pdf_context to get all necessary data
                    context = fetch_pdf_context(prop.property_id, presentation_id)
                    if not context:
                        print(f"Failed to get context for property {prop.property_id}")
                        continue
                    
                    # Generate HTML for PDF with complete context
                    html_content = render_template('print_property.html', 
                                                 property=context['property'],
                                                 property_images=context['property_images'],
                                                 complex=context['complex'],
                                                 complex_images=context['complex_images'],
                                                 manager=context['manager'],
                                                 presentation=presentation,
                                                 manager_note=getattr(prop, 'manager_note', None),
                                                 context=context,
                                                 for_pdf=True)
                    
                    # Generate PDF
                    pdf_buffer = BytesIO()
                    HTML(string=html_content, base_url=request.host_url).write_pdf(pdf_buffer)
                    
                    # Add to ZIP
                    filename = f'property_{prop.property_id}.pdf'
                    zip_file.writestr(filename, pdf_buffer.getvalue())
                    print(f"DEBUG: Added {filename} to ZIP (size: {len(pdf_buffer.getvalue())} bytes)")
        
        zip_buffer.seek(0)
        print(f"DEBUG: ZIP created with total size: {len(zip_buffer.getvalue())} bytes")
        
        return send_file(
            zip_buffer,
            as_attachment=True,
            download_name=f'presentation_{presentation_id}_all_properties.zip',
            mimetype='application/zip'
        )
        
    except Exception as e:
        print(f"Error creating ZIP: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# REMOVED: This function runs in executor, NOT as a Flask route
def generate_pdf_archive_background(unique_id, base_url):
    """Background task to generate PDF archive"""
    # CRITICAL: Must run within Flask application context to access database
    with app.app_context():
        try:
            from models import Collection, CollectionProperty
            import zipfile
            from weasyprint import HTML
            from io import BytesIO
            
            # Find presentation
            presentation = Collection.query.filter_by(
                unique_url=unique_id,
                collection_type='presentation'
            ).first()
            
            if not presentation:
                progress_storage[f"presentation_{unique_id}"] = {
                    'stage': 'error',
                    'progress': 0,
                    'message': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'
                }
                return
            
            # Get properties with eager loading
            properties_data = CollectionProperty.query.filter_by(
                collection_id=presentation.id
            ).all()
            
            if not properties_data:
                progress_storage[f"presentation_{unique_id}"] = {
                    'stage': 'error',
                    'progress': 0,
                    'message': '–ù–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏'
                }
                return
            
            total = len(properties_data)
            progress_storage[f"presentation_{unique_id}"] = {
                'stage': 'starting',
                'progress': 0,
                'current': 0,
                'total': total,
                'message': f'–ù–∞—á–∏–Ω–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ {total} PDF —Ñ–∞–π–ª–æ–≤...'
            }
            
            print(f"DEBUG: Background task started for {total} properties")
            
            # Create temporary ZIP file
            zip_filename = f"presentation_{unique_id}_{int(time.time())}.zip"
            zip_path = os.path.join(TEMP_DOWNLOAD_DIR, zip_filename)
            
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for idx, cp in enumerate(properties_data, 1):
                    # Update progress
                    progress_pct = int((idx / total) * 90)  # 0-90% for PDF generation
                    progress_storage[f"presentation_{unique_id}"] = {
                        'stage': 'processing',
                        'progress': progress_pct,
                        'current': idx,
                        'total': total,
                        'message': f'–°–æ–∑–¥–∞—é PDF {idx} –∏–∑ {total}'
                    }
                    
                    # Use fetch_pdf_context to get all necessary data (same as download_all_properties_public)
                    context = fetch_pdf_context(cp.property_id, presentation.id)
                    if not context:
                        print(f"DEBUG: Failed to get context for property {cp.property_id}")
                        continue
                    
                    # Generate HTML for PDF with complete context (same template as download_all_properties_public)
                    html_content = render_template('print_property.html', 
                                                 property=context['property'],
                                                 property_images=context['property_images'],
                                                 complex=context['complex'],
                                                 complex_images=context['complex_images'],
                                                 manager=context['manager'],
                                                 presentation=presentation,
                                                 manager_note=getattr(cp, 'manager_note', None),
                                                 context=context,
                                                 for_pdf=True)
                    
                    # Generate PDF
                    pdf_buffer = BytesIO()
                    HTML(string=html_content, base_url=base_url).write_pdf(pdf_buffer)
                    
                    # Add to ZIP
                    pdf_filename = f"property_{cp.property_id}.pdf"
                    zipf.writestr(pdf_filename, pdf_buffer.getvalue())
                    
                    print(f"DEBUG: Added {pdf_filename} to ZIP (size: {len(pdf_buffer.getvalue())} bytes)")
            
            # Final progress
            progress_storage[f"presentation_{unique_id}"] = {
                'stage': 'complete',
                'progress': 100,
                'current': total,
                'total': total,
                'message': '–ê—Ä—Ö–∏–≤ –≥–æ—Ç–æ–≤!'
            }
            
            # Store file path
            file_storage[unique_id] = {
                'path': zip_path,
                'created_at': time.time()
            }
            
            print(f"DEBUG: ZIP created successfully: {zip_path}")
            
        except Exception as e:
            import traceback
            print(f"ERROR in background task: {str(e)}")
            traceback.print_exc()
            progress_storage[f"presentation_{unique_id}"] = {
                'stage': 'error',
                'progress': 0,
                'message': f'–û—à–∏–±–∫–∞: {str(e)}'
            }

@app.route('/presentation/view/<string:unique_id>/download-all')
def download_all_properties_public(unique_id):
    """–ü—É–±–ª–∏—á–Ω–æ–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –≤ ZIP –∞—Ä—Ö–∏–≤–µ"""
    from models import Collection, CollectionProperty
    from weasyprint import HTML, CSS
    import zipfile
    from io import BytesIO
    import tempfile
    
    try:
        # Find presentation by unique_id instead of presentation_id
        presentation = Collection.query.filter_by(
            unique_url=unique_id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return "–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", 404
        
        # Get all properties in presentation
        properties = CollectionProperty.query.filter_by(
            collection_id=presentation.id
        ).all()
        
        print(f"DEBUG: Found {len(properties)} properties in presentation {presentation.id}")
        for prop in properties:
            print(f"DEBUG: Property ID: {prop.property_id}")
        
        if not properties:
            return "–ù–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏", 400
        
        # Initialize progress tracking
        progress_key = f"presentation_{unique_id}"
        total_properties = len(properties)
        
        # Initialize progress at 0%
        progress_storage[progress_key] = {
            'stage': 'processing',
            'progress': 0,
            'current': 0,
            'total': total_properties,
            'message': f'–ù–∞—á–∏–Ω–∞—é —Å–æ–∑–¥–∞–Ω–∏–µ PDF —Ñ–∞–π–ª–æ–≤...'
        }
        print(f"DEBUG: Initialized progress for {total_properties} properties")
        
        # Create ZIP archive with real progress tracking
        zip_buffer = BytesIO()
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for current_index, prop in enumerate(properties, 1):
                # Update progress
                # progress = int((current_index / total_properties) * 90)  # Reserve 90-100% for finalization
                # progress_storage[progress_key] = {
                # 'stage': 'processing',
                # 'progress': progress,
                # 'current': current_index,
                # 'total': total_properties,
                # 'message': f'–°–æ–∑–¥–∞—é PDF –¥–ª—è –∫–≤–∞—Ä—Ç–∏—Ä—ã {current_index} –∏–∑ {total_properties}...'
                # }
                
                # Get property details from database using raw SQL for compatibility
                try:
                    query = text("""
                        SELECT 
                            p.inner_id AS id,
                            CAST(p.area AS FLOAT) AS area,
                            CAST(p.price AS INTEGER) AS price,
                            CAST(p.floor AS INTEGER) AS floor,
                            CAST(p.total_floors AS INTEGER) AS total_floors,
                            CAST(p.rooms AS INTEGER) AS rooms,
                            '–ö–≤–∞—Ä—Ç–∏—Ä–∞' AS property_type,
                            p.address AS address_display_name,
                            rc.name AS jk_name,
                            d.name AS developer_name,
                            NULL AS completion_date
                        FROM properties p
                        LEFT JOIN residential_complexes rc ON p.complex_id = rc.id
                        LEFT JOIN developers d ON p.developer_id = d.id
                        WHERE p.inner_id = CAST(:prop_id AS TEXT) OR p.id = :prop_id_int
                    """)
                    
                    try:
                        prop_id_int_val = int(prop.property_id)
                    except (ValueError, TypeError):
                        prop_id_int_val = -1
                    result = db.session.execute(query, {'prop_id': str(prop.property_id), 'prop_id_int': prop_id_int_val}).fetchone()
                    
                    if not result:
                        print(f"Property {prop.property_id} not found in database")
                        continue  # Skip if property not found
                        
                    # Convert row to object and compute safe values
                    from types import SimpleNamespace
                    row_dict = dict(result._mapping)
                    
                    # Ensure safe types and compute price per sqm
                    row_dict['price'] = int(row_dict['price'] or 0)
                    row_dict['area'] = float(row_dict['area'] or 0)
                    row_dict['rooms'] = int(row_dict['rooms'] or 0)
                    
                    # Compute price per sqm safely
                    if row_dict['area'] and row_dict['area'] > 0:
                        row_dict['price_per_sqm'] = int(row_dict['price'] / row_dict['area'])
                    else:
                        row_dict['price_per_sqm'] = 0
                        
                    property_item = SimpleNamespace(**row_dict)
                    property_data = [property_item]
                except Exception as e:
                    print(f"Database error for property {prop.property_id}: {e}")
                    continue
                
                if property_data:
                    property_item = property_data[0]
                    
                    # Use fetch_pdf_context to get all necessary data
                    context = fetch_pdf_context(prop.property_id, presentation.id)
                    if not context:
                        print(f"Failed to get context for property {prop.property_id}")
                        continue
                    
                    # Generate HTML for PDF with complete context
                    html_content = render_template('print_property.html', 
                                                 property=context['property'],
                                                 property_images=context['property_images'],
                                                 complex=context['complex'],
                                                 complex_images=context['complex_images'],
                                                 manager=context['manager'],
                                                 presentation=presentation,
                                                 manager_note=getattr(prop, 'manager_note', None),
                                                 context=context,
                                                 for_pdf=True)
                    
                    # Generate PDF
                    pdf_buffer = BytesIO()
                    HTML(string=html_content, base_url=request.host_url).write_pdf(pdf_buffer)
                    
                    # Add to ZIP
                    filename = f'property_{prop.property_id}.pdf'
                    zip_file.writestr(filename, pdf_buffer.getvalue())
                    print(f"DEBUG: Added {filename} to ZIP (size: {len(pdf_buffer.getvalue())} bytes)")
                    
                    # Update progress after each PDF is created
                    progress_percent = int((current_index / total_properties) * 90)  # Reserve 90-100% for finalization
                    progress_storage[progress_key] = {
                        'stage': 'processing',
                        'progress': progress_percent,
                        'current': current_index,
                        'total': total_properties,
                        'message': f'–°–æ–∑–¥–∞—é PDF {current_index} –∏–∑ {total_properties}'
                    }
                    print(f"DEBUG: Progress update: {progress_percent}% ({current_index}/{total_properties})")
        
        # Final progress - creating archive
        progress_storage[progress_key] = {
            'stage': 'completing',
            'progress': 90,
            'message': '–°–æ–∑–¥–∞—é –∞—Ä—Ö–∏–≤...'
        }
        
        zip_buffer.seek(0)
        print(f"DEBUG: ZIP created with total size: {len(zip_buffer.getvalue())} bytes")
        
        # Mark as complete
        progress_storage[progress_key] = {
            'stage': 'complete',
            'progress': 100,
            'message': '–ì–æ—Ç–æ–≤–æ! –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –Ω–∞—á–∞–ª–æ—Å—å.'
        }
        
        return send_file(
            zip_buffer,
            as_attachment=True,
            download_name=f'presentation_{presentation.title.replace(" ", "_")}_all_properties.zip',
            mimetype='application/zip'
        )
        
    except Exception as e:
        print(f"Error creating ZIP: {e}")
        
        # Update progress with error
        progress_key = f"presentation_{unique_id}"
        progress_storage[progress_key] = {
            'stage': 'error',
            'progress': 0,
            'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∞—Ä—Ö–∏–≤–∞: {str(e)}'
        }
        
        return f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∞—Ä—Ö–∏–≤–∞: {str(e)}", 500

# Global progress storage for tracking real-time PDF generation
progress_storage = {}

# Temporary ZIP file storage system
TEMP_DOWNLOAD_DIR = '/tmp/presentation_downloads'
os.makedirs(TEMP_DOWNLOAD_DIR, exist_ok=True)

# Storage for file paths keyed by unique_id
file_storage = {}  # Format: {unique_id: {'path': '/tmp/...zip', 'created_at': timestamp}}

# Thread pool for background PDF generation
pdf_executor = ThreadPoolExecutor(max_workers=3, thread_name_prefix='pdf_gen')

def cleanup_old_files():
    """Remove ZIP files older than 1 hour"""
    try:
        now = time.time()
        for filepath in glob.glob(f"{TEMP_DOWNLOAD_DIR}/*.zip"):
            if os.path.exists(filepath):
                file_age = now - os.path.getmtime(filepath)
                if file_age > 3600:  # 1 hour
                    os.remove(filepath)
                    print(f"Cleaned up old file: {filepath}")
    except Exception as e:
        print(f"Error during cleanup: {e}")

# Schedule cleanup on startup and every 30 minutes
atexit.register(cleanup_old_files)

@app.route('/presentation/view/<string:unique_id>/progress')
def download_progress_stream(unique_id):
    """SSE endpoint –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ —Å–æ–∑–¥–∞–Ω–∏—è PDF —Ñ–∞–π–ª–æ–≤"""
    from flask import Response
    import json
    import time
    from models import Collection, CollectionProperty
    
    try:
        # Find presentation by unique_id
        presentation = Collection.query.filter_by(
            unique_url=unique_id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            def error_stream():
                yield f"data: {json.dumps({'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'})}\n\n"
            return Response(
                error_stream(),
                content_type='text/event-stream',
                headers={
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Connection': 'keep-alive',
                    'X-Accel-Buffering': 'no'
                }
            )
        
        # Get properties count
        properties = CollectionProperty.query.filter_by(
            collection_id=presentation.id
        ).all()
        
        if not properties:
            def error_stream():
                yield f"data: {json.dumps({'error': '–ù–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏'})}\n\n"
            return Response(
                error_stream(),
                content_type='text/event-stream',
                headers={
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Connection': 'keep-alive',
                    'X-Accel-Buffering': 'no'
                }
            )
            
        def progress_generator():
            try:
                total = len(properties)
                progress_key = f"presentation_{unique_id}"
                
                # Initialize progress
                progress_storage[progress_key] = {
                    'stage': 'starting',
                    'progress': 0,
                    'current': 0,
                    'total': total,
                    'message': '–ù–∞—á–∏–Ω–∞—é —Å–æ–∑–¥–∞–Ω–∏–µ PDF —Ñ–∞–π–ª–æ–≤...'
                }
                
                # –ù–∞—á–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                yield f"data: {json.dumps(progress_storage[progress_key])}\n\n"
                time.sleep(1)
                
                # Wait for real progress updates from download endpoint
                last_progress = 0
                timeout_counter = 0
                
                while True:
                    if progress_key in progress_storage:
                        current_progress = progress_storage[progress_key]
                        
                        # Only send updates when progress changes
                        if current_progress['progress'] != last_progress or current_progress['stage'] != 'processing':
                            yield f"data: {json.dumps(current_progress)}\n\n"
                            last_progress = current_progress['progress']
                        
                        # Check if completed
                        if current_progress['stage'] == 'complete':
                            break
                            
                        # Check if error occurred
                        if current_progress['stage'] == 'error':
                            break
                    
                    time.sleep(0.5)
                    timeout_counter += 1
                    
                    # Timeout after 2 minutes
                    if timeout_counter > 240:
                        progress_storage[progress_key] = {
                            'stage': 'error',
                            'message': '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è',
                            'progress': 0
                        }
                        yield f"data: {json.dumps(progress_storage[progress_key])}\n\n"
                        break
                
                # Cleanup
                if progress_key in progress_storage:
                    del progress_storage[progress_key]
                    
            except Exception as e:
                yield f"data: {json.dumps({'error': f'–û—à–∏–±–∫–∞: {str(e)}'})}\n\n"
        
        return Response(
            progress_generator(),
            content_type='text/event-stream',
            headers={
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'Pragma': 'no-cache',
                'Expires': '0',
                'Connection': 'keep-alive',
                'X-Accel-Buffering': 'no',  # Disable nginx buffering
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Headers': 'Cache-Control',
                'Content-Type': 'text/event-stream; charset=utf-8'
            }
        )
        
    except Exception as e:
        def error_stream():
            yield f"data: {json.dumps({'error': f'–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}'})}\n\n"
        return Response(error_stream(), content_type='text/plain')


@app.route('/presentation/view/<string:unique_id>/progress-poll')

def poll_pdf_progress(unique_id):
    """Poll progress of background PDF generation"""
    try:
        progress_key = f"presentation_{unique_id}"
        
        if progress_key in progress_storage:
            return jsonify(progress_storage[progress_key])
        else:
            # No progress yet - task might not be started
            return jsonify({
                'status': 'pending',
                'progress': 0,
                'message': '–û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–ø—É—Å–∫–∞...'
            })
    except Exception as e:
        return jsonify({
            'status': 'error',
            'progress': 0,
            'message': str(e)
        }), 500

@app.route('/presentation/view/<string:unique_id>/start-generation', methods=['POST'])
def start_pdf_generation(unique_id):
    """Start background PDF generation task"""
    try:
        # Validate presentation exists
        from models import Collection
        presentation = Collection.query.filter_by(
            unique_url=unique_id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return jsonify({'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # Submit background task
        # Capture base_url from request context before submitting to executor
        base_url = request.url_root
        pdf_executor.submit(generate_pdf_archive_background, unique_id, base_url)
        
        return jsonify({
            'success': True,
            'message': '–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–ø—É—â–µ–Ω–∞'
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/presentation/view/<string:unique_id>/download-result')
def download_pdf_result(unique_id):
    """Download the generated ZIP file"""
    try:
        # Check if file exists in storage
        if unique_id not in file_storage:
            return "–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –µ—â–µ –Ω–µ –≥–æ—Ç–æ–≤", 404
        
        file_info = file_storage[unique_id]
        zip_path = file_info['path']
        
        if not os.path.exists(zip_path):
            return "–§–∞–π–ª –±—ã–ª —É–¥–∞–ª–µ–Ω", 404
        
        # Send file and clean up
        response = send_file(
            zip_path,
            as_attachment=True,
            download_name=f'presentation_{unique_id}.zip',
            mimetype='application/zip'
        )
        
        # Schedule cleanup (remove from storage after sending)
        def cleanup_after_send():
            time.sleep(5)  # Wait for download to start
            if unique_id in file_storage:
                del file_storage[unique_id]
            if os.path.exists(zip_path):
                os.remove(zip_path)
        
        threading.Thread(target=cleanup_after_send, daemon=True).start()
        
        return response
        
    except Exception as e:
        return f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏: {str(e)}", 500
def download_progress_poll(unique_id):
    """Polling endpoint for PDF generation progress (replaces SSE)"""
    from flask import jsonify
    
    progress_key = f"presentation_{unique_id}"
    
    if progress_key in progress_storage:
        return jsonify(progress_storage[progress_key])
    else:
        # No progress yet or already completed
        return jsonify({
            'stage': 'waiting',
            'progress': 0,
            'message': '–û–∂–∏–¥–∞–Ω–∏–µ...'
        })

@app.route('/api/manager/presentation/<int:presentation_id>/send-email', methods=['POST'])
@manager_required
# @require_json_csrf  # CSRF disabled
def send_presentation_email(presentation_id):
    """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –Ω–∞ email"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    import smtplib
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText
    from email.mime.base import MIMEBase
    from email import encoders
    
    try:
        data = request.get_json()
        if not data or not data.get('email'):
            return jsonify({'success': False, 'error': 'Email –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
        
        email = data['email']
        
        # Find presentation
        presentation = Collection.query.get_or_404(presentation_id)
        
        # Check ownership
        current_manager = current_user
        if presentation.created_by_manager_id != current_manager.id:
            return jsonify({'success': False, 'error': 'Access denied'}), 403
        
        # Get properties count
        properties_count = CollectionProperty.query.filter_by(
            collection_id=presentation_id
        ).count()
        
        # Create simple email (without attachments for now)
        msg = MIMEMultipart()
        msg['From'] = "noreply@inback.ru"
        msg['To'] = email
        msg['Subject'] = f"–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –æ—Ç InBack - {presentation.name}"
        
        # Email body
        body = f"""
        –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ!
        
        –í—ã—Å—ã–ª–∞–µ–º –≤–∞–º –ø–æ–¥–æ–±—Ä–∞–Ω–Ω—É—é –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ "{presentation.name}".
        
        –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—ä–µ–∫—Ç–æ–≤: {properties_count}
        
        –ß—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é, –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ:
        {request.host_url}manager/presentation/{presentation_id}
        
        –° —É–≤–∞–∂–µ–Ω–∏–µ–º,
        –ö–æ–º–∞–Ω–¥–∞ InBack
        """
        
        msg.attach(MIMEText(body, 'plain', 'utf-8'))
        
        # Send email (simplified version - would need real SMTP config)
        print(f"EMAIL SENT TO: {email}")
        print(f"EMAIL BODY: {body}")
        
        return jsonify({
            'success': True,
            'message': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ email'
        })
        
    except Exception as e:
        print(f"Error sending email: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/presentation/<int:presentation_id>/add-complex', methods=['POST'])
@csrf.exempt
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def add_complex_to_presentation(presentation_id):
    """–î–æ–±–∞–≤–∏—Ç—å –ñ–ö –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é (–±–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    complex_id = data.get('complex_id')
    if not complex_id:
        return jsonify({'success': False, 'error': 'ID –ñ–ö –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
    
    # Get current manager
    current_manager = current_user
        
    # –°—Ç—Ä–æ–≥–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–ª–∞–¥–µ–Ω–∏—è –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–µ–π
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_manager.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞'}), 404
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã –∏–∑ –ñ–ö
        properties = load_properties()
        complex_properties = []
        
        for prop in properties:
            if str(prop.get('complex_id')) == str(complex_id):
                complex_properties.append(prop)
        
        if not complex_properties:
            return jsonify({'success': False, 'error': '–ñ–ö –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –≤ –Ω–µ–º –Ω–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤'}), 404
        
        added_count = 0
        for prop in complex_properties[:5]:  # –î–æ–±–∞–≤–ª—è–µ–º –º–∞–∫—Å–∏–º—É–º 5 –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –ñ–ö
            property_id = prop.get('ID')
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω –ª–∏ —É–∂–µ —ç—Ç–æ—Ç –æ–±—ä–µ–∫—Ç
            existing = CollectionProperty.query.filter_by(
                collection_id=presentation_id,
                property_id=property_id
            ).first()
            
            if not existing:
                # DUAL WRITE: Resolve property to get both IDs
                property_obj, canonical_id = resolve_property_by_identifier(property_id)
                if not property_obj:
                    continue  # Skip if property not found
                
                collection_property = CollectionProperty(
                    collection_id=presentation_id,
                    property_id=str(property_obj.id),  # Old: database ID
                    property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
                    property_name=f"{prop.get('Type', '')} –≤ {prop.get('Complex', '')}",
                    property_price=int(prop.get('Price', 0)) if prop.get('Price') else None,
                    complex_name=prop.get('Complex', ''),
                    property_type=prop.get('Type', ''),
                    property_size=float(prop.get('Size', 0)) if prop.get('Size') else None,
                    order_index=len(presentation.properties) + added_count + 1
                )
                
                db.session.add(collection_property)
                added_count += 1
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'–î–æ–±–∞–≤–ª–µ–Ω–æ {added_count} –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –ñ–ö –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é',
            'added_count': added_count
        })
        
    except Exception as e:
        db.session.rollback()
@app.route('/api/manager/presentation/create-with-property', methods=['POST'])
@csrf.exempt
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def create_presentation_with_property():
    """–°–æ–∑–¥–∞—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –∏ —Å—Ä–∞–∑—É –¥–æ–±–∞–≤–∏—Ç—å –æ–±—ä–µ–∫—Ç (–±–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    print(f"üéØ DEBUG: create_presentation_with_property called")
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
    print(f"üéØ DEBUG: Got data: {data}")
        
    title = data.get('title', '').strip()
    client_name = data.get('client_name', '').strip()
    property_id = data.get('property_id')
    
    # –°—Ç—Ä–æ–≥–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
    if not title:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    if not property_id:
        return jsonify({'success': False, 'error': 'ID –æ–±—ä–µ–∫—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'}), 400
    
    
    # Convert to int if it's a string, keep as int if already int
    try:
        property_id_int = int(property_id) if isinstance(property_id, str) else property_id
        property_id = str(property_id_int)  # Convert to string for VARCHAR column
    except (ValueError, TypeError):
        return jsonify({'success': False, 'error': '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π ID –æ–±—ä–µ–∫—Ç–∞'}), 400

    try:
        # Get current manager
        current_manager = current_user
        print(f"üéØ DEBUG: current_manager set to {current_manager}")
            
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection(
            title=title,
            created_by_manager_id=current_manager.id,
            collection_type='presentation',
            client_name=client_name,
            status='–ß–µ—Ä–Ω–æ–≤–∏–∫'
        )
        print(f"üéØ DEBUG: presentation object created")
        
        presentation.generate_unique_url()
        print(f"üéØ DEBUG: unique URL generated")
        db.session.add(presentation)
        print(f"üéØ DEBUG: presentation added to session")
        db.session.flush()  # –ü–æ–ª—É—á–∞–µ–º ID –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        print(f"üéØ DEBUG: flushed, presentation ID: {presentation.id}")
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—ä–µ–∫—Ç - direct DB query instead of Excel cache
        from models import Property
        property_obj = Property.query.get(property_id_int)
        
        if not property_obj:
            print(f"üéØ DEBUG: Property {property_id} not found in database")
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        print(f"üéØ DEBUG: property_obj found: {property_obj}")
        
        collection_property = CollectionProperty(
            collection_id=presentation.id,
            property_id=str(property_obj.id),  # Old: database ID
            property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
            property_name=property_obj.title or f"{property_obj.rooms}-–∫–æ–º–Ω –≤ {property_obj.residential_complex.name if property_obj.residential_complex else ''}",
            property_price=property_obj.price,
            complex_name=property_obj.residential_complex.name if property_obj.residential_complex else '',
            property_type=f"{property_obj.rooms}-–∫–æ–º–Ω" if property_obj.rooms else "–°—Ç—É–¥–∏—è",
            property_size=property_obj.area,
            order_index=1
        )
        print(f"üéØ DEBUG: collection_property created")
        
        db.session.add(collection_property)
        print(f"üéØ DEBUG: about to commit")
        db.session.commit()
        print(f"üéØ DEBUG: committed successfully")
        
        return jsonify({
            'success': True,
            'presentation': presentation.to_dict(),
            'message': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞ –∏ –æ–±—ä–µ–∫—Ç –¥–æ–±–∞–≤–ª–µ–Ω'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400
@app.route('/api/manager/presentation/create-with-complex', methods=['POST'])
@csrf.exempt
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def create_presentation_with_complex():
    """–°–æ–∑–¥–∞—Ç—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é –∏ —Å—Ä–∞–∑—É –¥–æ–±–∞–≤–∏—Ç—å –ñ–ö (–±–µ–∑–æ–ø–∞—Å–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    # –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': '–î–∞–Ω–Ω—ã–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω—ã'}), 400
        
    title = data.get('title', '').strip()
    client_name = data.get('client_name', '').strip()
    complex_id = data.get('complex_id')
    
    # –°—Ç—Ä–æ–≥–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
    if not title:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    if not complex_id:
        return jsonify({'success': False, 'error': 'ID –ñ–ö –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'}), 400
    
    try:
        # Get current manager
        current_manager = current_user
            
        # –°–æ–∑–¥–∞–µ–º –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection(
            title=title,
            created_by_manager_id=current_manager.id,
            collection_type='presentation', 
            client_name=client_name,
            status='–ß–µ—Ä–Ω–æ–≤–∏–∫'
        )
        
        presentation.generate_unique_url()
        db.session.add(presentation)
        db.session.flush()  # –ü–æ–ª—É—á–∞–µ–º ID –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—ä–µ–∫—Ç—ã –∏–∑ –ñ–ö
        properties = load_properties()
        complex_properties = []
        
        for prop in properties:
            if str(prop.get('complex_id')) == str(complex_id):
                complex_properties.append(prop)
        
        if not complex_properties:
            return jsonify({'success': False, 'error': '–ñ–ö –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –≤ –Ω–µ–º –Ω–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤'}), 404
        
        added_count = 0
        for prop in complex_properties[:5]:  # –î–æ–±–∞–≤–ª—è–µ–º –º–∞–∫—Å–∏–º—É–º 5 –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –ñ–ö
            property_id = prop.get('ID')
            
            # DUAL WRITE: Resolve property to get both IDs
            property_obj, canonical_id = resolve_property_by_identifier(property_id)
            if not property_obj:
                continue  # Skip if property not found
            
            collection_property = CollectionProperty(
                collection_id=presentation.id,
                property_id=str(property_obj.id),  # Old: database ID
                property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
                property_name=f"{prop.get('Type', '')} –≤ {prop.get('Complex', '')}",
                property_price=int(prop.get('Price', 0)) if prop.get('Price') else None,
                complex_name=prop.get('Complex', ''),
                property_type=prop.get('Type', ''),
                property_size=float(prop.get('Size', 0)) if prop.get('Size') else None,
                order_index=added_count + 1
            )
            
            db.session.add(collection_property)
            added_count += 1
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'presentation': presentation.to_dict(),
            'message': f'–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞ —Å {added_count} –æ–±—ä–µ–∫—Ç–∞–º–∏ –∏–∑ –ñ–ö'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400


# ===== –ù–û–í–´–ï API ENDPOINT'–´ –î–õ–Ø –î–ï–ô–°–¢–í–ò–ô –° –û–ë–™–ï–ö–¢–ê–ú–ò –í –ü–†–ï–ó–ï–ù–¢–ê–¶–ò–ò =====

# REMOVED DUPLICATE PRINT ENDPOINT - security fix
    from models import Collection, CollectionProperty
    
    try:
        # –ù–∞–π—Ç–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            abort(404)
        
        prop_obj, inner_id_str = resolve_property_by_identifier(property_id)
        if not prop_obj:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        collection_property = CollectionProperty.query.filter(
            CollectionProperty.collection_id == presentation_id,
            db.or_(
                CollectionProperty.property_id == inner_id_str,
                CollectionProperty.property_id == str(property_id),
                CollectionProperty.property_id == str(prop_obj.id)
            )
        ).first()
        
        if not collection_property:
            abort(404)
        
        # –ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç–∞
        properties = load_properties()
        property_data = None
        
        for prop in properties:
            if str(prop.get('id')) == str(property_id) or str(prop.get('ID')) == str(property_id) or str(prop.get('inner_id')) == str(property_id):
                property_data = prop
                break
        
        if not property_data:
            abort(404)
        
        # –†–µ–Ω–¥–µ—Ä–∏—Ç—å print-friendly –≤–µ—Ä—Å–∏—é
        return render_template('property_print.html', 
                             property=property_data,
                             presentation=presentation,
                             collection_property=collection_property)
        
    except Exception as e:
        print(f"Error in property_print_view: {e}")
        abort(500)


@app.route('/api/presentation/<int:presentation_id>/property/<string:property_id>/download')
@manager_required
def property_download_pdf(presentation_id, property_id):
    """–°–∫–∞—á–∞—Ç—å PDF –æ–±—ä–µ–∫—Ç–∞ –∏–∑ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏"""
    from models import Collection, CollectionProperty
    from flask import make_response
    import io
    
    # Try to import weasyprint with fallback
    try:
        import weasyprint
        pdf_available = True
    except ImportError:
        pdf_available = False
    
    try:
        # –ù–∞–π—Ç–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            abort(404)
        
        prop_obj, inner_id_str = resolve_property_by_identifier(property_id)
        if not prop_obj:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        collection_property = CollectionProperty.query.filter(
            CollectionProperty.collection_id == presentation_id,
            db.or_(
                CollectionProperty.property_id == inner_id_str,
                CollectionProperty.property_id == str(property_id),
                CollectionProperty.property_id == str(prop_obj.id)
            )
        ).first()
        
        if not collection_property:
            abort(404)
        
        # –ó–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É—è fetch_pdf_context –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ñ–æ—Ç–æ –∏ –∫—ç—à–±–µ–∫–∞
        context = fetch_pdf_context(property_id, presentation_id)
        
        if not context:
            abort(404)
        
        # Check if PDF generation is available
        if not pdf_available:
            # Fallback: redirect to print view
            return redirect(url_for('property_print_view', 
                                  presentation_id=presentation_id, 
                                  property_id=property_id))
        
        # –†–µ–Ω–¥–µ—Ä–∏—Ç—å HTML –¥–ª—è PDF —Å –ø–æ–ª–Ω—ã–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º (—Ç–æ—Ç –∂–µ —à–∞–±–ª–æ–Ω —á—Ç–æ –∏ –¥–ª—è –∞—Ä—Ö–∏–≤–∞)
        html_content = render_template('print_property.html', 
                                     property=context['property'],
                                     property_images=context['property_images'],
                                     complex=context['complex'],
                                     complex_images=context['complex_images'],
                                     manager=context['manager'],
                                     presentation=presentation,
                                     manager_note=getattr(collection_property, 'manager_note', None),
                                     context=context,
                                     for_pdf=True)
        
        # –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å PDF
        try:
            pdf_buffer = io.BytesIO()
            weasyprint.HTML(string=html_content, base_url=request.url_root).write_pdf(pdf_buffer)
            pdf_buffer.seek(0)
            
            # –°–æ–∑–¥–∞—Ç—å ASCII-safe –∏–º—è —Ñ–∞–π–ª–∞ –¥–ª—è headers
            property_name = context['property'].get('name', f"–û–±—ä–µ–∫—Ç_{property_id}")
            original_filename = f"{property_name}_{presentation.title}.pdf"
            
            # Create ASCII-safe filename for HTTP headers
            ascii_filename = f"property_{property_id}_{presentation_id}.pdf"
            
            # Clean original filename for RFC 5987 encoding if needed
            clean_filename = "".join(c for c in original_filename if c.isalnum() or c in (' ', '.', '_', '-')).rstrip()
        except Exception as pdf_error:
            print(f"PDF generation failed: {pdf_error}")
            # Fallback: redirect to print view
            return redirect(url_for('property_print_view', 
                                  presentation_id=presentation_id, 
                                  property_id=property_id))
        
        # –í–µ—Ä–Ω—É—Ç—å PDF –∫–∞–∫ —Ñ–∞–π–ª –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∫–æ–¥–∏—Ä–æ–≤–∫–æ–π
        from urllib.parse import quote
        
        response = make_response(pdf_buffer.read())
        response.headers['Content-Type'] = 'application/pdf'
        
        # Use ASCII-safe filename in Content-Disposition with RFC 5987 fallback for Unicode
        try:
            # Try to encode original filename for browsers that support RFC 5987
            encoded_filename = quote(clean_filename.encode('utf-8'))
            response.headers['Content-Disposition'] = (
                f'attachment; '
                f'filename="{ascii_filename}"; '
                f'filename*=UTF-8\'\'{encoded_filename}'
            )
        except:
            # Fallback to ASCII-only filename
            response.headers['Content-Disposition'] = f'attachment; filename="{ascii_filename}"'
        
        return response
        
    except Exception as e:
        print(f"Error in property_download_pdf: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/presentation/<int:presentation_id>/property/<string:property_id>/view')
def property_view_redirect(presentation_id, property_id):
    """–ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ –ø–æ–ª–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –æ–±—ä–µ–∫—Ç–∞ –Ω–∞ —Å–∞–π—Ç–µ"""
    from models import Collection, CollectionProperty
    
    try:
        # –ù–∞–π—Ç–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            abort(404)
        
        prop_obj, inner_id_str = resolve_property_by_identifier(property_id)
        if not prop_obj:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # –ù–∞–π—Ç–∏ –æ–±—ä–µ–∫—Ç –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É—è inner_id
        # Resolve property by inner_id OR database ID
        prop_obj, canonical_id = resolve_property_by_identifier(property_id)
        if not prop_obj:
            return jsonify({"success": False, "error": "–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"}), 404
        
        collection_property = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=inner_id_str
        ).first()
        
        if not collection_property:
            abort(404)
        
        # –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–∏—Ç—å –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –æ–±—ä–µ–∫—Ç–∞
        return redirect(url_for('property_detail', property_id=property_id))
        
    except Exception as e:
        print(f"Error in property_view_redirect: {e}")
        abort(500)


@app.route('/api/manager/presentation/<int:presentation_id>/property/<string:property_id>/delete', methods=['DELETE'])
@csrf.exempt
@manager_required
def delete_property_from_presentation(presentation_id, property_id):
    """–£–¥–∞–ª–∏—Ç—å –æ–±—ä–µ–∫—Ç –∏–∑ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ (—Ç–æ–ª—å–∫–æ –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞-–≤–ª–∞–¥–µ–ª—å—Ü–∞)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    try:
        # –ù–∞–π—Ç–∏ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ - —Ç–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –º–æ–∂–µ—Ç —É–¥–∞–ª—è—Ç—å –æ–±—ä–µ–∫—Ç—ã
        if presentation.created_by_manager_id != current_user.id:
            return jsonify({'success': False, 'error': '–ù–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ —ç—Ç–æ–π –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏'}), 403
        
        prop_obj, inner_id_str = resolve_property_by_identifier(property_id)
        if not prop_obj:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        collection_property = CollectionProperty.query.filter(
            CollectionProperty.collection_id == presentation_id,
            db.or_(
                CollectionProperty.property_id == inner_id_str,
                CollectionProperty.property_id == str(property_id),
                CollectionProperty.property_id == str(prop_obj.id)
            )
        ).first()
        
        if not collection_property:
            return jsonify({'success': False, 'error': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏'}), 404
        
        # –£–¥–∞–ª–∏—Ç—å –æ–±—ä–µ–∫—Ç –∏–∑ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        db.session.delete(collection_property)
        db.session.commit()
        
        # –û–±–Ω–æ–≤–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—ä–µ–∫—Ç–æ–≤ –≤ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        remaining_properties = CollectionProperty.query.filter_by(collection_id=presentation_id).count()
        
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω –∏–∑ –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏',
            'remaining_properties': remaining_properties
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error in delete_property_from_presentation: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


def send_collection_to_user():
    """Send collection to user - legacy function"""
    if request.method != 'POST':
        return jsonify({'success': False, 'error': 'Only POST method allowed'}), 405
    
    data = request.get_json()
    current_manager = current_user
    
    try:
        name = data.get('name')
        client_id = data.get('client_id')
        property_ids = data.get('property_ids', [])
        
        if not name or not client_id or not property_ids:
            return jsonify({'success': False, 'error': 'Missing required fields'}), 400
        
        # Get client and manager info
        client = User.query.get(client_id)
        manager = current_manager
        
        if not client or not manager:
            return jsonify({'success': False, 'error': 'Client or manager not found'}), 404
        
        # Load property details
        with open('data/properties_expanded.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        selected_properties = []
        total_cashback = 0
        
        for prop_id in property_ids:
            for prop in properties_data:
                if str(prop.get('id')) == str(prop_id):
                    price = prop.get('price', 0)
                    cashback = int(price * 0.05)
                    total_cashback += cashback
                    
                    selected_properties.append({
                        'complex_name': prop.get('complex_name', ''),
                        'district': prop.get('district', ''),
                        'developer': prop.get('developer', ''),
                        'rooms': prop.get('rooms', 0),
                        'area': prop.get('area', 0),
                        'price': price,
                        'cashback': cashback,
                        'type': prop.get('type', ''),
                        'description': prop.get('description', '')
                    })
                    break
        
        # Create email content
        properties_list = '\n'.join([
            f"‚Ä¢ {prop['complex_name']} ({prop['district']})\n"
            f"  {prop['rooms']}-–∫–æ–º–Ω., {prop['area']} –º¬≤\n"
            f"  –¶–µ–Ω–∞: {prop['price']:,} ‚ÇΩ\n"
            f"  –ö–µ—à–±–µ–∫: {prop['cashback']:,} ‚ÇΩ\n"
            for prop in selected_properties
        ])
        
        subject = f"–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {name}"
        text_message = f"""
–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {client.full_name}!

–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä {manager.full_name} –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –¥–ª—è –≤–∞—Å –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—É—é –ø–æ–¥–±–æ—Ä–∫—É –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ "{name}".

–ü–û–î–û–ë–†–ê–ù–ù–´–ï –û–ë–™–ï–ö–¢–´ ({len(selected_properties)} —à—Ç.):

{properties_list}

–û–ë–©–ò–ô –ö–ï–®–ë–ï–ö: {total_cashback:,} ‚ÇΩ

–î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏ –∑–∞–ø–∏—Å–∏ –Ω–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –≤–∞—à–∏–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º:
{manager.full_name}
Email: {manager.email}
–¢–µ–ª–µ—Ñ–æ–Ω: {manager.phone or '–Ω–µ —É–∫–∞–∑–∞–Ω'}

–ò–ª–∏ –ø–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç –Ω–∞ —Å–∞–π—Ç–µ InBack.ru

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,
–ö–æ–º–∞–Ω–¥–∞ InBack.ru
        """.strip()
        
        # Send email
        try:
            from email_service import send_email
            send_email(
                to_email=client.email,
                subject=subject,
                text_content=text_message,
                template_name='collection'
            )
            
            return jsonify({
                'success': True,
                'message': f'–ü–æ–¥–±–æ—Ä–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–∞ email {client.email}'
            })
            
        except Exception as e:
            print(f"Error sending email: {e}")
            return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ email'}), 500
        
    except Exception as e:
        print(f"Error sending collection: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/data/properties_expanded.json')
def properties_json():
    """Serve properties JSON data"""
    try:
        properties = load_properties()
        return jsonify(properties)
    except Exception as e:
        print(f"Error serving properties JSON: {e}")
        return jsonify([]), 500

# Database initialization will be done after all imports

# Client Recommendations API endpoints
@app.route('/api/user/collections', methods=['GET'])
@login_required
def api_user_get_collections():
    """Get collections assigned to current user"""
    from models import Collection
    import json
    from zoneinfo import ZoneInfo
    
    try:
        collections = Collection.query.filter_by(
            assigned_to_user_id=current_user.id
        ).order_by(Collection.created_at.desc()).all()
        
        collections_data = []
        for collection in collections:
            # Get manager info
            manager = collection.created_by
            manager_name = manager.full_name if manager else '–ú–µ–Ω–µ–¥–∂–µ—Ä'
            # Use manager's profile image if available, otherwise use first letter
            # Use manager's profile image if available and not randomuser.me, otherwise use first letter
            if manager and manager.profile_image and 'randomuser.me' not in manager.profile_image:
                # Convert relative path to absolute URL
                if manager.profile_image.startswith('http'):
                    manager_avatar = manager.profile_image
                else:
                    base_url = request.host_url.rstrip('/')
                    manager_avatar = f"{base_url}{manager.profile_image}"
            else:
                manager_avatar = manager_name[0].upper() if manager_name else '–ú'
            
            # ‚úÖ MIGRATED: Get properties with images from normalized tables
            properties_data = []
            for prop in collection.properties[:4]:
                # Load property - try by ID first, then by inner_id for consistency
                property_obj = PropertyRepository.get_by_id(prop.property_id)
                if not property_obj:
                    from models import Property as PropertyModel
                    property_obj = PropertyModel.query.filter_by(inner_id=prop.property_id).first()
                if property_obj:
                    # Get first photo from photos array
                    image_url = ''
                    if property_obj.gallery_images:
                        try:
                            photos_list = json.loads(property_obj.gallery_images) if isinstance(property_obj.gallery_images, str) else property_obj.gallery_images
                            image_url = photos_list[0] if photos_list and len(photos_list) > 0 else ''
                        except Exception as photo_error:
                            print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                    
                    # Build title from property data
                    rooms_text = f"{property_obj.rooms}-–∫–æ–º–Ω" if property_obj.rooms and property_obj.rooms > 0 else "–°—Ç—É–¥–∏—è"
                    area_text = f"{property_obj.area} –º¬≤" if property_obj.area else ""
                    title = f"{rooms_text}, {area_text}".strip(', ')
                    
                    properties_data.append({
                        'id': prop.property_id,
                        'image': image_url,
                        'title': title
                    })
            
            collections_data.append({
                'id': collection.id,
                'title': collection.title,
                'description': collection.description,
                'status': collection.status,
                'created_at': collection.created_at.replace(tzinfo=ZoneInfo('UTC')).astimezone(ZoneInfo('Europe/Moscow')).strftime('%d.%m.%Y –≤ %H:%M'),
                'manager_name': manager_name,
                'manager_avatar': manager_avatar,
                'properties_count': len(collection.properties),
                'properties': properties_data,
                'unique_url': collection.unique_url
            })
        
        print(f"üéØ Collections API: returning {len(collections_data)} collections")
        
        return jsonify({
            'success': True,
            'collections': collections_data
        })
        
    except Exception as e:
        print(f"‚ùå Error loading collections: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 400

@login_required
def api_user_get_saved_searches():
    """Get saved searches for current user"""
    from models import SavedSearch
    
    try:
        # Get regular saved searches
        saved_searches = SavedSearch.query.filter_by(
            user_id=current_user.id
        ).order_by(SavedSearch.created_at.desc()).all()
        
        # Get sent searches from managers
        from models import SentSearch
        sent_searches = SentSearch.query.filter_by(
            client_id=current_user.id
        ).order_by(SentSearch.sent_at.desc()).all()
        
        searches_data = []
        
        # Add regular saved searches
        for search in saved_searches:
            filters = {}
            if search.filters:
                import json
                filters = json.loads(search.filters) if isinstance(search.filters, str) else search.filters
            
            searches_data.append({
                'id': search.id,
                'name': search.name,
                'filters': filters,
                'created_at': search.created_at.strftime('%d.%m.%Y'),
                'last_used': search.last_used.strftime('%d.%m.%Y') if search.last_used else None,
                'type': 'saved'
            })
        
        # Add sent searches from managers
        for search in sent_searches:
            filters = {}
            if search.additional_filters:
                import json
                filters = json.loads(search.additional_filters) if isinstance(search.additional_filters, str) else search.additional_filters
            
            searches_data.append({
                'id': search.id,
                'name': search.name,
                'filters': filters,
                'created_at': search.sent_at.strftime('%d.%m.%Y') if search.sent_at else '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                'last_used': search.applied_at.strftime('%d.%m.%Y') if search.applied_at else None,
                'type': 'sent',
                'from_manager': True
            })
        
        return jsonify({
            'success': True,
            'searches': searches_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/recommendations', methods=['GET'])
@login_required
def api_user_get_recommendations():
    """Get recommendations for current user"""
    from models import Recommendation, SentSearch
    from datetime import datetime
    
    try:
        print(f"DEBUG: Loading recommendations for user ID: {current_user.id}")
        
        # Get traditional recommendations
        recommendations = Recommendation.query.filter_by(
            client_id=current_user.id
        ).order_by(Recommendation.sent_at.desc()).all()
        
        print(f"DEBUG: Found {len(recommendations)} recommendations for user {current_user.id}")
        
        recommendations_data = []
        for rec in recommendations:
            rec_data = rec.to_dict()
            rec_data['manager_name'] = f"{rec.manager.first_name} {rec.manager.last_name}" if rec.manager else '–ú–µ–Ω–µ–¥–∂–µ—Ä'
            recommendations_data.append(rec_data)
        
        # Get sent searches from managers as recommendations  
        sent_searches = SentSearch.query.filter_by(client_id=current_user.id).order_by(SentSearch.sent_at.desc()).all()
        
        # Convert sent searches to recommendation format
        for search in sent_searches:
            search_rec = {
                'id': f'search_{search.id}',
                'title': f'–ü–æ–¥–±–æ—Ä –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏: {search.name}',
                'description': search.description or '–ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥–±–æ—Ä –æ—Ç –≤–∞—à–µ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
                'recommendation_type': 'search',
                'item_id': str(search.id),
                'item_name': search.name,
                'manager_notes': f'–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä {search.manager.name} –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥–±–æ—Ä –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏',
                'priority_level': 'high',
                'status': search.status,
                'viewed_at': search.viewed_at.isoformat() if search.viewed_at else None,
                'created_at': search.sent_at.isoformat() if search.sent_at else None,
                'sent_at': search.sent_at.isoformat() if search.sent_at else None,
                'manager_name': search.manager.name,
                'search_filters': search.additional_filters,
                'search_id': search.id
            }
            recommendations_data.append(search_rec)
        
        # Sort by creation date 
        recommendations_data.sort(key=lambda x: x.get('created_at', ''), reverse=True)
        
        return jsonify({
            'success': True, 
            'recommendations': recommendations_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/saved-searches/<int:search_id>')
@login_required
def get_saved_search_details(search_id):
    """Get saved search details for applying filters"""
    from models import SavedSearch
    
    try:
        user_id = session.get('user_id')
        if not user_id:
            return jsonify({'success': False, 'error': 'User not authenticated'}), 401
        
        # Get the saved search
        saved_search = SavedSearch.query.filter_by(id=search_id, user_id=user_id).first()
        if not saved_search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        return jsonify({
            'success': True,
            'search': {
                'id': saved_search.id,
                'name': saved_search.name,
                'description': saved_search.description,
                'additional_filters': saved_search.additional_filters,
                'created_at': saved_search.created_at.isoformat() if saved_search.created_at else None
            }
        })
        
    except Exception as e:
        print(f"Error getting saved search details: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/sent-searches')
@login_required
def get_sent_searches():
    """Get sent searches from managers as recommendations"""
    from models import SentSearch
    
    try:
        user_id = session.get('user_id')
        if not user_id:
            return jsonify({'success': False, 'error': 'User not authenticated'}), 401
        
        # Get sent searches
        sent_searches = SentSearch.query.filter_by(client_id=user_id).order_by(SentSearch.sent_at.desc()).all()
        
        # Format as recommendation-like objects
        search_list = []
        
        for search in sent_searches:
            search_list.append({
                'id': search.id,
                'name': search.name or '–ü–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
                'title': search.name or '–ü–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
                'description': search.description,
                'status': search.status or 'sent',
                'sent_at': search.sent_at.isoformat() if search.sent_at else None,
                'created_at': search.sent_at.isoformat() if search.sent_at else None,
                'search_filters': search.additional_filters,
                'manager_id': search.manager_id,
                'recommendation_type': 'search'
            })
        
        return jsonify({
            'success': True,
            'sent_searches': search_list
        })
        
    except Exception as e:
        print(f"Error getting sent searches: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/sent-search/<int:search_id>')
@login_required
def get_sent_search_detail(search_id):
    """Get details of a specific sent search from manager"""
    from models import SentSearch
    import json
    
    try:
        # Get the specific sent search for this client using current_user from Flask-Login
        sent_search = SentSearch.query.filter_by(id=search_id, client_id=current_user.id).first()
        
        if not sent_search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Parse additional_filters if it's a JSON string
        filters = sent_search.additional_filters
        if isinstance(filters, str):
            try:
                filters = json.loads(filters)
            except json.JSONDecodeError:
                filters = {}
        elif filters is None:
            filters = {}
        
        return jsonify({
            'success': True,
            'search': {
                'id': sent_search.id,
                'name': sent_search.name or '–ü–æ–∏—Å–∫ –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
                'description': sent_search.description,
                'additional_filters': filters,
                'status': sent_search.status or 'sent',
                'sent_at': sent_search.sent_at.isoformat() if sent_search.sent_at else None,
                'manager_id': sent_search.manager_id
            }
        })
        
    except Exception as e:
        print(f"Error getting sent search detail: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/recommendations/<rec_id>/viewed', methods=['POST'])
@login_required  
def api_mark_recommendation_viewed(rec_id):
    """Mark recommendation as viewed"""
    from models import Recommendation, SentSearch
    from datetime import datetime
    
    try:
        # Handle search recommendations
        if str(rec_id).startswith('search_'):
            search_id = int(rec_id.replace('search_', ''))
            sent_search = SentSearch.query.filter_by(
                id=search_id, 
                client_id=current_user.id
            ).first()
            
            if not sent_search:
                return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
                
            if sent_search.status == 'sent':
                sent_search.status = 'viewed'
                sent_search.viewed_at = datetime.utcnow()
                db.session.commit()
            
            return jsonify({'success': True})
        
        # Handle traditional recommendations
        recommendation = Recommendation.query.filter_by(
            id=int(rec_id), 
            client_id=current_user.id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
            
        if recommendation.status == 'sent':
            recommendation.status = 'viewed'
            recommendation.viewed_at = datetime.utcnow()
            db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/recommendations/<int:rec_id>/dismiss', methods=['POST'])
@login_required
def api_dismiss_recommendation(rec_id):
    """Dismiss/hide recommendation"""
    from models import Recommendation
    from datetime import datetime
    
    try:
        recommendation = Recommendation.query.filter_by(
            id=rec_id, 
            client_id=current_user.id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
            
        # Mark as dismissed
        recommendation.status = 'dismissed'
        recommendation.viewed_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/recommendations/<rec_id>/apply', methods=['POST'])
@login_required  
def api_apply_search_recommendation(rec_id):
    """Apply search recommendation - redirect to properties with filters"""
    from models import SentSearch
    from datetime import datetime
    import json
    
    try:
        # Handle search recommendations only
        if not str(rec_id).startswith('search_'):
            return jsonify({'success': False, 'error': '–¢–æ–ª—å–∫–æ –ø–æ–∏—Å–∫–∏ –º–æ–∂–Ω–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å'}), 400
            
        search_id = int(rec_id.replace('search_', ''))
        sent_search = SentSearch.query.filter_by(
            id=search_id, 
            client_id=current_user.id
        ).first()
        
        if not sent_search:
            return jsonify({'success': False, 'error': '–ü–æ–∏—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Update search status
        sent_search.applied_at = datetime.utcnow()
        if sent_search.status == 'sent':
            sent_search.status = 'applied'
        db.session.commit()
        
        # Parse filters from the search and normalize keys
        raw_filters = {}
        if sent_search.additional_filters:
            try:
                raw_filters = json.loads(sent_search.additional_filters)
            except json.JSONDecodeError:
                pass

        filters = {}
        rooms_val = raw_filters.get('rooms')
        if rooms_val:
            filters['rooms'] = rooms_val if isinstance(rooms_val, list) else [str(rooms_val)]
        elif hasattr(sent_search, 'property_type') and sent_search.property_type:
            filters['rooms'] = [str(r) for r in sent_search.property_type.split(',') if r.strip()]
        filters['priceFrom'] = raw_filters.get('priceFrom') or raw_filters.get('price_min') or (getattr(sent_search, 'price_min', '') or '')
        filters['priceTo'] = raw_filters.get('priceTo') or raw_filters.get('price_max') or (getattr(sent_search, 'price_max', '') or '')
        filters['areaFrom'] = raw_filters.get('areaFrom') or raw_filters.get('area_min') or (getattr(sent_search, 'size_min', '') or '')
        filters['areaTo'] = raw_filters.get('areaTo') or raw_filters.get('area_max') or (getattr(sent_search, 'size_max', '') or '')
        filters['district'] = raw_filters.get('district') or (getattr(sent_search, 'location', '') or '')
        filters['complex_name'] = raw_filters.get('complex_name') or raw_filters.get('complex') or (getattr(sent_search, 'complex_name', '') or '')
        filters['districts'] = raw_filters.get('districts', [])
        filters['developers'] = raw_filters.get('developers', [])

        return jsonify({
            'success': True, 
            'filters': filters
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/recommendation-categories', methods=['GET'])
@login_required
def api_user_get_categories():
    """Get all categories that have recommendations for current user"""
    from models import RecommendationCategory
    
    try:
        categories = RecommendationCategory.query.filter_by(
            client_id=current_user.id
        ).filter(RecommendationCategory.recommendations_count > 0).all()
        
        categories_data = []
        for category in categories:
            categories_data.append({
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'color': category.color,
                'recommendations_count': category.recommendations_count
            })
        
        return jsonify({
            'success': True,
            'categories': categories_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

# User Comparison Count API Endpoints
@app.route('/api/user/comparison/properties/count')
def api_user_comparison_properties_count():
    """Get count of properties in comparison for current user"""
    from models import ComparisonProperty, UserComparison
    from services.guest_session import get_guest_comparison_properties
    
    try:
        if not current_user.is_authenticated:
            guest_props = get_guest_comparison_properties()
            return jsonify({'success': True, 'count': len(guest_props)})
        
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({'success': True, 'count': 0})
        
        count = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({'success': True, 'count': count})
        
    except Exception as e:
        print(f"Error getting user comparison properties count: {e}")
        return jsonify({'success': False, 'error': str(e), 'count': 0}), 500

@app.route('/api/user/comparison/complexes/count')
def api_user_comparison_complexes_count():
    """Get count of complexes in comparison for current user"""
    from models import ComparisonComplex, UserComparison
    from services.guest_session import get_guest_comparison_complexes
    
    try:
        if not current_user.is_authenticated:
            guest_complexes = get_guest_comparison_complexes()
            return jsonify({'success': True, 'count': len(guest_complexes)})
        
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({'success': True, 'count': 0})
        
        count = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({'success': True, 'count': count})
        
    except Exception as e:
        print(f"Error getting user comparison complexes count: {e}")
        return jsonify({'success': False, 'error': str(e), 'count': 0}), 500

# ========================================
# USER COMPARISON ENDPOINTS
# ========================================

@app.route('/api/user/comparison/property/add', methods=['POST'])
def api_user_comparison_property_add():
    """Add property to user's comparison - works for both authenticated and guest users"""
    from models import UserComparison, ComparisonProperty
    from services.guest_session import add_guest_comparison_property
    
    try:
        data = request.get_json()
        property_id = str(data.get('property_id'))
        
        if not current_user.is_authenticated:
            success, message, count = add_guest_comparison_property(property_id)
            return jsonify({'success': success, 'message': message, 'count': count})  # ‚úÖ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å—Ç—Ä–æ–∫—É
        
        if not property_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        # Find or create active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            user_comparison = UserComparison(
                user_id=current_user.id,
                name='–ú–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
                is_active=True
            )
            db.session.add(user_comparison)
            db.session.flush()
        
        # Check if property already in comparison
        existing = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id,
            property_id=property_id
        ).first()
        
        if existing:
            count = ComparisonProperty.query.filter_by(
                user_comparison_id=user_comparison.id
            ).count()
            return jsonify({
                'success': True,
                'message': '–û–±—ä–µ–∫—Ç —É–∂–µ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        if current_count >= 4:
            return jsonify({
                'success': False,
                'message': '–ú–∞–∫—Å–∏–º—É–º 4 –æ–±—ä–µ–∫—Ç–∞ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': current_count
            }), 400
        
        # Add property to comparison
        comparison_property = ComparisonProperty(
            user_comparison_id=user_comparison.id,
            property_id=property_id,
            property_name=data.get('property_name'),
            property_price=data.get('property_price'),
            complex_name=data.get('complex_name'),
            cashback=data.get('cashback', 0),
            area=data.get('area'),
            rooms=data.get('rooms'),
            order_index=current_count
        )
        db.session.add(comparison_property)
        db.session.commit()
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding property to user comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/comparison/property/remove', methods=['POST'])
@csrf.exempt
def api_user_comparison_property_remove():
    """Remove property from user's comparison - works for both authenticated and guest users"""
    from models import UserComparison, ComparisonProperty
    from services.guest_session import remove_guest_comparison_property
    
    try:
        data = request.get_json()
        property_id = str(data.get('property_id'))
        
        if not current_user.is_authenticated:
            success, message, count = remove_guest_comparison_property(property_id)
            return jsonify({'success': success, 'message': message, 'count': count})  # ‚úÖ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å—Ç—Ä–æ–∫—É
        
        if not property_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'message': '–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—É—Å—Ç–æ',
                'count': 0
            })
        
        # Find and delete property
        comparison_property = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id,
            property_id=property_id
        ).first()
        
        if comparison_property:
            db.session.delete(comparison_property)
            db.session.commit()
        
        # Get updated count
        count = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç —É–¥–∞–ª–µ–Ω –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing property from user comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/comparison/complex/add', methods=['POST'])
def api_user_comparison_complex_add():
    """Add residential complex to user's comparison - works for both authenticated and guest users"""
    from models import UserComparison, ComparisonComplex
    from services.guest_session import add_guest_comparison_complex
    
    try:
        data = request.get_json()
        complex_id = data.get('complex_id')
        
        if not current_user.is_authenticated:
            success, message, count = add_guest_comparison_complex(complex_id)
            return jsonify({'success': success, 'message': message, 'count': count})
        
        print(f'üîµ DEBUG USER: –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ñ–ö - complex_id={complex_id}, data={data}')
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        # Find or create active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            user_comparison = UserComparison(
                user_id=current_user.id,
                name='–ú–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
                is_active=True
            )
            db.session.add(user_comparison)
            db.session.flush()
            print(f'‚úÖ DEBUG USER: –°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π UserComparison id={user_comparison.id}')
        else:
            print(f'‚úÖ DEBUG USER: –ù–∞–π–¥–µ–Ω UserComparison id={user_comparison.id}')
        
        # Check if complex already in comparison
        existing = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id,
            complex_id=complex_id
        ).first()
        
        if existing:
            count = ComparisonComplex.query.filter_by(
                user_comparison_id=user_comparison.id
            ).count()
            print(f'‚ö†Ô∏è DEBUG USER: –ñ–ö —É–∂–µ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏, count={count}')
            return jsonify({
                'success': True,
                'message': '–ñ–ö —É–∂–µ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        if current_count >= 4:
            print(f'‚ö†Ô∏è DEBUG USER: –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç, count={current_count}')
            return jsonify({
                'success': False,
                'message': '–ú–∞–∫—Å–∏–º—É–º 4 –ñ–ö –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': current_count
            }), 400
        
        # Add complex to comparison
        comparison_complex = ComparisonComplex(
            user_comparison_id=user_comparison.id,
            complex_id=complex_id,
            complex_name=data.get('complex_name'),
            developer_name=data.get('developer_name'),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            district=data.get('district'),
            photo=data.get('photo'),
            buildings_count=data.get('buildings_count'),
            apartments_count=data.get('apartments_count'),
            completion_date=data.get('completion_date'),
            status=data.get('status'),
            complex_class=data.get('complex_class'),
            cashback_rate=data.get('cashback_rate', 5.0),
            order_index=current_count
        )
        db.session.add(comparison_complex)
        db.session.commit()
        
        print(f'‚úÖ DEBUG USER: –ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ –ë–î - id={comparison_complex.id}, complex_id={comparison_complex.complex_id}')
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Error adding complex to user comparison: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'message': str(e)}), 500
@app.route('/api/user/comparison/complex/remove', methods=['POST'])
@csrf.exempt
def api_user_comparison_complex_remove():
    """Remove residential complex from user's comparison - works for both authenticated and guest users"""
    from models import UserComparison, ComparisonComplex
    from services.guest_session import remove_guest_comparison_complex
    
    try:
        data = request.get_json()
        complex_id = data.get('complex_id')
        
        if not current_user.is_authenticated:
            success, message, count = remove_guest_comparison_complex(complex_id)
            return jsonify({'success': success, 'message': message, 'count': count})
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'message': '–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—É—Å—Ç–æ',
                'count': 0
            })
        
        # Find and delete complex
        comparison_complex = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id,
            complex_id=complex_id
        ).first()
        
        if comparison_complex:
            db.session.delete(comparison_complex)
            db.session.commit()
        
        # Get updated count
        count = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing complex from user comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/comparison/load')
def api_user_comparison_load():
    """Load all comparisons for current user from database with is_sold status check"""
    from models import UserComparison, ComparisonProperty, ComparisonComplex, Property
    from services.guest_session import get_guest_comparison_properties, get_guest_comparison_complexes
    
    try:
        if not current_user.is_authenticated:
            guest_props = get_guest_comparison_properties()
            guest_complexes = get_guest_comparison_complexes()
            properties_data = [{'property_id': pid} for pid in guest_props]
            return jsonify({
                'success': True,
                'properties': properties_data,
                'complexes': guest_complexes,
                'properties_count': len(guest_props),
                'complexes_count': len(guest_complexes)
            })
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'properties': [],
                'complexes': [],
                'properties_count': 0,
                'complexes_count': 0
            })
        
        # Get all comparison properties
        comparison_properties = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).all()
        
        # Batch-–∑–∞–≥—Ä—É–∑–∫–∞ Property –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç–∏ (–∏–∑–±–µ–≥–∞–µ–º N+1 –∑–∞–ø—Ä–æ—Å–æ–≤)
        property_ids = []
        for cp in comparison_properties:
            if cp.property_id:
                try:
                    # ComparisonProperty.property_id –º–æ–∂–µ—Ç –±—ã—Ç—å –∫–∞–∫ inner_id (string), —Ç–∞–∫ –∏ database ID (int)
                    property_ids.append(int(cp.property_id))
                except (ValueError, TypeError):
                    # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ int, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
                    pass
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ Property –æ–±—ä–µ–∫—Ç—ã –æ–¥–Ω–∏–º –∑–∞–ø—Ä–æ—Å–æ–º
        live_properties = {}
        if property_ids:
            properties_query = Property.query.filter(Property.id.in_(property_ids)).all()
            live_properties = {p.id: p for p in properties_query}
        
        # –û–±–æ–≥–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ñ–ª–∞–≥–æ–º is_sold –∏ status_label
        properties_data = []
        for cp in comparison_properties:
            cp_dict = cp.to_dict()
            
            # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π Property –æ–±—ä–µ–∫—Ç
            try:
                prop_id = int(cp.property_id) if cp.property_id else None
            except (ValueError, TypeError):
                prop_id = None
            
            live_prop = live_properties.get(prop_id) if prop_id else None
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Ñ–ª–∞–≥–∏ –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç–∏
            cp_dict['is_sold'] = not live_prop.is_active if live_prop else True
            cp_dict['status_label'] = '–ù–ï –í –ü–†–û–î–ê–ñ–ï' if cp_dict['is_sold'] else ''
            
            # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –æ–±–Ω–æ–≤–ª—è–µ–º –¥–µ–Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ –æ–±—ä–µ–∫—Ç –∞–∫—Ç—É–∞–ª–µ–Ω
            if live_prop and live_prop.is_active:
                cp_dict['current_price'] = live_prop.price
                cp_dict['current_area'] = live_prop.area
            
            properties_data.append(cp_dict)
        
        # Get all complex IDs
        complexes = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).all()
        complex_ids = [comp.complex_id for comp in complexes]
        
        return jsonify({
            'success': True,
            'properties': properties_data,
            'complexes': complex_ids,
            'properties_count': len(properties_data),
            'complexes_count': len(complex_ids)
        })
        
    except Exception as e:
        print(f"Error loading user comparison: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/comparison/clear', methods=['POST'])
def api_comparison_clear():
    """Clear all comparisons for current user"""
    from models import UserComparison, ComparisonProperty, ComparisonComplex
    from services.guest_session import clear_guest_comparison
    
    try:
        if not current_user.is_authenticated:
            clear_guest_comparison()
            return jsonify({
                'success': True,
                'message': '–°—Ä–∞–≤–Ω–µ–Ω–∏—è –æ—á–∏—â–µ–Ω—ã'
            })
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if user_comparison:
            # Delete all properties
            ComparisonProperty.query.filter_by(
                user_comparison_id=user_comparison.id
            ).delete()
            
            # Delete all complexes
            ComparisonComplex.query.filter_by(
                user_comparison_id=user_comparison.id
            ).delete()
            
            db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–í—Å–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è –æ—á–∏—â–µ–Ω—ã'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error clearing comparisons: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# ========================================
# PUBLIC COMPARISON DELETE ENDPOINTS (No Auth Required)
# ========================================

@app.route('/api/comparison/remove-property', methods=['POST', 'DELETE'])
@csrf.exempt
def api_comparison_remove_property():
    """Remove property from comparison (works for both authenticated and unauthenticated users)"""
    from models import UserComparison, ManagerComparison, ComparisonProperty
    
    try:
        # Get property_id from request
        if request.method == 'DELETE':
            data = request.get_json() or {}
        else:
            data = request.get_json() or {}
        
        property_id = data.get('property_id')
        
        if not property_id:
            return jsonify({'success': False, 'error': 'Property ID is required'}), 400
        
        # Try to remove from database if user is authenticated
        deleted = False
        
        # Check if regular user is authenticated
        if current_user.is_authenticated:
            user_comparison = UserComparison.query.filter_by(
                user_id=current_user.id,
                is_active=True
            ).first()
            
            if user_comparison:
                comparison_property = ComparisonProperty.query.filter_by(
                    user_comparison_id=user_comparison.id,
                    property_id=property_id
                ).first()
                
                if comparison_property:
                    db.session.delete(comparison_property)
                    db.session.commit()
                    deleted = True
        
        # Check if manager is authenticated
        if isinstance(current_user._get_current_object(), Manager) and not deleted:
            current_manager = current_user
            manager_comparison = ManagerComparison.query.filter_by(
                manager_id=current_manager.id,
                is_active=True
            ).first()
            
            if manager_comparison:
                comparison_property = ComparisonProperty.query.filter_by(
                    manager_comparison_id=manager_comparison.id,
                    property_id=property_id
                ).first()
                
                if comparison_property:
                    db.session.delete(comparison_property)
                    db.session.commit()
                    deleted = True
        
        # Return success even if not in database (frontend will handle localStorage)
        return jsonify({
            'success': True,
            'message': '–ö–≤–∞—Ä—Ç–∏—Ä–∞ —É–¥–∞–ª–µ–Ω–∞ –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'deleted_from_db': deleted
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Error removing property from comparison: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/comparison/remove-complex', methods=['POST', 'DELETE'])
@csrf.exempt
def api_comparison_remove_complex():
    """Remove complex from comparison (works for both authenticated and unauthenticated users)"""
    from models import UserComparison, ManagerComparison, ComparisonComplex
    
    try:
        # Get complex_id from request
        if request.method == 'DELETE':
            data = request.get_json() or {}
        else:
            data = request.get_json() or {}
        
        complex_id = data.get('complex_id')
        
        if not complex_id:
            return jsonify({'success': False, 'error': 'Complex ID is required'}), 400
        
        # Try to remove from database if user is authenticated
        deleted = False
        
        # Check if regular user is authenticated
        if current_user.is_authenticated:
            user_comparison = UserComparison.query.filter_by(
                user_id=current_user.id,
                is_active=True
            ).first()
            
            if user_comparison:
                comparison_complex = ComparisonComplex.query.filter_by(
                    user_comparison_id=user_comparison.id,
                    complex_id=complex_id
                ).first()
                
                if comparison_complex:
                    db.session.delete(comparison_complex)
                    db.session.commit()
                    deleted = True
        
        # Check if manager is authenticated
        if isinstance(current_user._get_current_object(), Manager) and not deleted:
            current_manager = current_user
            manager_comparison = ManagerComparison.query.filter_by(
                manager_id=current_manager.id,
                is_active=True
            ).first()
            
            if manager_comparison:
                comparison_complex = ComparisonComplex.query.filter_by(
                    manager_comparison_id=manager_comparison.id,
                    complex_id=complex_id
                ).first()
                
                if comparison_complex:
                    db.session.delete(comparison_complex)
                    db.session.commit()
                    deleted = True
        
        # Return success even if not in database (frontend will handle localStorage)
        return jsonify({
            'success': True,
            'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'deleted_from_db': deleted
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"‚ùå Error removing complex from comparison: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# ========================================
# MANAGER COMPARISON ENDPOINTS
# ========================================

@app.route('/api/manager/comparison/property/add', methods=['POST'])
@manager_required
def api_manager_comparison_property_add():
    """Add property to manager's comparison"""
    from models import ManagerComparison, ComparisonProperty
    
    try:
        data = request.get_json()
        property_id = data.get('property_id')
        print(f'üîç DEBUG: property/add called with data: {data}')
        print(f'üîç DEBUG: property_id type: {type(property_id)}, value: {property_id}')
        
        # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å—Ç—Ä–æ–∫—É, —Ç.–∫. –≤ –ë–î property_id - VARCHAR
        property_id = str(property_id)
        print(f'‚úÖ DEBUG: Converted property_id to string: {property_id}')
        
        if not property_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        current_manager = current_user
        
        # Find or create active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            manager_comparison = ManagerComparison(
                manager_id=current_manager.id,
                name='–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞',
                is_active=True
            )
            db.session.add(manager_comparison)
            db.session.flush()
        
        # Check if property already in comparison
        existing = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            property_id=property_id
        ).first()
        
        if existing:
            count = ComparisonProperty.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).count()
            return jsonify({
                'success': True,
                'message': '–û–±—ä–µ–∫—Ç —É–∂–µ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        if current_count >= 4:
            return jsonify({
                'success': False,
                'message': '–ú–∞–∫—Å–∏–º—É–º 4 –æ–±—ä–µ–∫—Ç–∞ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': current_count
            }), 400
        
        # ‚úÖ Get property inner_id for consistency with favorites system
        from models import Property
        property = Property.query.filter_by(id=property_id).first()
        
        if not property:
            return jsonify({
                'success': False,
                'message': '–û–±—ä–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'
            }), 404
        
        # Add property to comparison using Property.id
        comparison_property = ComparisonProperty(
            manager_comparison_id=manager_comparison.id,
            property_id=str(property.id),  # ‚úÖ Use Property.id –¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ —Å —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–æ–º
            property_name=data.get('property_name'),
            property_price=data.get('property_price'),
            complex_name=data.get('complex_name'),
            cashback=data.get('cashback', 0),
            area=data.get('area'),
            rooms=data.get('rooms'),
            order_index=current_count
        )
        db.session.add(comparison_property)
        db.session.commit()
        
        print(f"‚úÖ Added property {property_id} (inner_id: {property.inner_id}) to comparison")
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding property to manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500
@app.route('/api/manager/comparison/property/remove', methods=['POST'])
@manager_required
def api_manager_comparison_property_remove():
    """Remove property from manager's comparison"""
    from models import ManagerComparison, ComparisonProperty, Property
    
    try:
        data = request.get_json()
        property_id_or_inner_id = str(data.get('property_id'))  # ‚úÖ –ú–æ–∂–µ—Ç –±—ã—Ç—å inner_id –∏–ª–∏ id
        
        if not property_id_or_inner_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        current_manager = current_user
        
        # Find active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            return jsonify({
                'success': True,
                'message': '–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—É—Å—Ç–æ',
                'count': 0
            })
        
        # –í–ê–ñ–ù–û: –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º inner_id –≤ Property.id –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –Ω–∞–ø—Ä—è–º—É—é –ø–æ property_id
        print(f'üîç DEBUG: Received property_id={property_id_or_inner_id}')
        comparison_property = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            property_id=property_id_or_inner_id
        ).first()
        
        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –∑–Ω–∞—á–∏—Ç –ø—Ä–∏—à–µ–ª inner_id - –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ id
        if not comparison_property:
            print(f'üîç DEBUG: Not found by direct ID, trying to convert inner_id to Property.id')
            property_obj = Property.query.filter_by(inner_id=property_id_or_inner_id).first()
            if property_obj:
                actual_property_id = str(property_obj.id)
                print(f'‚úÖ DEBUG: Converted inner_id {property_id_or_inner_id} to Property.id {actual_property_id}')
                comparison_property = ComparisonProperty.query.filter_by(
                    manager_comparison_id=manager_comparison.id,
                    property_id=actual_property_id
                ).first()
            else:
                print(f'‚ùå DEBUG: Property not found with inner_id={property_id_or_inner_id}')
        
        print(f'üîç DEBUG: –ù–∞–π–¥–µ–Ω–∞ –∑–∞–ø–∏—Å—å? {comparison_property is not None}')
        if comparison_property:
            print(f'üîç DEBUG: –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å id={comparison_property.id}, property_id={comparison_property.property_id}')
            db.session.delete(comparison_property)
            db.session.commit()
            print(f'‚úÖ DEBUG: –ó–∞–ø–∏—Å—å —É–¥–∞–ª–µ–Ω–∞ –∏ commit –≤—ã–ø–æ–ª–Ω–µ–Ω')
        else:
            print(f'‚ùå DEBUG: –ó–∞–ø–∏—Å—å –ù–ï –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è!')
        
        # Get updated count
        count = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': '–û–±—ä–µ–∫—Ç —É–¥–∞–ª–µ–Ω –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing property from manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/clear', methods=['DELETE', 'POST'])
@csrf.exempt
@manager_required
def api_manager_comparison_clear():
    """Clear all items from manager's comparison"""
    from models import ManagerComparison, ComparisonProperty, ComparisonComplex
    
    try:
        current_manager = current_user
        print(f"üóëÔ∏è DEBUG: /api/manager/comparison/clear called by manager {current_manager.id}")
        
        # Find ALL active manager comparisons (not just first one!)
        manager_comparisons = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).all()
        
        if not manager_comparisons:
            print(f"‚ÑπÔ∏è DEBUG: No active comparison found for manager {current_manager.id}")
            return jsonify({
                'success': True,
                'message': '–°—Ä–∞–≤–Ω–µ–Ω–∏–µ —É–∂–µ –ø—É—Å—Ç–æ',
                'deleted_properties': 0,
                'deleted_complexes': 0
            })
        
        print(f"üîç DEBUG: Found {len(manager_comparisons)} active comparison(s), deleting items...")
        
        # Delete all properties and complexes from ALL active comparisons
        deleted_properties = 0
        deleted_complexes = 0
        
        for manager_comparison in manager_comparisons:
            deleted_properties += ComparisonProperty.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).delete()
            
            deleted_complexes += ComparisonComplex.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).delete()
        
        db.session.commit()
        
        print(f"‚úÖ DEBUG: Cleared {deleted_properties} properties and {deleted_complexes} complexes")
        
        return jsonify({
            'success': True,
            'message': f'–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –æ—á–∏—â–µ–Ω–æ: {deleted_properties} –∫–≤–∞—Ä—Ç–∏—Ä –∏ {deleted_complexes} –ñ–ö',
            'deleted_properties': deleted_properties,
            'deleted_complexes': deleted_complexes
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error clearing manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/complex/add', methods=['POST'])
@manager_required
def api_manager_comparison_complex_add():
    """Add residential complex to manager's comparison"""
    from models import ManagerComparison, ComparisonComplex
    
    try:
        data = request.get_json()
        complex_id = data.get('complex_id')
        print(f'üîç DEBUG: complex/add called with data: {data}')
        print(f'üîç DEBUG: complex_id type: {type(complex_id)}, value: {complex_id}')
        
        # Convert string ID to integer if needed
        try:
            complex_id = int(complex_id)
            print(f'‚úÖ DEBUG: Converted complex_id to integer: {complex_id}')
        except (ValueError, TypeError) as e:
            print(f'‚ùå DEBUG: Failed to convert complex_id to integer: {e}')
            return jsonify({'success': False, 'message': 'Invalid complex ID format'}), 400
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        current_manager = current_user
        
        # Find or create active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            manager_comparison = ManagerComparison(
                manager_id=current_manager.id,
                name='–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞',
                is_active=True
            )
            db.session.add(manager_comparison)
            db.session.flush()
        
        # Check if complex already in comparison
        existing = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            complex_id=complex_id
        ).first()
        
        if existing:
            count = ComparisonComplex.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).count()
            return jsonify({
                'success': True,
                'message': '–ñ–ö —É–∂–µ –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        if current_count >= 4:
            return jsonify({
                'success': False,
                'message': '–ú–∞–∫—Å–∏–º—É–º 4 –ñ–ö –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏',
                'count': current_count
            }), 400
        
        # Add complex to comparison
        comparison_complex = ComparisonComplex(
            manager_comparison_id=manager_comparison.id,
            complex_id=complex_id,
            complex_name=data.get('complex_name'),
            developer_name=data.get('developer_name'),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            district=data.get('district'),
            photo=data.get('photo'),
            buildings_count=data.get('buildings_count'),
            apartments_count=data.get('apartments_count'),
            completion_date=data.get('completion_date'),
            status=data.get('status'),
            complex_class=data.get('complex_class'),
            cashback_rate=data.get('cashback_rate', 5.0),
            order_index=current_count
        )
        db.session.add(comparison_complex)
        db.session.commit()
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': '–ñ–ö –¥–æ–±–∞–≤–ª–µ–Ω –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding complex to manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/complex/remove', methods=['POST'])
@manager_required
def api_manager_comparison_complex_remove():
    """Remove residential complex from manager's comparison"""
    from models import ManagerComparison, ComparisonComplex
    
    try:
        data = request.get_json()
        complex_id = str(data.get('complex_id'))  # ‚úÖ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å—Ç—Ä–æ–∫—É
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        current_manager = current_user
        
        # Find active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            return jsonify({
                'success': True,
                'message': '–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—É—Å—Ç–æ',
                'count': 0
            })
        
        # Find and delete complex
        print(f'üîç DEBUG: –ü–æ–∏—Å–∫ –ñ–ö –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è - manager_comparison_id={manager_comparison.id}, complex_id={complex_id} (type={type(complex_id)})')
        comparison_complex = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            complex_id=complex_id
        ).first()
        
        print(f'üîç DEBUG: –ù–∞–π–¥–µ–Ω–∞ –∑–∞–ø–∏—Å—å –ñ–ö? {comparison_complex is not None}')
        if comparison_complex:
            print(f'üîç DEBUG: –£–¥–∞–ª—è–µ–º –ñ–ö id={comparison_complex.id}, complex_id={comparison_complex.complex_id}')
            db.session.delete(comparison_complex)
            db.session.commit()
            print(f'‚úÖ DEBUG: –ñ–ö —É–¥–∞–ª–µ–Ω –∏ commit –≤—ã–ø–æ–ª–Ω–µ–Ω')
        else:
            print(f'‚ùå DEBUG: –ó–∞–ø–∏—Å—å –ñ–ö –ù–ï –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è!')
        
        # Get updated count
        count = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': '–ñ–ö —É–¥–∞–ª–µ–Ω –∏–∑ —Å—Ä–∞–≤–Ω–µ–Ω–∏—è',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing complex from manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/load')
def api_manager_comparison_load():
    """Load all comparisons for current manager from database with is_sold status check"""
    from models import ManagerComparison, ComparisonProperty, ComparisonComplex, Manager, Property
    
    try:
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞ –º–µ–Ω–µ–¥–∂–µ—Ä–∞
        if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
            print(f"‚ö†Ô∏è DEBUG: User not authenticated or not a manager - returning empty comparison")
            return jsonify({
                'success': True,
                'properties': [],
                'complexes': [],
                'properties_count': 0,
                'complexes_count': 0
            })
        
        current_manager = current_user
        print(f"üîç DEBUG: Loading comparisons from MANAGER_COMPARISONS table for manager {current_manager.id}")
        
        # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: Find ALL active manager comparisons (not just first one!)
        manager_comparisons = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).all()
        
        if not manager_comparisons:
            print(f"‚ÑπÔ∏è DEBUG: No active comparisons found")
            return jsonify({
                'success': True,
                'properties': [],
                'complexes': [],
                'properties_count': 0,
                'complexes_count': 0
            })
        
        print(f"üîç DEBUG: Found {len(manager_comparisons)} active comparison(s)")
        
        # ‚úÖ Collect all comparison properties and complexes from ALL active comparisons
        all_comparison_properties = []
        all_comparison_complexes = []
        seen_complex_ids = set()
        
        for manager_comparison in manager_comparisons:
            properties = ComparisonProperty.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).all()
            all_comparison_properties.extend(properties)
            
            complexes = ComparisonComplex.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).all()
            for comp in complexes:
                if comp.complex_id not in seen_complex_ids:
                    seen_complex_ids.add(comp.complex_id)
                    all_comparison_complexes.append(comp)
        
        # Batch-–∑–∞–≥—Ä—É–∑–∫–∞ Property –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç–∏ (–∏–∑–±–µ–≥–∞–µ–º N+1 –∑–∞–ø—Ä–æ—Å–æ–≤)
        property_ids = []
        for cp in all_comparison_properties:
            if cp.property_id:
                try:
                    # ComparisonProperty.property_id –º–æ–∂–µ—Ç –±—ã—Ç—å –∫–∞–∫ inner_id (string), —Ç–∞–∫ –∏ database ID (int)
                    property_ids.append(int(cp.property_id))
                except (ValueError, TypeError):
                    # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ int, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
                    pass
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ Property –æ–±—ä–µ–∫—Ç—ã –æ–¥–Ω–∏–º –∑–∞–ø—Ä–æ—Å–æ–º
        live_properties = {}
        if property_ids:
            properties_query = Property.query.filter(Property.id.in_(property_ids)).all()
            live_properties = {p.id: p for p in properties_query}
        
        # –û–±–æ–≥–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ñ–ª–∞–≥–æ–º is_sold –∏ status_label
        properties_data = []
        for cp in all_comparison_properties:
            cp_dict = cp.to_dict()
            
            # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–π Property –æ–±—ä–µ–∫—Ç
            try:
                prop_id = int(cp.property_id) if cp.property_id else None
            except (ValueError, TypeError):
                prop_id = None
            
            live_prop = live_properties.get(prop_id) if prop_id else None
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Ñ–ª–∞–≥–∏ –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç–∏
            cp_dict['is_sold'] = not live_prop.is_active if live_prop else True
            cp_dict['status_label'] = '–ù–ï –í –ü–†–û–î–ê–ñ–ï' if cp_dict['is_sold'] else ''
            
            # –û–ë–û–ì–ê–©–ê–ï–ú –¥–∞–Ω–Ω—ã–º–∏ –∏–∑ live Property –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏
            if live_prop:
                cp_dict["property_name"] = live_prop.title or cp_dict.get("property_name", "")
                cp_dict["property_price"] = live_prop.price or cp_dict.get("property_price", 0)
                cp_dict["area"] = live_prop.area or cp_dict.get("area", 0)
                cp_dict["rooms"] = live_prop.rooms if live_prop.rooms is not None else cp_dict.get("rooms")
                # Get complex name from relationship
                rc = live_prop.residential_complex
                if rc and hasattr(rc, "name"):
                    cp_dict["complex_name"] = rc.name or cp_dict.get("complex_name", "")
                else:
                    cp_dict["complex_name"] = cp_dict.get("complex_name", "")
                cp_dict["floor"] = live_prop.floor
                cp_dict["total_floors"] = live_prop.total_floors
                if live_prop.developer and hasattr(live_prop.developer, "name"):
                    cp_dict["developer_name"] = live_prop.developer.name or "–ù–µ —É–∫–∞–∑–∞–Ω"
                else:
                    cp_dict["developer_name"] = "–ù–µ —É–∫–∞–∑–∞–Ω"
                cp_dict["district"] = live_prop.district or ""
                cp_dict["property_type"] = live_prop.property_type or "–ö–≤–∞—Ä—Ç–∏—Ä–∞"
                cp_dict["building_type"] = live_prop.building_type or ""
                cp_dict["building_number"] = live_prop.building_number or ""
                # –ö–ª–∞—Å—Å –∂–∏–ª—å—è –∏–∑ –ñ–ö
                if hasattr(live_prop, "residential_complex") and live_prop.residential_complex:
                    rc = live_prop.residential_complex
                    if hasattr(rc, "object_class_display_name"):
                        cp_dict["housing_class"] = rc.object_class_display_name or ""
                    else:
                        cp_dict["housing_class"] = ""
                else:
                    cp_dict["housing_class"] = ""
                cp_dict["address"] = live_prop.address or ""
                
                # Get property image from main_image or gallery_images
                prop_image = live_prop.main_image
                if not prop_image and live_prop.gallery_images:
                    try:
                        import json
                        gallery = json.loads(live_prop.gallery_images)
                        if isinstance(gallery, list) and len(gallery) > 0:
                            prop_image = gallery[0]
                    except:
                        pass
                cp_dict["property_image"] = prop_image or "/static/images/no-photo.jpg"
                
                cashback_rate = 5.0
                if live_prop.price:
                    cp_dict["cashback"] = int(live_prop.price * cashback_rate / 100)
                
                # Delivery date and housing class from residential complex
                if hasattr(live_prop, 'residential_complex') and live_prop.residential_complex:
                    rc = live_prop.residential_complex
                    if rc.end_build_year and rc.end_build_quarter:
                        cp_dict["delivery_date"] = f"{rc.end_build_quarter} –∫–≤. {rc.end_build_year} –≥."
                    elif rc.end_build_year:
                        cp_dict["delivery_date"] = f"{rc.end_build_year} –≥."
                    else:
                        cp_dict["delivery_date"] = ""
                    cp_dict["housing_class"] = rc.object_class_display_name or ""
                else:
                    cp_dict["delivery_date"] = ""
            
            properties_data.append(cp_dict)
        
        # Enrich complex data from ResidentialComplex table
        complexes_data = []
        rc_ids = [c.complex_id for c in all_comparison_complexes]
        from models import ResidentialComplex as RC
        live_complexes = {}
        if rc_ids:
            rc_query = RC.query.filter(RC.id.in_(rc_ids)).all()
            live_complexes = {rc.id: rc for rc in rc_query}
        
        for cc in all_comparison_complexes:
            cc_dict = cc.to_dict()
            live_rc = live_complexes.get(cc.complex_id)
            if live_rc:
                cc_dict['complex_name'] = live_rc.name or cc_dict.get('complex_name', '')
                from models import Property as PriceProps
                price_stats = db.session.query(
                    func.min(PriceProps.price),
                    func.max(PriceProps.price)
                ).filter(
                    PriceProps.complex_id == live_rc.id,
                    PriceProps.is_active == True,
                    PriceProps.price > 0
                ).first()
                cc_dict['min_price'] = (price_stats[0] or 0) if price_stats else 0
                cc_dict['max_price'] = (price_stats[1] or 0) if price_stats else 0
                if live_rc.developer:
                    cc_dict['developer_name'] = live_rc.developer.name or ''
                cc_dict['district'] = live_rc.address or cc_dict.get('district', '')
                cc_dict['photo'] = cc_dict.get('photo') or live_rc.main_image or '/static/images/no-photo.jpg'
                from models import Property as PropModel
                bldg_count = db.session.query(func.count(func.distinct(PropModel.complex_building_name))).filter(
                    PropModel.complex_id == live_rc.id,
                    PropModel.complex_building_name.isnot(None),
                    PropModel.complex_building_name != ''
                ).scalar() or 0
                if bldg_count > 0:
                    cc_dict['buildings_count'] = bldg_count
                elif live_rc.buildings_count and live_rc.buildings_count > 0:
                    cc_dict['buildings_count'] = live_rc.buildings_count
                else:
                    cc_dict['buildings_count'] = None
                cc_dict['complex_class'] = cc_dict.get('complex_class') or live_rc.object_class_display_name or ''
                if live_rc.end_build_year and live_rc.end_build_quarter:
                    cc_dict['completion_date'] = cc_dict.get('completion_date') or f"{live_rc.end_build_quarter} –∫–≤. {live_rc.end_build_year} –≥."
                elif live_rc.end_build_year:
                    cc_dict['completion_date'] = cc_dict.get('completion_date') or f"{live_rc.end_build_year} –≥."
                cc_dict['cashback_rate'] = live_rc.cashback_rate or 5.0
                # Count apartments from properties
                from models import Property as Prop
                apt_count = Prop.query.filter_by(complex_id=live_rc.id, is_active=True).count()
                cc_dict['apartments_count'] = cc_dict.get('apartments_count') or apt_count
            complexes_data.append(cc_dict)
        
        print(f"‚úÖ DEBUG: Loaded {len(properties_data)} properties and {len(complexes_data)} complexes")
        
        return jsonify({
            'success': True,
            'properties': properties_data,
            'complexes': complexes_data,
            'properties_count': len(properties_data),
            'complexes_count': len(complexes_data)
        })
        
    except Exception as e:
        print(f"Error loading manager comparison: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500



@app.route('/api/comparison/replace-property', methods=['POST'])
@csrf.exempt
@login_required
def replace_comparison_property():
    """Replace a sold property in comparison with a similar one"""
    from models import ComparisonProperty, Property
    
    try:
        data = request.get_json()
        old_property_id = data.get('old_property_id')  # ID to replace
        new_property_id = data.get('new_property_id')  # Replacement ID
        comparison_id = data.get('comparison_id')
        
        if not all([old_property_id, new_property_id, comparison_id]):
            return jsonify({'success': False, 'error': 'Missing required parameters'}), 400
        
        # Find the comparison property to replace
        cp = ComparisonProperty.query.filter_by(
            user_comparison_id=comparison_id,
            property_id=str(old_property_id)
        ).first()
        
        if not cp:
            return jsonify({'success': False, 'error': 'Property not found in comparison'}), 404
        
        # Get the new property data
        new_prop = Property.query.filter_by(id=int(new_property_id)).first()
        if not new_prop:
            # Try by inner_id if database ID doesn't work
            new_prop = Property.query.filter_by(inner_id=str(new_property_id)).first()
        
        if not new_prop or not new_prop.is_active:
            return jsonify({'success': False, 'error': 'New property not found or inactive'}), 404
        
        # Update the comparison property with new data
        cp.property_id = str(new_prop.id)
        cp.property_name = f"{new_prop.rooms if new_prop.rooms else '–°—Ç—É–¥–∏—è'}, {new_prop.area} –º¬≤"
        cp.property_price = new_prop.price
        cp.area = new_prop.area
        cp.rooms = str(new_prop.rooms) if new_prop.rooms else '0'
        
        # Update complex name if available
        if new_prop.residential_complex:
            cp.complex_name = new_prop.residential_complex.name
        
        # Calculate cashback if available
        if new_prop.residential_complex and new_prop.price:
            cashback_rate = new_prop.residential_complex.cashback_rate or 5.0
            cp.cashback = int(new_prop.price * cashback_rate / 100)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Property replaced successfully',
            'new_property': {
                'id': new_prop.id,
                'property_id': str(new_prop.id),
                'property_name': cp.property_name,
                'property_price': cp.property_price,
                'area': cp.area,
                'complex_name': cp.complex_name,
                'cashback': cp.cashback,
                'is_sold': False,
                'status_label': ''
            }
        })
    
    except Exception as e:
        db.session.rollback()
        print(f"Error replacing property: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/user/phone/send-verification', methods=['POST'])
@login_required
def send_phone_verification():
    """Send verification code to user's phone"""
    from models import User
    import random
    from datetime import datetime, timedelta
    from scripts.sms_service import send_verification_code_sms
    
    try:
        data = request.get_json()
        phone = data.get('phone')
        
        if not phone:
            return jsonify({'success': False, 'message': '–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'}), 400
        
        # Generate 6-digit verification code
        code = ''.join([str(random.randint(0, 9)) for _ in range(6)])
        
        # Save code and expiration to user
        current_user.phone = phone
        current_user.phone_verification_code = code
        current_user.phone_verification_expires = datetime.utcnow() + timedelta(minutes=10)
        db.session.commit()
        
        # Send SMS
        sms_sent = send_verification_code_sms(phone, code)
        
        if sms_sent:
            return jsonify({
                'success': True,
                'message': '–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –≤–∞—à –Ω–æ–º–µ—Ä'
            })
        else:
            return jsonify({
                'success': False,
                'message': '–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ SMS. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
            }), 500
            
    except Exception as e:
        db.session.rollback()
        print(f"Error sending verification code: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/phone/verify-code', methods=['POST'])
@login_required
def verify_phone_code():
    """Verify phone number with code"""
    from models import User
    from datetime import datetime
    
    try:
        data = request.get_json()
        code = data.get('code')
        
        if not code:
            return jsonify({'success': False, 'message': '–ö–æ–¥ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'}), 400
        
        # Check if code matches and not expired
        if not current_user.phone_verification_code:
            return jsonify({'success': False, 'message': '–ö–æ–¥ –Ω–µ –±—ã–ª –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω'}), 400
        
        if current_user.phone_verification_expires < datetime.utcnow():
            return jsonify({'success': False, 'message': '–ö–æ–¥ –∏—Å—Ç–µ–∫. –ó–∞–ø—Ä–æ—Å–∏—Ç–µ –Ω–æ–≤—ã–π.'}), 400
        
        if current_user.phone_verification_code != code:
            return jsonify({'success': False, 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥'}), 400
        
        # Mark phone as verified
        current_user.phone_verified = True
        current_user.phone_verification_code = None
        current_user.phone_verification_expires = None
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–¢–µ–ª–µ—Ñ–æ–Ω —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω!'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error verifying phone code: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

# ========================================
# PRESENTATION SHARING (Manager to Client)
# ========================================

@app.route('/api/manager/collection/<int:collection_id>/assign-client', methods=['POST'])
@manager_required
def assign_client_to_presentation(collection_id):
    """Assign client to presentation"""
    from models import Collection, User
    
    try:
        current_manager = current_user
        data = request.get_json()
        
        if not data or 'client_id' not in data:
            return jsonify({'success': False, 'error': 'ID –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
        
        client_id = data['client_id']
        
        # Get collection
        collection = Collection.query.filter_by(
            id=collection_id,
            created_by_manager_id=current_manager.id
        ).first()
        
        if not collection:
            return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # Verify client exists and is assigned to this manager
        client = User.query.filter_by(id=client_id, assigned_manager_id=current_manager.id).first()
        
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ –∑–∞–∫—Ä–µ–ø–ª–µ–Ω –∑–∞ –≤–∞–º–∏'}), 404
        
        # Assign client to presentation
        collection.assigned_to_user_id = client_id
        collection.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'–ö–ª–∏–µ–Ω—Ç {client.full_name} –Ω–∞–∑–Ω–∞—á–µ–Ω –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error assigning client to presentation: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/collection/<int:collection_id>/send-to-client', methods=['POST'])
@manager_required
def send_presentation_to_client(collection_id):
    """Send presentation from manager to client's personal dashboard"""
    from models import Collection, User, UserNotification
    
    try:
        current_manager = current_user
        
        # Get collection
        collection = Collection.query.filter_by(
            id=collection_id,
            created_by_manager_id=current_manager.id
        ).first()
        
        if not collection:
            return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        if not collection.assigned_to_user_id:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω'}), 400
        
        if len(collection.properties) == 0:
            return jsonify({'success': False, 'error': '–í –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –Ω–µ—Ç –æ–±—ä–µ–∫—Ç–æ–≤'}), 400
        
        # Update collection status
        collection.status = '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞'
        collection.sent_at = datetime.utcnow()
        collection.updated_at = datetime.utcnow()
        
        # Create notification for client
        notification = UserNotification(
            user_id=collection.assigned_to_user_id,
            title='üì¶ –ù–æ–≤–∞—è –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
            message=f'–ú–µ–Ω–µ–¥–∂–µ—Ä –æ—Ç–ø—Ä–∞–≤–∏–ª –≤–∞–º –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—é "{collection.title}" —Å {len(collection.properties)} –æ–±—ä–µ–∫—Ç–∞–º–∏',
            notification_type='success',
            icon='fas fa-gift',
            action_url=f'/dashboard#presentations'
        )
        db.session.add(notification)
        
        # –õ–æ–≥–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏
        from models import UserActivity
        UserActivity.log_activity(
            user_id=collection.assigned_to_user_id,
            activity_type='presentation_received',
            description=f'–ü–æ–ª—É—á–µ–Ω–∞ –Ω–æ–≤–∞—è –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞: {collection.title} ({len(collection.properties)} –æ–±—ä–µ–∫—Ç–æ–≤)'
        )
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∫–ª–∏–µ–Ω—Ç—É'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error sending presentation to client: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/user/presentation/<int:presentation_id>/delete', methods=['DELETE'])
@login_required
@csrf.exempt  # CSRF disabled for user DELETE actions
def delete_user_presentation(presentation_id):
    """Delete presentation from user's dashboard"""
    from models import Collection
    
    try:
        # Get collection
        collection = Collection.query.filter_by(
            id=presentation_id,
            assigned_to_user_id=current_user.id
        ).first()
        
        if not collection:
            return jsonify({'success': False, 'error': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # Delete the collection
        db.session.delete(collection)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–∞'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting presentation: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/deals')
def api_manager_deals_count():
    """Get deals data for manager with count - used for preloading deals tab counter"""
    from models import Deal
    
    try:
        # Check if current user is a manager
        if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
            return jsonify({
                'success': True,
                'deals': [],
                'total': 0,
                'is_manager': False
            })
        
        current_manager = current_user
        
        # Get all deals for this manager
        deals = Deal.query.filter_by(manager_id=current_manager.id).all()
        
        deals_data = []
        for deal in deals:
            deals_data.append({
                'id': deal.id,
                'deal_number': deal.deal_number,
                'client_name': deal.client.full_name if deal.client else 'Unknown',
                'property_description': deal.property_description,
                'property_price': deal.property_price,
                'cashback_amount': deal.cashback_amount,
                'status': deal.status,
                'created_at': deal.created_at.isoformat() if deal.created_at else None
            })
        
        return jsonify({
            'success': True,
            'deals': deals_data,
            'total': len(deals_data),
            'is_manager': True
        })
        
    except Exception as e:
        print(f"Error getting deals count: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/comparison/count')
def api_manager_comparison_count():
    """Get count of items in manager comparison for navigation counter"""
    from models import ManagerComparison, ComparisonProperty, ComparisonComplex
    
    try:
        # Check if current user is a manager
        if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
            return jsonify({
                'success': True,
                'properties_count': 0,
                'complexes_count': 0,
                'total_count': 0
            })
        
        current_manager = current_user
        
        # Find active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            return jsonify({
                'success': True,
                'properties_count': 0,
                'complexes_count': 0,
                'total_count': 0
            })
        
        # Count properties and complexes
        properties_count = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        complexes_count = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        total_count = properties_count + complexes_count
        
        return jsonify({
            'success': True,
            'properties_count': properties_count,
            'complexes_count': complexes_count,
            'total_count': total_count
        })
        
    except Exception as e:
        print(f"Error getting manager comparison count: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/manager/generate-comparison-pdf', methods=['POST'])
@csrf.exempt
def api_manager_generate_comparison_pdf():
    """Generate HTML comparison document for manager to send to client"""
    try:
        from models import Manager
        from datetime import datetime
        
        data = request.get_json()
        
        recipient_name = data.get('recipient_name', '–ö–ª–∏–µ–Ω—Ç')
        message_notes = data.get('message_notes', '')
        hide_complex_names = data.get('hide_complex_names', False)
        hide_developer_names = data.get('hide_developer_names', False)
        hide_addresses = data.get('hide_addresses', False)
        properties = data.get('properties', [])
        complexes = data.get('complexes', [])
        
        # Base URL for absolute image paths
        base_url = request.host_url.rstrip('/')
        
        def make_absolute_url(url):
            if not url or url == '/static/images/no-photo.jpg':
                return f"{base_url}/static/images/no-photo.jpg"
            if url.startswith('http'):
                return url
            return f"{base_url}{url}"
        
        # Get current manager info
        manager = current_user if current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager) else None
        manager_name = manager.full_name if manager else "InBack –ú–µ–Ω–µ–¥–∂–µ—Ä"
        manager_phone = manager.phone if manager else "8 (862) 266-62-16"
        manager_email = manager.email if manager else "info@inback.ru"
        
        # Get manager avatar with full URL for downloadable HTML
        if manager and manager.profile_image:
            manager_avatar = make_absolute_url(manager.profile_image)
        else:
            manager_avatar = f"{base_url}/static/images/no-photo.jpg"
        
        # Get current date and time
        now = datetime.now()
        date_str = now.strftime('%d.%m.%Y')
        time_str = now.strftime('%H:%M')
        
        print(f"üìÑ Generating comparison PDF: {len(properties)} properties, {len(complexes)} complexes")
        
        # Build HTML document for comparison
        html_content = f"""<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ - {recipient_name}</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: 'Arial', 'Helvetica', sans-serif;
            line-height: 1.6;
            color: #000;
            background: #fff;
            padding: 40px 20px;
            max-width: 1200px;
            margin: 0 auto;
        }}
        
        /* Print styles */
        @media print {{
            body {{
                padding: 20px;
            }}
            .no-print {{
                display: none !important;
            }}
            .page-break {{
                page-break-after: always;
            }}
        }}
        
        /* Header */
        .header {{
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #000;
        }}
        
        .header h1 {{
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }}
        
        .header .subtitle {{
            font-size: 18px;
            color: #555;
            margin-bottom: 20px;
        }}
        
        /* Manager info */
        .manager-info {{
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            padding: 20px;
            background: #f8f8f8;
            border-radius: 8px;
        }}
        
        .manager-avatar {{
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #333;
        }}
        
        .manager-details {{
            text-align: left;
        }}
        
        .manager-details p {{
            margin: 5px 0;
            font-size: 14px;
        }}
        
        .manager-details strong {{
            font-weight: bold;
        }}
        
        /* Recipient info */
        .recipient-info {{
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            font-size: 16px;
        }}
        
        .recipient-info strong {{
            font-weight: bold;
        }}
        
        /* Notes */
        .notes {{
            margin: 20px 0;
            padding: 15px;
            background: #f0f0f0;
            border-left: 4px solid #333;
        }}
        
        .notes strong {{
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
        }}
        
        /* Section title */
        .section-title {{
            font-size: 20px;
            font-weight: bold;
            margin: 30px 0 15px 0;
            padding: 10px 0;
            border-bottom: 2px solid #000;
        }}
        
        /* Table */
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 12px;
        }}
        
        table th {{
            background: #f0f0f0;
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            font-weight: bold;
        }}
        
        table td {{
            border: 1px solid #ddd;
            padding: 10px;
            vertical-align: top;
        }}
        
        table tr:nth-child(even) {{
            background: #f9f9f9;
        }}
        
        table .label-col {{
            font-weight: bold;
            background: #f5f5f5;
            width: 180px;
        }}
        
        /* Footer */
        .footer {{
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 2px solid #000;
            font-size: 14px;
        }}
        
        .footer p {{
            margin: 5px 0;
        }}
        
        /* Print button */
        .print-btn {{
            position: fixed;
            top: 20px;
            right: 20px;
            background: #000;
            color: #fff;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 1000;
        }}
        
        .print-btn:hover {{
            background: #333;
        }}
        
        /* Sold property styles */
        .sold-property {{
            opacity: 0.6;
            background-color: #f3f4f6 !important;
        }}
        .sold-badge {{
            background: #dc2626;
            color: white;
            padding: 4px 12px;
            border-radius: 6px;
            font-weight: 600;
            display: inline-block;
            margin-left: 10px;
        }}
        .sold-text {{
            text-decoration: line-through;
            color: #6b7280;
        }}
        
    </style>
</head>
<body>
    <button onclick="window.print()" class="print-btn no-print">üñ®Ô∏è –ü–µ—á–∞—Ç—å</button>
    
    <div class="header">
        <h1>InBack –ù–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å</h1>
        <div class="subtitle">–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏</div>
    </div>
    
    <div class="manager-info">
        <img src="{manager_avatar}" alt="–§–æ—Ç–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞" class="manager-avatar">
        <div class="manager-details">
            <p><strong>–í–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä: {manager_name}</strong></p>
            <p>–¢–µ–ª–µ—Ñ–æ–Ω: {manager_phone}</p>
            <p>Email: {manager_email}</p>
        </div>
    </div>
    
    <div class="recipient-info">
        <p><strong>–ü–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–æ –¥–ª—è: {recipient_name}</strong></p>
        <p>–î–∞—Ç–∞: {date_str} –≤ {time_str}</p>
    </div>
"""
        
        # Add notes if provided
        if message_notes:
            html_content += f"""
    <div class="notes">
        <strong>–ó–∞–º–µ—Ç–∫–∏:</strong>
        <p>{message_notes}</p>
    </div>
"""
        
        # Add properties comparison table (vertical layout)
        if properties and len(properties) > 0:
            html_content += """
    <h2 class="section-title">–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∫–≤–∞—Ä—Ç–∏—Ä</h2>
    <table>
        <thead>
            <tr>
                <th class="label-col">–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞</th>"""
            
            # Add column headers for each property
            for i, prop in enumerate(properties, 1):
                is_sold = prop.get('is_sold', False)
                header_text = f"–û–±—ä–µ–∫—Ç {i}"
                if is_sold:
                    header_text += ' <span class="sold-badge">–ü–†–û–î–ê–ù</span>'
                html_content += f"\n                <th>{header_text}</th>"
            
            html_content += """
            </tr>
        </thead>
        <tbody>
"""
            

            # Row: –§–æ—Ç–æ
            html_content += """
            <tr>
                <td class="label-col">–§–æ—Ç–æ</td>"""
            for prop in properties:
                image_url = make_absolute_url(prop.get('property_image', ''))
                html_content += f'''
                <td><img src="{image_url}" alt="–§–æ—Ç–æ –æ–±—ä–µ–∫—Ç–∞" style="max-width:150px; max-height:100px; object-fit:cover; border-radius:8px;"></td>'''
            html_content += "\n            </tr>"
            
            # Row: –ù–∞–∑–≤–∞–Ω–∏–µ
            html_content += """
            <tr>
                <td class="label-col">–ù–∞–∑–≤–∞–Ω–∏–µ</td>"""
            for prop in properties:
                name = prop.get('property_name', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                is_sold = prop.get('is_sold', False)
                if is_sold:
                    html_content += f"\n                <td class=\"sold-text\">{name}</td>"
                else:
                    html_content += f"\n                <td>{name}</td>"
            html_content += "\n            </tr>"
            
            # Row: –ñ–ö (if not hidden)
            if not hide_complex_names:
                html_content += """
            <tr>
                <td class="label-col">–ñ–ö</td>"""
                for prop in properties:
                    html_content += f"\n                <td>{prop.get('complex_name', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')}</td>"
                html_content += "\n            </tr>"
            
            # Row: –¶–µ–Ω–∞
            html_content += """
            <tr>
                <td class="label-col">–¶–µ–Ω–∞</td>"""
            for prop in properties:
                price = prop.get('property_price', 0)
                is_sold = prop.get('is_sold', False)
                if is_sold:
                    html_content += f"\n                <td class=\"sold-text\">{price:,.0f} ‚ÇΩ</td>"
                else:
                    html_content += f"\n                <td>{price:,.0f} ‚ÇΩ</td>"
            html_content += "\n            </tr>"

            # Row: –ö–µ—à–±–µ–∫ (highlight max)
            cashback_amounts = []
            for prop in properties:
                price = prop.get('property_price', 0)
                cashback_rate = prop.get('cashback_rate', 5.0)
                if not cashback_rate:
                    cashback_rate = 5.0
                cashback_amounts.append(int(price * cashback_rate / 100))
            max_cashback = max(cashback_amounts) if cashback_amounts else 0
            
            html_content += """
            <tr>
                <td class="label-col">–ö–µ—à–±–µ–∫</td>"""
            for idx, prop in enumerate(properties):
                price = prop.get('property_price', 0)
                cashback_rate = prop.get('cashback_rate', 5.0)
                if not cashback_rate:
                    cashback_rate = 5.0
                cashback_amount = cashback_amounts[idx]
                is_sold = prop.get('is_sold', False)
                is_max = cashback_amount == max_cashback and len(properties) > 1 and cashback_amount > 0
                if is_sold:
                    html_content += f"\n                <td class=\"sold-text\">{cashback_amount:,} ‚ÇΩ ({cashback_rate}%)</td>"
                elif is_max:
                    html_content += f"\n                <td style=\"color:#059669; font-weight:700; background:#ecfdf5; border:2px solid #10b981;\">{cashback_amount:,} ‚ÇΩ ({cashback_rate}%)</td>"
                else:
                    html_content += f"\n                <td style=\"color:#059669; font-weight:600;\">{cashback_amount:,} ‚ÇΩ ({cashback_rate}%)</td>"
            html_content += "\n            </tr>"
            
            # Row: –ü–ª–æ—â–∞–¥—å
            html_content += """
            <tr>
                <td class="label-col">–ü–ª–æ—â–∞–¥—å</td>"""
            for prop in properties:
                size = prop.get('property_size', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                html_content += f"\n                <td>{size} –º¬≤</td>"
            html_content += "\n            </tr>"
            
            # Row: –ö–æ–º–Ω–∞—Ç—ã
            html_content += """
            <tr>
                <td class="label-col">–ö–æ–º–Ω–∞—Ç—ã</td>"""
            for prop in properties:
                rooms = prop.get('rooms', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                # Show "–°—Ç—É–¥–∏—è" instead of "0"
                if rooms == 0 or rooms == '0':
                    rooms_display = '–°—Ç—É–¥–∏—è'
                else:
                    rooms_display = rooms
                html_content += f"\n                <td>{rooms_display}</td>"
            html_content += "\n            </tr>"
            
            # Row: –≠—Ç–∞–∂
            html_content += """
            <tr>
                <td class="label-col">–≠—Ç–∞–∂</td>"""
            for prop in properties:
                floor = prop.get('floor', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                html_content += f"\n                <td>{floor}</td>"
            html_content += "\n            </tr>"
            
            # Row: –í—Å–µ–≥–æ —ç—Ç–∞–∂–µ–π
            html_content += """
            <tr>
                <td class="label-col">–í—Å–µ–≥–æ —ç—Ç–∞–∂–µ–π</td>"""
            for prop in properties:
                total_floors = prop.get('total_floors', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                html_content += f"\n                <td>{total_floors}</td>"
            html_content += "\n            </tr>"
            
            # Row: –ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ (if not hidden)
            if not hide_developer_names:
                html_content += """
            <tr>
                <td class="label-col">–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫</td>"""
                for prop in properties:
                    developer = prop.get('developer_name', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                    html_content += f"\n                <td>{developer}</td>"
                html_content += "\n            </tr>"
            
            # Row: –ê–¥—Ä–µ—Å (if not hidden)
            if not hide_addresses:
                html_content += """
            <tr>
                <td class="label-col">–ê–¥—Ä–µ—Å</td>"""
                for prop in properties:
                    address = prop.get('address', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                    html_content += f"\n                <td>{address}</td>"
                html_content += "\n            </tr>"
            
            html_content += """
        </tbody>
    </table>
"""
        
        # Add complexes comparison table (vertical layout)
        if complexes and len(complexes) > 0:
            html_content += """
    <div class="page-break"></div>
    <h2 class="section-title">–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∂–∏–ª—ã—Ö –∫–æ–º–ø–ª–µ–∫—Å–æ–≤</h2>
    <table>
        <thead>
            <tr>
                <th class="label-col">–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞</th>"""
            
            # Add column headers for each complex
            for i, complex_data in enumerate(complexes, 1):
                is_sold = complex_data.get('is_sold', False)
                header_text = f"–ñ–ö {i}"
                if is_sold:
                    header_text += ' <span class="sold-badge">–ü–†–û–î–ê–ù</span>'
                html_content += f"\n                <th>{header_text}</th>"
            
            html_content += """
            </tr>
        </thead>
        <tbody>
"""
            
            # Row: –§–æ—Ç–æ –ñ–ö
            html_content += """
            <tr>
                <td class="label-col">–§–æ—Ç–æ</td>"""
            for complex_data in complexes:
                image_url = make_absolute_url(complex_data.get('photo', complex_data.get('image', '')))
                html_content += f'''
                <td><img src="{image_url}" alt="–§–æ—Ç–æ –ñ–ö" style="max-width:150px; max-height:100px; object-fit:cover; border-radius:8px;"></td>'''
            html_content += "\n            </tr>"
            
            # Row: –ù–∞–∑–≤–∞–Ω–∏–µ –ñ–ö
            if not hide_complex_names:
                html_content += """
            <tr>
                <td class="label-col">–ù–∞–∑–≤–∞–Ω–∏–µ –ñ–ö</td>"""
                for complex_data in complexes:
                    name = complex_data.get('name', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                    is_sold = complex_data.get('is_sold', False)
                    if is_sold:
                        html_content += f"\n                <td class=\"sold-text\"><strong>{name}</strong></td>"
                    else:
                        html_content += f"\n                <td><strong>{name}</strong></td>"
                html_content += "\n            </tr>"
            
            # Row: –ö–ª–∞—Å—Å –∂–∏–ª—å—è
            html_content += """
            <tr>
                <td class="label-col">–ö–ª–∞—Å—Å –∂–∏–ª—å—è</td>"""
            for complex_data in complexes:
                obj_class = complex_data.get('object_class') or complex_data.get('housing_class') or complex_data.get('class') or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
                html_content += f"\n                <td>{obj_class}</td>"
            html_content += "\n            </tr>"
            
            # Row: –¶–µ–Ω–∞ –æ—Ç
            html_content += """
            <tr>
                <td class="label-col">–¶–µ–Ω–∞ –æ—Ç</td>"""
            for complex_data in complexes:
                min_price = complex_data.get('min_price', 0)
                is_sold = complex_data.get('is_sold', False)
                if is_sold:
                    html_content += f"\n                <td class=\"sold-text\">{min_price:,.0f} ‚ÇΩ</td>"
                else:
                    html_content += f"\n                <td>{min_price:,.0f} ‚ÇΩ</td>"
            html_content += "\n            </tr>"
            
            # Row: –¶–µ–Ω–∞ –¥–æ
            html_content += """
            <tr>
                <td class="label-col">–¶–µ–Ω–∞ –¥–æ</td>"""
            for complex_data in complexes:
                max_price = complex_data.get('max_price', 0)
                is_sold = complex_data.get('is_sold', False)
                if is_sold:
                    html_content += f"\n                <td class=\"sold-text\">{max_price:,.0f} ‚ÇΩ</td>"
                else:
                    html_content += f"\n                <td>{max_price:,.0f} ‚ÇΩ</td>"
            html_content += "\n            </tr>"
            
            # Row: –°—Ä–æ–∫ —Å–¥–∞—á–∏
            html_content += """
            <tr>
                <td class="label-col">–°—Ä–æ–∫ —Å–¥–∞—á–∏</td>"""
            for complex_data in complexes:
                completion = complex_data.get('completion_date', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                html_content += f"\n                <td>{completion}</td>"
            html_content += "\n            </tr>"
            
            # Row: –ö–µ—à–±–µ–∫
            html_content += """
            <tr>
                <td class="label-col">–ö–µ—à–±–µ–∫</td>"""
            for complex_data in complexes:
                cashback_rate = complex_data.get('cashback_rate', 0)
                html_content += f"\n                <td>{cashback_rate}%</td>"
            html_content += "\n            </tr>"
            
            # Row: –ó–∞—Å—Ç—Ä–æ–π—â–∏–∫ (if not hidden)
            if not hide_developer_names:
                html_content += """
            <tr>
                <td class="label-col">–ó–∞—Å—Ç—Ä–æ–π—â–∏–∫</td>"""
                for complex_data in complexes:
                    developer = complex_data.get('developer', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                    html_content += f"\n                <td>{developer}</td>"
                html_content += "\n            </tr>"
            
            # Row: –ê–¥—Ä–µ—Å (if not hidden)
            if not hide_addresses:
                html_content += """
            <tr>
                <td class="label-col">–ê–¥—Ä–µ—Å</td>"""
                for complex_data in complexes:
                    address = complex_data.get('address', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')
                    html_content += f"\n                <td>{address}</td>"
                html_content += "\n            </tr>"
            
            html_content += """
        </tbody>
    </table>
"""
        
        # Add footer
        html_content += f"""
    <div class="footer">
        <p><strong>InBack.ru</strong> - –≤–∞—à –∫–µ—à–±–µ–∫ –∑–∞ –Ω–æ–≤–æ—Å—Ç—Ä–æ–π–∫–∏</p>
        <p>–î–æ–∫—É–º–µ–Ω—Ç —Å–æ–∑–¥–∞–Ω {date_str} –≤ {time_str}</p>
    </div>
</body>
</html>
"""
        
        # Return HTML for download
        response = app.response_class(
            response=html_content,
            status=200,
            mimetype='text/html; charset=utf-8'
        )
        
        # Set download filename with safe ASCII characters
        from datetime import datetime
        from unidecode import unidecode
        timestamp = datetime.now().strftime('%Y-%m-%d')
        # Convert recipient name to ASCII to avoid encoding issues
        safe_name = unidecode(recipient_name).replace(' ', '_')
        ascii_filename = f'Sravnenie_{safe_name}_{timestamp}.html'
        
        response.headers['Content-Disposition'] = f'attachment; filename="{ascii_filename}"'
        
        print(f"‚úÖ Comparison HTML generated successfully")
        return response
        
    except Exception as e:
        print(f"‚ùå Error generating comparison PDF: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': 'Failed to generate comparison document', 'details': str(e)}), 500

@app.route('/api/recommendations/<int:rec_id>/respond', methods=['POST'])
@login_required
def api_respond_to_recommendation(rec_id):
    """Client responds to recommendation with interest/not interested"""
    from models import Recommendation
    from datetime import datetime
    
    try:
        data = request.get_json()
        response_type = data.get('response')  # 'interested' or 'not_interested'
        
        if response_type not in ['interested', 'not_interested']:
            return jsonify({'success': False, 'error': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø –æ—Ç–≤–µ—Ç–∞'}), 400
            
        recommendation = Recommendation.query.filter_by(
            id=rec_id,
            client_id=current_user.id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': '–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
            
        recommendation.status = response_type
        recommendation.client_response = response_type
        recommendation.responded_at = datetime.utcnow()
        
        db.session.commit()
        
        # Notify manager about client response
        if recommendation.manager:
            try:
                from email_service import send_notification
                subject = f"–û—Ç–≤–µ—Ç –∫–ª–∏–µ–Ω—Ç–∞ –Ω–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é: {recommendation.title}"
                message = f"""
–ö–ª–∏–µ–Ω—Ç {current_user.full_name} –æ—Ç–≤–µ—Ç–∏–ª –Ω–∞ –≤–∞—à—É —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é:

–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: {recommendation.title}
–û–±—ä–µ–∫—Ç: {recommendation.item_name}
–û—Ç–≤–µ—Ç: {'–ò–Ω—Ç–µ—Ä–µ—Å–Ω–æ' if response_type == 'interested' else '–ù–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ'}

–í—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞: {datetime.now().strftime('%d.%m.%Y %H:%M')}
"""
                send_notification(
                    recommendation.manager.email,
                    subject,
                    message,
                    notification_type="client_response"
                )
            except Exception as e:
                print(f"Error sending notification to manager: {e}")
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/manager/recommendation-categories/<int:client_id>', methods=['GET'])
def api_get_recommendation_categories(client_id):
    """Get recommendation categories for a specific client"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    current_manager = current_user
    
    try:
        categories = RecommendationCategory.query.filter_by(
            manager_id=current_manager.id,
            client_id=client_id,
            is_active=True
        ).order_by(RecommendationCategory.last_used.desc()).all()
        
        categories_data = []
        for category in categories:
            categories_data.append({
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'color': category.color,
                'recommendations_count': category.recommendations_count,
                'last_used': category.last_used.strftime('%d.%m.%Y') if category.last_used else '',
                'created_at': category.created_at.strftime('%d.%m.%Y') if category.created_at else ''
            })
        
        return jsonify({
            'success': True,
            'categories': categories_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/recommendation-categories', methods=['POST'])
def api_create_recommendation_category():
    """Create new recommendation category"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    current_manager = current_user
    
    try:
        data = request.get_json()
        category_name = data.get('name', '').strip()
        client_id = data.get('client_id')
        description = data.get('description', '').strip()
        color = data.get('color', 'blue')
        
        if not category_name or not client_id:
            return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –∫–ª–∏–µ–Ω—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã'}), 400
        
        # Check if category with this name already exists for this client
        existing = RecommendationCategory.query.filter_by(
            manager_id=current_manager.id,
            client_id=client_id,
            name=category_name,
            is_active=True
        ).first()
        
        if existing:
            return jsonify({'success': False, 'error': '–ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å —Ç–∞–∫–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'}), 400
        
        # Create new category
        category = RecommendationCategory(
            name=category_name,
            description=description,
            manager_id=current_manager.id,
            client_id=client_id,
            color=color
        )
        
        db.session.add(category)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'category': {
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'color': category.color,
                'recommendations_count': 0,
                'created_at': category.created_at.strftime('%d.%m.%Y')
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/all-categories', methods=['GET'])
def api_manager_all_categories():
    """Get all categories created by this manager"""
    from models import RecommendationCategory, User
    
    # Check if user is authenticated as manager
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    current_manager = current_user
    
    try:
        categories = db.session.query(
            RecommendationCategory, 
            User.email.label('client_email')
        ).outerjoin(
            User, RecommendationCategory.client_id == User.id
        ).filter(
            RecommendationCategory.manager_id == current_manager.id
        ).order_by(
            RecommendationCategory.last_used.desc().nulls_last(),
            RecommendationCategory.created_at.desc()
        ).all()
        
        category_data = []
        for category, client_email in categories:
            category_data.append({
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'client_email': client_email or '–û–±—â–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è',
                'recommendations_count': category.recommendations_count,
                'is_active': category.is_active,
                'last_used': category.last_used.isoformat() if category.last_used else None,
                'created_at': category.created_at.isoformat()
            })
        
        return jsonify({
            'success': True,
            'categories': category_data
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/categories/global', methods=['POST'])
def api_manager_create_global_category():
    """Create a new global category template"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    current_manager = current_user
    
    data = request.get_json()
    name = data.get('name', '').strip()
    description = data.get('description', '').strip()
    
    if not name:
        return jsonify({'success': False, 'error': '–£–∫–∞–∂–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏'}), 400
    
    try:
        # Create a template category without specific client
        category = RecommendationCategory(
            name=name,
            description=description,
            manager_id=current_manager.id,
            client_id=None,  # Global template
            is_template=True,
            recommendations_count=0
        )
        
        db.session.add(category)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'category': {
                'id': category.id,
                'name': category.name,
                'description': category.description
            }
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/categories/<int:category_id>/toggle', methods=['POST'])
def api_manager_toggle_category(category_id):
    """Toggle category active status"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
        return jsonify({'success': False, 'error': '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞'}), 401
    
    current_manager = current_user
    
    data = request.get_json()
    is_active = data.get('is_active', True)
    
    try:
        category = RecommendationCategory.query.filter_by(
            id=category_id,
            manager_id=current_manager.id
        ).first()
        
        if not category:
            return jsonify({'success': False, 'error': '–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        category.is_active = is_active
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

# Manager Dashboard API endpoints
@app.route('/api/manager/welcome-message', methods=['GET'])
@manager_required
def api_manager_welcome_message():
    """Get adaptive welcome message based on recent activity"""
    from models import User, Recommendation, Collection, SavedSearch, Manager
    from sqlalchemy import func, desc
    from datetime import datetime, timedelta
    
    current_manager = current_user
    
    if not current_manager:
        return jsonify({'success': False, 'error': '–ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    try:
        now = datetime.now()
        today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        week_start = today_start - timedelta(days=7)
        
        # Get recent activity counts
        recent_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == current_manager.id,
            Recommendation.created_at >= week_start
        ).count()
        
        today_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == current_manager.id,
            Recommendation.created_at >= today_start
        ).count()
        
        recent_collections = Collection.query.filter(
            Collection.created_by_manager_id == current_manager.id,
            Collection.created_at >= week_start
        ).count()
        
        total_clients = User.query.filter_by(assigned_manager_id=current_manager.id).count()
        
        new_clients_today = User.query.filter(
            User.assigned_manager_id == current_manager.id,
            User.created_at >= today_start
        ).count()
        
        # Get last activity time (use created_at if last_login_at doesn't exist)
        last_activity = getattr(current_manager, 'last_login_at', None) or current_manager.created_at
        hours_since_last_login = (now - last_activity).total_seconds() / 3600 if last_activity else 0
        
        # Get most recent activity
        latest_recommendation = Recommendation.query.filter_by(manager_id=current_manager.id).order_by(desc(Recommendation.created_at)).first()
        latest_collection = Collection.query.filter_by(created_by_manager_id=current_manager.id).order_by(desc(Collection.created_at)).first()
        
        # Generate adaptive message based on activity patterns
        messages = []
        
        # Time-based greeting
        hour = now.hour
        if 5 <= hour < 12:
            time_greeting = "–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ"
        elif 12 <= hour < 18:
            time_greeting = "–î–æ–±—Ä—ã–π –¥–µ–Ω—å"
        elif 18 <= hour < 23:
            time_greeting = "–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä"
        else:
            time_greeting = "–î–æ–±—Ä–æ–π –Ω–æ—á–∏"
        
        first_name = current_manager.full_name.split()[0] if current_manager.full_name else '–ö–æ–ª–ª–µ–≥–∞'
        
        # Activity-based messages
        if hours_since_last_login >= 24:
            messages.append(f"{time_greeting}, {first_name}! –†–∞–¥—ã –≤–∏–¥–µ—Ç—å –≤–∞—Å —Å–Ω–æ–≤–∞.")
            if recent_recommendations > 0:
                messages.append(f"–ó–∞ –≤—Ä–µ–º—è –≤–∞—à–µ–≥–æ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {recent_recommendations} —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π.")
        elif hours_since_last_login >= 8:
            messages.append(f"{time_greeting}, {first_name}! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω–æ.")
        else:
            messages.append(f"{time_greeting}, {first_name}!")
        
        # Recent activity highlights
        if today_recommendations > 0:
            messages.append(f"–°–µ–≥–æ–¥–Ω—è –≤—ã —É–∂–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ {today_recommendations} —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π - –æ—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!")
        elif recent_recommendations > 0:
            messages.append(f"–ù–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ –≤—ã –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ {recent_recommendations} —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –∫–ª–∏–µ–Ω—Ç–∞–º.")
        
        if new_clients_today > 0:
            messages.append(f"–£ –≤–∞—Å {new_clients_today} –Ω–æ–≤—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ —Å–µ–≥–æ–¥–Ω—è.")
        
        if recent_collections > 0:
            messages.append(f"–°–æ–∑–¥–∞–Ω–æ {recent_collections} –Ω–æ–≤—ã—Ö –ø–æ–¥–±–æ—Ä–æ–∫ –Ω–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ.")
        
        # Motivational suggestions based on activity
        if recent_recommendations == 0 and recent_collections == 0:
            messages.append("–ì–æ—Ç–æ–≤—ã —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –ø–æ–¥–±–æ—Ä–∫—É –¥–ª—è –∫–ª–∏–µ–Ω—Ç–æ–≤?")
        elif total_clients > 0 and recent_recommendations < 3:
            messages.append("–í–æ–∑–º–æ–∂–Ω–æ, —Å—Ç–æ–∏—Ç –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –∞–∫—Ç–∏–≤–Ω—ã–º –∫–ª–∏–µ–Ω—Ç–∞–º?")
        
        # Default fallback
        if len(messages) == 1:  # Only greeting
            messages.append("–ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ.")
        
        # Activity context for additional UI hints
        activity_context = {
            'has_recent_activity': recent_recommendations > 0 or recent_collections > 0,
            'needs_attention': total_clients > 0 and recent_recommendations == 0,
            'high_activity': recent_recommendations >= 5 or recent_collections >= 3,
            'new_day': hours_since_last_login >= 8,
            'latest_recommendation_date': latest_recommendation.created_at.strftime('%d.%m.%Y') if latest_recommendation else None,
            'latest_collection_date': latest_collection.created_at.strftime('%d.%m.%Y') if latest_collection else None
        }
        
        return jsonify({
            'success': True,
            'messages': messages,
            'context': activity_context,
            'stats': {
                'recent_recommendations': recent_recommendations,
                'today_recommendations': today_recommendations,
                'recent_collections': recent_collections,
                'total_clients': total_clients,
                'new_clients_today': new_clients_today
            }
        })
        
    except Exception as e:
        print(f"Error generating welcome message: {e}")
        return jsonify({
            'success': True,
            'messages': [f"{time_greeting}, {first_name}!", "–ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏"],
            'context': {'has_recent_activity': False},
            'stats': {}
        })

@app.route('/api/manager/dashboard-stats', methods=['GET'])
@login_required
@manager_required
def api_manager_dashboard_stats():
    """Get manager dashboard statistics"""
    from models import User, Recommendation
    from sqlalchemy import func
    
    current_manager = current_user
    
    try:
        # Count clients assigned to this manager
        clients_count = User.query.filter_by(assigned_manager_id=current_manager.id).count()
        
        # Count recommendations sent by this manager
        recommendations_count = Recommendation.query.filter_by(manager_id=current_manager.id).count()
        
        # Count recommendations sent this month
        from datetime import datetime
        month_start = datetime.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        monthly_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == current_manager.id,
            Recommendation.sent_at >= month_start
        ).count()
        
        # Collections count (placeholder for now)
        collections_count = 5
        
        return jsonify({
            'success': True,
            'clients_count': clients_count,
            'recommendations_count': monthly_recommendations,
            'total_recommendations': recommendations_count,
            'collections_count': collections_count
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/activity-feed', methods=['GET'])
@manager_required
def api_manager_activity_feed():
    """Get manager activity feed"""
    from models import Recommendation, User, ManagerNotification
    from datetime import datetime, timedelta
    
    current_manager = current_user
    
    try:
        # Get recent activities (recommendations sent)
        from sqlalchemy.orm import joinedload
        recent_recommendations = Recommendation.query.filter_by(
            manager_id=current_manager.id
        ).options(joinedload(Recommendation.client)).order_by(Recommendation.sent_at.desc()).limit(10).all()
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞
        recent_notifications = ManagerNotification.query.filter_by(
            manager_id=current_manager.id
        ).order_by(ManagerNotification.created_at.desc()).limit(15).all()
        
        # –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏
        def format_time_ago(timestamp):
            time_diff = datetime.utcnow() - timestamp
            if time_diff.days > 0:
                return f"{time_diff.days} –¥–Ω. –Ω–∞–∑–∞–¥"
            elif time_diff.seconds > 3600:
                return f"{time_diff.seconds // 3600} —á. –Ω–∞–∑–∞–¥"
            else:
                return f"{time_diff.seconds // 60} –º–∏–Ω. –Ω–∞–∑–∞–¥"
        
        # –°–æ–∑–¥–∞–µ–º –æ–±—â–∏–π —Å–ø–∏—Å–æ–∫ —Å –≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ –º–µ—Ç–∫–∞–º–∏ –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
        all_activities = []
        
        # –î–æ–±–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
        for notification in recent_notifications:
            icon = 'eye'
            ntype = 'notification'
            if notification.notification_type == 'presentation_view':
                icon = 'eye'
                ntype = 'presentation_view'
            elif notification.notification_type == 'deal_update':
                icon = 'briefcase'
                ntype = 'deal_update'
            elif notification.notification_type == 'task_update':
                icon = 'clipboard'
                ntype = 'task_update'
            elif notification.notification_type == 'task_reminder':
                icon = 'clock'
                ntype = 'task_reminder'
            all_activities.append({
                'timestamp': notification.created_at,
                'activity': {
                    'title': notification.title,
                    'description': notification.message,
                    'time_ago': format_time_ago(notification.created_at),
                    'icon': icon,
                    'color': 'blue',
                    'is_read': notification.is_read,
                    'notification_id': notification.id,
                    'type': ntype
                }
            })
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        for rec in recent_recommendations:
            client_name = rec.client.full_name if rec.client and hasattr(rec.client, 'full_name') else '–ö–ª–∏–µ–Ω—Ç'
            all_activities.append({
                'timestamp': rec.sent_at,
                'activity': {
                    'title': f'–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è',
                    'description': f'{rec.title} –¥–ª—è {client_name}',
                    'time_ago': format_time_ago(rec.sent_at),
                    'icon': 'paper-plane',
                    'color': 'blue',
                    'type': 'recommendation'
                }
            })
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ —Å–¥–µ–ª–∫–∞–º (DealHistory)
        from models import DealHistory, Deal
        recent_deal_history = DealHistory.query.filter_by(
            author_id=current_manager.id
        ).order_by(DealHistory.created_at.desc()).limit(10).all()
        
        for dh in recent_deal_history:
            deal = Deal.query.get(dh.deal_id)
            deal_label = f'–°–¥–µ–ª–∫–∞ #{deal.deal_number}' if deal else '–°–¥–µ–ª–∫–∞'
            icon = 'briefcase'
            ntype = 'deal_update'
            desc = dh.description or ''
            if dh.action == 'stage_change':
                desc = f'{deal_label}: —ç—Ç–∞–ø –∏–∑–º–µ–Ω–µ–Ω' + (f' ‚Üí {dh.new_value}' if dh.new_value else '')
            elif dh.action == 'task_created':
                icon = 'clipboard'
                ntype = 'task_update'
                desc = f'{deal_label}: —Å–æ–∑–¥–∞–Ω–∞ –∑–∞–¥–∞—á–∞'
            elif dh.action == 'task_completed':
                icon = 'clipboard'
                ntype = 'task_update'
                desc = f'{deal_label}: –∑–∞–¥–∞—á–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞'
            elif dh.action == 'comment_added':
                icon = 'chat'
                ntype = 'comment'
                desc = f'{deal_label}: –¥–æ–±–∞–≤–ª–µ–Ω –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π'
            elif dh.action == 'field_update':
                desc = f'{deal_label}: –æ–±–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–ª–µ {dh.field_name or ""}'
            elif dh.action == 'deal_created':
                desc = f'{deal_label} —Å–æ–∑–¥–∞–Ω–∞'
            
            all_activities.append({
                'timestamp': dh.created_at,
                'activity': {
                    'title': DealHistory.ACTION_LABELS.get(dh.action, dh.action),
                    'description': desc,
                    'time_ago': format_time_ago(dh.created_at),
                    'icon': icon,
                    'color': 'blue',
                    'type': ntype
                }
            })
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∏ –±–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        all_activities.sort(key=lambda x: x['timestamp'], reverse=True)
        activities = [item['activity'] for item in all_activities[:10]]
        
        # –î–æ–±–∞–≤–ª—è–µ–º –¥–µ–º–æ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ä–µ–∞–ª—å–Ω—ã—Ö –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π –º–∞–ª–æ
        if len(activities) < 2:
            activities.extend([
                {
                    'title': '–ù–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω',
                    'description': '–î–µ–º–æ –ö–ª–∏–µ–Ω—Ç–æ–≤ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª—Å—è –≤ —Å–∏—Å—Ç–µ–º–µ',
                    'time_ago': '2 —á. –Ω–∞–∑–∞–¥',
                    'icon': 'user-plus',
                    'color': 'green'
                },
                {
                    'title': '–ù–∞—á–Ω–∏—Ç–µ —Ä–∞–±–æ—Ç—É',
                    'description': '–°–æ–∑–¥–∞–π—Ç–µ —Å–¥–µ–ª–∫—É –∏–ª–∏ –ø–æ–¥–±–æ—Ä–∫—É –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞',
                    'time_ago': '',
                    'icon': 'briefcase',
                    'color': 'blue'
                }
            ])
        
        return jsonify({
            'success': True,
            'activities': activities
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/dashboard/all', methods=['GET'])
@manager_required
def api_manager_dashboard_all():
    """–ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π endpoint –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –ø–∞–Ω–µ–ª–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ - –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –∑–∞ –æ–¥–∏–Ω –∑–∞–ø—Ä–æ—Å"""
    from models import (User, Recommendation, ManagerSavedSearch, Deal, ManagerComparison, 
                       ComparisonProperty, ComparisonComplex, ManagerFavoriteProperty, ManagerFavoriteComplex,
                       ManagerNotification, Manager)
    from sqlalchemy import func
    from datetime import datetime, timedelta
    
    current_manager = current_user
    
    try:
        # ===== 1. CLIENTS =====
        clients = User.query.filter_by(assigned_manager_id=current_manager.id).all()
        clients_data = [{
            'id': client.id,
            'full_name': client.full_name,
            'email': client.email,
            'phone': client.phone or '',
            'profile_image': client.profile_image or '',
            'status': client.status if hasattr(client, 'status') else 'active',
            'search_preferences': client.search_preferences if hasattr(client, 'search_preferences') else None,
            'created_at': client.created_at.isoformat() if client.created_at else None
        } for client in clients]
        
        # ===== 2. WELCOME MESSAGE =====
        import pytz
        moscow_tz = pytz.timezone('Europe/Moscow')
        now_utc = datetime.utcnow()
        now_moscow = now_utc.replace(tzinfo=pytz.UTC).astimezone(moscow_tz)
        hour = now_moscow.hour
        
        if 5 <= hour < 12:
            time_greeting = "–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ"
        elif 12 <= hour < 18:
            time_greeting = "–î–æ–±—Ä—ã–π –¥–µ–Ω—å"
        else:
            time_greeting = "–î–æ–±—Ä—ã–π –≤–µ—á–µ—Ä"
        
        first_name = current_manager.full_name.split()[0] if current_manager.full_name else '–ú–µ–Ω–µ–¥–∂–µ—Ä'
        
        today = datetime.utcnow().date()
        week_ago = datetime.utcnow() - timedelta(days=7)
        
        recent_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == current_manager.id,
            Recommendation.sent_at >= week_ago
        ).count()
        
        today_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == current_manager.id,
            func.date(Recommendation.sent_at) == today
        ).count()
        
        total_clients = len(clients_data)
        new_clients_today = User.query.filter(
            User.assigned_manager_id == current_manager.id,
            func.date(User.created_at) == today
        ).count()
        
        messages = [f"{time_greeting}, {first_name}! –†–∞–¥—ã –≤–∏–¥–µ—Ç—å –≤–∞—Å —Å–Ω–æ–≤–∞."]
        
        if new_clients_today > 0:
            messages.append(f"–£ –≤–∞—Å {new_clients_today} –Ω–æ–≤—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ —Å–µ–≥–æ–¥–Ω—è!")
        elif recent_recommendations == 0:
            messages.append("–ì–æ—Ç–æ–≤—ã —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –ø–æ–¥–±–æ—Ä–∫—É –¥–ª—è –∫–ª–∏–µ–Ω—Ç–æ–≤?")
        elif today_recommendations > 0:
            messages.append(f"–û—Ç–ª–∏—á–Ω–æ! –°–µ–≥–æ–¥–Ω—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {today_recommendations} —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π.")
        else:
            messages.append(f"–ù–∞ —ç—Ç–æ–π –Ω–µ–¥–µ–ª–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {recent_recommendations} —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π.")
        
        # ===== 3. ACTIVITY FEED =====
        from sqlalchemy.orm import joinedload
        recent_recs = Recommendation.query.filter_by(
            manager_id=current_manager.id
        ).options(joinedload(Recommendation.client)).order_by(Recommendation.sent_at.desc()).limit(10).all()
        
        recent_notifications = ManagerNotification.query.filter_by(
            manager_id=current_manager.id
        ).order_by(ManagerNotification.created_at.desc()).limit(15).all()
        
        def format_time_ago(timestamp):
            time_diff = datetime.utcnow() - timestamp
            if time_diff.days > 0:
                return f"{time_diff.days} –¥–Ω. –Ω–∞–∑–∞–¥"
            elif time_diff.seconds > 3600:
                return f"{time_diff.seconds // 3600} —á. –Ω–∞–∑–∞–¥"
            else:
                return f"{time_diff.seconds // 60} –º–∏–Ω. –Ω–∞–∑–∞–¥"
        
        all_activities = []
        
        for notification in recent_notifications:
            icon = 'eye'
            ntype = 'notification'
            if notification.notification_type == 'presentation_view':
                icon = 'eye'
                ntype = 'presentation_view'
            elif notification.notification_type == 'deal_update':
                icon = 'briefcase'
                ntype = 'deal_update'
            elif notification.notification_type == 'task_update':
                icon = 'clipboard'
                ntype = 'task_update'
            elif notification.notification_type == 'task_reminder':
                icon = 'clock'
                ntype = 'task_reminder'
            all_activities.append({
                'timestamp': notification.created_at,
                'activity': {
                    'title': notification.title,
                    'description': notification.message,
                    'time_ago': format_time_ago(notification.created_at),
                    'icon': icon,
                    'color': 'blue',
                    'is_read': notification.is_read,
                    'notification_id': notification.id,
                    'type': ntype
                }
            })
        
        for rec in recent_recs:
            client_name = rec.client.full_name if rec.client and hasattr(rec.client, 'full_name') else '–ö–ª–∏–µ–Ω—Ç'
            all_activities.append({
                'timestamp': rec.sent_at,
                'activity': {
                    'title': '–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è',
                    'description': f'{rec.title} –¥–ª—è {client_name}',
                    'time_ago': format_time_ago(rec.sent_at),
                    'icon': 'paper-plane',
                    'color': 'blue',
                    'type': 'recommendation'
                }
            })
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ —Å–¥–µ–ª–∫–∞–º
        from models import DealHistory, Deal
        recent_deal_history = DealHistory.query.filter_by(
            author_id=current_manager.id
        ).order_by(DealHistory.created_at.desc()).limit(10).all()
        
        for dh in recent_deal_history:
            deal = Deal.query.get(dh.deal_id)
            deal_label = f'–°–¥–µ–ª–∫–∞ #{deal.deal_number}' if deal else '–°–¥–µ–ª–∫–∞'
            icon = 'briefcase'
            ntype = 'deal_update'
            desc = dh.description or ''
            if dh.action == 'stage_change':
                desc = f'{deal_label}: —ç—Ç–∞–ø –∏–∑–º–µ–Ω–µ–Ω' + (f' ‚Üí {dh.new_value}' if dh.new_value else '')
            elif dh.action == 'task_created':
                icon = 'clipboard'
                ntype = 'task_update'
                desc = f'{deal_label}: —Å–æ–∑–¥–∞–Ω–∞ –∑–∞–¥–∞—á–∞'
            elif dh.action == 'task_completed':
                icon = 'clipboard'
                ntype = 'task_update'
                desc = f'{deal_label}: –∑–∞–¥–∞—á–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞'
            elif dh.action == 'comment_added':
                icon = 'chat'
                ntype = 'comment'
                desc = f'{deal_label}: –¥–æ–±–∞–≤–ª–µ–Ω –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π'
            elif dh.action == 'field_update':
                desc = f'{deal_label}: –æ–±–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–ª–µ {dh.field_name or ""}'
            elif dh.action == 'deal_created':
                desc = f'{deal_label} —Å–æ–∑–¥–∞–Ω–∞'
            
            all_activities.append({
                'timestamp': dh.created_at,
                'activity': {
                    'title': DealHistory.ACTION_LABELS.get(dh.action, dh.action),
                    'description': desc,
                    'time_ago': format_time_ago(dh.created_at),
                    'icon': icon,
                    'color': 'blue',
                    'type': ntype
                }
            })
        
        all_activities.sort(key=lambda x: x['timestamp'], reverse=True)
        activities = [item['activity'] for item in all_activities[:10]]
        
        if len(activities) < 2:
            activities.extend([
                {
                    'title': '–ù–æ–≤—ã–π –∫–ª–∏–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω',
                    'description': '–î–µ–º–æ –ö–ª–∏–µ–Ω—Ç–æ–≤ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª—Å—è –≤ —Å–∏—Å—Ç–µ–º–µ',
                    'time_ago': '2 —á. –Ω–∞–∑–∞–¥',
                    'icon': 'user-plus',
                    'color': 'green'
                },
                {
                    'title': '–ù–∞—á–Ω–∏—Ç–µ —Ä–∞–±–æ—Ç—É',
                    'description': '–°–æ–∑–¥–∞–π—Ç–µ —Å–¥–µ–ª–∫—É –∏–ª–∏ –ø–æ–¥–±–æ—Ä–∫—É –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞',
                    'time_ago': '',
                    'icon': 'briefcase',
                    'color': 'blue'
                }
            ])
        
        # ===== 4. FAVORITES COUNT =====
        properties_count = ManagerFavoriteProperty.query.filter_by(manager_id=current_manager.id).count()
        complexes_count = ManagerFavoriteComplex.query.filter_by(manager_id=current_manager.id).count()
        
        # ===== 5. SAVED SEARCHES =====
        saved_searches = ManagerSavedSearch.query.filter_by(manager_id=current_manager.id).order_by(ManagerSavedSearch.created_at.desc()).all()
        searches_data = [{
            'id': search.id,
            'name': search.name,
            'filters': json.loads(search.additional_filters) if search.additional_filters else {},
            'created_at': search.created_at.strftime('%d.%m.%Y')
        } for search in saved_searches]
        
        # ===== 6. RECOMMENDATIONS =====
        recommendations = Recommendation.query.filter_by(manager_id=current_manager.id).order_by(Recommendation.sent_at.desc()).limit(10).all()
        recs_data = []
        for rec in recommendations:
            client = User.query.get(rec.client_id) if rec.client_id else None
            recs_data.append({
                'id': rec.id,
                'title': rec.title,
                'client_name': client.full_name if client else '–ö–ª–∏–µ–Ω—Ç —É–¥–∞–ª–µ–Ω',
                'sent_at': rec.sent_at.strftime('%d.%m.%Y –≤ %H:%M'),
                'status': rec.status,
                'properties_count': len(rec.properties) if hasattr(rec, 'properties') else 0
            })
        
        # ===== 7. DEALS COUNT =====
        deals_count = Deal.query.filter_by(manager_id=current_manager.id).count()
        
        # ===== 8. COMPARISON COUNT =====
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        comparison_props = 0
        comparison_complexes = 0
        if manager_comparison:
            comparison_props = ComparisonProperty.query.filter_by(manager_comparison_id=manager_comparison.id).count()
            comparison_complexes = ComparisonComplex.query.filter_by(manager_comparison_id=manager_comparison.id).count()
        
        return jsonify({
            'success': True,
            'clients': clients_data,
            'welcome': {
                'messages': messages,
                'stats': {
                    'recent_recommendations': recent_recommendations,
                    'today_recommendations': today_recommendations,
                    'total_clients': total_clients,
                    'new_clients_today': new_clients_today
                }
            },
            'activities': activities,
            'favorites': {
                'properties_count': properties_count,
                'complexes_count': complexes_count,
                'total_count': properties_count + complexes_count
            },
            'saved_searches': {
                'count': len(searches_data),
                'searches': searches_data
            },
            'recommendations': recs_data,
            'deals_count': deals_count,
            'comparison': {
                'properties_count': comparison_props,
                'complexes_count': comparison_complexes,
                'total_count': comparison_props + comparison_complexes
            }
        })
        
    except Exception as e:
        import traceback
        print(f"Error loading manager dashboard data: {e}")
        print(traceback.format_exc())
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/top-clients', methods=['GET'])
@login_required
@manager_required
def api_manager_top_clients():
    """Get top clients by interactions"""
    from models import User, Recommendation
    from sqlalchemy import func
    
    current_manager = current_user
    
    try:
        # Get clients with most interactions (recommendations received)
        top_clients = db.session.query(
            User,
            func.count(Recommendation.id).label('interactions_count')
        ).join(
            Recommendation, User.id == Recommendation.client_id
        ).filter(
            Recommendation.manager_id == current_manager.id
        ).group_by(User.id).order_by(
            func.count(Recommendation.id).desc()
        ).limit(5).all()
        
        clients_data = []
        for user, count in top_clients:
            clients_data.append({
                'id': user.id,
                'full_name': user.full_name,
                'email': user.email,
                'interactions_count': count
            })
        
        # Add demo clients if not enough data
        if len(clients_data) < 3:
            demo_clients = [
                {'id': 999, 'full_name': '–î–µ–º–æ –ö–ª–∏–µ–Ω—Ç–æ–≤', 'email': 'demo@inback.ru', 'interactions_count': 8},
                {'id': 998, 'full_name': '–ê–Ω–Ω–∞ –ü–æ–∫—É–ø–∞—Ç–µ–ª–µ–≤–∞', 'email': 'buyer@test.ru', 'interactions_count': 5},
                {'id': 997, 'full_name': '–ü–µ—Ç—Ä –ò–Ω–≤–µ—Å—Ç–æ—Ä–æ–≤', 'email': 'investor@test.ru', 'interactions_count': 3}
            ]
            clients_data.extend(demo_clients[:3-len(clients_data)])
        
        return jsonify({
            'success': True,
            'clients': clients_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

# Blog Management Routes for Managers
@app.route('/admin/blog-manager')
@manager_required
def admin_blog_manager():
    """Manager blog management page"""
    from models import BlogArticle, Category
    
    try:
        # Get filter parameters
        search = request.args.get('search', '')
        status = request.args.get('status', '')
        category_id = request.args.get('category_id', '')
        
        # Build query
        query = BlogArticle.query
        
        if search:
            query = query.filter(BlogArticle.title.contains(search) | 
                               BlogArticle.content.contains(search))
        
        if status:
            query = query.filter(BlogArticle.status == status)
            
        if category_id:
            query = query.filter(BlogArticle.category_id == int(category_id))
        
        # Order by creation date
        articles = query.order_by(BlogArticle.created_at.desc()).all()
        
        # Get categories for filter dropdown
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        
        return render_template('admin/blog_manager.html',
                             articles=articles,
                             categories=categories,
                             search=search,
                             status=status,
                             category_id=category_id)
        
    except Exception as e:
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –±–ª–æ–≥–∞: {str(e)}', 'error')
        return redirect(url_for('manager_dashboard'))


@app.route('/admin/blog/create-new', methods=['GET', 'POST'])
@manager_required
def admin_create_new_article():
    """Create new blog article"""
    from models import Category, BlogArticle
    import re
    from datetime import datetime
    
    if request.method == 'GET':
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        return render_template('admin/blog_create_new.html', categories=categories)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt')
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status', 'draft')
        is_featured = 'is_featured' in request.form
        
        # Generate slug from title
        slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while BlogArticle.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        # Create article
        article = BlogArticle(
            title=title,
            slug=slug,
            excerpt=excerpt,
            content=content,
            category_id=int(category_id),
            author_id=current_user.id,
            status=status,
            is_featured=is_featured
        )
        
        # Set publish date if status is published
        if status == 'published':
            article.published_at = datetime.utcnow()
        
        # Calculate reading time (approx 200 words per minute)
        word_count = len(content.split()) if content else 0
        article.reading_time = max(1, word_count // 200)
        
        db.session.add(article)
        db.session.commit()
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_manager'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
        return redirect(url_for('admin_create_new_article'))


@app.route('/admin/blog/<int:article_id>/edit-article', methods=['GET', 'POST'])
@manager_required 
def admin_edit_new_article(article_id):
    """Edit existing blog article"""
    from models import BlogArticle, Category
    import re
    from datetime import datetime
    
    article = BlogArticle.query.get_or_404(article_id)
    
    if request.method == 'GET':
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        return render_template('admin/blog_edit_new.html', article=article, categories=categories)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt') 
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status')
        is_featured = 'is_featured' in request.form
        
        # Update slug if title changed
        if title != article.title:
            slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure slug is unique (exclude current article)
            original_slug = slug
            counter = 1
            while BlogArticle.query.filter_by(slug=slug).filter(BlogArticle.id != article_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            article.slug = slug
        
        # Update article
        article.title = title
        article.excerpt = excerpt
        article.content = content
        article.category_id = int(category_id)
        article.status = status
        article.is_featured = is_featured
        article.updated_at = datetime.utcnow()
        
        # Set/update publish date if status changed to published
        if status == 'published' and not article.published_at:
            article.published_at = datetime.utcnow()
        
        # Recalculate reading time
        word_count = len(content.split()) if content else 0
        article.reading_time = max(1, word_count // 200)
        
        db.session.commit()
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_manager'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
        return redirect(url_for('admin_edit_new_article', article_id=article_id))


@app.route('/admin/blog/<int:article_id>/delete-article', methods=['POST'])
@manager_required
def admin_delete_new_article(article_id):
    """Delete blog article"""
    from models import BlogArticle
    
    try:
        article = BlogArticle.query.get_or_404(article_id)
        db.session.delete(article)
        db.session.commit()
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
    
    return redirect(url_for('admin_blog_manager'))


@app.route('/admin/blog/categories')
@admin_required
def admin_blog_categories():
    """Manage blog categories"""
    from models import Admin, Category, BlogPost, BlogArticle
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    categories = Category.query.order_by(Category.sort_order, Category.name).all()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥—Å—á–µ—Ç —Å—Ç–∞—Ç–µ–π –¥–ª—è –∫–∞–∂–¥–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    for category in categories:
        # –°—á–∏—Ç–∞–µ–º —Å—Ç–∞—Ç—å–∏ –∏–∑ BlogPost (–ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –∫–∞—Ç–µ–≥–æ—Ä–∏–∏)
        blog_post_count = BlogPost.query.filter_by(
            category=category.name, 
            status='published'
        ).count()
        
        # –°—á–∏—Ç–∞–µ–º —Å—Ç–∞—Ç—å–∏ –∏–∑ BlogArticle (–ø–æ category_id)
        blog_article_count = BlogArticle.query.filter_by(
            category_id=category.id,
            status='published'
        ).count()
        
        # –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç–∞—Ç–µ–π
        category.articles_count = blog_post_count + blog_article_count
    
    return render_template('admin/blog_categories.html', admin=current_admin, categories=categories)


@app.route('/admin/blog/categories/create', methods=['GET', 'POST'])
@admin_required
# @csrf.exempt  # CSRF disabled  # –û—Ç–∫–ª—é—á–∞–µ–º CSRF –¥–ª—è –∞–¥–º–∏–Ω –ø–∞–Ω–µ–ª–∏
def admin_create_category():
    """Create new blog category - both form and JSON API"""
    from models import Admin, Category
    import re
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    # Handle JSON requests (from inline category creation)
    if request.is_json:
        try:
            data = request.get_json()
            name = data.get('name')
            description = data.get('description', '')
            
            if not name:
                return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'})
            
            # Generate slug from Russian name
            def transliterate(text):
                rus_to_eng = {
                    '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo', '–∂': 'zh', '–∑': 'z',
                    '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm', '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r',
                    '—Å': 's', '—Ç': 't', '—É': 'u', '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
                    '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
                }
                return ''.join(rus_to_eng.get(char.lower(), char) for char in text)
            
            slug = transliterate(name.lower())
            slug = re.sub(r'[^\w\s-]', '', slug)
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure unique slug
            original_slug = slug
            counter = 1
            while Category.query.filter_by(slug=slug).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            category = Category(
                name=name,
                slug=slug,
                description=description,
                is_active=True
            )
            
            db.session.add(category)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'category': {
                    'id': category.id,
                    'name': category.name,
                    'slug': category.slug
                }
            })
            
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)})
    
    # Handle form requests (standard category creation page)
    if request.method == 'GET':
        return render_template('admin/blog_category_create.html', admin=current_admin)
    
    try:
        name = request.form.get('name')
        if not name:
            flash('–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ', 'error')
            return render_template('admin/blog_category_create.html', admin=current_admin)
            
        description = request.form.get('description', '')
        
        # Generate slug
        slug = re.sub(r'[^\w\s-]', '', name.lower())
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure unique slug
        original_slug = slug
        counter = 1
        while Category.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        category = Category(
            name=name,
            slug=slug,
            description=description
        )
        
        db.session.add(category)
        db.session.commit()
        
        flash(f'–ö–∞—Ç–µ–≥–æ—Ä–∏—è "{name}" —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_blog'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {str(e)}', 'error')
        return render_template('admin/blog_category_create.html', admin=current_admin)


# Blog Public Routes  
@app.route('/blog-new')
def blog_new():
    """Public blog page"""
    from models import BlogArticle, Category
    
    try:
        # Get published articles
        articles = BlogArticle.query.filter_by(status='published').order_by(BlogArticle.published_at.desc()).all()
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        
        # Add pagination variables that template expects
        return render_template('blog.html', 
                             articles=articles, 
                             categories=categories,
                             total_pages=1,
                             current_page=1,
                             has_prev=False,
                             has_next=False,
                             prev_num=None,
                             next_num=None,
                             search_query='',
                             category_filter=None)
        
    except Exception as e:
        print(f"Blog error: {str(e)}")
        import traceback
        traceback.print_exc()
        # Fallback for when there's an error
        try:
            return render_template('blog.html', articles=[], categories=[])
        except:
            return "–í—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã —Å –±–ª–æ–≥–æ–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", 500


@app.route('/blog-new/<slug>')
def blog_article_new(slug):
    """View single blog article"""
    from models import BlogArticle
    
    try:
        article = BlogArticle.query.filter_by(slug=slug, status='published').first_or_404()
        
        # Increment view count
        article.views_count += 1
        db.session.commit()
        
        # Get related articles from same category
        related_articles = BlogArticle.query.filter_by(
            category_id=article.category_id,
            status='published'
        ).filter(
            BlogArticle.id != article.id
        ).order_by(
            BlogArticle.published_at.desc()
        ).limit(3).all()
        
        return render_template('blog_article.html', 
                             article=article,
                             related_articles=related_articles)
        
    except Exception as e:
        flash('–°—Ç–∞—Ç—å—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
        return redirect(url_for('blog_new'))


@app.route('/blog-new/category/<slug>')
def blog_category_new(slug):
    """View articles by category"""
    from models import Category, BlogArticle
    
    try:
        category = Category.query.filter_by(slug=slug, is_active=True).first_or_404()
        
        articles = BlogArticle.query.filter_by(
            category_id=category.id,
            status='published'
        ).order_by(
            BlogArticle.published_at.desc()
        ).all()
        
        return render_template('blog_category.html', 
                             category=category,
                             articles=articles)
        
    except Exception as e:
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
        return redirect(url_for('blog_new'))


@app.route('/blog/<slug>')
def blog_post(slug):
    """Display single blog post by slug"""
    try:
        # Find post by slug - using direct SQL query
        from sqlalchemy import text
        result = db.session.execute(text("""
            SELECT id, title, slug, content, excerpt, category, featured_image, 
                   views_count, created_at, '' as author_name
            FROM blog_posts 
            WHERE slug = :slug AND status = 'published'
        """), {'slug': slug}).fetchone()
        
        if not result:
            flash('–°—Ç–∞—Ç—å—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
            return redirect(url_for('blog'))
        
        # Convert to dict for template
        post = {
            'id': result[0],
            'title': result[1],
            'slug': result[2],
            'content': result[3],
            'excerpt': result[4],
            'category': result[5],
            'featured_image': result[6],
            'views_count': result[7] or 0,
            'created_at': result[8],
            'author_name': result[9] or 'InBack'
        }
        
        # Increment view count
        try:
            db.session.execute(text("""
                UPDATE blog_posts 
                SET views_count = COALESCE(views_count, 0) + 1 
                WHERE id = :id
            """), {'id': post['id']})
            db.session.commit()
            post['views_count'] += 1
        except Exception as e:
            db.session.rollback()
        
        # Get related posts from same category
        related_results = db.session.execute(text("""
            SELECT id, title, slug, excerpt, featured_image, created_at
            FROM blog_posts 
            WHERE category = :category AND status = 'published' AND id != :id
            ORDER BY created_at DESC
            LIMIT 3
        """), {'category': post['category'], 'id': post['id']}).fetchall()
        
        related_posts = []
        for r in related_results:
            related_posts.append({
                'id': r[0],
                'title': r[1], 
                'slug': r[2],
                'excerpt': r[3],
                'featured_image': r[4],
                'created_at': r[5]
            })
        
        return render_template('blog_post.html', 
                             post=post,
                             related_posts=related_posts)
        
    except Exception as e:
        flash('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç—å–∏', 'error')
        return redirect(url_for('blog'))


# Admin Blog Management Routes
@app.route('/admin/blog-management')
@admin_required
def admin_blog_management():
    """Admin blog management page"""
    from models import BlogPost, Category
    
    try:
        # Get filter parameters
        search = request.args.get('search', '')
        status = request.args.get('status', '')
        category_name = request.args.get('category', '')
        page = request.args.get('page', 1, type=int)
        
        # Build query
        query = BlogPost.query
        
        if search:
            query = query.filter(BlogPost.title.contains(search) | 
                               BlogPost.content.contains(search))
        
        if status:
            query = query.filter(BlogPost.status == status)
            
        if category_name:
            query = query.filter(BlogPost.category == category_name)
        
        # Order by creation date and paginate
        posts = query.order_by(BlogPost.created_at.desc()).paginate(
            page=page, per_page=10, error_out=False
        )
        
        # Get categories for filter dropdown
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        
        # Get admin user for template
        from flask_login import current_user
        admin = current_user if current_user.is_authenticated else None
        
        return render_template('admin/blog_management.html',
                             posts=posts,
                             categories=categories,
                             search=search,
                             status=status,
                             category_name=category_name,
                             admin=admin)
        
    except Exception as e:
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –±–ª–æ–≥–∞: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/blog-management/create', methods=['GET', 'POST'])
@admin_required
def admin_create_blog_post():
    """Create new blog post"""
    from models import BlogPost, Category, Admin
    import re
    from datetime import datetime
    
    if request.method == 'GET':
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
        # Get current admin
        current_admin = current_user
        
        categories = Category.query.order_by(Category.name).all()
        return render_template('admin/blog_post_create.html', categories=categories, admin=current_admin)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt')
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status', 'draft')
        is_featured = 'is_featured' in request.form
        featured_image = request.form.get('featured_image', '')
        meta_title = request.form.get('meta_title', '')
        meta_description = request.form.get('meta_description', '')
        keywords = request.form.get('keywords', '')
        
        # Get category name from category_id
        category = Category.query.get(int(category_id))
        if not category:
            flash('–í—ã–±—Ä–∞–Ω–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
            return redirect(url_for('admin_create_blog_post'))
        
        # Generate slug from title
        slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while BlogPost.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        # Calculate reading time (approx 200 words per minute)
        word_count = len(content.split()) if content else 0
        reading_time = max(1, word_count // 200)
        
        # Create blog post using BlogPost model
        post = BlogPost(
            title=title,
            slug=slug,
            excerpt=excerpt,
            content=content,
            category=category.name,  # Use category name, not ID
            author_id=1,  # Default author
            status=status,
            featured_image=featured_image,
            tags=keywords
        )
        
        if status == 'published':
            post.published_at = datetime.utcnow()
        
        db.session.add(post)
        db.session.commit()
        
        # –û–±–Ω–æ–≤–∏–º —Å—á–µ—Ç—á–∏–∫ —Å—Ç–∞—Ç–µ–π –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        category.articles_count = BlogPost.query.filter_by(category=category.name, status='published').count()
        db.session.commit()
        
        print(f'DEBUG: Created article "{title}" in category "{category.name}" with status "{status}"')
        print(f'DEBUG: Updated category "{category.name}" article count to {category.articles_count}')
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_management'))
        
    except Exception as e:
        db.session.rollback()
        print(f'ERROR creating blog post: {str(e)}')
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
        return redirect(url_for('admin_create_blog_post'))

@app.route('/admin/upload-image', methods=['POST'])
@admin_required
@csrf.exempt
def admin_upload_image():
    """Upload image for TinyMCE editor and blog posts"""
    if 'file' not in request.files:
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
    
    # Check if file is an image
    allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    if not (file.filename and '.' in file.filename and file.filename.rsplit('.', 1)[1].lower() in allowed_extensions):
        return jsonify({'success': False, 'error': '–†–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (PNG, JPG, JPEG, GIF, WebP)'}), 400
    
    try:
        # Generate secure filename
        from werkzeug.utils import secure_filename
        import os, uuid
        
        filename = secure_filename(file.filename) if file.filename else 'unnamed_file'
        
        # Create upload directory if it doesn't exist
        upload_dir = 'static/uploads/blog/content'
        os.makedirs(upload_dir, exist_ok=True)
        
        # Save file with unique name to avoid conflicts
        unique_filename = f"{uuid.uuid4()}_{filename}"
        file_path = os.path.join(upload_dir, unique_filename)
        file.save(file_path)
        
        # Return URL - TinyMCE expects 'location' field
        file_url = f"/{file_path}"
        
        return jsonify({
            'success': True,
            'location': file_url,  # TinyMCE expects 'location' field
            'url': file_url,       # –î–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å –¥—Ä—É–≥–∏–º–∏ —á–∞—Å—Ç—è–º–∏ –∫–æ–¥–∞
            'filename': unique_filename
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: {str(e)}'}), 500

# Duplicate route removed - already defined earlier


@app.route('/admin/blog-management/<int:post_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_blog_post(post_id):
    """Edit blog post"""
    from models import BlogPost, Category, Admin
    import re
    from datetime import datetime
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    # Get current admin
    current_admin = current_user
    
    post = BlogPost.query.get_or_404(post_id)
    
    if request.method == 'GET':
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        return render_template('admin/blog_post_create.html', post=post, categories=categories, admin=current_admin)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt')
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status')
        is_featured = 'is_featured' in request.form
        featured_image = request.form.get('featured_image', '')
        meta_title = request.form.get('meta_title', '')
        meta_description = request.form.get('meta_description', '')
        keywords = request.form.get('keywords', '')
        
        # Validation
        if not title or title.strip() == '':
            flash('–ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å—Ç–∞—Ç—å–∏ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))
        
        if not content or content.strip() == '':
            flash('–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ —Å—Ç–∞—Ç—å–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))
        
        if not category_id or category_id == '':
            flash('–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å—Ç–∞—Ç—å–∏', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))

        # Get category name from category_id
        category = Category.query.get(int(category_id))
        if not category:
            flash('–í—ã–±—Ä–∞–Ω–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))
        
        # Update slug if title changed
        if title != post.title:
            slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            original_slug = slug
            counter = 1
            while BlogPost.query.filter_by(slug=slug).filter(BlogPost.id != post_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            post.slug = slug
        
        # Calculate reading time
        word_count = len(content.split()) if content else 0
        reading_time = max(1, word_count // 200)
        
        # Update post
        old_category = post.category
        post.title = title
        post.excerpt = excerpt
        post.content = content
        post.category = category.name  # BlogPost uses category name as string
        post.status = status
        post.is_featured = is_featured
        post.featured_image = featured_image
        post.meta_title = meta_title or title
        post.meta_description = meta_description or excerpt  
        post.tags = keywords  # BlogPost uses tags field
        post.reading_time = reading_time
        post.updated_at = datetime.utcnow()
        
        if status == 'published' and not post.published_at:
            post.published_at = datetime.utcnow()
        
        db.session.commit()
        
        # Update category article counts for both old and new categories
        for cat_name in [old_category, category.name]:
            if cat_name:
                cat = Category.query.filter_by(name=cat_name).first()
                if cat:
                    cat.articles_count = BlogPost.query.filter_by(category=cat_name, status='published').count()
        
        db.session.commit()
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
        return redirect(url_for('admin_edit_blog_post', post_id=post_id))


@app.route('/admin/blog-management/<int:post_id>/delete', methods=['POST'])
@admin_required
def admin_delete_blog_post(post_id):
    """Delete blog post"""
    from models import BlogPost, Category
    
    try:
        post = BlogPost.query.get_or_404(post_id)
        category_name = post.category
        
        db.session.delete(post)
        db.session.commit()
        
        # Update category article count
        if category_name:
            category = Category.query.filter_by(name=category_name).first()
            if category:
                category.articles_count = BlogPost.query.filter_by(category=category_name, status='published').count()
                db.session.commit()
        
        flash('–°—Ç–∞—Ç—å—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—å–∏: {str(e)}', 'error')
    
    return redirect(url_for('admin_blog_management'))


@app.route('/admin/blog-categories-management')
@admin_required
def admin_blog_categories_management():
    """Admin blog categories management"""
    from models import Category
    
    try:
        categories = Category.query.order_by(Category.sort_order).all()
        return render_template('admin/blog_categories.html', categories=categories)
        
    except Exception as e:
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/blog-categories-management/create', methods=['GET', 'POST'])
@admin_required
def admin_create_blog_category_new():
    """Create blog category"""
    from models import Category
    import re
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
            '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
            '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
            '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
            '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    if request.method == 'GET':
        return render_template('admin/blog_category_create.html')
    
    try:
        # Get form data
        name = request.form.get('name')
        description = request.form.get('description', '')
        color = request.form.get('color', 'blue')
        icon = request.form.get('icon', 'fas fa-folder')
        sort_order = request.form.get('sort_order', 0, type=int)
        
        # Generate slug with proper Russian transliteration
        slug = transliterate_russian_to_latin(name)
        slug = re.sub(r'[^a-z0-9\s-]', '', slug)  # Keep only safe characters
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while Category.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        category = Category(
            name=name,
            slug=slug,
            description=description,
            color=color,
            icon=icon,
            sort_order=sort_order,
            is_active=True,
            articles_count=0
        )
        
        db.session.add(category)
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {str(e)}', 'error')
        return redirect(url_for('admin_create_blog_category_new'))


@app.route('/admin/blog-categories-management/<int:category_id>/edit', methods=['GET', 'POST'])
@admin_required  
def admin_edit_blog_category_new(category_id):
    """Edit blog category"""
    from models import Category
    import re
    
    category = Category.query.get_or_404(category_id)
    
    if request.method == 'GET':
        return render_template('admin/blog_category_edit.html', category=category)
    
    try:
        # Get form data
        name = request.form.get('name')
        description = request.form.get('description', '')
        color = request.form.get('color', 'blue')
        icon = request.form.get('icon', 'fas fa-folder')
        sort_order = request.form.get('sort_order', 0, type=int)
        is_active = 'is_active' in request.form
        
        # Update slug if name changed
        if name != category.name:
            def transliterate_russian_to_latin(text):
                """Convert Russian text to Latin characters for URL slugs"""
                translit_map = {
                    '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
                    '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
                    '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
                    '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
                    '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
                    ' ': '-', '_': '-'
                }
                
                result = ''
                for char in text.lower():
                    result += translit_map.get(char, char)
                
                return result
                
            slug = transliterate_russian_to_latin(name)
            slug = re.sub(r'[^a-z0-9\s-]', '', slug)  # Keep only safe characters
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            original_slug = slug
            counter = 1
            while Category.query.filter_by(slug=slug).filter(Category.id != category_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            category.slug = slug
        
        category.name = name
        category.description = description
        category.color = color
        category.icon = icon
        category.sort_order = sort_order
        category.is_active = is_active
        
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!', 'success')
        return redirect(url_for('admin_blog_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {str(e)}', 'error')
        return redirect(url_for('admin_edit_blog_category_new', category_id=category_id))


@csrf.exempt
@app.route('/admin/blog-categories-management/<int:category_id>/delete', methods=['POST'])
@admin_required
def admin_delete_blog_category_new(category_id):
    """Delete blog category"""
    from models import Category, BlogArticle
    
    try:
        category = Category.query.get_or_404(category_id)
        
        # Check if category has posts
        posts_count = BlogArticle.query.filter_by(category_id=category_id).count()
        if posts_count > 0:
            flash(f'–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å {posts_count} —Å—Ç–∞—Ç—å—è–º–∏. –°–Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç–µ —Å—Ç–∞—Ç—å–∏ –≤ –¥—Ä—É–≥–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.', 'error')
            return redirect(url_for('admin_blog_categories_management'))
        
        db.session.delete(category)
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏: {str(e)}', 'error')
    
    return redirect(url_for('admin_blog_categories_management'))


# === JOB MANAGEMENT ADMIN ROUTES ===

@app.route('/admin/jobs')
@admin_required
def admin_jobs_management():
    """Admin jobs management"""
    from models import Job, JobCategory, Admin
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    try:
        jobs = Job.query.order_by(Job.created_at.desc()).all()
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        
        # Calculate statistics
        stats = {
            'total': len(jobs),
            'active': len([job for job in jobs if job.status == 'active']),
            'paused': len([job for job in jobs if job.status == 'paused']),
            'closed': len([job for job in jobs if job.status == 'closed']),
            'featured': len([job for job in jobs if job.is_featured])
        }
        
        return render_template('admin/careers_panel.html', vacancies=jobs, categories=categories, admin=current_admin, stats=stats)
        
    except Exception as e:
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≤–∞–∫–∞–Ω—Å–∏–π: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/jobs/create', methods=['GET', 'POST'])
@admin_required
def admin_create_job():
    """Create new job"""
    from models import Job, JobCategory, Admin
    import re
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
            '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
            '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
            '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
            '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    if request.method == 'GET':
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        return render_template('admin/create_vacancy.html', categories=categories, admin=current_admin)
    
    try:
        # Get form data
        title = request.form.get('title')
        category_id = request.form.get('category_id', type=int)
        description = request.form.get('description')
        
        # Validate required fields
        if not title or not category_id or not description:
            flash('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è', 'error')
            categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
            return render_template('admin/create_vacancy.html', categories=categories, admin=current_admin)
        requirements = request.form.get('requirements', '')
        benefits = request.form.get('benefits', '')
        responsibilities = request.form.get('responsibilities', '')
        location = request.form.get('location')
        salary_min = request.form.get('salary_min', type=int)
        salary_max = request.form.get('salary_max', type=int)
        employment_type = request.form.get('employment_type', 'full_time')
        experience_level = request.form.get('experience_level', '')
        is_remote = 'is_remote' in request.form
        is_featured = 'is_featured' in request.form
        
        # Additional fields
        department = request.form.get('department', '')
        is_urgent = 'is_urgent' in request.form
        status = request.form.get('status', 'active')
        contact_email = request.form.get('contact_email', '')
        contact_phone = request.form.get('contact_phone', '')
        meta_title = request.form.get('meta_title', '')
        meta_description = request.form.get('meta_description', '')
        
        # Generate slug
        slug = transliterate_russian_to_latin(title)
        slug = re.sub(r'[^a-z0-9\s-]', '', slug)
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while Job.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        job = Job(
            title=title,
            slug=slug,
            category_id=category_id,
            description=description,
            requirements=requirements,
            benefits=benefits,
            responsibilities=responsibilities,
            location=location,
            salary_min=salary_min,
            salary_max=salary_max,
            salary_currency='RUB',
            salary_period='month',
            employment_type=employment_type,
            experience_level=experience_level,
            is_remote=is_remote,
            is_featured=is_featured,
            is_urgent=is_urgent,
            status=status,
            department=department,
            is_active=True,
            contact_email=contact_email,
            contact_phone=contact_phone,
            meta_title=meta_title,
            meta_description=meta_description,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        db.session.add(job)
        db.session.commit()
        
        flash('–í–∞–∫–∞–Ω—Å–∏—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_jobs_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≤–∞–∫–∞–Ω—Å–∏–∏: {str(e)}', 'error')
        return redirect(url_for('admin_create_job'))


@app.route('/admin/jobs/<int:job_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_job(job_id):
    """Edit job"""
    from models import Job, JobCategory, Admin
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    job = Job.query.get_or_404(job_id)
    
    if request.method == 'GET':
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        return render_template('admin/edit_vacancy.html', job=job, categories=categories, admin=current_admin)
    
    try:
        # Update job data
        job.title = request.form.get('title')
        job.category_id = request.form.get('category_id', type=int)
        job.description = request.form.get('description')
        job.requirements = request.form.get('requirements', '')
        job.benefits = request.form.get('benefits', '')
        job.responsibilities = request.form.get('responsibilities', '')
        job.location = request.form.get('location')
        job.salary_min = request.form.get('salary_min', type=int)
        job.salary_max = request.form.get('salary_max', type=int)
        job.employment_type = request.form.get('employment_type', 'full_time')
        job.experience_level = request.form.get('experience_level', '')
        job.is_remote = 'is_remote' in request.form
        job.is_featured = 'is_featured' in request.form
        job.is_urgent = 'is_urgent' in request.form
        job.status = request.form.get('status', 'active')
        job.department = request.form.get('department', '')
        job.contact_email = request.form.get('contact_email', '')
        job.contact_phone = request.form.get('contact_phone', '')
        job.meta_title = request.form.get('meta_title', '')
        job.meta_description = request.form.get('meta_description', '')
        job.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        flash('–í–∞–∫–∞–Ω—Å–∏—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!', 'success')
        return redirect(url_for('admin_jobs_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–∞–∫–∞–Ω—Å–∏–∏: {str(e)}', 'error')
        return redirect(url_for('admin_edit_job', job_id=job_id))


@app.route('/admin/jobs/<int:job_id>/delete', methods=['POST'])
@admin_required
def admin_delete_job(job_id):
    """Delete job"""
    from models import Job
    
    try:
        job = Job.query.get_or_404(job_id)
        db.session.delete(job)
        db.session.commit()
        
        flash('–í–∞–∫–∞–Ω—Å–∏—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤–∞–∫–∞–Ω—Å–∏–∏: {str(e)}', 'error')
    
    return redirect(url_for('admin_jobs_management'))


@app.route('/job/<job_slug>')
def job_detail(job_slug):
    """Job detail page"""
    from models import Job
    
    try:
        job = Job.query.filter(Job.slug == job_slug, Job.is_active == True, Job.status == 'active').first_or_404()
        
        # Increment views count
        job.views_count = (job.views_count or 0) + 1
        db.session.commit()
        
        return render_template('vacancy_details.html', vacancy=job)
        
    except Exception as e:
        print(f"Job detail error: {e}")
        flash('–í–∞–∫–∞–Ω—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞', 'error')
        return redirect(url_for('careers'))


@app.route('/job/<job_slug>/apply', methods=['POST'])
# @csrf.exempt  # –í—Ä–µ–º–µ–Ω–Ω–æ –∏—Å–∫–ª—é—á–∞–µ–º –∏–∑ CSRF –∑–∞—â–∏—Ç—ã - TODO: –¥–æ–±–∞–≤–∏—Ç—å CSRF –≤ —Ñ–æ—Ä–º—É
def submit_job_application(job_slug):
    """Submit job application with resume"""
    from models import Job
    import os
    import uuid
    from datetime import datetime
    
    try:
        # Find the job
        job = Job.query.filter(Job.slug == job_slug, Job.is_active == True, Job.status == 'active').first_or_404()
        
        # Get form data
        candidate_name = request.form.get('candidate_name', '').strip()
        candidate_phone = request.form.get('candidate_phone', '').strip()
        candidate_email = request.form.get('candidate_email', '').strip()
        cover_letter = request.form.get('cover_letter', '').strip()
        
        # Validate required fields
        if not candidate_name or not candidate_phone:
            flash('–ò–º—è –∏ —Ç–µ–ª–µ—Ñ–æ–Ω –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è', 'error')
            return redirect(url_for('job_detail', job_slug=job_slug))
        
        # Validate phone format
        import re
        phone_pattern = r'^[\+]?[0-9\s\-\(\)]{10,18}$'
        if not re.match(phone_pattern, candidate_phone):
            flash('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–æ–º–µ—Ä–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–∞', 'error')
            return redirect(url_for('job_detail', job_slug=job_slug))
        
        # Handle file upload
        resume_file = request.files.get('resume_file')
        resume_filename = None
        
        if resume_file and resume_file.filename:
            # Validate file
            allowed_extensions = {'pdf', 'doc', 'docx', 'txt', 'rtf'}
            filename = resume_file.filename.lower()
            
            if not any(filename.endswith('.' + ext) for ext in allowed_extensions):
                flash('–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ PDF, DOC, DOCX, TXT –∏–ª–∏ RTF', 'error')
                return redirect(url_for('job_detail', job_slug=job_slug))
            
            # Check file size (5MB max)
            resume_file.seek(0, 2)  # Seek to end
            file_size = resume_file.tell()
            resume_file.seek(0)  # Reset to beginning
            
            if file_size > 5 * 1024 * 1024:  # 5MB
                flash('–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –Ω–µ –¥–æ–ª–∂–µ–Ω –ø—Ä–µ–≤—ã—à–∞—Ç—å 5 –ú–ë', 'error')
                return redirect(url_for('job_detail', job_slug=job_slug))
            
            # Save file with unique name
            file_extension = filename.split('.')[-1]
            unique_filename = f"{uuid.uuid4()}_{candidate_name.replace(' ', '_')}_{job.slug}.{file_extension}"
            resume_filename = secure_filename(unique_filename)
            
            # Ensure upload directory exists
            upload_dir = os.path.join(app.root_path, 'static', 'uploads', 'resumes')
            os.makedirs(upload_dir, exist_ok=True)
            
            # Save file
            resume_path = os.path.join(upload_dir, resume_filename)
            resume_file.save(resume_path)
        else:
            flash('–†–µ–∑—é–º–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏', 'error')
            return redirect(url_for('job_detail', job_slug=job_slug))
        
        # Prepare email notification
        try:
            # Email to HR/Admin
            admin_subject = f"–ù–æ–≤—ã–π –æ—Ç–∫–ª–∏–∫ –Ω–∞ –≤–∞–∫–∞–Ω—Å–∏—é: {job.title}"
            admin_message = f"""–ü–æ—Å—Ç—É–ø–∏–ª –Ω–æ–≤—ã–π –æ—Ç–∫–ª–∏–∫ –Ω–∞ –≤–∞–∫–∞–Ω—Å–∏—é "{job.title}":

–ö–∞–Ω–¥–∏–¥–∞—Ç: {candidate_name}
–¢–µ–ª–µ—Ñ–æ–Ω: {candidate_phone}
Email: {candidate_email if candidate_email else '–ù–µ —É–∫–∞–∑–∞–Ω'}

–°–æ–ø—Ä–æ–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ–µ –ø–∏—Å—å–º–æ:
{cover_letter if cover_letter else '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}

–†–µ–∑—é–º–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {resume_filename}

–í–∞–∫–∞–Ω—Å–∏—è: {job.title}
–û—Ç–¥–µ–ª: {job.department}
–î–∞—Ç–∞ –ø–æ–¥–∞—á–∏: {datetime.now().strftime('%d.%m.%Y %H:%M')}
"""
            
            # Send notification using existing email service
            send_notification(
                subject=admin_subject,
                message=admin_message,
                to_email="hr@inback.ru",  # You can configure this
                notification_type="job_application"
            )
            
            # Optional: Send confirmation to candidate if email provided
            if candidate_email:
                candidate_subject = f"–°–ø–∞—Å–∏–±–æ –∑–∞ –æ—Ç–∫–ª–∏–∫ –Ω–∞ –≤–∞–∫–∞–Ω—Å–∏—é: {job.title}"
                candidate_message = f"""–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {candidate_name}!

–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –æ—Ç–∫–ª–∏–∫ –Ω–∞ –≤–∞–∫–∞–Ω—Å–∏—é "{job.title}" –≤ –∫–æ–º–ø–∞–Ω–∏–∏ InBack.

–ú—ã –ø–æ–ª—É—á–∏–ª–∏ –≤–∞—à–µ —Ä–µ–∑—é–º–µ –∏ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –µ–≥–æ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è. 
–ï—Å–ª–∏ –≤–∞—à–∞ –∫–∞–Ω–¥–∏–¥–∞—Ç—É—Ä–∞ –ø–æ–¥–æ–π–¥–µ—Ç, –º—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É {candidate_phone}.

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,
–ö–æ–º–∞–Ω–¥–∞ InBack
"""
                
                send_notification(
                    subject=candidate_subject,
                    message=candidate_message,
                    to_email=candidate_email,
                    notification_type="application_confirmation"
                )
            
        except Exception as e:
            print(f"Email sending error: {e}")
            # Don't fail the whole process if email fails
            pass
        
        flash('–°–ø–∞—Å–∏–±–æ! –í–∞—à–µ —Ä–µ–∑—é–º–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ. –ú—ã —Å–≤—è–∂–µ–º—Å—è —Å –≤–∞–º–∏ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.', 'success')
        return redirect(url_for('job_detail', job_slug=job_slug))
        
    except Exception as e:
        print(f"Job application error: {e}")
        flash('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ä–µ–∑—é–º–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.', 'error')
        return redirect(url_for('job_detail', job_slug=job_slug))


@app.route('/admin/jobs/<int:vacancy_id>/toggle-status', methods=['POST'])
@admin_required
def admin_toggle_vacancy_status(vacancy_id):
    """Toggle vacancy status between active and paused"""
    from models import Job
    
    job = Job.query.get_or_404(vacancy_id)
    
    # Toggle between 'active' and 'paused' status
    if job.status == 'active':
        job.status = 'paused'
        status_text = '–ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞'
    else:
        job.status = 'active'
        status_text = '–∞–∫—Ç–∏–≤–Ω–∞'
    
    try:
        db.session.commit()
        flash(f'–í–∞–∫–∞–Ω—Å–∏—è "{job.title}" {status_text}', 'success')
    except Exception as e:
        db.session.rollback()
        flash('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –≤–∞–∫–∞–Ω—Å–∏–∏', 'error')
    
    return redirect(url_for('admin_jobs_management'))


@app.route('/admin/job-categories')
@admin_required
def admin_job_categories_management():
    """Admin job categories management"""
    from models import JobCategory, Admin
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    try:
        categories = JobCategory.query.order_by(JobCategory.sort_order).all()
        return render_template('admin/job_categories_management.html', categories=categories, admin=current_admin)
        
    except Exception as e:
        flash(f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –≤–∞–∫–∞–Ω—Å–∏–π: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/job-categories/create', methods=['GET', 'POST'])
@admin_required
@csrf.exempt
def admin_create_job_category():
    """Create new job category"""
    from models import JobCategory, Admin
    import re
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
            '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
            '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
            '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
            '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    if request.method == 'GET':
        return render_template('admin/create_job_category.html', admin=current_admin)
    
    try:
        # Get form data
        name = request.form.get('name')
        description = request.form.get('description', '')
        color = request.form.get('color', 'blue')
        icon = request.form.get('icon', 'fas fa-briefcase')
        sort_order = request.form.get('sort_order', 0, type=int)
        
        # Generate slug
        slug = transliterate_russian_to_latin(name)
        slug = re.sub(r'[^a-z0-9\s-]', '', slug)
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while JobCategory.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        category = JobCategory(
            name=name,
            slug=slug,
            description=description,
            color=color,
            icon=icon,
            sort_order=sort_order,
            is_active=True
        )
        
        db.session.add(category)
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è –≤–∞–∫–∞–Ω—Å–∏–π —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!', 'success')
        return redirect(url_for('admin_job_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–∞–∫–∞–Ω—Å–∏–π: {str(e)}', 'error')
        return redirect(url_for('admin_create_job_category'))


@app.route('/admin/job-categories/<int:category_id>/edit', methods=['GET', 'POST'])
@csrf.exempt
@admin_required
def admin_edit_job_category(category_id):
    """Edit job category"""
    from models import JobCategory, Admin
    import re
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    current_admin = current_user
    
    category = JobCategory.query.get_or_404(category_id)
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e',
            '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
            '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
            '—Ñ': 'f', '—Ö': 'h', '—Ü': 'c', '—á': 'ch', '—à': 'sh', '—â': 'sch',
            '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    if request.method == 'GET':
        return render_template('admin/edit_job_category.html', category=category, admin=current_admin)
    
    try:
        # Get new name first (before updating)
        new_name = request.form.get('name')
        
        # Update other fields
        category.description = request.form.get('description', '')
        category.color = request.form.get('color', 'blue')
        category.icon = request.form.get('icon', 'fas fa-briefcase')
        category.sort_order = request.form.get('sort_order', 0, type=int)
        category.is_active = 'is_active' in request.form
        
        # Update slug only if name changed
        if new_name and category.name != new_name:
            # Update name
            category.name = new_name
            
            # Generate new slug
            slug = transliterate_russian_to_latin(new_name)
            slug = re.sub(r'[^a-z0-9\s-]', '', slug)
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure slug is unique (excluding current category)
            original_slug = slug
            counter = 1
            while JobCategory.query.filter(JobCategory.slug == slug, JobCategory.id != category_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            category.slug = slug
        
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è –≤–∞–∫–∞–Ω—Å–∏–π —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!', 'success')
        return redirect(url_for('admin_job_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–∞–∫–∞–Ω—Å–∏–π: {str(e)}', 'error')
        return redirect(url_for('admin_edit_job_category', category_id=category_id))


@csrf.exempt
@app.route('/admin/job-categories/<int:category_id>/delete', methods=['POST'])
@admin_required
def admin_delete_job_category(category_id):
    """Delete job category"""
    from models import JobCategory, Job
    
    try:
        category = JobCategory.query.get_or_404(category_id)
        
        # Check if category has jobs
        jobs_count = Job.query.filter_by(category_id=category_id).count()
        if jobs_count > 0:
            flash(f'–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é —Å {jobs_count} –≤–∞–∫–∞–Ω—Å–∏—è–º–∏. –°–Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç–µ –≤–∞–∫–∞–Ω—Å–∏–∏ –≤ –¥—Ä—É–≥–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.', 'error')
            return redirect(url_for('admin_job_categories_management'))
        
        db.session.delete(category)
        db.session.commit()
        
        flash('–ö–∞—Ç–µ–≥–æ—Ä–∏—è –≤–∞–∫–∞–Ω—Å–∏–π —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –≤–∞–∫–∞–Ω—Å–∏–π: {str(e)}', 'error')
    
    return redirect(url_for('admin_job_categories_management'))


# Admin API Endpoints
@api_bp.route('/admin/clients-managers')
def admin_clients_managers_api():
    """API endpoint to get all clients and managers for admin panel"""
    from models import User, Manager, Admin
    
    # Check if user is admin
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Admin):
        return jsonify({'success': False, 'error': '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω'}), 403
    
    try:
        # Get all users (clients)
        users = User.query.order_by(User.created_at.desc()).all()
        
        # Get all active managers (order by first_name since full_name is a property)
        managers = Manager.query.filter_by(is_active=True).order_by(Manager.first_name, Manager.last_name).all()
        
        # Format clients data
        clients_data = []
        for user in users:
            client = {
                'id': user.id,
                'user_id': f"USER-{user.id}",
                'full_name': user.full_name or '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                'email': user.email,
                'phone': user.phone,
                'created_at': user.created_at.strftime('%d.%m.%Y') if user.created_at else '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                'assigned_manager': None
            }
            
            # Add assigned manager info if exists
            if user.assigned_manager_id:
                manager = Manager.query.get(user.assigned_manager_id)
                if manager:
                    client['assigned_manager'] = {
                        'id': manager.id,
                        'name': manager.full_name
                    }
            
            clients_data.append(client)
        
        # Format managers data
        managers_data = []
        for manager in managers:
            # Count assigned clients
            assigned_count = User.query.filter_by(assigned_manager_id=manager.id).count()
            
            managers_data.append({
                'id': manager.id,
                'name': manager.full_name,
                'email': manager.email,
                'assigned_clients_count': assigned_count
            })
        
        return jsonify({
            'success': True,
            'clients': clients_data,
            'managers': managers_data
        })
        
    except Exception as e:
        print(f"ERROR in admin_clients_managers_api: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@api_bp.route('/admin/assign-client', methods=['POST'])
@csrf.exempt
def admin_assign_client_api():
    """API endpoint to assign/unassign manager to client"""
    from models import User, Manager, Admin
    
    # Check if user is admin
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Admin):
        return jsonify({'success': False, 'error': '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω'}), 403
    
    try:
        data = request.get_json()
        client_id = data.get('client_id')
        manager_id = data.get('manager_id')
        
        if not client_id:
            return jsonify({'success': False, 'error': 'ID –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
        
        # Get client
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Handle assignment/unassignment
        if manager_id:
            manager = Manager.query.get(manager_id)
            if not manager:
                return jsonify({'success': False, 'error': '–ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
            
            if not manager.is_active:
                return jsonify({'success': False, 'error': '–ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω'}), 400
            
            client.assigned_manager_id = manager_id
            manager_name = manager.full_name
            message = f'–ö–ª–∏–µ–Ω—Ç {client.full_name} –Ω–∞–∑–Ω–∞—á–µ–Ω –º–µ–Ω–µ–¥–∂–µ—Ä—É {manager_name}'
        else:
            # Unassign manager
            client.assigned_manager_id = None
            manager_name = None
            message = f'–ú–µ–Ω–µ–¥–∂–µ—Ä —É–¥–∞–ª–µ–Ω —É –∫–ª–∏–µ–Ω—Ç–∞ {client.full_name}'
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': message,
            'manager_name': manager_name
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"ERROR in admin_assign_client_api: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


# Register API blueprint
app.register_blueprint(api_bp)

# Smart Search API Endpoints
@app.route('/api/smart-search')
def smart_search_api():
    """–£–º–Ω—ã–π –ø–æ–∏—Å–∫ —Å OpenAI –∞–Ω–∞–ª–∏–∑–æ–º"""
    query = request.args.get('q', '').strip()
    
    if not query:
        return jsonify({'results': [], 'criteria': {}, 'suggestions': []})
    
    try:
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å —Å –ø–æ–º–æ—â—å—é OpenAI (–≤–∫–ª—é—á–∞—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≥–æ—Ä–æ–¥–∞)
        criteria = smart_search.analyze_search_query(query)
        # Search criteria processed
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ –∏ –ø—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
        properties = load_properties()
        
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –≥–æ—Ä–æ–¥—É –µ—Å–ª–∏ –æ–Ω –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –≤ –∑–∞–ø—Ä–æ—Å–µ
        city_id = criteria.get('city_id')
        if city_id:
            # –§–∏–ª—å—Ç—Ä—É–µ–º –æ–±—ä–µ–∫—Ç—ã –ø–æ –≥–æ—Ä–æ–¥—É
            properties = [p for p in properties if p.get('city_id') == city_id]
            print(f"üåç –ê–≤—Ç–æ—Ñ–∏–ª—å—Ç—Ä: –æ—Å—Ç–∞–≤–ª–µ–Ω–æ {len(properties)} –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è –≥–æ—Ä–æ–¥–∞ ID {city_id}")
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º –±–∞–∑–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤
        filtered_properties = apply_smart_filters(properties, criteria)
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        if criteria.get('semantic_search') or criteria.get('features'):
            filtered_properties = smart_search.semantic_property_search(
                filtered_properties, query, criteria
            )
        
        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        results = []
        for prop in filtered_properties[:20]:
            results.append({
                'type': 'property',
                'id': prop_orm.inner_id or str(prop_orm.id),
                'title': f"{prop.get('rooms', 0)}-–∫–æ–º–Ω {prop.get('area', 0)} –º¬≤" if prop.get('rooms', 0) > 0 else f"–°—Ç—É–¥–∏—è {prop.get('area', 0)} –º¬≤",
                'subtitle': f"{prop.get('complex_name', '')} ‚Ä¢ {prop['district']}",
                'price': prop['price'],
                'rooms': prop.get('rooms', 1),
                'area': prop.get('area', 0),
                'url': f"/object/{prop['id']}"
            })
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ–¥—Å–∫–∞–∑–∫–∏
        suggestions = smart_search.generate_search_suggestions(query)
        
        return jsonify({
            'results': results,
            'criteria': criteria,
            'suggestions': suggestions[:5],
            'total': len(filtered_properties),
            'detected_city': {
                'city_id': criteria.get('city_id'),
                'city_name': criteria.get('city_name'),
                'city_slug': criteria.get('city_slug')
            } if criteria.get('city_id') else None
        })
        
    except Exception as e:
        print(f"ERROR: Smart search failed: {e}")
        # Fallback –∫ –æ–±—ã—á–Ω–æ–º—É –ø–æ–∏—Å–∫—É
        return jsonify({'results': [], 'error': str(e)})

@app.route('/api/search-suggestions')
# ‚ùå –ö–≠–® –û–¢–ö–õ–Æ–ß–Å–ù –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ —Ç–∏–ø–æ–≤ –∫–≤–∞—Ä—Ç–∏—Ä
# @cache.memoize(timeout=300)
def search_suggestions_api():
    """–°—É–ø–µ—Ä-–±—ã—Å—Ç—Ä—ã–π API –¥–ª—è –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞ - –ü–†–ò–û–†–ò–¢–ï–¢: –¥–∞–Ω–Ω—ã–µ –∏–∑ –ë–î"""
    query = request.args.get('q', '').strip()
    if not query or len(query) < 1:
        return jsonify([])
    
    try:
        from smart_search import smart_search
        
        # 1. –ü–†–ò–û–†–ò–¢–ï–¢: –ü–æ–∏—Å–∫ –ø–æ —Ä–µ–∞–ª—å–Ω—ã–º –¥–∞–Ω–Ω—ã–º –ë–î (–ñ–ö, –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∏, —Ä–∞–π–æ–Ω—ã, —É–ª–∏—Ü—ã)
        db_suggestions = smart_search.database_suggestions(query, limit=8)
        
        # 2. –ï—Å–ª–∏ –Ω–∞—à–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ –ë–î - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∏—Ö
        if db_suggestions and len(db_suggestions) > 0:
            print(f"‚úÖ Found {len(db_suggestions)} DB suggestions for '{query}'")
            return jsonify(db_suggestions)
        
        # 3. –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–∏ –≤ –ë–î - –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback (—Ö–∞—Ä–¥–∫–æ–¥ –ø–æ–¥—Å–∫–∞–∑–∫–∏)
        print(f"‚ö†Ô∏è No DB results for '{query}', using fallback")
        fallback_suggestions = smart_search.fallback_suggestions(query, limit=8)
        return jsonify(fallback_suggestions)
        
    except Exception as e:
        # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ - –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback
        print(f"‚ùå Database search failed for '{query}': {e}")
        import traceback
        traceback.print_exc()
        return search_suggestions_fallback(query)

def search_suggestions_fallback(query):
    """‚úÖ MIGRATED TO NORMALIZED TABLES: Fallback search using ResidentialComplexRepository"""
    suggestions = []
    query_lower = query.lower()
    
    try:
        # ‚úÖ MIGRATED: Search complexes using ResidentialComplexRepository
        from models import ResidentialComplex
        complexes = (
            db.session.query(
                ResidentialComplex.name,
                func.count(Property.id).label('count')
            )
            .join(Property, ResidentialComplex.id == Property.complex_id)
            .filter(
                ResidentialComplex.name.ilike(f'%{query_lower}%'),
                Property.is_active == True
            )
            .group_by(ResidentialComplex.name)
            .order_by(func.count(Property.id).desc())
            .limit(4)
            .all()
        )
        
        for row in complexes:
            suggestions.append({
                'type': 'complex',
                'title': row[0],
                'subtitle': f'{row[1]} –∫–≤–∞—Ä—Ç–∏—Ä',
                'icon': 'building',
                'url': f'/properties?residential_complex={row[0]}'
            })
        
        return jsonify({'suggestions': suggestions[:6]})
    except Exception as e:
        return jsonify({'suggestions': [], 'error': str(e)})

@app.route('/api/super-search')
@cache.memoize(timeout=180)  # –ö—ç—à –Ω–∞ 3 –º–∏–Ω—É—Ç—ã
def super_search_api():
    """–ù–æ–≤—ã–π —Å—É–ø–µ—Ä-–±—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏"""
    query = request.args.get('q', '').strip()
    if not query:
        return jsonify({'results': [], 'total': 0})
    
    try:
        from smart_search import smart_search
        results = smart_search.search_properties(query, limit=50)
        return jsonify(results)
        
    except Exception as e:
        print(f"Super search error: {e}")
        return jsonify({'results': [], 'total': 0, 'error': str(e)})

@app.route('/api/metrics', methods=['POST'])
def collect_metrics():
    """–°–±–æ—Ä –º–µ—Ç—Ä–∏–∫ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'status': 'error', 'message': 'No data provided'}), 400
        
        # –õ–æ–≥–∏—Ä—É–µ–º –≤–∞–∂–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
        metric_type = data.get('type', 'unknown')
        
        if metric_type == 'page_load':
            duration = data.get('duration', 0)
            url = data.get('url', 'unknown')
            print(f"‚ö° Page Load: {url} in {round(duration)}ms")
        
        elif metric_type == 'search_performance':
            query = data.get('query', '')
            response_time = data.get('response_time', 0)
            results_count = data.get('results_count', 0)
            print(f"üîç Search: '{query}' - {round(response_time)}ms, {results_count} results")
        
        # –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –±—ã –±—ã–ª–∞ –∑–∞–ø–∏—Å—å –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        # –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        
        return jsonify({'status': 'success'})
        
    except Exception as e:
        print(f"Metrics collection error: {e}")
        return jsonify({'status': 'error'}), 500

@app.route('/api/smart-suggestions')
def smart_suggestions_api():
    """API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —É–º–Ω—ã—Ö –ø–æ–¥—Å–∫–∞–∑–æ–∫ –ø–æ–∏—Å–∫–∞"""
    query = request.args.get('q', '').strip()
    
    if len(query) < 2:
        return jsonify({'suggestions': []})
    
    try:
        suggestions = smart_search.generate_search_suggestions(query)
        return jsonify({'suggestions': suggestions})
    except Exception as e:
        print(f"ERROR: Smart suggestions failed: {e}")
        return jsonify({'suggestions': []})

def apply_smart_filters(properties, criteria):
    """–ü—Ä–∏–º–µ–Ω—è–µ—Ç —É–º–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤ OpenAI"""
    filtered = properties.copy()
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –∫–æ–º–Ω–∞—Ç–∞–º
    if criteria.get('rooms'):
        rooms_list = criteria['rooms']
        filtered = [p for p in filtered if str(p.get('rooms', '')) in rooms_list]
    
    # –§–∏–ª—å—Ç—Ä –ø–æ —Ä–∞–π–æ–Ω—É
    if criteria.get('district'):
        district = criteria['district']
        filtered = [p for p in filtered if p.get('district', '') == district]
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º (—Ç–∏–ø—ã –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏, –∫–ª–∞—Å—Å—ã, –º–∞—Ç–µ—Ä–∏–∞–ª—ã)
    if criteria.get('keywords'):
        keywords_filtered = []
        for prop in filtered:
            prop_matches = False
            for keyword in criteria['keywords']:
                keyword_lower = keyword.lower()
                
                # –¢–∏–ø –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏
                prop_type_lower = prop.get('property_type', '–ö–≤–∞—Ä—Ç–∏—Ä–∞').lower()
                if keyword_lower == prop_type_lower:
                    prop_matches = True
                    break
                
                # –ö–ª–∞—Å—Å –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ (—Ç–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ)
                prop_class_lower = prop.get('property_class', '').lower()
                if keyword_lower == prop_class_lower:
                    prop_matches = True
                    break
                
                # –ú–∞—Ç–µ—Ä–∏–∞–ª —Å—Ç–µ–Ω
                wall_material_lower = prop.get('wall_material', '').lower()
                if keyword_lower in wall_material_lower:
                    prop_matches = True
                    break
                
                # –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏
                features = prop.get('features', [])
                if any(keyword_lower in feature.lower() for feature in features):
                    prop_matches = True
                    break
                
                # –û—Å–æ–±–∞—è –ª–æ–≥–∏–∫–∞ –¥–ª—è —Ü–µ–Ω–æ–≤—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π
                if keyword_lower == '–¥–æ—Ä–æ–≥–æ' or keyword_lower == '–Ω–µ–¥–æ—Ä–æ–≥–æ':
                    # –≠—Ç–∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ –ø–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
                    continue
                
                # –ü–æ–∏—Å–∫ –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ –∫–∞–∫ fallback
                property_title = f"{prop.get('rooms', 0)}-–∫–æ–º–Ω {prop.get('area', 0)} –º¬≤" if prop.get('rooms', 0) > 0 else f"–°—Ç—É–¥–∏—è {prop.get('area', 0)} –º¬≤"
                title_lower = property_title.lower()
                if keyword_lower in title_lower:
                    prop_matches = True
                    break
            
            if prop_matches:
                keywords_filtered.append(prop)
        
        filtered = keywords_filtered
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ü–µ–Ω–æ–≤—ã—Ö –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –ø–æ—Å–ª–µ –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
        if '–¥–æ—Ä–æ–≥–æ' in criteria.get('keywords', []):
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ü–µ–Ω–µ –∏ –±–µ—Ä–µ–º –≤–µ—Ä—Ö–Ω–∏–µ 50%
            filtered = sorted(filtered, key=lambda x: x.get('price', 0), reverse=True)
            filtered = filtered[:max(1, len(filtered)//2)]
        elif '–Ω–µ–¥–æ—Ä–æ–≥–æ' in criteria.get('keywords', []):
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ü–µ–Ω–µ –∏ –±–µ—Ä–µ–º –Ω–∏–∂–Ω–∏–µ 50%
            filtered = sorted(filtered, key=lambda x: x.get('price', 0))
            filtered = filtered[:max(1, len(filtered)//2)]
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—è–º
    if criteria.get('features'):
        features_list = criteria['features']
        features_filtered = []
        for prop in filtered:
            prop_features = [f.lower() for f in prop.get('features', [])]
            if any(feature.lower() in prop_features for feature in features_list):
                features_filtered.append(prop)
        filtered = features_filtered
    
    # –§–∏–ª—å—Ç—Ä –ø–æ —Ü–µ–Ω–µ
    if criteria.get('price_range'):
        price_range = criteria['price_range']
        if len(price_range) >= 1 and price_range[0]:
            min_price = price_range[0]
            filtered = [p for p in filtered if p.get('price', 0) >= min_price]
        if len(price_range) >= 2 and price_range[1]:
            max_price = price_range[1]
            filtered = [p for p in filtered if p.get('price', 0) <= max_price]
    
    return filtered

# Manager Client Management Routes
@app.route('/manager/clients')
@manager_required
def manager_clients():
    """Manager clients page"""
    from models import User, Manager
    
    current_manager = current_user
    
    if not current_manager:
        return redirect(url_for('manager_login'))
    
    # Get clients assigned to this manager
    clients = User.query.filter_by(assigned_manager_id=current_manager.id).order_by(User.created_at.desc()).all()
    
    return render_template('manager/clients.html', 
                         manager=current_manager,
                         clients=clients)

# Manager Deals Management Routes  
@app.route('/manager/deals')
@manager_required
def manager_deals():
    """Manager deals page"""
    from models import User, Manager, Deal, ResidentialComplex
    from sqlalchemy import func
    
    current_manager = current_user
    
    if not current_manager:
        return redirect(url_for('manager_login'))
    
    # Get deals for this manager
    deals = Deal.query.filter_by(manager_id=current_manager.id).order_by(Deal.created_at.desc()).all()
    
    # Get clients available for this manager (assigned OR unassigned)
    # –ú–µ–Ω–µ–¥–∂–µ—Ä –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å–¥–µ–ª–∫–∏ –¥–ª—è —Å–≤–æ–∏—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ –∏ –¥–ª—è –Ω–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
    assigned_clients = User.query.filter(
        db.or_(
            User.assigned_manager_id == current_manager.id,
            User.assigned_manager_id == None
        )
    ).filter_by(role='buyer').order_by(User.full_name).all()
    
    residential_complexes = ResidentialComplex.query.order_by(ResidentialComplex.name).all()
    
    # Calculate stats
    active_deals_count = Deal.query.filter(
        Deal.manager_id == current_manager.id,
        Deal.status.in_(['new', 'reserved', 'mortgage'])
    ).count()
    
    completed_deals_count = Deal.query.filter(
        Deal.manager_id == current_manager.id,
        Deal.status == 'completed'
    ).count()
    
    in_progress_deals_count = Deal.query.filter(
        Deal.manager_id == current_manager.id,
        Deal.status.in_(['reserved', 'mortgage'])
    ).count()
    
    # Calculate total cashback
    total_cashback = db.session.query(func.sum(Deal.cashback_amount)).filter(
        Deal.manager_id == current_manager.id,
        Deal.status == 'completed'
    ).scalar() or 0
    
    return render_template('manager/deals.html',
                         manager=current_manager,
                         deals=deals,
                         assigned_clients=assigned_clients,
                         residential_complexes=residential_complexes,
                         active_deals_count=active_deals_count,
                         completed_deals_count=completed_deals_count,
                         in_progress_deals_count=in_progress_deals_count,
                         total_cashback=int(total_cashback))


@app.route('/api/manager/add-client', methods=['POST'])
@manager_required
def manager_add_client():
    """Add new client"""
    from models import User, Manager
    import re
    
    current_manager = current_user
    print(f"DEBUG: Add client endpoint called by manager {current_manager.id}")
    print(f"DEBUG: Request method: {request.method}, Content-Type: {request.content_type}")
    print(f"DEBUG: Request is_json: {request.is_json}")
    
    try:
        # Accept both JSON and form data
        if request.is_json:
            data = request.get_json()
            print(f"DEBUG: Received JSON data: {data}")
            full_name = data.get('full_name', '').strip()
            email = data.get('email', '').strip().lower()
            phone = data.get('phone', '').strip() if data.get('phone') else None
            is_active = data.get('is_active', True)
            client_request = data.get('client_request', '').strip() if data.get('client_request') else None
        else:
            print(f"DEBUG: Received form data: {dict(request.form)}")
            full_name = request.form.get('full_name', '').strip()
            email = request.form.get('email', '').strip().lower()
            phone = request.form.get('phone', '').strip() if request.form.get('phone') else None
            is_active = 'is_active' in request.form
            client_request = request.form.get('client_request', '').strip() if request.form.get('client_request') else None
        
        print(f"DEBUG: Parsed data - name: {full_name}, email: {email}, phone: {phone}, active: {is_active}")
        
        # Validation
        if not full_name or len(full_name) < 2:
            return jsonify({'success': False, 'error': '–ü–æ–ª–Ω–æ–µ –∏–º—è –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞'}), 400
        
        # Email validation
        email_regex = r'^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$'
        if not email or not re.match(email_regex, email):
            return jsonify({'success': False, 'error': '–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email –∞–¥—Ä–µ—Å'}), 400
        
        # Phone validation (optional but must be correct format if provided)
        if phone:
            phone_regex = r'^\+7-\d{3}-\d{3}-\d{2}-\d{2}$'
            if not re.match(phone_regex, phone):
                return jsonify({'success': False, 'error': '–¢–µ–ª–µ—Ñ–æ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ +7-918-123-45-67'}), 400
        
        # Check if email already exists
        existing_user = User.query.filter_by(email=email).first()
        if existing_user:
            return jsonify({'success': False, 'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'}), 400
        
        # Check if phone already exists (normalized comparison like registration)
        if phone:
            from sqlalchemy import func as sqlfunc
            phone_digits = re.sub(r'[^0-9]', '', phone)
            existing_phone_user = User.query.filter(
                sqlfunc.replace(sqlfunc.replace(sqlfunc.replace(User.phone, "-", ""), " ", ""), "+", "") == phone_digits
            ).first()
            if existing_phone_user:
                return jsonify({'success': False, 'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'}), 400
        
        # Generate temporary password
        import secrets
        import string
        temp_password = ''.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(8))
        
        # Create new user with temporary password
        user = User(
            is_verified=True,  # Auto-verify
            full_name=full_name,
            email=email,
            phone=phone,
            is_active=is_active,
            role='buyer',
            assigned_manager_id=current_manager.id,
            registration_source='Manager',
            client_status='–ù–æ–≤—ã–π',
            client_notes=client_request
        )
        user.must_change_password = True  # –¢—Ä–µ–±—É–µ—Ç—Å—è —Å–º–µ–Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –ø–∞—Ä–æ–ª—è
        user.set_password(temp_password)  # Set temporary password
        
        db.session.add(user)
        db.session.commit()
        
        print(f"DEBUG: Successfully created client {user.id}: {user.full_name}")
        
        # Send welcome email and SMS with credentials
        try:
            from email_service import send_email
            manager = Manager.query.get(manager_id)
            manager_name = manager.full_name if manager else '–í–∞—à –º–µ–Ω–µ–¥–∂–µ—Ä'
            
            # Email with login credentials
            subject = "–í–∞—à –∞–∫–∫–∞—É–Ω—Ç —Å–æ–∑–¥–∞–Ω –≤ InBack.ru - –î–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞"
            email_content = f"""–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {full_name}!

–î–ª—è –≤–∞—Å —Å–æ–∑–¥–∞–Ω –∞–∫–∫–∞—É–Ω—Ç –Ω–∞ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ InBack.ru

üìß Email –¥–ª—è –≤—Ö–æ–¥–∞: {email}
üîë –í—Ä–µ–º–µ–Ω–Ω—ã–π –ø–∞—Ä–æ–ª—å: {temp_password}

üåê –°—Å—ã–ª–∫–∞ –¥–ª—è –≤—Ö–æ–¥–∞: {request.url_root.rstrip('/')}/login

–í–ê–ñ–ù–û: –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º —Å–º–µ–Ω–∏—Ç—å –ø–∞—Ä–æ–ª—å –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –≤—Ö–æ–¥–∞ –≤ —Ä–∞–∑–¥–µ–ª–µ "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ—Ñ–∏–ª—è"

–í–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä: {manager_name}

–ü–æ –≤—Å–µ–º –≤–æ–ø—Ä–æ—Å–∞–º –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å –∫ —Å–≤–æ–µ–º—É –º–µ–Ω–µ–¥–∂–µ—Ä—É.

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,
–ö–æ–º–∞–Ω–¥–∞ InBack.ru"""
            
            send_email(
                to_email=email,
                subject=subject,
                content=email_content,
                template_name='notification'
            )
            print(f"DEBUG: Welcome email with credentials sent to {email}")
            
            # Send SMS if phone number provided
            if phone:
                try:
                    from sms_service import send_login_credentials_sms
                    
                    sms_sent = send_login_credentials_sms(
                        phone=phone,
                        email=email,
                        password=temp_password,
                        manager_name=manager_name,
                        login_url=f"{request.url_root.rstrip('/')}/login"
                    )
                    
                    if sms_sent:
                        print(f"DEBUG: SMS sent successfully to {phone}")
                    else:
                        print(f"DEBUG: SMS sending failed for {phone}")
                    
                except Exception as sms_e:
                    print(f"DEBUG: Failed to send SMS: {sms_e}")
                    
        except Exception as e:
            print(f"DEBUG: Failed to send welcome email: {e}")
        
        return jsonify({
            'success': True, 
            'client_id': user.id,
            'message': f'–ö–ª–∏–µ–Ω—Ç {full_name} —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω. –î–∞–Ω–Ω—ã–µ –¥–ª—è –≤—Ö–æ–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –Ω–∞ email {email}' + (f' –∏ SMS –Ω–∞ {phone}' if phone else '') + '.',
            'client_data': {
                'id': user.id,
                'full_name': user.full_name,
                'email': user.email,
                'phone': user.phone,
                'user_id': user.user_id,
                'login_url': f"{request.url_root.rstrip('/')}/login",
                'temp_password': temp_password  # Include for manager reference
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding client: {str(e)}")
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}'}), 500

@app.route('/manager/get-client/<int:client_id>')
@manager_required
@csrf.exempt
def manager_get_client(client_id):
    """Get client data for editing"""
    from models import User
    
    try:
        current_manager = current_user
        
        client = User.query.filter_by(id=client_id, assigned_manager_id=current_manager.id).first()
        
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        return jsonify({
            'success': True,
            'id': client.id,
            'full_name': client.full_name or '',
            'email': client.email or '',
            'phone': client.phone or '',
            'is_active': client.is_active if hasattr(client, 'is_active') else True,
            'status': getattr(client, 'status', 'active'),
            'search_preferences': getattr(client, 'search_preferences', None),
            'created_at': client.created_at.isoformat() if hasattr(client, 'created_at') and client.created_at else None
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

# ================================
# DEAL MANAGEMENT API ENDPOINTS
# ================================

@app.route('/api/deals', methods=['POST'])
@manager_required
@require_json_csrf
def api_create_deal():
    """Create new deal (managers only)"""
    from models import Deal, Manager, User, ResidentialComplex
    from decimal import Decimal
    
    try:
        current_manager = current_user
        data = request.get_json()
        
        if not data:
            return jsonify({'success': False, 'error': '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏'}), 400
        
        # Validation - client_id and price are required
        if 'client_id' not in data or not data['client_id']:
            return jsonify({'success': False, 'error': '–ü–æ–ª–µ client_id –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        if 'property_price' not in data or not data['property_price']:
            return jsonify({'success': False, 'error': '–ü–æ–ª–µ property_price –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
        
        # Get complex name from request
        complex_name = data.get('residential_complex_name', '').strip()
        if not complex_name:
            return jsonify({'success': False, 'error': '–ù–µ–æ–±—Ö–æ–¥–∏–º–æ —É–∫–∞–∑–∞—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ –ñ–ö'}), 400
        
        # Validate client exists and belongs to this manager
        client_id = int(data['client_id'])
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # –ú–µ–Ω–µ–¥–∂–µ—Ä –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å–¥–µ–ª–∫–∏ –¥–ª—è:
        # 1. –°–≤–æ–∏—Ö –Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ (assigned_manager_id == current_manager.id)
        # 2. –ù–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ (assigned_manager_id is None)
        if client.assigned_manager_id is not None and client.assigned_manager_id != current_manager.id:
            return jsonify({'success': False, 'error': '–≠—Ç–æ—Ç –∫–ª–∏–µ–Ω—Ç —É–∂–µ –Ω–∞–∑–Ω–∞—á–µ–Ω –¥—Ä—É–≥–æ–º—É –º–µ–Ω–µ–¥–∂–µ—Ä—É'}), 403
        
        # Validate price and cashback amounts
        try:
            property_price = Decimal(str(data['property_price']))
            cashback_amount = Decimal(str(data['cashback_amount']))
            
            if property_price <= 0:
                return jsonify({'success': False, 'error': '–°—Ç–æ–∏–º–æ—Å—Ç—å –æ–±—ä–µ–∫—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ 0'}), 400
            
            if cashback_amount < 0:
                return jsonify({'success': False, 'error': '–°—É–º–º–∞ –∫–µ—à–±–µ–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–π'}), 400
                
            # Get complex cashback rate for validation
            max_rate = Decimal('0.15')  # Default max 15% cashback
            if cashback_amount > property_price * max_rate:  # Max cashback validation
                return jsonify({'success': False, 'error': f'–°—É–º–º–∞ –∫–µ—à–±–µ–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å {max_rate * 100}% –æ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –æ–±—ä–µ–∫—Ç–∞'}), 400
                
        except (ValueError, TypeError):
            return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ü–µ–Ω—ã –∏–ª–∏ –∫–µ—à–±–µ–∫–∞'}), 400
        
        # Create new deal
        deal = Deal(
            manager_id=current_manager.id,
            client_id=data['client_id'],
            residential_complex_name=complex_name,  # Save complex name as text
            property_price=property_price,
            cashback_amount=cashback_amount,
            property_description=data.get('property_description', ''),
            property_floor=data.get('property_floor'),
            property_area=data.get('property_area'),
            property_rooms=data.get('property_rooms', ''),
            status=data.get('status', 'new'),
            notes=data.get('notes', ''),
            client_notes=data.get('client_notes', '')
        )
        
        db.session.add(deal)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–°–¥–µ–ª–∫–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞',
            'deal': {
                'id': deal.id,
                'deal_number': deal.deal_number,
                'status': deal.status,
                'status_display': deal.status_display,
                'property_price': float(deal.property_price),
                'cashback_amount': float(deal.cashback_amount),
                'client_name': client.full_name,
                'complex_name': complex_name,
                'created_at': deal.created_at.isoformat()
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error creating deal: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å–¥–µ–ª–∫–∏'}), 500


@app.route('/api/deals', methods=['GET'])
def api_get_deals():
    """Get list of deals with filtering"""
    from models import Deal, Manager, User, ResidentialComplex
    from flask_login import current_user
    
    print("ü§ù DEBUG: /api/deals endpoint called")
    
    try:
        # Check if user is manager or client
        is_manager = current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager)
        
        print(f"ü§ù DEBUG: is_manager={is_manager}, authenticated={current_user.is_authenticated}")
        
        if is_manager:
            # Manager can see all their deals
            current_manager = current_user
            print(f"ü§ù DEBUG: Manager ID = {current_manager.id}, Email = {current_manager.email}")
            deals_query = Deal.query.filter_by(manager_id=current_manager.id)
        elif current_user.is_authenticated:
            # Client can only see their own deals
            user_id = current_user.id
            print(f"ü§ù DEBUG: Client ID = {user_id}")
            deals_query = Deal.query.filter_by(client_id=user_id)
        else:
            # No authentication
            print("ü§ù DEBUG: User not authenticated")
            return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
        
        # Apply status filtering if provided
        status_filter = request.args.get('status')
        if status_filter:
            status_list = [s.strip() for s in status_filter.split(',') if s.strip()]
            if status_list:
                print(f"ü§ù DEBUG: Applying status filter: {status_list}")
                deals_query = deals_query.filter(Deal.status.in_(status_list))
        
        # Order by creation date (newest first)
        deals = deals_query.order_by(Deal.created_at.desc()).all()
        
        print(f"ü§ù DEBUG: Found {len(deals)} deals")
        if len(deals) > 0:
            print(f"ü§ù DEBUG: First deal: ID={deals[0].id}, Client={deals[0].client.full_name}, Complex={deals[0].residential_complex_name}")
        
        # Format response
        deals_data = []
        for deal in deals:
            deals_data.append({
                'id': deal.id,
                'deal_number': deal.deal_number,
                'status': deal.status,
                'status_display': deal.status_display,
                'status_color': deal.status_color,
                'property_price': float(deal.property_price),
                'cashback_amount': float(deal.cashback_amount),
                'cashback_percentage': deal.get_cashback_percentage(),
                'property_description': deal.property_description,
                'property_floor': deal.property_floor,
                'property_area': deal.property_area,
                'property_rooms': deal.property_rooms,
                'notes': deal.notes,
                'client_notes': deal.client_notes,
                'client_name': deal.client.full_name,
                'client_profile_image': deal.client.profile_image or '',
                'manager_name': deal.manager.full_name,
                'complex_name': deal.residential_complex_name or (deal.residential_complex.name if deal.residential_complex else ''),
                'contract_date': deal.contract_date.isoformat() if deal.contract_date else None,
                'completion_date': deal.completion_date.isoformat() if deal.completion_date else None,
                'created_at': deal.created_at.isoformat(),
                'updated_at': deal.updated_at.isoformat(),
                'can_edit': deal.can_edit(current_manager.id if is_manager else current_user.id, is_manager)
            })
        
        print(f"ü§ù DEBUG: Returning {len(deals_data)} deals to client")
        
        return jsonify({
            'success': True,
            'deals': deals_data,
            'total': len(deals_data),
            'is_manager': is_manager
        })
        
    except Exception as e:
        print(f"‚ùå Error getting deals: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–¥–µ–ª–æ–∫'}), 500



@app.route('/api/deals/<int:deal_id>', methods=['GET'])
@login_required
def api_get_deal(deal_id):
    """Get specific deal with access control"""
    from models import Deal
    
    try:
        deal = Deal.query.get(deal_id)
        if not deal:
            return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        # Check access rights
        is_manager = current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager)
        
        if is_manager:
            # Manager can only see their own deals
            current_manager = current_user
            if deal.manager_id != current_manager.id:
                return jsonify({'success': False, 'error': '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —ç—Ç–æ–π —Å–¥–µ–ª–∫–∏'}), 403
        else:
            # Client can only see their own deals
            if deal.client_id != current_user.id:
                return jsonify({'success': False, 'error': '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —ç—Ç–æ–π —Å–¥–µ–ª–∫–∏'}), 403
        
        # Return deal data
        deal_data = {
            'id': deal.id,
            'deal_number': deal.deal_number,
            'status': deal.status,
            'status_display': deal.status_display,
            'status_color': deal.status_color,
            'property_price': float(deal.property_price),
            'cashback_amount': float(deal.cashback_amount),
            'cashback_percentage': deal.get_cashback_percentage(),
            'property_description': deal.property_description,
            'property_floor': deal.property_floor,
            'property_area': deal.property_area,
            'property_rooms': deal.property_rooms,
            'notes': deal.notes,
            'client_notes': deal.client_notes,
            'client_name': deal.client.full_name,
                'client_profile_image': deal.client.profile_image or '',
            'client_email': deal.client.email,
            'client_phone': deal.client.phone,
            'manager_name': deal.manager.full_name,
            'manager_email': deal.manager.email,
            'manager_phone': deal.manager.phone,
            'complex_name': deal.residential_complex_name or (deal.residential_complex.name if deal.residential_complex else ''),
            'complex_id': deal.residential_complex.id if deal.residential_complex else None,
            'contract_date': deal.contract_date.isoformat() if deal.contract_date else None,
            'completion_date': deal.completion_date.isoformat() if deal.completion_date else None,
            'created_at': deal.created_at.isoformat(),
            'updated_at': deal.updated_at.isoformat(),
            'can_edit': deal.can_edit(current_manager.id if is_manager else current_user.id, is_manager)
        }
        
        return jsonify({
            'success': True,
            'deal': deal_data
        })
        
    except Exception as e:
        print(f"Error getting deal {deal_id}: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–¥–µ–ª–∫–∏'}), 500


@app.route('/api/deals/<int:deal_id>', methods=['PUT'])
@csrf.exempt
def api_update_deal(deal_id):
    """Update deal (status, notes)"""
    from models import Deal
    from datetime import datetime, date
    from flask_login import current_user
    
    try:
        # Check authentication
        is_manager = current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager)
        
        if not is_manager and not current_user.is_authenticated:
            return jsonify({'success': False, 'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
        
        deal = Deal.query.get(deal_id)
        if not deal:
            return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è'}), 400
        
        if is_manager:
            # Manager can only update their own deals
            current_manager = current_user
            if deal.manager_id != current_manager.id:
                return jsonify({'success': False, 'error': '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π —Å–¥–µ–ª–∫–∏'}), 403
            
            allowed_fields = ['status', 'notes', 'client_notes', 'property_description', 
                            'property_floor', 'property_area', 'property_rooms', 
                            'contract_date', 'completion_date', 'property_price', 
                            'cashback_amount', 'residential_complex_id', 'residential_complex_name']
        else:
            # Client can only update their own deals and limited fields
            if deal.client_id != current_user.id:
                return jsonify({'success': False, 'error': '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π —Å–¥–µ–ª–∫–∏'}), 403
            
            # Client can only update notes and only if deal is in editable status
            if deal.status not in ['new', 'object_reserved']:
                return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –±–æ–ª—å—à–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∞'}), 403
            
            allowed_fields = ['client_notes']
        
        # Store old values for logging
        old_status = deal.status
        old_property_price = float(deal.property_price) if deal.property_price else 0
        old_cashback_amount = float(deal.cashback_amount) if deal.cashback_amount else 0
        
        # Update allowed fields
        updated_fields = []
        
        for field in allowed_fields:
            if field in data:
                if field == 'status':
                    # Validate status
                    valid_statuses = ['new', 'in_progress', 'calculation', 'meeting_scheduled', 'meeting_done',
                                       'postponed', 'verbal_reserve', 'reserved', 'documents', 'mortgage',
                                       'ddu_preparation', 'ddu_signing', 'registration', 'receivables',
                                       'completed', 'rejected',
                                       'object_reserved', 'successful']
                    if data[field] not in valid_statuses:
                        return jsonify({'success': False, 'error': f'–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Å—Ç–∞—Ç—É—Å: {data[field]}'}), 400
                    # Save validated status
                    setattr(deal, field, data[field])
                    updated_fields.append(field)
                
                elif field in ['contract_date', 'completion_date']:
                    # Handle date fields
                    if data[field]:
                        try:
                            date_value = datetime.strptime(data[field], '%Y-%m-%d').date()
                            setattr(deal, field, date_value)
                            updated_fields.append(field)
                        except ValueError:
                            return jsonify({'success': False, 'error': f'–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã –¥–ª—è {field}. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ YYYY-MM-DD'}), 400
                    else:
                        setattr(deal, field, None)
                        updated_fields.append(field)
                
                elif field == 'property_price':
                    # Validate and handle property_price
                    try:
                        price_value = float(data[field])
                        if price_value <= 0:
                            return jsonify({'success': False, 'error': '–°—Ç–æ–∏–º–æ—Å—Ç—å –æ–±—ä–µ–∫—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è'}), 400
                        setattr(deal, field, price_value)
                        updated_fields.append(field)
                        app.logger.debug(f"üí∞ Deal #{deal.deal_number}: property_price set to {price_value}")
                    except (ValueError, TypeError):
                        return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –æ–±—ä–µ–∫—Ç–∞'}), 400
                
                elif field == 'cashback_amount':
                    # Validate and handle cashback_amount
                    try:
                        cashback_value = float(data[field])
                        if cashback_value < 0:
                            return jsonify({'success': False, 'error': '–°—É–º–º–∞ –∫–µ—à–±–µ–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–π'}), 400
                        
                        # Check if cashback exceeds property price (use updated property_price if provided, otherwise use current)
                        property_price = float(data.get('property_price', deal.property_price))
                        if cashback_value > property_price:
                            return jsonify({'success': False, 'error': '–°—É–º–º–∞ –∫–µ—à–±–µ–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–µ–≤—ã—à–∞—Ç—å —Å—Ç–æ–∏–º–æ—Å—Ç—å –æ–±—ä–µ–∫—Ç–∞'}), 400
                        
                        setattr(deal, field, cashback_value)
                        updated_fields.append(field)
                        app.logger.debug(f"üí∞ Deal #{deal.deal_number}: cashback_amount set to {cashback_value}")
                    except (ValueError, TypeError):
                        return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å—É–º–º—ã –∫–µ—à–±–µ–∫–∞'}), 400
                
                else:
                    # Handle text fields
                    setattr(deal, field, data[field])
                    updated_fields.append(field)
        
        if not updated_fields:
            return jsonify({'success': False, 'error': '–ù–µ—Ç –ø–æ–ª–µ–π –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è'}), 400
        
        deal.updated_at = datetime.utcnow()
        
        if is_manager:
            from models import DealHistory, Deal as DealModel
            current_manager_obj = current_user
            field_labels = {
                'status': '–≠—Ç–∞–ø', 'property_price': '–°—Ç–æ–∏–º–æ—Å—Ç—å', 'cashback_amount': '–ö–µ—à–±–µ–∫',
                'property_description': '–û–ø–∏—Å–∞–Ω–∏–µ', 'property_floor': '–≠—Ç–∞–∂', 'property_area': '–ü–ª–æ—â–∞–¥—å',
                'property_rooms': '–ö–æ–º–Ω–∞—Ç', 'notes': '–ó–∞–º–µ—Ç–∫–∏', 'contract_date': '–î–∞—Ç–∞ –¥–æ–≥–æ–≤–æ—Ä–∞',
                'completion_date': '–î–∞—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è', 'residential_complex_name': '–ñ–ö'
            }
            if 'status' in updated_fields and old_status != deal.status:
                old_label = DealModel.STAGE_LABELS.get(old_status, old_status)
                new_label = DealModel.STAGE_LABELS.get(deal.status, deal.status)
                history = DealHistory(
                    deal_id=deal.id, author_id=current_manager_obj.id, action='stage_change',
                    field_name='status', old_value=old_label, new_value=new_label,
                    description=f'–≠—Ç–∞–ø –∏–∑–º–µ–Ω—ë–Ω: {old_label} ‚Üí {new_label}'
                )
                db.session.add(history)
                try:
                    from models import UserNotification
                    notification_icons = {
                        'new': 'fas fa-star', 'in_progress': 'fas fa-spinner', 'calculation': 'fas fa-calculator',
                        'meeting_scheduled': 'fas fa-calendar-check', 'meeting_done': 'fas fa-handshake',
                        'postponed': 'fas fa-pause-circle', 'verbal_reserve': 'fas fa-comment-dots',
                        'reserved': 'fas fa-bookmark', 'documents': 'fas fa-file-alt', 'mortgage': 'fas fa-university',
                        'ddu_preparation': 'fas fa-file-contract', 'ddu_signing': 'fas fa-pen-fancy',
                        'registration': 'fas fa-stamp', 'receivables': 'fas fa-money-bill-wave',
                        'completed': 'fas fa-check-circle', 'rejected': 'fas fa-times-circle'
                    }
                    notif_type = 'success' if deal.status in ('completed', 'successful') else ('error' if deal.status == 'rejected' else 'info')
                    complex_name = deal.residential_complex_name or (deal.residential_complex.name if deal.residential_complex else '')
                    notif = UserNotification(
                        user_id=deal.client_id,
                        title=f'–°–¥–µ–ª–∫–∞ {deal.deal_number}: {new_label}',
                        message=f'–°—Ç–∞—Ç—É—Å –≤–∞—à–µ–π —Å–¥–µ–ª–∫–∏' + (f' –ø–æ {complex_name}' if complex_name else '') + f' –∏–∑–º–µ–Ω—ë–Ω —Å ¬´{old_label}¬ª –Ω–∞ ¬´{new_label}¬ª',
                        notification_type=notif_type,
                        icon=notification_icons.get(deal.status, 'fas fa-info-circle'),
                        action_url='/dashboard#deals'
                    )
                    db.session.add(notif)
                except Exception as e:
                    app.logger.error(f'Failed to create deal notification in PUT: {e}')
            for field in updated_fields:
                if field == 'status':
                    continue
                old_val = str(locals().get(f'old_{field}', ''))
                new_val = str(getattr(deal, field, ''))
                if old_val != new_val:
                    history = DealHistory(
                        deal_id=deal.id, author_id=current_manager_obj.id, action='field_update',
                        field_name=field_labels.get(field, field), old_value=old_val, new_value=new_val,
                        description=f'{field_labels.get(field, field)}: {old_val} ‚Üí {new_val}'
                    )
                    db.session.add(history)
        
        # Comprehensive logging for financial fields changes
        if is_manager and ('property_price' in updated_fields or 'cashback_amount' in updated_fields):
            current_manager = current_user
            timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
            
            if 'property_price' in updated_fields:
                new_property_price = float(deal.property_price)
                if old_property_price != new_property_price:
                    app.logger.info(
                        f"üí∞ Deal #{deal.deal_number}: property_price changed from "
                        f"{old_property_price:,.2f}‚ÇΩ to {new_property_price:,.2f}‚ÇΩ "
                        f"by manager {current_manager.id} ({current_manager.email}) "
                        f"at {timestamp}"
                    )
            
            if 'cashback_amount' in updated_fields:
                new_cashback_amount = float(deal.cashback_amount)
                if old_cashback_amount != new_cashback_amount:
                    app.logger.info(
                        f"üí∞ Deal #{deal.deal_number}: cashback_amount changed from "
                        f"{old_cashback_amount:,.2f}‚ÇΩ to {new_cashback_amount:,.2f}‚ÇΩ "
                        f"by manager {current_manager.id} ({current_manager.email}) "
                        f"at {timestamp}"
                    )
        
        db.session.commit()
        
        # üí∞ –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ï –ù–ê–ß–ò–°–õ–ï–ù–ò–ï –ë–ê–õ–ê–ù–°–ê –ü–†–ò –ó–ê–í–ï–†–®–ï–ù–ò–ò –°–î–ï–õ–ö–ò

        # Helper function –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–µ–Ω–µ–≥ —Å –∫–æ–ø–µ–π–∫–∞–º–∏
        def _format_money_ru(amount):
            """Format Decimal/float as RUB with kopecks: 1 234,56 ‚ÇΩ"""
            from decimal import Decimal, ROUND_HALF_UP
            KOPECK = Decimal('0.01')
            rounded = Decimal(str(amount)).quantize(KOPECK, rounding=ROUND_HALF_UP)
            formatted = f"{rounded:,.2f}".replace(',', ' ').replace('.', ',')
            return f"{formatted} ‚ÇΩ"

        if 'status' in updated_fields and old_status != deal.status and deal.status == 'successful':
            try:
                from services.balance_service import BalanceService
                from models import BalanceTransaction
                
                # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ –±–∞–ª–∞–Ω—Å –µ—â–µ –Ω–µ –Ω–∞—á–∏—Å–ª–µ–Ω –∑–∞ —ç—Ç—É —Å–¥–µ–ª–∫—É
                existing_transaction = BalanceTransaction.query.filter_by(
                    deal_id=deal.id,
                    transaction_type='cashback_earned'
                ).first()
                
                if not existing_transaction and deal.cashback_amount > 0:
                    # –ù–∞—á–∏—Å–ª–∏—Ç—å –∫–µ—à–±–µ–∫ —á–µ—Ä–µ–∑ –Ω–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É –±–∞–ª–∞–Ω—Å–æ–≤
                    transaction = BalanceService.credit_balance(
                        user_id=deal.client_id,
                        amount=deal.cashback_amount,
                        description=f'–ö–µ—à–±–µ–∫ –ø–æ —Å–¥–µ–ª–∫–µ {deal.deal_number} ({deal.residential_complex_name or "–æ–±—ä–µ–∫—Ç"})',
                        transaction_type='cashback_earned',
                        deal_id=deal.id,
                        created_by_id=deal.manager_id
                    )
                    
                    app.logger.info(f"‚úÖ –ö–µ—à–±–µ–∫ {deal.cashback_amount}‚ÇΩ –Ω–∞—á–∏—Å–ª–µ–Ω –∫–ª–∏–µ–Ω—Ç—É (user_id={deal.client_id}) –∑–∞ —Å–¥–µ–ª–∫—É {deal.deal_number}")
                    
                    # –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç—É –æ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –∫–µ—à–±–µ–∫–∞
                    try:
                        from telegram_bot import send_telegram_message
                        from models import User
                        client = User.query.get(deal.client_id)
                        
                        if client:
                            message = f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω –∫–µ—à–±–µ–∫ {_format_money_ru(deal.cashback_amount)}‚ÇΩ –ø–æ —Å–¥–µ–ª–∫–µ {deal.deal_number}.\n\n–°—Ä–µ–¥—Å—Ç–≤–∞ –¥–æ—Å—Ç—É–ø–Ω—ã –¥–ª—è –≤—ã–≤–æ–¥–∞ –≤ –ª–∏—á–Ω–æ–º –∫–∞–±–∏–Ω–µ—Ç–µ."
                            
                            # Telegram
                            if client.telegram_chat_id:
                                send_telegram_message(client.telegram_chat_id, message)
                            
                            # Email
                            if client.email:
                                email_subject = f"–ù–∞—á–∏—Å–ª–µ–Ω –∫–µ—à–±–µ–∫ {_format_money_ru(deal.cashback_amount)}‚ÇΩ"
                                email_body = f"""
–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ, {client.full_name or client.email.split('@')[0]}!

–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω –∫–µ—à–±–µ–∫ {_format_money_ru(deal.cashback_amount)}‚ÇΩ –ø–æ —Å–¥–µ–ª–∫–µ {deal.deal_number}.

–î–µ—Ç–∞–ª–∏ —Å–¥–µ–ª–∫–∏:
- –û–±—ä–µ–∫—Ç: {deal.residential_complex_name or 'N/A'}
- –°—Ç–æ–∏–º–æ—Å—Ç—å: {_format_money_ru(deal.property_price)}‚ÇΩ
- –ö–µ—à–±–µ–∫: {_format_money_ru(deal.cashback_amount)}‚ÇΩ

–°—Ä–µ–¥—Å—Ç–≤–∞ –¥–æ—Å—Ç—É–ø–Ω—ã –¥–ª—è –≤—ã–≤–æ–¥–∞ –≤ –ª–∏—á–Ω–æ–º –∫–∞–±–∏–Ω–µ—Ç–µ.

–° —É–≤–∞–∂–µ–Ω–∏–µ–º,
–ö–æ–º–∞–Ω–¥–∞ InBack
"""
                                send_email_notification(client.email, email_subject, email_body)
                                
                            app.logger.info(f"‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –∫–ª–∏–µ–Ω—Ç—É {client.id} –æ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –∫–µ—à–±–µ–∫–∞")
                    except Exception as e:
                        app.logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∫–µ—à–±–µ–∫–µ: {str(e)}")
                    
            except Exception as e:
                app.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –Ω–∞—á–∏—Å–ª–µ–Ω–∏—è –∫–µ—à–±–µ–∫–∞ –¥–ª—è —Å–¥–µ–ª–∫–∏ {deal.id}: {str(e)}")
                # –ù–ï –æ—Ç–∫–∞—Ç—ã–≤–∞–µ–º –≤—Å—é —Å–¥–µ–ª–∫—É –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—á–∏—Å–ª–∏—Ç—å –±–∞–ª–∞–Ω—Å
                # –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç –Ω–∞—á–∏—Å–ª–∏—Ç—å –≤—Ä—É—á–Ω—É—é —á–µ—Ä–µ–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
        
        # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
        if 'status' in updated_fields and old_status != deal.status:
            from models import UserActivity
            status_display_map = {
                'new': '–ù–æ–≤–∞—è',
                'object_reserved': '–û–±—ä–µ–∫—Ç –∑–∞—Ä–µ–∑–µ—Ä–≤–∏—Ä–æ–≤–∞–Ω',
                'mortgage': '–ò–ø–æ—Ç–µ–∫–∞',
                'successful': '–£—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞',
                'rejected': '–û—Ç–∫–ª–æ–Ω–µ–Ω–∞'
            }
            old_status_display = status_display_map.get(old_status, old_status)
            new_status_display = status_display_map.get(deal.status, deal.status)
            
            UserActivity.log_activity(
                user_id=deal.client_id,
                activity_type='deal_status_update',
                description=f'–°—Ç–∞—Ç—É—Å —Å–¥–µ–ª–∫–∏ {deal.deal_number} –∏–∑–º–µ–Ω–µ–Ω —Å "{old_status_display}" –Ω–∞ "{new_status_display}"'
            )
        
        return jsonify({
            'success': True,
            'message': '–°–¥–µ–ª–∫–∞ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞',
            'updated_fields': updated_fields,
            'deal': {
                'id': deal.id,
                'deal_number': deal.deal_number,
                'status': deal.status,
                'status_display': deal.status_display,
                'status_color': deal.status_color,
                'property_price': float(deal.property_price),
                'cashback_amount': float(deal.cashback_amount),
                'cashback_percentage': deal.get_cashback_percentage(),
                'property_description': deal.property_description,
                'property_floor': deal.property_floor,
                'property_area': deal.property_area,
                'property_rooms': deal.property_rooms,
                'notes': deal.notes,
                'client_notes': deal.client_notes,
                'client_name': deal.client.full_name,
                'client_profile_image': deal.client.profile_image or '',
                'complex_name': deal.residential_complex_name or (deal.residential_complex.name if deal.residential_complex else ''),
                'contract_date': deal.contract_date.isoformat() if deal.contract_date else None,
                'completion_date': deal.completion_date.isoformat() if deal.completion_date else None,
                'updated_at': deal.updated_at.isoformat()
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error updating deal {deal_id}: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å–¥–µ–ª–∫–∏'}), 500


@app.route('/api/deals/<int:deal_id>', methods=['DELETE'])
@manager_required
@require_json_csrf
def api_delete_deal(deal_id):
    """Delete deal (managers only)"""
    from models import Deal
    
    try:
        deal = Deal.query.get(deal_id)
        if not deal:
            return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
        
        current_manager = current_user
        
        # Check if manager owns this deal
        if deal.manager_id != current_manager.id:
            return jsonify({'success': False, 'error': '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è —ç—Ç–æ–π —Å–¥–µ–ª–∫–∏'}), 403
        
        # Check if deal can be deleted (only new or rejected deals)
        if deal.status not in ['new', 'rejected']:
            return jsonify({'success': False, 'error': '–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å —Å–¥–µ–ª–∫—É —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º "' + deal.status_display + '"'}), 400
        
        deal_number = deal.deal_number
        db.session.delete(deal)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'–°–¥–µ–ª–∫–∞ {deal_number} —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting deal {deal_id}: {e}")
        return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–¥–µ–ª–∫–∏'}), 500

@app.route('/manager/deals-archive')
@manager_required
def manager_deals_archive():
    from models import Deal, Manager, OrgRole, Department
    current_manager = current_user
    role = current_manager.org_role
    is_rop = getattr(current_manager, 'is_rop', False)
    can_view_all = (role.can_view_all_archive if role else False) or is_rop
    can_view_dept = role.can_view_department_archive if role else False
    
    manager_id_filter = request.args.get('manager_id', type=int)
    status_filter = request.args.get('status', '')
    period = request.args.get('period', '')
    
    query = Deal.query.filter(Deal.status.in_(['completed', 'successful', 'rejected']))
    if can_view_all:
        if manager_id_filter:
            query = query.filter(Deal.manager_id == manager_id_filter)
    elif can_view_dept and current_manager.department_id:
        dept = Department.query.get(current_manager.department_id)
        dept_manager_ids = dept.get_all_manager_ids() if dept else [current_manager.id]
        if manager_id_filter and manager_id_filter in dept_manager_ids:
            query = query.filter(Deal.manager_id == manager_id_filter)
        else:
            query = query.filter(Deal.manager_id.in_(dept_manager_ids))
    else:
        query = query.filter(Deal.manager_id == current_manager.id)
    
    if status_filter:
        if status_filter == 'completed':
            query = query.filter(Deal.status.in_(['completed', 'successful']))
        else:
            query = query.filter(Deal.status == status_filter)
    if period:
        from datetime import timedelta
        now = datetime.utcnow()
        periods_map = {'week': 7, 'month': 30, 'quarter': 90, 'year': 365}
        if period in periods_map:
            query = query.filter(Deal.updated_at >= now - timedelta(days=periods_map[period]))
    
    deals = query.order_by(Deal.updated_at.desc()).all()
    
    all_closed_list = deals
    
    successful = [d for d in all_closed_list if d.status in ('completed', 'successful')]
    rejected_list = [d for d in all_closed_list if d.status == 'rejected']
    total_revenue = sum(float(d.property_price or 0) for d in successful)
    total_cashback = sum(float(d.cashback_amount or 0) for d in successful)
    avg_deal = total_revenue / len(successful) if successful else 0
    conversion = round(len(successful) / len(all_closed_list) * 100, 1) if all_closed_list else 0
    
    stats = {
        'total': len(all_closed_list),
        'successful': len(successful),
        'rejected': len(rejected_list),
        'conversion': conversion,
        'total_revenue': total_revenue,
        'total_cashback': total_cashback,
        'avg_deal': avg_deal,
    }
    
    rejection_reasons = {}
    for d in rejected_list:
        reason = d.rejection_reason or '–ù–µ —É–∫–∞–∑–∞–Ω–∞'
        rejection_reasons[reason] = rejection_reasons.get(reason, 0) + 1
    rejection_stats = sorted([{'reason': r, 'count': c} for r, c in rejection_reasons.items()], key=lambda x: -x['count'])
    
    managers = []
    if can_view_all:
        managers = Manager.query.filter_by(is_active=True).order_by(Manager.first_name).all()
    elif can_view_dept and current_manager.department_id:
        dept = Department.query.get(current_manager.department_id)
        dept_ids = dept.get_all_manager_ids() if dept else []
        managers = Manager.query.filter(Manager.id.in_(dept_ids)).order_by(Manager.first_name).all()
    
    manager_stats_data = []
    if can_view_all or can_view_dept:
        if can_view_all:
            stats_managers = Manager.query.filter_by(is_active=True).all()
        else:
            dept = Department.query.get(current_manager.department_id) if current_manager.department_id else None
            dept_ids = dept.get_all_manager_ids() if dept else [current_manager.id]
            stats_managers = Manager.query.filter(Manager.id.in_(dept_ids), Manager.is_active == True).all()
        for m in stats_managers:
            m_deals = [d for d in Deal.query.filter(Deal.manager_id == m.id, Deal.status.in_(['completed', 'successful', 'rejected'])).all()]
            if not m_deals:
                continue
            m_success = [d for d in m_deals if d.status in ('completed', 'successful')]
            m_rejected_l = [d for d in m_deals if d.status == 'rejected']
            m_revenue = sum(float(d.property_price or 0) for d in m_success)
            m_conv = round(len(m_success) / len(m_deals) * 100, 1) if m_deals else 0
            manager_stats_data.append({
                'name': m.full_name,
                'total': len(m_deals),
                'successful': len(m_success),
                'rejected': len(m_rejected_l),
                'conversion': m_conv,
                'revenue': m_revenue,
            })
        manager_stats_data.sort(key=lambda x: -x['successful'])
    
    sidebar_links, user_profile = get_manager_sidebar_data(current_manager, active_page='deals_archive')
    return render_template('manager/deals_archive.html',
                         manager=current_manager,
                         is_rop=can_view_all or can_view_dept,
                         deals=deals, stats=stats,
                         rejection_stats=rejection_stats,
                         managers=managers,
                         manager_stats=manager_stats_data,
                         sidebar_links=sidebar_links,
                         user_profile=user_profile)


@app.route('/manager/kanban')
@manager_required
def manager_deals_kanban():
    from models import Deal, DealStageConfig, User, ResidentialComplex
    current_manager = current_user
    DealStageConfig.seed_defaults()
    stages_config = Deal.get_stages_config()
    stages_db = DealStageConfig.get_ordered_stages()
    if not stages_db:
        stages_db = []
        for i, key in enumerate(Deal.STAGE_ORDER):
            class FakeStage:
                pass
            s = FakeStage()
            s.key = key
            s.label = Deal.STAGE_LABELS.get(key, key)
            s.color = Deal.STAGE_COLORS.get(key, '#6b7280')
            s.sort_order = i
            s.is_terminal = key in ['completed', 'rejected']
            stages_db.append(s)
    from models import OrgRole, Department, Manager as ManagerModel
    role = current_manager.org_role
    can_view_all = role.can_view_all_deals if role else False
    can_view_dept = role.can_view_department_deals if role else getattr(current_manager, 'is_rop', False)
    can_change_responsible = role.can_change_deal_responsible if role else False
    
    manager_filter_id = request.args.get('manager_id', type=int)
    
    if can_view_all:
        if manager_filter_id:
            deals = Deal.query.filter_by(manager_id=manager_filter_id).all()
        else:
            deals = Deal.query.all()
    elif can_view_dept and current_manager.department_id:
        dept = Department.query.get(current_manager.department_id)
        dept_manager_ids = dept.get_all_manager_ids() if dept else [current_manager.id]
        if manager_filter_id and manager_filter_id in dept_manager_ids:
            deals = Deal.query.filter_by(manager_id=manager_filter_id).all()
        else:
            deals = Deal.query.filter(Deal.manager_id.in_(dept_manager_ids)).all()
    elif getattr(current_manager, 'is_rop', False):
        deals = Deal.query.all()
    else:
        deals = Deal.query.filter_by(manager_id=current_manager.id).all()
    
    deals_by_stage = {}
    for deal in deals:
        if deal.status not in deals_by_stage:
            deals_by_stage[deal.status] = []
        deals_by_stage[deal.status].append(deal)
    for key in deals_by_stage:
        deals_by_stage[key].sort(key=lambda d: d.updated_at or d.created_at, reverse=True)
    total_deals = len(deals)
    assigned_clients = User.query.filter(
        db.or_(User.assigned_manager_id == current_manager.id, User.assigned_manager_id == None)
    ).filter_by(role='buyer').order_by(User.full_name).all()
    residential_complexes = ResidentialComplex.query.order_by(ResidentialComplex.name).all()
    
    viewable_managers = []
    if can_view_all:
        viewable_managers = ManagerModel.query.filter_by(is_active=True).order_by(ManagerModel.first_name).all()
    elif can_view_dept and current_manager.department_id:
        dept = Department.query.get(current_manager.department_id)
        dept_manager_ids = dept.get_all_manager_ids() if dept else []
        viewable_managers = ManagerModel.query.filter(ManagerModel.id.in_(dept_manager_ids)).order_by(ManagerModel.first_name).all()
    elif getattr(current_manager, 'is_rop', False):
        viewable_managers = ManagerModel.query.filter_by(is_active=True).order_by(ManagerModel.first_name).all()
    
    sidebar_links, user_profile = get_manager_sidebar_data(current_manager, active_page='deals')
    
    try:
        from zoneinfo import ZoneInfo
    except ImportError:
        from backports.zoneinfo import ZoneInfo
    now_moscow = datetime.now(ZoneInfo('Europe/Moscow')).replace(tzinfo=None)
    today_moscow = now_moscow.replace(hour=0, minute=0, second=0, microsecond=0)
    weekday = today_moscow.weekday()
    week_end_moscow = today_moscow + timedelta(days=(6 - weekday))
    week_end_moscow = week_end_moscow.replace(hour=23, minute=59, second=59)
    next_week_end_moscow = week_end_moscow + timedelta(days=7)
    
    import json as json_mod
    from models import DealTask
    all_tasks = DealTask.query.join(Deal).filter(Deal.manager_id == current_manager.id).order_by(DealTask.due_date.asc().nullslast()).all()
    calendar_stats = {
        'total': len(all_tasks),
        'active': sum(1 for t in all_tasks if not t.is_completed),
        'overdue': sum(1 for t in all_tasks if not t.is_completed and t.due_date and t.due_date < now_moscow),
        'completed': sum(1 for t in all_tasks if t.is_completed),
    }
    priority_labels = {'high': '–í—ã—Å–æ–∫–∏–π', 'normal': '–û–±—ã—á–Ω—ã–π', 'low': '–ù–∏–∑–∫–∏–π'}
    calendar_events = []
    for t in all_tasks:
        if not t.due_date:
            continue
        if t.is_completed:
            color = '#10b981'
        elif t.due_date < now_moscow:
            color = '#ef4444'
        elif t.priority == 'high':
            color = '#6366f1'
        else:
            color = '#f59e0b'
        calendar_events.append({
            'id': 'task_' + str(t.id),
            'title': t.title,
            'start': t.due_date.isoformat(),
            'color': color,
            'extendedProps': {
                'type': 'task',
                'deal_id': t.deal_id,
                'deal_number': t.deal.deal_number if t.deal else '',
                'client_name': t.deal.client.full_name if t.deal and t.deal.client else '',
                'description': t.description or '',
                'priority_label': priority_labels.get(t.priority, '–û–±—ã—á–Ω—ã–π'),
                'is_overdue': not t.is_completed and t.due_date < now_moscow,
            }
        })
    for d in deals:
        stage_cfg = {s.key: s for s in stages_db}.get(d.status)
        stage_label = stage_cfg.label if stage_cfg else d.status
        stage_color = stage_cfg.color if stage_cfg else '#0088CC'
        calendar_events.append({
            'id': 'deal_' + str(d.id),
            'title': f'{d.deal_number} ‚Äî {stage_label}',
            'start': d.updated_at.isoformat() if d.updated_at else d.created_at.isoformat(),
            'color': stage_color,
            'display': 'block',
            'extendedProps': {
                'type': 'deal',
                'deal_id': d.id,
                'deal_number': d.deal_number,
                'client_name': d.client.full_name if d.client else '',
                'description': f'–ñ–ö: {d.residential_complex.name if d.residential_complex else (d.residential_complex_name or "–ù–µ —É–∫–∞–∑–∞–Ω")}',
                'priority_label': stage_label,
            }
        })
        if d.contract_date:
            calendar_events.append({
                'id': 'contract_' + str(d.id),
                'title': f'üìã –î–æ–≥–æ–≤–æ—Ä {d.deal_number}',
                'start': d.contract_date.isoformat(),
                'color': '#059669',
                'display': 'block',
                'extendedProps': {
                    'type': 'deal',
                    'deal_id': d.id,
                    'deal_number': d.deal_number,
                    'client_name': d.client.full_name if d.client else '',
                    'description': '–î–∞—Ç–∞ –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è –¥–æ–≥–æ–≤–æ—Ä–∞',
                    'priority_label': '–î–æ–≥–æ–≤–æ—Ä',
                }
            })
    calendar_events_json = json_mod.dumps(calendar_events, ensure_ascii=False)
    
    task_columns_data = {'overdue': [], 'today': [], 'this_week': [], 'next_week': [], 'no_tasks': []}
    today_str = today_moscow.strftime('%Y-%m-%d')
    week_end_str = week_end_moscow.strftime('%Y-%m-%d')
    next_week_end_str = next_week_end_moscow.strftime('%Y-%m-%d')
    for deal in deals:
        active_tasks = [t for t in deal.tasks.filter_by(is_completed=False).all() if t.due_date]
        no_date_tasks = [t for t in deal.tasks.filter_by(is_completed=False).all() if not t.due_date]
        if not active_tasks and not no_date_tasks:
            task_columns_data['no_tasks'].append({'deal': deal, 'task': None})
            continue
        if not active_tasks and no_date_tasks:
            task_columns_data['no_tasks'].append({'deal': deal, 'task': no_date_tasks[0]})
            continue
        deal_placed = set()
        for t in sorted(active_tasks, key=lambda x: x.due_date):
            td = t.due_date.strftime('%Y-%m-%d')
            if t.due_date < now_moscow and 'overdue' not in deal_placed:
                task_columns_data['overdue'].append({'deal': deal, 'task': t})
                deal_placed.add('overdue')
            elif td == today_str and 'today' not in deal_placed:
                task_columns_data['today'].append({'deal': deal, 'task': t})
                deal_placed.add('today')
            elif td > today_str and td <= week_end_str and 'this_week' not in deal_placed:
                task_columns_data['this_week'].append({'deal': deal, 'task': t})
                deal_placed.add('this_week')
            elif td > week_end_str and td <= next_week_end_str and 'next_week' not in deal_placed:
                task_columns_data['next_week'].append({'deal': deal, 'task': t})
                deal_placed.add('next_week')
        if not deal_placed:
            task_columns_data['no_tasks'].append({'deal': deal, 'task': active_tasks[0] if active_tasks else None})
    
    return render_template('manager/deals_kanban.html',
                         manager=current_manager, stages=stages_db,
                         deals_by_stage=deals_by_stage, total_deals=total_deals,
                         assigned_clients=assigned_clients,
                         residential_complexes=residential_complexes,
                         stages_config=stages_config,
                         sidebar_links=sidebar_links, user_profile=user_profile,
                         current_manager=current_manager,
                         can_change_responsible=can_change_responsible,
                         viewable_managers=viewable_managers,
                         now_moscow=now_moscow,
                         week_end_moscow=week_end_moscow,
                         next_week_end_moscow=next_week_end_moscow,
                         calendar_events_json=calendar_events_json,
                         calendar_stats=calendar_stats,
                         task_columns_data=task_columns_data)

@app.route('/manager/calendar')
@manager_required
def manager_tasks_calendar():
    import json as json_mod
    from models import Deal, DealTask, DealStageConfig
    current_manager = current_user
    tasks = DealTask.query.join(Deal).filter(Deal.manager_id == current_manager.id).order_by(DealTask.due_date.asc().nullslast()).all()
    from zoneinfo import ZoneInfo
    now = datetime.now(ZoneInfo('Europe/Moscow')).replace(tzinfo=None)
    stats = {
        'total': len(tasks),
        'active': sum(1 for t in tasks if not t.is_completed),
        'overdue': sum(1 for t in tasks if not t.is_completed and t.due_date and t.due_date < now),
        'completed': sum(1 for t in tasks if t.is_completed),
    }
    priority_labels = {'high': '–í—ã—Å–æ–∫–∏–π', 'normal': '–û–±—ã—á–Ω—ã–π', 'low': '–ù–∏–∑–∫–∏–π'}
    events = []
    for t in tasks:
        if not t.due_date:
            continue
        if t.is_completed:
            color = '#10b981'
        elif t.due_date < now:
            color = '#ef4444'
        elif t.priority == 'high':
            color = '#6366f1'
        else:
            color = '#f59e0b'
        events.append({
            'id': 'task_' + str(t.id),
            'title': t.title,
            'start': t.due_date.isoformat(),
            'color': color,
            'extendedProps': {
                'type': 'task',
                'deal_id': t.deal_id,
                'deal_number': t.deal.deal_number if t.deal else '',
                'client_name': t.deal.client.full_name if t.deal and t.deal.client else '',
                'description': t.description or '',
                'priority_label': priority_labels.get(t.priority, '–û–±—ã—á–Ω—ã–π'),
                'is_overdue': not t.is_completed and t.due_date < now,
            }
        })
    stage_configs = {s.key: s for s in DealStageConfig.query.all()}
    deals = Deal.query.filter_by(manager_id=current_manager.id).all()
    for d in deals:
        stage_cfg = stage_configs.get(d.status)
        stage_label = stage_cfg.label if stage_cfg else d.status_display if hasattr(d, 'status_display') else d.status
        stage_color = stage_cfg.color if stage_cfg else '#0088CC'
        events.append({
            'id': 'deal_' + str(d.id),
            'title': f'{d.deal_number} ‚Äî {stage_label}',
            'start': d.updated_at.isoformat() if d.updated_at else d.created_at.isoformat(),
            'color': stage_color,
            'display': 'block',
            'extendedProps': {
                'type': 'deal',
                'deal_id': d.id,
                'deal_number': d.deal_number,
                'client_name': d.client.full_name if d.client else '',
                'description': f'–ñ–ö: {d.residential_complex.name if d.residential_complex else (d.residential_complex_name or "–ù–µ —É–∫–∞–∑–∞–Ω")}',
                'priority_label': stage_label,
            }
        })
        if d.contract_date:
            events.append({
                'id': 'contract_' + str(d.id),
                'title': f'üìã –î–æ–≥–æ–≤–æ—Ä {d.deal_number}',
                'start': d.contract_date.isoformat(),
                'color': '#059669',
                'display': 'block',
                'extendedProps': {
                    'type': 'deal',
                    'deal_id': d.id,
                    'deal_number': d.deal_number,
                    'client_name': d.client.full_name if d.client else '',
                    'description': '–î–∞—Ç–∞ –ø–æ–¥–ø–∏—Å–∞–Ω–∏—è –¥–æ–≥–æ–≤–æ—Ä–∞',
                    'priority_label': '–î–æ–≥–æ–≤–æ—Ä',
                }
            })
    tasks_json = json_mod.dumps(events, ensure_ascii=False)
    sidebar_links, user_profile = get_manager_sidebar_data(current_manager, active_page='deals')
    return render_template('manager/tasks_calendar.html',
                         manager=current_manager, stats=stats, tasks_json=tasks_json,
                         sidebar_links=sidebar_links, user_profile=user_profile,
                         current_manager=current_manager)

@app.route('/api/manager/checkin', methods=['POST'])
@manager_required
def api_manager_checkin():
    from models import ManagerCheckin
    from zoneinfo import ZoneInfo
    moscow_tz = ZoneInfo('Europe/Moscow')
    now_moscow = datetime.now(moscow_tz)
    current_manager = current_user
    today = now_moscow.date()
    active_checkin = ManagerCheckin.query.filter_by(
        manager_id=current_manager.id, date=today, is_active=True
    ).first()
    if active_checkin:
        active_checkin.check_out_time = now_moscow.replace(tzinfo=None)
        active_checkin.is_active = False
        db.session.commit()
        return jsonify({'success': True, 'status': 'checked_out', 'duration': active_checkin.duration_display})
    else:
        checkin = ManagerCheckin(
            manager_id=current_manager.id,
            check_in_time=now_moscow.replace(tzinfo=None),
            date=today,
            is_active=True
        )
        db.session.add(checkin)
        db.session.commit()
        return jsonify({'success': True, 'status': 'checked_in', 'time': checkin.check_in_time.strftime('%H:%M')})

@app.route('/api/manager/checkin/status')
@manager_required
def api_manager_checkin_status():
    from models import ManagerCheckin
    from zoneinfo import ZoneInfo
    moscow_tz = ZoneInfo('Europe/Moscow')
    now_moscow = datetime.now(moscow_tz)
    current_manager = current_user
    today = now_moscow.date()
    active_checkin = ManagerCheckin.query.filter_by(
        manager_id=current_manager.id, date=today, is_active=True
    ).first()
    if active_checkin:
        return jsonify({'success': True, 'is_checked_in': True, 'since': active_checkin.check_in_time.strftime('%H:%M'), 'duration': active_checkin.duration_display, 'checked_in_at': active_checkin.check_in_time.isoformat()})
    return jsonify({'success': True, 'is_checked_in': False})

@app.route('/admin/attendance')
@admin_required
def admin_attendance():
    from models import ManagerCheckin, Manager
    date_str = request.args.get('date', '')
    if date_str:
        try:
            selected_date = datetime.strptime(date_str, '%Y-%m-%d').date()
        except ValueError:
            selected_date = datetime.utcnow().date()
    else:
        from zoneinfo import ZoneInfo
        selected_date = datetime.now(ZoneInfo('Europe/Moscow')).date()
    checkins = ManagerCheckin.query.filter_by(date=selected_date).order_by(ManagerCheckin.check_in_time).all()
    managers = Manager.query.filter_by(is_active=True).all()
    checkin_map = {}
    for c in checkins:
        if c.manager_id not in checkin_map:
            checkin_map[c.manager_id] = []
        checkin_map[c.manager_id].append(c)
    attendance_data = []
    for m in managers:
        manager_checkins = checkin_map.get(m.id, [])
        total_minutes = sum(c.duration_minutes for c in manager_checkins)
        hours = total_minutes // 60
        mins = total_minutes % 60
        attendance_data.append({
            'manager': m,
            'checkins': manager_checkins,
            'total_time': f'{hours}—á {mins}–º' if hours > 0 else f'{mins}–º',
            'is_currently_active': any(c.is_active for c in manager_checkins),
            'first_checkin': manager_checkins[0].check_in_time.strftime('%d.%m.%Y %H:%M') if manager_checkins else None,
            'last_activity': manager_checkins[-1].check_out_time.strftime('%d.%m.%Y %H:%M') if manager_checkins and manager_checkins[-1].check_out_time else (manager_checkins[-1].check_in_time.strftime('%d.%m.%Y %H:%M') if manager_checkins else None),
        })
    from zoneinfo import ZoneInfo
    return render_template('admin/attendance.html',
                         attendance_data=attendance_data,
                         selected_date=selected_date,
                         today=datetime.now(ZoneInfo('Europe/Moscow')).date(),
                         admin=current_user)





@app.route('/manager/deals/<int:deal_id>')
@manager_required
def manager_deal_card(deal_id):
    try:
        from models import Deal, DealComment, DealTask, DealHistory, User, ResidentialComplex, OrgRole, Department, Manager as ManagerModel
        current_manager = current_user
        deal = Deal.query.get(deal_id)
        if not deal:
            return redirect(url_for('manager_deals'))
        role = current_manager.org_role
        can_view_all = (role.can_view_all_deals if role else False) or getattr(current_manager, 'is_rop', False)
        can_view_dept = role.can_view_department_deals if role else False
        can_change_responsible = (role.can_change_deal_responsible if role else False) or getattr(current_manager, 'is_rop', False)
        is_own = deal.manager_id == current_manager.id
        can_view = is_own or can_view_all
        if not can_view and can_view_dept and current_manager.department_id:
            dept = Department.query.get(current_manager.department_id)
            can_view = deal.manager_id in (dept.get_all_manager_ids() if dept else [])
        if not can_view:
            return redirect(url_for('manager_deals'))
        comments = DealComment.query.filter_by(deal_id=deal.id).order_by(DealComment.created_at.desc()).all()
        tasks = DealTask.query.filter_by(deal_id=deal.id).order_by(DealTask.is_completed, DealTask.due_date.asc().nullslast(), DealTask.created_at.desc()).all()
        history = DealHistory.query.filter_by(deal_id=deal.id).order_by(DealHistory.created_at.desc()).all()
        activity = []
        for c in comments:
            activity.append({'type': 'comment', 'id': c.id, 'text': c.text, 'author': c.author.full_name or c.author.email if c.author else '–ú–µ–Ω–µ–¥–∂–µ—Ä', 'created_at': c.created_at, 'is_pinned': c.is_pinned})
        for h in history:
            activity.append({'type': 'history', 'id': h.id, 'action': h.action, 'description': h.description, 'author': h.author.full_name or h.author.email if h.author else '–°–∏—Å—Ç–µ–º–∞', 'created_at': h.created_at, 'old_value': h.old_value, 'new_value': h.new_value})
        activity.sort(key=lambda x: x['created_at'], reverse=True)
        residential_complexes = ResidentialComplex.query.order_by(ResidentialComplex.name).all()
        assigned_clients = User.query.filter(db.or_(User.assigned_manager_id == current_manager.id, User.assigned_manager_id == None)).filter_by(role='buyer').order_by(User.full_name).all()
        stages_config = Deal.get_stages_config()
        sidebar_links, user_profile = get_manager_sidebar_data(current_manager, active_page='deals')
        available_managers = []
        if can_change_responsible:
            if can_view_all:
                available_managers = ManagerModel.query.filter_by(is_active=True).order_by(ManagerModel.first_name).all()
            elif current_manager.department_id:
                dept = Department.query.get(current_manager.department_id)
                dept_ids = dept.get_all_manager_ids() if dept else [current_manager.id]
                available_managers = ManagerModel.query.filter(ManagerModel.id.in_(dept_ids), ManagerModel.is_active == True).order_by(ManagerModel.first_name).all()
            else:
                available_managers = ManagerModel.query.filter_by(is_active=True).order_by(ManagerModel.first_name).all()
        
        return render_template('manager/deal_card.html',
                             deal=deal, manager=current_manager, comments=comments,
                             tasks=tasks, history=history, activity=activity,
                             residential_complexes=residential_complexes,
                             assigned_clients=assigned_clients,
                             stages=stages_config['order'], stage_labels=stages_config['labels'],
                             stage_colors=stages_config['colors'],
                             hasattr=hasattr,
                             sidebar_links=sidebar_links, user_profile=user_profile,
                             current_manager=current_manager,
                             can_change_responsible=can_change_responsible,
                             available_managers=available_managers)
    except Exception as e:
        logging.error(f"Error in manager_deal_card: {str(e)}")
        logging.error(traceback.format_exc())
        return str(e), 500


@app.route('/api/deals/<int:deal_id>/comments', methods=['POST'])
@csrf.exempt
@manager_required
def api_deal_add_comment(deal_id):
    from models import Deal, DealComment, DealHistory
    current_manager = current_user
    deal = Deal.query.get(deal_id)
    if not deal or deal.manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    data = request.get_json()
    text = data.get('text', '').strip() if data else ''
    if not text:
        return jsonify({'success': False, 'error': '–¢–µ–∫—Å—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º'}), 400
    comment = DealComment(deal_id=deal.id, author_id=current_manager.id, text=text)
    db.session.add(comment)
    db.session.add(DealHistory(deal_id=deal.id, author_id=current_manager.id, action='comment_added', description=f'–î–æ–±–∞–≤–ª–µ–Ω –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π'))
    db.session.commit()
    return jsonify({'success': True, 'comment': {'id': comment.id, 'text': comment.text, 'author': current_manager.full_name or current_manager.email, 'created_at': comment.created_at.strftime('%d.%m.%Y %H:%M')}})


@app.route('/api/deals/<int:deal_id>/comments/<int:comment_id>', methods=['DELETE'])
@csrf.exempt
@manager_required
def api_deal_delete_comment(deal_id, comment_id):
    from models import Deal, DealComment
    current_manager = current_user
    deal = Deal.query.get(deal_id)
    if not deal or deal.manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    comment = DealComment.query.get(comment_id)
    if not comment or comment.deal_id != deal.id:
        return jsonify({'success': False, 'error': '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    db.session.delete(comment)
    db.session.commit()
    return jsonify({'success': True})


@app.route('/api/deals/<int:deal_id>/comments/<int:comment_id>/pin', methods=['POST'])
@csrf.exempt
@manager_required
def api_deal_pin_comment(deal_id, comment_id):
    from models import Deal, DealComment
    current_manager = current_user
    deal = Deal.query.get(deal_id)
    if not deal or deal.manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    comment = DealComment.query.get(comment_id)
    if not comment or comment.deal_id != deal.id:
        return jsonify({'success': False, 'error': '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    comment.is_pinned = not comment.is_pinned
    db.session.commit()
    return jsonify({'success': True, 'is_pinned': comment.is_pinned})


@app.route("/api/deals/<int:deal_id>/tasks", methods=["GET", "POST"])
@csrf.exempt
@manager_required
def api_deal_add_task(deal_id):
    from models import Deal, DealTask, DealHistory
    current_manager = current_user
    deal = Deal.query.get(deal_id)
    if not deal or deal.manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    if request.method == 'GET':
        tasks = DealTask.query.filter_by(deal_id=deal.id).order_by(DealTask.created_at.desc()).all()
        return jsonify({'success': True, 'tasks': [{'id': t.id, 'title': t.title, 'due_date': t.due_date.strftime('%d.%m.%Y %H:%M') if t.due_date else None, 'priority': t.priority, 'is_completed': t.is_completed, 'is_overdue': t.is_overdue} for t in tasks]})
    data = request.get_json()
    title = data.get('title', '').strip() if data else ''
    if not title:
        return jsonify({'success': False, 'error': '–ù–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ'}), 400
    due_date = None
    if data.get('due_date'):
        try:
            from datetime import datetime as dt
            due_date = dt.strptime(data['due_date'], '%Y-%m-%dT%H:%M') if 'T' in data['due_date'] else dt.strptime(data['due_date'], '%Y-%m-%d')
        except ValueError:
            pass
    task = DealTask(deal_id=deal.id, author_id=current_manager.id, title=title,
                   description=data.get('description', ''), due_date=due_date,
                   priority=data.get('priority', 'normal'))
    db.session.add(task)
    db.session.add(DealHistory(deal_id=deal.id, author_id=current_manager.id, action='task_created', description=f'–°–æ–∑–¥–∞–Ω–∞ –∑–∞–¥–∞—á–∞: {title}'))
    db.session.commit()
    return jsonify({'success': True, 'task': {'id': task.id, 'title': task.title, 'due_date': task.due_date.strftime('%d.%m.%Y %H:%M') if task.due_date else None, 'priority': task.priority, 'is_completed': task.is_completed}})


@app.route('/api/deals/<int:deal_id>/tasks/<int:task_id>/toggle', methods=['POST'])
@csrf.exempt
@manager_required
def api_deal_toggle_task(deal_id, task_id):
    from models import Deal, DealTask, DealHistory
    from datetime import datetime as dt
    current_manager = current_user
    deal = Deal.query.get(deal_id)
    if not deal or deal.manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    task = DealTask.query.get(task_id)
    if not task or task.deal_id != deal.id:
        return jsonify({'success': False, 'error': '–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    task.is_completed = not task.is_completed
    task.completed_at = dt.utcnow() if task.is_completed else None
    action = 'task_completed' if task.is_completed else 'task_created'
    desc = f'–ó–∞–¥–∞—á–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞: {task.title}' if task.is_completed else f'–ó–∞–¥–∞—á–∞ –æ—Ç–∫—Ä—ã—Ç–∞ –∑–∞–Ω–æ–≤–æ: {task.title}'
    db.session.add(DealHistory(deal_id=deal.id, author_id=current_manager.id, action=action, description=desc))
    db.session.commit()
    return jsonify({'success': True, 'is_completed': task.is_completed})


@app.route('/api/deals/<int:deal_id>/tasks/<int:task_id>', methods=['DELETE'])
@csrf.exempt
@manager_required
def api_deal_delete_task(deal_id, task_id):
    from models import Deal, DealTask
    current_manager = current_user
    deal = Deal.query.get(deal_id)
    if not deal or deal.manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    task = DealTask.query.get(task_id)
    if not task or task.deal_id != deal.id:
        return jsonify({'success': False, 'error': '–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    db.session.delete(task)
    db.session.commit()
    return jsonify({'success': True})



@app.route('/api/deals/<int:deal_id>/tasks/<int:task_id>/reschedule', methods=['POST'])
@csrf.exempt
@manager_required
def api_deal_reschedule_task(deal_id, task_id):
    from models import Deal, DealTask, DealHistory
    from datetime import datetime as dt
    current_manager = current_user
    deal = Deal.query.get(deal_id)
    if not deal or deal.manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    task = DealTask.query.get(task_id)
    if not task or task.deal_id != deal.id:
        return jsonify({'success': False, 'error': '–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    data = request.get_json()
    new_date_str = data.get('due_date') if data else None
    if not new_date_str:
        return jsonify({'success': False, 'error': '–ù–µ —É–∫–∞–∑–∞–Ω–∞ –¥–∞—Ç–∞'}), 400
    try:
        new_date = dt.strptime(new_date_str, '%Y-%m-%dT%H:%M')
    except ValueError:
        try:
            new_date = dt.strptime(new_date_str, '%Y-%m-%d')
            if task.due_date:
                new_date = new_date.replace(hour=task.due_date.hour, minute=task.due_date.minute)
        except ValueError:
            return jsonify({'success': False, 'error': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã'}), 400
    old_date = task.due_date.strftime('%d.%m.%Y %H:%M') if task.due_date else '–Ω–µ —É–∫–∞–∑–∞–Ω–∞'
    task.due_date = new_date
    db.session.add(DealHistory(deal_id=deal.id, author_id=current_manager.id, action='task_created', description=f'–ó–∞–¥–∞—á–∞ "{task.title}" –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–∞: {old_date} ‚Üí {new_date.strftime("%d.%m.%Y %H:%M")}'))
    db.session.commit()
    return jsonify({'success': True, 'task': {'id': task.id, 'title': task.title, 'due_date': task.due_date.strftime('%d.%m.%Y %H:%M') if task.due_date else None}})


@app.route('/api/deals/<int:deal_id>/reassign', methods=['POST'])
@csrf.exempt
@manager_required
def api_deal_reassign(deal_id):
    from models import Deal, DealHistory, Manager, OrgRole, Department
    current_manager = current_user
    role = current_manager.org_role
    can_change = (role.can_change_deal_responsible if role else False) or getattr(current_manager, 'is_rop', False)
    can_view_all = (role.can_view_all_deals if role else False)
    
    if not can_change:
        return jsonify({'success': False, 'error': '–ù–µ—Ç –ø—Ä–∞–≤ –Ω–∞ —Å–º–µ–Ω—É –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ'}), 403
    
    deal = Deal.query.get(deal_id)
    if not deal:
        return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    
    if deal.is_locked:
        return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∞'}), 400
    
    data = request.get_json()
    new_manager_id = data.get('manager_id') if data else None
    if not new_manager_id:
        return jsonify({'success': False, 'error': '–ù–µ —É–∫–∞–∑–∞–Ω –Ω–æ–≤—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä'}), 400
    
    new_manager = Manager.query.get(int(new_manager_id))
    if not new_manager or not new_manager.is_active:
        return jsonify({'success': False, 'error': '–ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    if not can_view_all and current_manager.department_id:
        dept = Department.query.get(current_manager.department_id)
        dept_ids = dept.get_all_manager_ids() if dept else [current_manager.id]
        if new_manager.id not in dept_ids:
            return jsonify({'success': False, 'error': '–ú–µ–Ω–µ–¥–∂–µ—Ä –Ω–µ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≤–∞—à–µ–º—É –æ—Ç–¥–µ–ª—É'}), 403
    
    old_manager = deal.manager
    old_name = old_manager.full_name if old_manager else '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω'
    new_name = new_manager.full_name
    
    deal.manager_id = new_manager.id
    deal.updated_at = datetime.utcnow()
    
    db.session.add(DealHistory(
        deal_id=deal.id, author_id=current_manager.id, action='field_change',
        field_name='manager_id', old_value=old_name, new_value=new_name,
        description=f'–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–∑–º–µ–Ω—ë–Ω: {old_name} ‚Üí {new_name}'
    ))
    
    db.session.commit()
    return jsonify({'success': True, 'message': f'–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–∑–º–µ–Ω—ë–Ω –Ω–∞ {new_name}'})


@app.route('/api/deals/<int:deal_id>/stage', methods=['POST'])
@csrf.exempt
@manager_required
def api_deal_change_stage(deal_id):
    from models import Deal, DealHistory, UserNotification
    current_manager = current_user
    deal = Deal.query.get(deal_id)
    if not deal or deal.manager_id != current_manager.id:
        return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}), 404
    data = request.get_json()
    if deal.is_locked:
        return jsonify({'success': False, 'error': '–°–¥–µ–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∞'}), 400
    new_stage = data.get('stage') if data else None
    stages_config = Deal.get_stages_config()
    if not new_stage or new_stage not in stages_config['order']:
        return jsonify({'success': False, 'error': '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —ç—Ç–∞–ø'}), 400
    old_stage = deal.status
    if old_stage == new_stage:
        return jsonify({'success': True, 'message': '–≠—Ç–∞–ø –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è'})
    old_label = stages_config['labels'].get(old_stage, old_stage)
    new_label = stages_config['labels'].get(new_stage, new_stage)
    deal.status = new_stage
    deal.updated_at = datetime.utcnow()
    if new_stage in ['completed', 'rejected']:
        deal.closed_at = datetime.utcnow()
        closing_comment = data.get('closing_comment', '').strip() if data else ''
        if closing_comment:
            deal.closing_comment = closing_comment
        if new_stage == 'rejected':
            rejection_reason = data.get('rejection_reason', '').strip() if data else ''
            if rejection_reason:
                deal.rejection_reason = rejection_reason
    db.session.add(DealHistory(deal_id=deal.id, author_id=current_manager.id, action='stage_change',
                               field_name='status', old_value=old_label, new_value=new_label,
                               description=f'–≠—Ç–∞–ø –∏–∑–º–µ–Ω—ë–Ω: {old_label} ‚Üí {new_label}'))
    notification_icons = {
        'new': 'fas fa-star', 'in_progress': 'fas fa-spinner', 'calculation': 'fas fa-calculator',
        'meeting_scheduled': 'fas fa-calendar-check', 'meeting_done': 'fas fa-handshake',
        'postponed': 'fas fa-pause-circle', 'verbal_reserve': 'fas fa-comment-dots',
        'reserved': 'fas fa-bookmark', 'documents': 'fas fa-file-alt', 'mortgage': 'fas fa-university',
        'ddu_preparation': 'fas fa-file-contract', 'ddu_signing': 'fas fa-pen-fancy',
        'registration': 'fas fa-stamp', 'receivables': 'fas fa-money-bill-wave',
        'completed': 'fas fa-check-circle', 'rejected': 'fas fa-times-circle'
    }
    notif_type = 'success' if new_stage == 'completed' else ('error' if new_stage == 'rejected' else 'info')
    complex_name = deal.residential_complex_name or (deal.residential_complex.name if deal.residential_complex else '')
    try:
        notif = UserNotification(
            user_id=deal.client_id,
            title=f'–°–¥–µ–ª–∫–∞ {deal.deal_number}: {new_label}',
            message=f'–°—Ç–∞—Ç—É—Å –≤–∞—à–µ–π —Å–¥–µ–ª–∫–∏' + (f' –ø–æ {complex_name}' if complex_name else '') + f' –∏–∑–º–µ–Ω—ë–Ω —Å ¬´{old_label}¬ª –Ω–∞ ¬´{new_label}¬ª',
            notification_type=notif_type,
            icon=notification_icons.get(new_stage, 'fas fa-info-circle'),
            action_url='/dashboard#deals'
        )
        db.session.add(notif)
    except Exception as e:
        app.logger.error(f'Failed to create deal notification: {e}')
    db.session.commit()
    return jsonify({'success': True, 'stage': new_stage, 'stage_label': new_label})


@app.route('/manager/edit-client', methods=['POST'])
@csrf.exempt
@manager_required
def manager_edit_client():
    """Edit existing client"""
    from models import User
    
    current_manager = current_user
    
    try:
        client_id = request.form.get('client_id')
        full_name = request.form.get('full_name')
        email = request.form.get('email')
        phone = request.form.get('phone')
        is_active = 'is_active' in request.form
        
        if not client_id:
            return jsonify({'success': False, 'error': 'ID –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
        
        # Try to find client assigned to this manager first, then any buyer
        client = User.query.filter_by(id=client_id, assigned_manager_id=current_manager.id).first()
        if not client:
            client = User.query.filter_by(id=client_id, role='buyer').first()
        
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        if not all([full_name, email]):
            return jsonify({'success': False, 'error': '–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è'}), 400
        
        # Check if email already exists (excluding current client)
        existing_user = User.query.filter(User.email == email, User.id != client_id).first()
        if existing_user:
            return jsonify({'success': False, 'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'}), 400
        
        # Check if phone already exists (excluding current client, normalized like registration)
        if phone:
            import re as re_mod
            from sqlalchemy import func as sqlfunc
            phone_digits = re_mod.sub(r'[^0-9]', '', phone)
            existing_phone_user = User.query.filter(
                sqlfunc.replace(sqlfunc.replace(sqlfunc.replace(User.phone, "-", ""), " ", ""), "+", "") == phone_digits,
                User.id != int(client_id)
            ).first()
            if existing_phone_user:
                return jsonify({'success': False, 'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'}), 400
        
        # Update client data
        client.full_name = full_name
        client.email = email
        client.phone = phone
        client.is_active = is_active
        client.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/manager/delete-client', methods=['POST'])
@csrf.exempt
@manager_required
def manager_delete_client():
    """Delete client"""
    from models import User
    
    current_manager = current_user
    
    try:
        # Handle both JSON and form data
        if request.content_type == 'application/json':
            data = request.get_json()
            client_id = data.get('client_id')
        else:
            client_id = request.form.get('client_id')
        
        if not client_id:
            return jsonify({'success': False, 'error': 'ID –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ —É–∫–∞–∑–∞–Ω'}), 400
        
        # Try to find client assigned to this manager first, then any buyer
        client = User.query.filter_by(id=client_id, assigned_manager_id=current_manager.id).first()
        if not client:
            client = User.query.filter_by(id=client_id, role='buyer').first()
        
        if not client:
            return jsonify({'success': False, 'error': '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # Instead of deleting, mark as inactive
        client.is_active = False
        client.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

def send_callback_notification_email(callback_req, manager):
    """Send email notification about callback request"""
    try:
        from email_service import send_email
        
        # Email content
        subject = f"–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –æ–±—Ä–∞—Ç–Ω—ã–π –∑–≤–æ–Ω–æ–∫ - {callback_req.name}"
        
        # Build message content
        content = f"""
        –ü–æ–ª—É—á–µ–Ω–∞ –Ω–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –Ω–∞ –æ–±—Ä–∞—Ç–Ω—ã–π –∑–≤–æ–Ω–æ–∫:
        
        –ö–ª–∏–µ–Ω—Ç: {callback_req.name}
        –¢–µ–ª–µ—Ñ–æ–Ω: {callback_req.phone}
        Email: {callback_req.email or '–ù–µ —É–∫–∞–∑–∞–Ω'}
        –£–¥–æ–±–Ω–æ–µ –≤—Ä–µ–º—è: {callback_req.preferred_time}
        
        –ò–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç: {callback_req.interest}
        –ë—é–¥–∂–µ—Ç: {callback_req.budget}
        –ü–ª–∞–Ω–∏—Ä—É–µ—Ç –ø–æ–∫—É–ø–∫—É: {callback_req.timing}
        
        –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ: {callback_req.notes or '–ù–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏'}
        
        –ù–∞–∑–Ω–∞—á–µ–Ω–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä: {manager.full_name if manager else '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω'}
        –î–∞—Ç–∞ –∑–∞—è–≤–∫–∏: {callback_req.created_at.strftime('%d.%m.%Y %H:%M')}
        """
        
        # Try to send to manager first, then to admin email
        recipient_email = manager.email if manager else 'admin@inback.ru'
        
        success = send_email(
            to_email=recipient_email,
            subject=subject,
            content=content,
            template_name='notification'
        )
        
        if success:
            print(f"‚úì Callback notification email sent to {recipient_email}")
        else:
            print(f"‚úó Failed to send callback notification email to {recipient_email}")
            
    except Exception as e:
        print(f"Error sending callback notification email: {e}")


def send_callback_notification_telegram(callback_req, manager):
    """Send Telegram notification about callback request"""
    try:
        # Check if telegram_bot module can be imported
        try:
            from telegram_bot import send_telegram_message
        except ImportError as e:
            print(f"Telegram bot not available: {e}")
            return False
        
        # Calculate potential cashback
        potential_cashback = ""
        if callback_req.budget:
            if "–º–ª–Ω" in callback_req.budget:
                # Extract average from range like "3-5 –º–ª–Ω"
                numbers = [float(x) for x in callback_req.budget.replace(" –º–ª–Ω", "").replace("—Ä—É–±", "").split("-") if x.strip().replace(".", "").replace(",", "").isdigit()]
                if numbers:
                    avg_price = sum(numbers) / len(numbers) * 1000000
                    cashback = int(avg_price * 0.02)
                    potential_cashback = f"üí∞ *–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π –∫—ç—à–±–µ–∫:* {cashback:,} —Ä—É–±. (2%)\n"
        
        # Enhanced Telegram message
        message = f"""üìû *–ù–û–í–ê–Ø –ó–ê–Ø–í–ö–ê –ù–ê –û–ë–†–ê–¢–ù–´–ô –ó–í–û–ù–û–ö*

üë§ *–ö–û–ù–¢–ê–ö–¢–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*
‚Ä¢ –ò–º—è: {callback_req.name}
‚Ä¢ –¢–µ–ª–µ—Ñ–æ–Ω: {callback_req.phone}
‚Ä¢ Email: {callback_req.email or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –£–¥–æ–±–Ω–æ–µ –≤—Ä–µ–º—è –∑–≤–æ–Ω–∫–∞: {callback_req.preferred_time}

üîç *–ö–†–ò–¢–ï–†–ò–ò –ü–û–ò–°–ö–ê:*
‚Ä¢ –ò–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç: {callback_req.interest or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}
‚Ä¢ –ë—é–¥–∂–µ—Ç: {callback_req.budget or '–ù–µ —É–∫–∞–∑–∞–Ω'}
‚Ä¢ –ü–ª–∞–Ω—ã –Ω–∞ –ø–æ–∫—É–ø–∫—É: {callback_req.timing or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}

{potential_cashback}üìù *–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:*
{callback_req.notes or '–ù–µ—Ç –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏'}

üìÖ *–í–†–ï–ú–Ø –ó–ê–Ø–í–ö–ò:* {callback_req.created_at.strftime('%d.%m.%Y –≤ %H:%M')}
üåê *–ò–°–¢–û–ß–ù–ò–ö:* –§–æ—Ä–º–∞ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –∑–≤–æ–Ω–∫–∞ –Ω–∞ —Å–∞–π—Ç–µ InBack.ru
üë®‚Äçüíº *–ù–ê–ó–ù–ê–ß–ï–ù–ù–´–ô –ú–ï–ù–ï–î–ñ–ï–†:* {manager.full_name if manager else '–ù–µ –Ω–∞–∑–Ω–∞—á–µ–Ω'}

üìã *–°–õ–ï–î–£–Æ–©–ò–ï –®–ê–ì–ò:*
1Ô∏è‚É£ –ü–µ—Ä–µ–∑–≤–æ–Ω–∏—Ç—å –∫–ª–∏–µ–Ω—Ç—É –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è
2Ô∏è‚É£ –ü—Ä–æ–≤–µ—Å—Ç–∏ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—é –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º
3Ô∏è‚É£ –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—É—é –ø–æ–¥–±–æ—Ä–∫—É
4Ô∏è‚É£ –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–æ–∫–∞–∑—ã –æ–±—ä–µ–∫—Ç–æ–≤

‚ö° *–í–ê–ñ–ù–û:* –°–æ–±–ª—é–¥–∞–π—Ç–µ –≤—Ä–µ–º—è, —É–¥–æ–±–Ω–æ–µ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞!"""
        
        # Always send to admin chat for now
        chat_id = "730764738"  # Admin chat
        
        success = send_telegram_message(chat_id, message)
        
        if success:
            print(f"‚úì Callback notification sent to Telegram chat {chat_id}")
        else:
            print(f"‚úó Failed to send callback notification to Telegram")
            
    except Exception as e:
        print(f"Error sending callback notification to Telegram: {e}")


# Database initialization happens in the app context below

@app.route('/api/blog/search')
def blog_search_api():
    """API endpoint for instant blog search and suggestions"""
    from models import BlogPost, Category
    from sqlalchemy import or_, func
    
    try:
        query = request.args.get('q', '').strip()
        category = request.args.get('category', '').strip()
        suggestions_only = request.args.get('suggestions', '').lower() == 'true'
        
        # Start with base query - use BlogPost (where data actually is)
        search_query = BlogPost.query.filter(BlogPost.status == 'published')
        
        # Apply search filter
        if query:
            search_query = search_query.filter(
                or_(
                    BlogPost.title.ilike(f'%{query}%'),
                    BlogPost.content.ilike(f'%{query}%'),
                    BlogPost.excerpt.ilike(f'%{query}%')
                )
            )
        
        # Apply category filter
        if category:
            search_query = search_query.filter(BlogPost.category == category)
        
        # For suggestions, limit to title matches only
        if suggestions_only:
            if query:
                suggestions = search_query.filter(
                    BlogPost.title.ilike(f'%{query}%')
                ).limit(5).all()
                
                return jsonify({
                    'suggestions': [{
                        'title': post.title,
                        'slug': post.slug,
                        'category': post.category or '–û–±—â–µ–µ'
                    } for post in suggestions]
                })
            else:
                return jsonify({'suggestions': []})
        
        # For full search, return formatted articles
        articles = search_query.order_by(BlogPost.created_at.desc()).limit(20).all()
        
        formatted_articles = []
        for article in articles:
            formatted_articles.append({
                'title': article.title,
                'slug': article.slug,
                'excerpt': article.excerpt or '',
                'featured_image': article.featured_image or '',
                'category': article.category or '–û–±—â–µ–µ',
                'date': article.created_at.strftime('%d.%m.%Y'),
                'reading_time': getattr(article, 'reading_time', 5),
                'views': getattr(article, 'views', 0)
            })
        return jsonify({
            'articles': formatted_articles,
            'total': len(formatted_articles)
        })
        
    except Exception as e:
        print(f"ERROR in blog search API: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': 'Search failed', 'articles': [], 'suggestions': []}), 500

# Developer Scraper Management Endpoints
@app.route('/admin/scraper')
@admin_required
def admin_scraper():
    """Admin panel for developer scraper management"""
    from models import Admin
    
    # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º Flask-Login current_user
    admin = current_user
    
    return render_template('admin/scraper.html', admin=admin)

@app.route('/admin/scraper/run', methods=['POST'])
@admin_required
def run_scraper():
    """Run the AI-powered developer scraper"""
    try:
        from developer_parser_integration import DeveloperParserService
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä –ª–∏–º–∏—Ç–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10)
        limit = 10
        try:
            data = request.get_json(force=True) if request.data else {}
        except:
            data = {}
        
        if data:
            limit = data.get('limit', 10)
        
        service = DeveloperParserService()
        result = service.parse_and_save_developers(limit=limit)
        
        return jsonify({
            'success': True,
            'stats': {
                'developers_created': result.get('created', 0),
                'developers_updated': result.get('updated', 0),
                'total_processed': result.get('total_processed', 0),
                'errors': result.get('errors', 0)
            },
            'message': f'–ò–ò-–ø–∞—Ä—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω! –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ {result["total_processed"]} –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–æ–≤. –°–æ–∑–¥–∞–Ω–æ: {result["created"]}, –æ–±–Ω–æ–≤–ª–µ–Ω–æ: {result["updated"]}',
            'errors_list': result.get('errors_list', [])
        })
        
    except Exception as e:
        print(f"AI Scraper error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'success': False,
            'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –ò–ò-–ø–∞—Ä—Å–∏–Ω–≥–µ: {str(e)}'
        }), 500

@app.route('/admin/scraper/test', methods=['POST'])
@admin_required
def test_scraper():
    """Test AI scraper with sample data"""
    try:
        # –ü—Ä–æ—Å—Ç—ã–µ —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        test_data = {
            'name': '–¢–µ—Å—Ç–æ–≤—ã–π –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫',
            'description': '–û–ø–∏—Å–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫–∞',
            'website': 'https://example.com',
            'phone': '+7-918-000-00-00',
            'email': 'test@example.com'
        }
        
        return jsonify({
            'success': True,
            'data': test_data,
            'stats': {
                'developers_tested': 1,
                'complexes_found': 0,
                'ai_extraction': True,
                'mock_data': True
            },
            'message': '–ò–ò-—Ç–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω! –ó–∞—Å—Ç—Ä–æ–π—â–∏–∫: –¢–µ—Å—Ç–æ–≤—ã–π –∑–∞—Å—Ç—Ä–æ–π—â–∏–∫'
        })
        
    except Exception as e:
        print(f"AI Scraper test error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'success': False,
            'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –ò–ò-–ø–∞—Ä—Å–µ—Ä–∞: {str(e)}'
        }), 500

@app.route('/admin/scraper/statistics')
@admin_required
def scraper_statistics():
    """Get AI parser statistics"""
    try:
        from developer_parser_integration import DeveloperParserService
        
        service = DeveloperParserService()
        stats = service.get_parsing_statistics()
        
        return jsonify({
            'success': True,
            'data': stats
        })
        
    except Exception as e:
        print(f"Statistics error: {e}")
        return jsonify({
            'success': False,
            'message': f'–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {str(e)}'
        }), 500

@app.route('/admin/scraper/files')
@admin_required
def scraper_files():
    """List scraped data files"""
    try:
        import glob
        import os
        from datetime import datetime
        
        files = glob.glob('scraped_developers_*.json')
        file_info = []
        
        for file in files:
            stat = os.stat(file)
            file_info.append({
                'name': file,
                'size': stat.st_size,
                'created': datetime.fromtimestamp(stat.st_ctime).strftime('%d.%m.%Y %H:%M'),
                'modified': datetime.fromtimestamp(stat.st_mtime).strftime('%d.%m.%Y %H:%M')
            })
        
        # Sort by creation time, newest first
        file_info.sort(key=lambda x: x['modified'], reverse=True)
        
        return jsonify({
            'success': True,
            'files': file_info
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —Ñ–∞–π–ª–æ–≤: {str(e)}'
        }), 500

@app.route('/admin/scraper/view-file/<filename>')
@admin_required
def view_scraped_file(filename):
    """View scraped data file content"""
    try:
        import json
        import os
        
        # Security check - only allow scraped files
        if not filename.startswith('scraped_developers_') or not filename.endswith('.json'):
            return jsonify({'success': False, 'message': '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∏–º—è —Ñ–∞–π–ª–∞'}), 400
        
        if not os.path.exists(filename):
            return jsonify({'success': False, 'message': '–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        with open(filename, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        return jsonify({
            'success': True,
            'data': data,
            'filename': filename
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'message': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞: {str(e)}'
        }), 500

@app.route('/admin/upload-excel', methods=['POST'])
def admin_upload_excel():
    """Handle Excel file upload from admin panel"""
    try:
        if 'excel_file' not in request.files:
            return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'})
        
        file = request.files['excel_file']
        if file.filename == '':
            return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'})
        
        if not file.filename.endswith(('.xlsx', '.xls')):
            return jsonify({'success': False, 'error': '–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ñ–∞–π–ª—ã Excel (.xlsx, .xls)'})
        
        # Save file to attached_assets directory
        import os
        import uuid
        
        # Ensure attached_assets directory exists
        os.makedirs('attached_assets', exist_ok=True)
        
        # Generate unique filename
        file_extension = os.path.splitext(file.filename)[1]
        unique_filename = f"upload_{uuid.uuid4().hex[:8]}{file_extension}"
        file_path = os.path.join('attached_assets', unique_filename)
        
        # Save the file
        file.save(file_path)
        
        # –ó–∞–ø—É—Å–∫ –∏–º–ø–æ—Ä—Ç–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–º –ø—Ä–æ—Ü–µ—Å—Å–µ –¥–ª—è –±–æ–ª—å—à–∏—Ö —Ñ–∞–π–ª–æ–≤
        try:
            import threading
            import time
            
            # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –∑–∞–¥–∞—á–∏
            task_id = unique_filename.replace('.', '_')
            
            # –°—Ç–∞—Ç—É—Å –∏–º–ø–æ—Ä—Ç–∞ (–±—É–¥–µ–º —Ö—Ä–∞–Ω–∏—Ç—å –≤ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π)
            global import_status
            if 'import_status' not in globals():
                import_status = {}
            
            import_status[task_id] = {
                'status': 'processing',
                'progress': 0,
                'message': '–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–∞–π–ª–∞...',
                'started_at': time.time()
            }
            
            def background_import():
                try:
                    with app.app_context():
                        result = import_excel_to_database(file_path)
                    
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏ —É—Å–ø–µ—Ö–µ
                    import_status[task_id] = {
                        'status': 'completed',
                        'progress': 100,
                        'message': f'‚úÖ {result["message"]} –ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: {result["imported"]} –∑–∞–ø–∏—Å–µ–π.',
                        'result': result,
                        'completed_at': time.time()
                    }
                    
                    # –û—á–∏—â–∞–µ–º –∫–µ—à
                    global _properties_cache, _cache_timestamp
                    _properties_cache = None
                    _cache_timestamp = None
                    
                except Exception as import_error:
                    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏ –æ—à–∏–±–∫–µ
                    import_status[task_id] = {
                        'status': 'error',
                        'progress': 0,
                        'message': f'‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: {str(import_error)}',
                        'error': str(import_error),
                        'failed_at': time.time()
                    }
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –∏–º–ø–æ—Ä—Ç –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            thread = threading.Thread(target=background_import, daemon=True)
            thread.start()
            
            # –°—Ä–∞–∑—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–≤–µ—Ç –æ –Ω–∞—á–∞–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏
            return jsonify({
                'success': True,
                'message': f'üì§ –§–∞–π–ª –∑–∞–≥—Ä—É–∂–µ–Ω! –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞ –≤ —Ñ–æ–Ω–µ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç–∞—Ç—É—Å —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç.',
                'task_id': task_id,
                'background': True
            })
            
        except Exception as import_error:
            return jsonify({
                'success': False, 
                'error': f'–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: {str(import_error)}'
            })
            
    except Exception as e:
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∞–π–ª–∞: {str(e)}'})

@app.route('/admin/check-import-status/<task_id>')
def admin_check_import_status(task_id):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Ñ–æ–Ω–æ–≤–æ–≥–æ –∏–º–ø–æ—Ä—Ç–∞"""
    try:
        global import_status
        if 'import_status' not in globals():
            import_status = {}
        
        if task_id not in import_status:
            return jsonify({
                'success': False,
                'error': '–ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'
            })
        
        status_info = import_status[task_id]
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        import time
        if 'started_at' in status_info:
            elapsed = time.time() - status_info['started_at']
            status_info['elapsed_time'] = f"{elapsed:.1f} —Å–µ–∫"
        
        return jsonify({
            'success': True,
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞: {str(e)}'
        })

# ================== REGIONAL FUNCTIONS ==================

def parse_address_components(address_display_name):
    """
    –ü–∞—Ä—Å–∏—Ç –ø–æ–ª–Ω—ã–π –∞–¥—Ä–µ—Å –∏ –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Ä–µ–≥–∏–æ–Ω, –≥–æ—Ä–æ–¥ –∏ —Ä–∞–π–æ–Ω
    –ü—Ä–∏–º–µ—Ä: "–†–æ—Å—Å–∏—è, –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π, –°–æ—á–∏, –ö—É–¥–µ–ø—Å—Ç–∞ –º-–Ω, –ò—Å–∫—Ä—ã, 88 –ª–∏—Ç7"
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: {'region': '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π', 'city': '–°–æ—á–∏', 'district': '–ö—É–¥–µ–ø—Å—Ç–∞ –º-–Ω'}
    """
    if not address_display_name:
        return {'region': None, 'city': None, 'district': None}
    
    # –†–∞–∑–¥–µ–ª—è–µ–º –∞–¥—Ä–µ—Å –ø–æ –∑–∞–ø—è—Ç—ã–º
    parts = [part.strip() for part in address_display_name.split(',')]
    
    result = {'region': None, 'city': None, 'district': None}
    
    # –ò—â–µ–º —Ä–µ–≥–∏–æ–Ω (–æ–±—ã—á–Ω–æ —Å–æ–¥–µ—Ä–∂–∏—Ç "–∫—Ä–∞–π", "–æ–±–ª–∞—Å—Ç—å", "—Ä–µ—Å–ø—É–±–ª–∏–∫–∞")
    for part in parts:
        if any(keyword in part.lower() for keyword in ['–∫—Ä–∞–π', '–æ–±–ª–∞—Å—Ç—å', '—Ä–µ—Å–ø—É–±–ª–∏–∫–∞', '—Ñ–µ–¥–µ—Ä–∞—Ü–∏—è']):
            result['region'] = part
            break
    
    # –ò—â–µ–º –≥–æ—Ä–æ–¥ (–ø–æ—Å–ª–µ —Ä–µ–≥–∏–æ–Ω–∞, –æ–±—ã—á–Ω–æ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å—É—Ñ—Ñ–∏–∫—Å–æ–≤)
    region_found = False
    for part in parts:
        if result['region'] and part == result['region']:
            region_found = True
            continue
        
        if region_found and part != '–†–æ—Å—Å–∏—è':
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –Ω–µ —É–ª–∏—Ü–∞ –∏–ª–∏ –¥–æ–º
            if not any(keyword in part.lower() for keyword in ['—É–ª', '—É–ª–∏—Ü–∞', '–ø—Ä–æ—Å–ø–µ–∫—Ç', '–ø—Ä-—Ç', '–ø–µ—Ä–µ—É–ª–æ–∫', '–ø–µ—Ä', '–º-–Ω', '–ª–∏—Ç', '—Å—Ç—Ä', '–∫–æ—Ä–ø', '–¥.']):
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –Ω–µ –Ω–æ–º–µ—Ä –∏ –Ω–µ –ø—Å–µ–≤–¥–æ-–≥–æ—Ä–æ–¥ —Ç–∏–ø–∞ "–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä 6"
                if not part.replace(' ', '').replace('–∞', '').replace('–±', '').replace('–≤', '').replace('–≥', '').isdigit():
                    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Å–µ–≤–¥–æ-–≥–æ—Ä–æ–¥–∞ (–Ω–∞–∑–≤–∞–Ω–∏–µ + –ø—Ä–æ–±–µ–ª + —á–∏—Å–ª–æ)
                    import re
                    if not re.match(r'^[–∞-—è—ë]+\s+\d+$', part.lower()):
                        result['city'] = part
                        break
    
    # –ò—â–µ–º —Ä–∞–π–æ–Ω/–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω (–æ–±—ã—á–Ω–æ —Å–æ–¥–µ—Ä–∂–∏—Ç "–º-–Ω", "—Ä-–Ω" –∏–ª–∏ –∏–¥–µ—Ç –ø–æ—Å–ª–µ –≥–æ—Ä–æ–¥–∞)
    city_found = False
    for part in parts:
        if result['city'] and part == result['city']:
            city_found = True
            continue
            
        if city_found:
            # –ï—Å–ª–∏ —ç—Ç–æ —Ä–∞–π–æ–Ω/–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω
            if any(keyword in part.lower() for keyword in ['–º-–Ω', '—Ä-–Ω', '—Ä–∞–π–æ–Ω', '–º–∏–∫—Ä–æ—Ä–∞–π–æ–Ω', '–º–∫—Ä']):
                result['district'] = part
                break
            # –ò–ª–∏ –µ—Å–ª–∏ —ç—Ç–æ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–∞–π–æ–Ω–∞ –±–µ–∑ —Å—É—Ñ—Ñ–∏–∫—Å–æ–≤ (–ø–µ—Ä–≤–æ–µ –ø–æ—Å–ª–µ –≥–æ—Ä–æ–¥–∞)
            elif not any(keyword in part.lower() for keyword in ['—É–ª', '—É–ª–∏—Ü–∞', '–ø—Ä–æ—Å–ø–µ–∫—Ç', '–ø—Ä-—Ç', '–ª–∏—Ç', '—Å—Ç—Ä', '–∫–æ—Ä–ø', '–¥–æ–º', '–¥.']):
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –Ω–µ –Ω–æ–º–µ—Ä –¥–æ–º–∞ (—Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã –∏ –±—É–∫–≤—ã —Ç–∏–ø–∞ 2–ê, 10, 36 –∏ —Ç.–¥.)
                if not (part.replace('/', '').replace('–∫', '').replace('—Å—Ç—Ä', '').replace('–∞', '').replace('–±', '').replace('–≤', '').replace('–≥', '').replace(' ', '').isdigit() or len(part) <= 5):
                    result['district'] = part
                    break
    
    return result

def get_or_create_region(region_name):
    """–ü–æ–ª—É—á–∏—Ç—å –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å —Ä–µ–≥–∏–æ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"""
    if not region_name:
        return None
        
    from models import Region
    
    # –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ä–µ–≥–∏–æ–Ω
    region = Region.query.filter_by(name=region_name).first()
    
    if not region:
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Ä–µ–≥–∏–æ–Ω
        slug = region_name.lower().replace(' ', '-').replace('—Å–∫–∏–π', '').replace('–∫—Ä–∞–π', 'krai')
        region = Region(
            name=region_name,
            slug=slug,
            is_active=True,
            is_default=(region_name == '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π')  # –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä—Å–∫–∏–π –∫—Ä–∞–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        )
        db.session.add(region)
        try:
            db.session.commit()
            print(f"Created new region: {region_name}")
        except Exception as e:
            db.session.rollback()
            print(f"Error creating region {region_name}: {e}")
            return None
    
    return region

def get_or_create_city(city_name, region):
    """–ü–æ–ª—É—á–∏—Ç—å –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –≥–æ—Ä–æ–¥ –≤ —Ä–µ–≥–∏–æ–Ω–µ"""
    if not city_name or not region:
        return None
        
    from models import City
    
    # –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –≥–æ—Ä–æ–¥ –≤ —ç—Ç–æ–º —Ä–µ–≥–∏–æ–Ω–µ
    city = City.query.filter_by(name=city_name, region_id=region.id).first()
    
    if not city:
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –≥–æ—Ä–æ–¥
        slug = city_name.lower().replace(' ', '-')
        city = City(
            name=city_name,
            slug=slug,
            region_id=region.id,
            is_active=True,
            is_default=(city_name == '–ö—Ä–∞—Å–Ω–æ–¥–∞—Ä')  # –ö—Ä–∞—Å–Ω–æ–¥–∞—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        )
        db.session.add(city)
        try:
            db.session.commit()
            print(f"Created new city: {city_name} in {region.name}")
        except Exception as e:
            db.session.rollback()
            print(f"Error creating city {city_name}: {e}")
            return None
    
    return city

def update_properties_with_regions():
    """–û–±–Ω–æ–≤–∏—Ç—å –≤—Å–µ –æ–±—ä–µ–∫—Ç—ã –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏ —Å —Ä–µ–≥–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø—Ä–∏–≤—è–∑–∫–æ–π"""
    
    # ‚úÖ MIGRATED: Use normalized Property model
    properties = Property.query.all()
    updated_count = 0
    
    print(f"Updating {len(properties)} properties with regional data...")
    
    for prop in properties:
        if prop.address_display_name:
            # –ü–∞—Ä—Å–∏–º –∞–¥—Ä–µ—Å
            address_parts = parse_address_components(prop.address_display_name)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞—Ä—Å–µ–Ω—ã–µ –ø–æ–ª—è
            prop.parsed_region = address_parts['region']
            prop.parsed_city = address_parts['city'] 
            prop.parsed_district = address_parts['district']
            
            # –°–æ–∑–¥–∞–µ–º/–Ω–∞—Ö–æ–¥–∏–º —Ä–µ–≥–∏–æ–Ω –∏ –≥–æ—Ä–æ–¥
            if address_parts['region']:
                region = get_or_create_region(address_parts['region'])
                if region:
                    prop.region_id = region.id
                    
                    if address_parts['city']:
                        city = get_or_create_city(address_parts['city'], region)
                        if city:
                            prop.city_id = city.id
            
            updated_count += 1
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ —á–∞—Å—Ç—è–º –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è —Ç–∞–π–º–∞—É—Ç–æ–≤
            if updated_count % 50 == 0:
                try:
                    db.session.commit()
                    print(f"Updated {updated_count} properties...")
                except Exception as e:
                    print(f"Error committing batch: {str(e)}")
                    db.session.rollback()
    
    # –§–∏–Ω–∞–ª—å–Ω—ã–π –∫–æ–º–º–∏—Ç
    try:
        db.session.commit()
        print(f"‚úÖ Successfully updated {updated_count} properties with regional data")
    except Exception as e:
        print(f"Error in final commit: {str(e)}")
        db.session.rollback()
    
    return updated_count


# ==================== VIDEO MANAGEMENT API ====================
@app.route('/api/manager/complex/<int:complex_id>/video/add-link', methods=['POST'])
@admin_required
def add_complex_video_link(complex_id):
    """–î–æ–±–∞–≤–∏—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–µ–æ –¥–ª—è –ñ–ö (—Ç–æ–ª—å–∫–æ –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤)"""
    try:
        data = request.get_json()
        url = data.get('url', '').strip()
        title = data.get('title', '').strip()
        description = data.get('description', '').strip()
        video_type = data.get('type', 'youtube')
        
        if not url or not title:
            return jsonify({'success': False, 'error': 'URL –∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã'}), 400
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–ª–µ–∫—Å
        complex = ResidentialComplex.query.get(complex_id)
        if not complex:
            return jsonify({'success': False, 'error': '–ö–æ–º–ø–ª–µ–∫—Å –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        # –ü–∞—Ä—Å–∏–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –≤–∏–¥–µ–æ
        existing_videos = []
        if complex.videos:
            try:
                existing_videos = json.loads(complex.videos)
            except:
                existing_videos = []
        
        # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ –≤–∏–¥–µ–æ
        new_video = {
            'type': video_type,
            'url': url,
            'title': title
        }
        if description:
            new_video['description'] = description
        
        existing_videos.append(new_video)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º
        complex.videos = json.dumps(existing_videos, ensure_ascii=False)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–í–∏–¥–µ–æ —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ',
            'videos_count': len(existing_videos)
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding video link: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/manager/complex/<int:complex_id>/video/upload', methods=['POST'])
@admin_required
def upload_complex_video(complex_id):
    """–ó–∞–≥—Ä—É–∑–∏—Ç—å –≤–∏–¥–µ–æ —Ñ–∞–π–ª –¥–ª—è –ñ–ö (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤)"""
    app.logger.info(f"=== VIDEO UPLOAD START: complex_id={complex_id}")
    app.logger.info(f"=== request.files keys: {list(request.files.keys())}")
    
    try:
        import os
        from werkzeug.utils import secure_filename
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–∞–π–ª
        if 'video' not in request.files:
            app.logger.error("=== ERROR: 'video' not in request.files")
            return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 400
        
        file = request.files['video']
        app.logger.info(f"=== File received: {file.filename}")
        
        if file.filename == '':
            app.logger.error("=== ERROR: Empty filename")
            return jsonify({'success': False, 'error': '–§–∞–π–ª –Ω–µ –≤—ã–±—Ä–∞–Ω'}), 400
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
        allowed_extensions = {'mp4', 'webm', 'mov', 'avi'}
        filename = secure_filename(file.filename)
        file_ext = filename.rsplit('.', 1)[1].lower() if '.' in filename else ''
        
        app.logger.info(f"=== File extension: {file_ext}")
        
        if file_ext not in allowed_extensions:
            app.logger.error(f"=== ERROR: Invalid extension {file_ext}")
            return jsonify({'success': False, 'error': '–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç –≤–∏–¥–µ–æ'}), 400
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–ª–µ–∫—Å
        complex = ResidentialComplex.query.get(complex_id)
        if not complex:
            app.logger.error(f"=== ERROR: Complex {complex_id} not found")
            return jsonify({'success': False, 'error': '–ö–æ–º–ø–ª–µ–∫—Å –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        app.logger.info(f"=== Complex found: {complex.name}, slug: {complex.slug}")
        
        # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
        import uuid
        unique_filename = f"{complex.slug}_{uuid.uuid4().hex[:8]}.{file_ext}"
        
        # –ü—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        upload_folder = 'static/uploads/complexes/videos'
        os.makedirs(upload_folder, exist_ok=True)
        file_path = os.path.join(upload_folder, unique_filename)
        
        app.logger.info(f"=== Saving file to: {file_path}")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
        file.save(file_path)
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –ë–î
        relative_path = f"/{file_path}"
        complex.uploaded_video = relative_path
        db.session.commit()
        
        app.logger.info(f"=== VIDEO UPLOAD SUCCESS: {relative_path}")
        
        return jsonify({
            'success': True,
            'message': '–í–∏–¥–µ–æ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ',
            'video_path': relative_path
        })
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"=== VIDEO UPLOAD EXCEPTION: {str(e)}")
        import traceback
        app.logger.error(traceback.format_exc())
        return jsonify({'success': False, 'error': str(e)}), 500
        print(f"Error uploading video: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/manager/complex/<int:complex_id>/video/delete', methods=['DELETE'])
@manager_required  
def delete_complex_video(complex_id):
    """–£–¥–∞–ª–∏—Ç—å –≤–∏–¥–µ–æ (—Å—Å—ã–ª–∫—É –∏–ª–∏ —Ñ–∞–π–ª) –¥–ª—è –ñ–ö"""
    try:
        data = request.get_json()
        video_index = data.get('video_index')  # –ò–Ω–¥–µ–∫—Å –≤–∏–¥–µ–æ –≤ –º–∞—Å—Å–∏–≤–µ videos
        delete_uploaded = data.get('delete_uploaded', False)  # –£–¥–∞–ª–∏—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–µ –≤–∏–¥–µ–æ
        
        complex = ResidentialComplex.query.get(complex_id)
        if not complex:
            return jsonify({'success': False, 'error': '–ö–æ–º–ø–ª–µ–∫—Å –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        if video_index is not None:
            # –£–¥–∞–ª—è–µ–º –≤–∏–¥–µ–æ –∏–∑ –º–∞—Å—Å–∏–≤–∞
            if complex.videos:
                try:
                    videos = json.loads(complex.videos)
                    if 0 <= video_index < len(videos):
                        videos.pop(video_index)
                        complex.videos = json.dumps(videos, ensure_ascii=False) if videos else None
                except:
                    return jsonify({'success': False, 'error': '–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –≤–∏–¥–µ–æ'}), 400
        
        if delete_uploaded and complex.uploaded_video:
            # –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª —Å –¥–∏—Å–∫–∞
            import os
            try:
                file_path = complex.uploaded_video.lstrip('/')
                if os.path.exists(file_path):
                    os.remove(file_path)
            except:
                pass
            complex.uploaded_video = None
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': '–í–∏–¥–µ–æ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting video: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


# ===== BATCH GEOCODE FOR MINI MAP FIX =====
@app.route('/api/mini-map/batch-geocode', methods=['GET'])
@csrf.exempt
def batch_geocode_for_minimap():
    """
    Batch geocode properties without coordinates
    Fixes mini-map showing only 6/106 properties
    """
    try:
        from models import Property
        from services.geocoding import get_geocoding_service
        
        props_no_coords = Property.query.filter(
            ((Property.latitude.is_(None)) | (Property.latitude == 0)) &
            ((Property.longitude.is_(None)) | (Property.longitude == 0))
        ).limit(50).all()  # Process 50 at a time
        
        if not props_no_coords:
            return jsonify({'success': True, 'geocoded': 0, 'message': 'All properties have coordinates'})
        
        geocoding_service = get_geocoding_service()
        geocoded = 0
        
        for prop in props_no_coords:
            if not prop.address:
                continue
            try:
                result = geocoding_service.forward_geocode(prop.address)
                if result and result.get('latitude') and result.get('longitude'):
                    prop.latitude = float(result['latitude'])
                    prop.longitude = float(result['longitude'])
                    geocoded += 1
            except:
                pass
        
        db.session.commit()
        return jsonify({'success': True, 'geocoded': geocoded, 'remaining': len(props_no_coords)})
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/change-password', methods=['POST'])
@login_required
def api_change_password():
    """API endpoint for changing password (including forced change after temp password)"""
    try:
        data = request.get_json()
        new_password = data.get('new_password', '').strip()
        confirm_password = data.get('confirm_password', '').strip()
        
        if not new_password or len(new_password) < 6:
            return jsonify({'success': False, 'message': '–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤'}), 400
        
        if new_password != confirm_password:
            return jsonify({'success': False, 'message': '–ü–∞—Ä–æ–ª–∏ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç'}), 400
        
        # Update password
        current_user.set_password(new_password)
        current_user.must_change_password = False
        db.session.commit()
        
        return jsonify({'success': True, 'message': '–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω—ë–Ω'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': f'–û—à–∏–±–∫–∞: {str(e)}'}), 500


@app.route('/manager/employees')
@manager_required
def manager_employees():
    from models import Manager, Department, OrgRole, ManagerCheckin, Deal, DealHistory
    from zoneinfo import ZoneInfo
    from datetime import timedelta
    
    current_manager = current_user
    role = current_manager.org_role
    can_view_all = (role.can_view_all_deals if role else False)
    can_view_dept = (role.can_view_department_deals if role else False)
    is_rop = getattr(current_manager, 'is_rop', False) or can_view_dept or can_view_all
    
    now_msk = datetime.now(ZoneInfo('Europe/Moscow'))
    today = now_msk.date()
    
    if can_view_all:
        managers = Manager.query.filter_by(is_active=True).order_by(Manager.first_name).all()
    elif can_view_dept or is_rop:
        if current_manager.department_id:
            dept = Department.query.get(current_manager.department_id)
            dept_ids = dept.get_all_manager_ids() if dept else [current_manager.id]
            managers = Manager.query.filter(Manager.id.in_(dept_ids), Manager.is_active == True).order_by(Manager.first_name).all()
        else:
            managers = [current_manager]
    else:
        if current_manager.department_id:
            dept = Department.query.get(current_manager.department_id)
            dept_ids = dept.get_all_manager_ids() if dept else [current_manager.id]
            managers = Manager.query.filter(Manager.id.in_(dept_ids), Manager.is_active == True).order_by(Manager.first_name).all()
        else:
            managers = [current_manager]
    
    employees_data = []
    for m in managers:
        today_checkins = ManagerCheckin.query.filter_by(manager_id=m.id, date=today).order_by(ManagerCheckin.check_in_time).all()
        total_minutes_today = sum(c.duration_minutes for c in today_checkins)
        hours = total_minutes_today // 60
        mins = total_minutes_today % 60
        is_currently_active = any(c.is_active for c in today_checkins)
        
        active_deals = Deal.query.filter(Deal.manager_id == m.id, Deal.status.in_(['active', 'new'])).count()
        
        recent_activities = DealHistory.query.filter_by(author_id=m.id).order_by(DealHistory.created_at.desc()).limit(5).all()
        
        last_login = getattr(m, 'last_login', None) or getattr(m, 'last_login_at', None)
        
        dept_name = m.department.name if m.department else None
        role_name = m.org_role.name if m.org_role else None
        
        employees_data.append({
            'manager': m,
            'is_currently_active': is_currently_active,
            'today_time': f'{hours}—á {mins}–º' if hours > 0 else f'{mins}–º',
            'active_deals': active_deals,
            'recent_activities': recent_activities,
            'last_login': last_login,
            'department': dept_name,
            'role': role_name,
            'first_checkin': today_checkins[0].check_in_time if today_checkins else None,
        })
    
    sidebar_links, user_profile = get_manager_sidebar_data(current_manager, active_page='employees')
    
    return render_template('manager/employees.html',
                         employees_data=employees_data,
                         current_manager=current_manager,
                         is_rop=is_rop,
                         today=today,
                         sidebar_links=sidebar_links,
                         user_profile=user_profile,
                         manager=current_manager)


@app.route('/api/manager/employees/<int:manager_id>/dismiss', methods=['POST'])
@manager_required
def api_dismiss_employee(manager_id):
    from models import Manager, Department, OrgRole
    current_manager = current_user
    role = current_manager.org_role
    can_view_all = role.can_view_all_deals if role else False
    can_view_dept = role.can_view_department_deals if role else False
    is_rop = getattr(current_manager, 'is_rop', False) or can_view_dept or can_view_all
    
    if not is_rop:
        return jsonify({'success': False, 'error': '–ù–µ—Ç –ø—Ä–∞–≤ –Ω–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞–º–∏'}), 403
    
    if manager_id == current_manager.id:
        return jsonify({'success': False, 'error': '–ù–µ–ª—å–∑—è —É–≤–æ–ª–∏—Ç—å —Å–∞–º–æ–≥–æ —Å–µ–±—è'}), 400
    
    target = Manager.query.get(manager_id)
    if not target:
        return jsonify({'success': False, 'error': '–°–æ—Ç—Ä—É–¥–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    if not can_view_all:
        if current_manager.department_id:
            dept = Department.query.get(current_manager.department_id)
            dept_ids = dept.get_all_manager_ids() if dept else [current_manager.id]
            if target.id not in dept_ids:
                return jsonify({'success': False, 'error': '–°–æ—Ç—Ä—É–¥–Ω–∏–∫ –Ω–µ –≤ –≤–∞—à–µ–º –æ—Ç–¥–µ–ª–µ'}), 403
        else:
            return jsonify({'success': False, 'error': '–í—ã –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω—ã –∫ –æ—Ç–¥–µ–ª—É'}), 403
    
    reassign_to_id = request.json.get('reassign_to_id') if request.json else None
    
    from models import Deal
    active_deals = Deal.query.filter(
        Deal.manager_id == target.id,
        ~Deal.status.in_(['completed', 'successful', 'rejected', 'cancelled'])
    ).all()
    
    if active_deals and reassign_to_id:
        reassign_to = Manager.query.get(reassign_to_id)
        if not reassign_to or not reassign_to.is_active:
            return jsonify({'success': False, 'error': '–ú–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω'}), 400
        for deal in active_deals:
            deal.manager_id = reassign_to_id
    elif active_deals and not reassign_to_id:
        return jsonify({
            'success': False,
            'error': '–£ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–¥–µ–ª–∫–∏. –í—ã–±–µ—Ä–∏—Ç–µ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –¥–ª—è –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è.',
            'active_deals_count': len(active_deals),
            'needs_reassignment': True
        }), 400
    
    target.is_active = False
    db.session.commit()
    
    msg = f'{target.full_name or target.email} —É–≤–æ–ª–µ–Ω(–∞)'
    if active_deals and reassign_to_id:
        reassign_to = Manager.query.get(reassign_to_id)
        msg += f'. {len(active_deals)} —Å–¥–µ–ª–æ–∫ –ø–µ—Ä–µ–¥–∞–Ω—ã {reassign_to.full_name}'
    return jsonify({'success': True, 'message': msg})


@app.route('/api/manager/employee/<int:manager_id>/profile')
@manager_required
def api_employee_profile(manager_id):
    from models import Manager, Department, OrgRole, Deal, DealHistory, DealTask, User, ManagerCheckin
    from datetime import datetime, timedelta
    import pytz
    import traceback
    
    try:
        current_manager = current_user
        employee = Manager.query.get(manager_id)
        if not employee:
            return jsonify({'success': False, 'error': '–°–æ—Ç—Ä—É–¥–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
        
        role = current_manager.org_role
        can_view_all = role.can_view_all_deals if role else False
        can_view_dept = role.can_view_department_deals if role else False
        
        if not can_view_all and employee.id != current_manager.id:
            if can_view_dept and current_manager.department_id:
                dept = Department.query.get(current_manager.department_id)
                dept_ids = dept.get_all_manager_ids() if dept else [current_manager.id]
                if employee.id not in dept_ids:
                    return jsonify({'success': False, 'error': '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞'}), 403
            elif not can_view_dept or not current_manager.department_id:
                return jsonify({'success': False, 'error': '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞'}), 403
    
        emp_role = employee.org_role.name if employee.org_role else (employee.position or '–ú–µ–Ω–µ–¥–∂–µ—Ä')
        emp_department = employee.department.name if employee.department else None
    
        msk = pytz.timezone('Europe/Moscow')
        now_msk = datetime.now(msk)
        today_start = now_msk.replace(hour=0, minute=0, second=0, microsecond=0)
    
        checkin = ManagerCheckin.query.filter(
            ManagerCheckin.manager_id == employee.id,
            ManagerCheckin.check_in_time >= today_start.astimezone(pytz.utc).replace(tzinfo=None)
        ).order_by(ManagerCheckin.check_in_time.desc()).first()
        is_online = checkin is not None and checkin.check_out_time is None
    
        active_deals = Deal.query.filter(
            Deal.manager_id == employee.id,
            ~Deal.status.in_(['completed', 'successful', 'rejected', 'cancelled'])
        ).count()
        completed_deals = Deal.query.filter(
            Deal.manager_id == employee.id,
            Deal.status.in_(['completed', 'successful'])
        ).count()
        clients = User.query.filter_by(assigned_manager_id=employee.id).count()
        pending_tasks = DealTask.query.join(Deal).filter(
            Deal.manager_id == employee.id,
            DealTask.is_completed == False
        ).count()
    
        subordinates = []
        if employee.department_id:
            dept = Department.query.get(employee.department_id)
            if dept and dept.head_manager_id == employee.id:
                subs = Manager.query.filter(
                    Manager.department_id == employee.department_id,
                    Manager.id != employee.id,
                    Manager.is_active == True
                ).all()
                subordinates = [{'id': s.id, 'full_name': s.full_name, 'role': s.org_role.name if s.org_role else (s.position or '–ú–µ–Ω–µ–¥–∂–µ—Ä'), 'avatar': s.profile_image, 'initials': (s.first_name or '?')[0].upper()} for s in subs]
    
        supervisor = None
        if employee.department_id:
            dept = Department.query.get(employee.department_id)
            if dept and dept.head_manager_id and dept.head_manager_id != employee.id:
                sup = Manager.query.get(dept.head_manager_id)
                if sup:
                    supervisor = {'id': sup.id, 'full_name': sup.full_name, 'role': sup.org_role.name if sup.org_role else (sup.position or '–†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å'), 'avatar': sup.profile_image, 'initials': (sup.first_name or '?')[0].upper()}
    
        recent_activities = []
        week_ago = datetime.utcnow() - timedelta(days=7)
        histories = DealHistory.query.join(Deal).filter(
            Deal.manager_id == employee.id,
            DealHistory.created_at >= week_ago
        ).order_by(DealHistory.created_at.desc()).limit(10).all()
        msk_tz = pytz.timezone('Europe/Moscow')
        for h in histories:
            created_msk = pytz.utc.localize(h.created_at).astimezone(msk_tz) if h.created_at else None
            recent_activities.append({
                'action': h.action,
                'description': h.description,
                'created_at': created_msk.strftime('%d.%m.%Y %H:%M') if created_msk else ''
            })
    
        return jsonify({
                'success': True,
                'employee': {
                    'id': employee.id,
                    'full_name': employee.full_name,
                    'first_name': employee.first_name,
                    'last_name': employee.last_name,
                    'email': employee.email,
                    'phone': employee.phone,
                    'position': employee.position,
                    'avatar': employee.profile_image,
                    'initials': (employee.first_name or employee.email or '?')[0].upper(),
                    'role': emp_role,
                    'department': emp_department,
                    'is_online': is_online,
                    'stats': {
                        'active_deals': active_deals,
                        'completed_deals': completed_deals,
                        'clients': clients,
                        'pending_tasks': pending_tasks
                    },
                    'subordinates': subordinates,
                    'supervisor': supervisor,
                    'recent_activities': recent_activities
                }
            })
    except Exception as e:
        print(f"ERROR in api_employee_profile: {traceback.format_exc()}")
        return jsonify({'success': False, 'error': f'–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}'}), 500


@app.route('/manager/employee/<int:manager_id>')
@manager_required
def manager_employee_profile(manager_id):
    from models import Manager, Department, OrgRole, Deal, DealHistory, DealTask, User, ManagerCheckin
    from datetime import datetime, timedelta
    import pytz
    
    current_manager = current_user
    employee = Manager.query.get_or_404(manager_id)
    
    role = current_manager.org_role
    can_view_all = role.can_view_all_deals if role else False
    can_view_dept = role.can_view_department_deals if role else False
    
    if not can_view_all and employee.id != current_manager.id:
        if can_view_dept and current_manager.department_id:
            dept = Department.query.get(current_manager.department_id)
            dept_ids = dept.get_all_manager_ids() if dept else [current_manager.id]
            if employee.id not in dept_ids:
                flash('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–æ—Ñ–∏–ª—é —ç—Ç–æ–≥–æ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞', 'error')
                return redirect(url_for('manager_employees'))
        elif not can_view_dept or not current_manager.department_id:
            flash('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –ø—Ä–æ—Ñ–∏–ª—é —ç—Ç–æ–≥–æ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞', 'error')
            return redirect(url_for('manager_employees'))
    
    emp_role = employee.org_role.name if employee.org_role else (employee.position or '–ú–µ–Ω–µ–¥–∂–µ—Ä')
    emp_department = employee.department.name if employee.department else None
    
    msk = pytz.timezone('Europe/Moscow')
    now_msk = datetime.now(msk)
    today_start = now_msk.replace(hour=0, minute=0, second=0, microsecond=0)
    
    checkin = ManagerCheckin.query.filter(
        ManagerCheckin.manager_id == employee.id,
        ManagerCheckin.check_in_time >= today_start.astimezone(pytz.utc).replace(tzinfo=None)
    ).order_by(ManagerCheckin.check_in_time.desc()).first()
    is_online = checkin is not None and checkin.check_out_time is None
    
    active_deals = Deal.query.filter(
        Deal.manager_id == employee.id,
        ~Deal.status.in_(['completed', 'successful', 'rejected', 'cancelled'])
    ).count()
    completed_deals = Deal.query.filter(
        Deal.manager_id == employee.id,
        Deal.status.in_(['completed', 'successful'])
    ).count()
    clients = User.query.filter_by(assigned_manager_id=employee.id).count()
    pending_tasks = DealTask.query.join(Deal).filter(
        Deal.manager_id == employee.id,
        DealTask.is_completed == False
    ).count()
    
    stats = {
        'active_deals': active_deals,
        'completed_deals': completed_deals,
        'clients': clients,
        'pending_tasks': pending_tasks
    }
    
    subordinates = []
    if employee.department_id:
        dept = Department.query.get(employee.department_id)
        if dept and dept.head_manager_id == employee.id:
            subordinates = Manager.query.filter(
                Manager.department_id == employee.department_id,
                Manager.id != employee.id,
                Manager.is_active == True
            ).all()
    
    supervisor = None
    if employee.department_id:
        dept = Department.query.get(employee.department_id)
        if dept and dept.head_manager_id and dept.head_manager_id != employee.id:
            supervisor = Manager.query.get(dept.head_manager_id)
    
    recent_activities = []
    week_ago = datetime.utcnow() - timedelta(days=7)
    histories = DealHistory.query.join(Deal).filter(
        Deal.manager_id == employee.id,
        DealHistory.created_at >= week_ago
    ).order_by(DealHistory.created_at.desc()).limit(10).all()
    for h in histories:
        recent_activities.append({
            'action': h.action,
            'description': h.description,
            'created_at': h.created_at
        })
    
    sidebar_links, user_profile = get_manager_sidebar_data(current_manager, active_page='employees')
    
    return render_template('manager/employee_profile.html',
                         employee=employee,
                         emp_role=emp_role,
                         emp_department=emp_department,
                         is_online=is_online,
                         stats=stats,
                         subordinates=subordinates,
                         supervisor=supervisor,
                         recent_activities=recent_activities,
                         sidebar_links=sidebar_links,
                         user_profile=user_profile)
