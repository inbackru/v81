import os
import nearby_places
import json
import logging
import requests
import traceback

from types import SimpleNamespace
# Configure logging for debugging PDF generation
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

from flask import Flask, render_template, request, jsonify, redirect, url_for, flash, session, abort, Blueprint, send_from_directory, send_file, make_response
from sqlalchemy import text, func
from flask_login import LoginManager, login_user, logout_user, login_required, current_user
from werkzeug.utils import secure_filename
from flask_wtf.csrf import CSRFProtect, validate_csrf
from werkzeug.exceptions import BadRequest

# Configure CSRF protection - ENABLED for security

# Import smart search
from smart_search import smart_search
import math
from urllib.parse import unquote, quote
from datetime import datetime
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import DeclarativeBase
from werkzeug.middleware.proxy_fix import ProxyFix
import secrets
import threading
import time
import atexit
import glob
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
import re
from email_service import send_notification, send_email
from services.geocoding import get_geocoding_service
from services.dadata_client import get_dadata_client
from flask_caching import Cache
from services.alert_service import AlertService
import qrcode
from seo_redirects import get_redirect_city_slug, redirect_to_city_based, get_city_slug_for_resource
import io
import base64
from PIL import Image

# Models and repositories will be imported after db initialization to avoid circular imports


# Import unified transliteration functions
from utils.transliteration import create_slug, create_complex_slug, create_developer_slug
def parse_address_components(address_display_name):
    """
    ИСПРАВЛЕННАЯ ФУНКЦИЯ: Парсит адрес в формате: Россия, Краснодарский край, Сочи, Кудепста м-н, Искры, 88 лит7
    Возвращает словарь с компонентами адреса
    """
    # ПОЛНАЯ ИНИЦИАЛИЗАЦИЯ РЕЗУЛЬТАТА
    result = {
        'country': None,
        'region': None, 
        'city': None,
        'district': None,
        'street': None,
        'house_number': None
    }
    
    if not address_display_name:
        return result
    
    # РАЗБИВАЕМ АДРЕС ПО ЗАПЯТЫМ
    parts = [part.strip() for part in address_display_name.split(',')]
    
    # ПРЯМОЕ ЗАПОЛНЕНИЕ ОСНОВНЫХ ЧАСТЕЙ
    if len(parts) >= 1:
        result['country'] = parts[0]  # Россия
        
    if len(parts) >= 2:
        result['region'] = parts[1]   # Краснодарский край
        
    if len(parts) >= 3:
        result['city'] = parts[2]     # Сочи
        
    # ОБРАБАТЫВАЕМ ОСТАВШИЕСЯ ЧАСТИ (район, улица, дом)
    if len(parts) >= 4:
        remaining_parts = parts[3:]  # ['Дагомыс', 'Российская', '26г стр']
        
        if len(remaining_parts) == 1:
            # Одна часть: может быть район или улица
            part = remaining_parts[0]
            if any(marker in part for marker in ['м-н', 'микрорайон', 'ЖК', 'жилой комплекс']):
                result['district'] = part
            else:
                result['street'] = part
                
        elif len(remaining_parts) == 2:
            # Две части: район+улица или улица+дом
            first_part, second_part = remaining_parts[0], remaining_parts[1]
            
            if any(marker in first_part for marker in ['м-н', 'микрорайон']):
                result['district'] = first_part
                result['street'] = second_part
            else:
                result['street'] = first_part
                result['house_number'] = second_part
                
        elif len(remaining_parts) == 3:
            # Три части: район, улица, дом
            result['district'] = remaining_parts[0]
            result['street'] = remaining_parts[1]
            result['house_number'] = remaining_parts[2]
            
        elif len(remaining_parts) >= 4:
            # Больше трех частей: район, улица, дом (остальное объединяем в дом)
            result['district'] = remaining_parts[0]
            result['street'] = remaining_parts[1]
            result['house_number'] = ', '.join(remaining_parts[2:])
    
    return result

def resolve_city_context(city_id=None, city_slug=None, default_if_none=True):
    """
    Resolve city context with priority order.
    
    Priority order:
        1. city_id parameter (explicit override)
        2. city_slug parameter (explicit override)
        3. session['city_id'] (user's selected city)
        4. default city (fallback if default_if_none=True)
    
    Args:
        city_id: Integer city ID
        city_slug: String city slug (e.g., 'krasnodar', 'sochi')
        default_if_none: If True, return default city when no params provided
        
    Returns:
        City: City model instance (NOT dict) with attributes: id, name, slug
        None: If city not found and default_if_none is False
        
    Examples:
        resolve_city_context(city_id=1) -> City(id=1, name='Краснодар', ...)
        resolve_city_context(city_slug='sochi') -> City(id=2, name='Сочи', ...)
        resolve_city_context() -> City from session or default (Краснодар)
    """
    from models import City
    
    city = None
    
    # Try to find city by ID
    if city_id:
        try:
            city = City.query.filter_by(id=int(city_id), is_active=True).first()
        except (ValueError, TypeError):
            pass
    
    # Try to find city by slug
    if not city and city_slug:
        city = City.query.filter_by(slug=city_slug, is_active=True).first()
    
    # Try session (user's selected city)
    if not city and 'city_id' in session:
        try:
            city = City.query.filter_by(id=session['city_id'], is_active=True).first()
        except (KeyError, ValueError, TypeError):
            pass
    
    # Fallback to default city if requested
    if not city and default_if_none:
        city = City.query.filter_by(is_default=True, is_active=True).first()
    
    # Return City model directly (NOT dict)
    return city

# DEPRECATED: Legacy function for excel_properties table - not used with normalized Property model
# def update_parsed_addresses():
#     """
#     DEPRECATED: Обновляет ВСЕ поля parsed_* для всех записей в базе данных
#     на основе address_display_name
#     
#     NOTE: This function is no longer used with the normalized Property model.
#     Address parsing is handled directly in Property model fields.
#     """
#     pass

class Base(DeclarativeBase):
    pass

db = SQLAlchemy(model_class=Base)

# Create the app
app = Flask(__name__)
app.secret_key = os.environ.get("SESSION_SECRET")
app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)

# SEO: Production canonical base URL (always HTTPS)
CANONICAL_BASE_URL = 'https://inback.ru'

# Initialize CSRF protection after app creation - ENABLED FOR SECURITY
csrf = CSRFProtect(app)

# CSRF configuration (object defined at top of file)
app.config['WTF_CSRF_TIME_LIMIT'] = 3600  # 1 hour
app.config['WTF_CSRF_SSL_STRICT'] = False  # Allow non-HTTPS for development


# ==========================================
# COMPREHENSIVE SECURITY CONFIGURATION  
# ==========================================
# Initialize advanced security features:
# - Rate Limiting (DDoS protection)
# - Security Headers (XSS, Clickjacking protection)
# - Content Security Policy
# - Additional hardening measures
try:
    from security_config import init_security
    limiter, talisman = init_security(app)
    print("✅ Advanced security features initialized successfully")
except Exception as e:
    print(f"⚠️  Warning: Could not initialize advanced security: {e}")
    limiter = None
    talisman = None
# ИСПРАВЛЕНО (22.10.2025): Добавляем hasattr в Jinja2 для проверки типов пользователей
app.jinja_env.globals['hasattr'] = hasattr

# Add CSRF token to template context - ENABLED
@app.context_processor
def inject_csrf_token():
    from flask_wtf.csrf import generate_csrf
    return dict(csrf_token=generate_csrf)

def validate_json_csrf():
    """Validate CSRF token for JSON requests"""
    try:
        # For JSON requests, expect CSRF token in X-CSRFToken header
        token = request.headers.get('X-CSRFToken')
        if not token:
            return False
        validate_csrf(token)
        return True
    except Exception as e:
        return False

def require_json_csrf(f):
    """Decorator to require CSRF protection for JSON endpoints"""
    from functools import wraps
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Check CSRF for all dangerous HTTP methods with JSON content
        if request.method in ['POST', 'PUT', 'PATCH', 'DELETE'] and request.is_json:
            if not validate_json_csrf():
                return jsonify({'success': False, 'error': 'CSRF token missing or invalid'}), 400
        return f(*args, **kwargs)
    return decorated_function

# Русские названия месяцев для локализации
RUSSIAN_MONTHS = {
    1: 'января', 2: 'февраля', 3: 'марта', 4: 'апреля',
    5: 'мая', 6: 'июня', 7: 'июля', 8: 'августа',
    9: 'сентября', 10: 'октября', 11: 'ноября', 12: 'декабря'
}

@app.template_filter('russian_date')
def russian_date_filter(date_value):
    """Форматирует дату на русском языке"""
    if not date_value:
        return 'Недавно'
    
    if isinstance(date_value, str):
        return date_value
    
    day = date_value.day
    month = RUSSIAN_MONTHS.get(date_value.month, date_value.strftime('%B'))
    year = date_value.year
    
    return f"{day} {month} {year}"

@app.template_filter('msk_time')
def msk_time_filter(utc_datetime, format='%d.%m.%Y в %H:%M'):
    """Конвертирует UTC время в московское (MSK = UTC+3) и форматирует"""
    if not utc_datetime:
        return 'Недавно'
    
    if isinstance(utc_datetime, str):
        return utc_datetime
    
    from datetime import timedelta
    # Конвертируем UTC в MSK (UTC+3)
    msk_datetime = utc_datetime + timedelta(hours=3)
    return msk_datetime.strftime(format)

# Настройка супер-производительного кэширования
app.config['CACHE_TYPE'] = 'simple'
app.config['CACHE_DEFAULT_TIMEOUT'] = 300  # 5 минут
cache = Cache(app)

# Session configuration for Replit iframe environment
app.config['SESSION_COOKIE_HTTPONLY'] = True
# Session configuration for development
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'  # Changed from None for better compatibility
app.config['SESSION_COOKIE_SECURE'] = False  # Changed to False for HTTP development
app.config['PERMANENT_SESSION_LIFETIME'] = 60 * 60 * 24 * 30  # 30 days
app.config['SESSION_COOKIE_HTTPONLY'] = True  # Security: prevent JS access to cookies
app.config['WTF_CSRF_TIME_LIMIT'] = 3600  # 1 hour CSRF token timeout
app.config['WTF_CSRF_SSL_STRICT'] = False  # Allow development over HTTP
app.config['SESSION_PERMANENT'] = True  # Make sessions permanent by default

# Enable permanent sessions by default
from datetime import timedelta
app.permanent_session_lifetime = timedelta(days=30)

# Configure the database
app.config["SQLALCHEMY_DATABASE_URI"] = os.environ.get("DATABASE_URL", "sqlite:///properties.db")
app.config["SQLALCHEMY_ENGINE_OPTIONS"] = {
    "pool_recycle": 300,
    "pool_pre_ping": True,
}

# Configure file uploads
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size
app.config['UPLOAD_FOLDER'] = os.path.join('static', 'uploads')

# Ensure upload directory exists
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

# Add route for uploaded files

# ========================================
# HELPER: Smart Property ID Resolution
# ========================================
def resolve_property_by_identifier(identifier):
    """
    Resolve property by identifier - handles both inner_id (string) and database ID (int).
    
    This is needed because:
    - JavaScript sends inner_id in URLs (e.g., "1999611557")
    - CollectionProperty.property_id contains MIXED types (old: database IDs, new: inner_ids)
    
    Returns:
        tuple: (Property object, canonical_identifier_for_collection_property)
        Returns (None, None) if not found
    
    Usage:
        property_obj, canonical_id = resolve_property_by_identifier(property_id)
        if not property_obj:
            return error_response()
    """
    from models import Property as PropertyModel
    
    # Try as inner_id first (most common case from frontend)
    property_obj = PropertyModel.query.filter_by(inner_id=str(identifier)).first()
    if property_obj:
        print(f"DEBUG: ✅ Found property by inner_id: {identifier}")
        return property_obj, str(property_obj.inner_id)
    
    # If not found, try as database ID (legacy data)
    try:
        db_id = int(identifier)
        property_obj = PropertyModel.query.get(db_id)
        if property_obj:
            print(f"DEBUG: ✅ Found property by database ID: {db_id} (inner_id: {property_obj.inner_id})")
            return property_obj, str(property_obj.inner_id)
    except (ValueError, TypeError):
        pass
    
    print(f"DEBUG: ❌ Property not found: {identifier} (tried inner_id and database ID)")
    return None, None

@app.route('/uploads/<path:filename>')
def uploaded_file(filename):
    """Serve uploaded files"""
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

# Initialize the app with the extension
db.init_app(app)

# Import and register all models with SQLAlchemy after db initialization
with app.app_context():
    # Import all models explicitly to ensure they are registered with SQLAlchemy
    from models import (User, Manager, SavedSearch, SentSearch, PropertyAlert, BlogPost, BlogArticle, Category, 
                       Developer, ResidentialComplex, CashbackRecord, 
                       Application, Favorite, Notification, District, Street, RoomType, 
                       Admin, City, Region, Offer, MarketingMaterial)
    # db.create_all()  # Disabled - database already migrated
    print("Database tables created successfully!")

# Import repositories after db initialization to avoid circular imports
from repositories.property_repository import PropertyRepository, ResidentialComplexRepository, DeveloperRepository

# Import Manager and Admin for isinstance checks throughout the file
from models import Manager, Admin

# Add Jinja2 helper for creating slugs
@app.template_filter('slug')
def create_slug_filter(name):
    """Jinja2 filter for creating SEO-friendly slug from complex name"""
    return create_slug(name)

# Create API blueprint without login requirement
api_bp = Blueprint('api', __name__, url_prefix='/api')

# Debug endpoint removed for security - exposed session data

@api_bp.route('/properties/filter')
def api_properties_filter():
    """
    ✅ MIGRATED TO NORMALIZED TABLES (Property → ResidentialComplex → Developer)
    Unified API endpoint for filtering properties.
    Supports pagination, sorting, and returns properties with coordinates for map.
    
    Query parameters:
        - All filter parameters from build_property_filters()
        - page (int): Page number (default: 1)
        - per_page (int): Results per page (default: 20, max: 100)
        - sort (str): Sort type (price_asc, price_desc, area_asc, area_desc, date_desc)
    
    Returns:
        JSON with:
        - success (bool)
        - properties (list): Filtered properties with coordinates
        - total (int): Total count of filtered properties
        - page (int): Current page
        - per_page (int): Results per page
        - total_pages (int): Total pages
    """
    try:
        # Use unified filter function to parse request arguments
        where_conditions, params, filters_parsed = build_property_filters(request.args)
        
        # Convert build_property_filters() output to PropertyRepository filter format
        repo_filters = {
            'min_price': params.get('price_min'),
            'max_price': params.get('price_max'),
            'min_area': params.get('area_min'),
            'max_area': params.get('area_max'),
            'floor_min': params.get('floor_min'),
            'floor_max': params.get('floor_max'),
            'building_floors_min': params.get('building_floors_min'),
            'building_floors_max': params.get('building_floors_max'),
            'rooms': filters_parsed.get('rooms', []),
            'developer': filters_parsed.get('developer'),
            'developers': filters_parsed.get('developers', []),
            'district': filters_parsed.get('district'),
            'districts': filters_parsed.get('districts', []),
            'residential_complex': filters_parsed.get('residential_complex'),
            'building': filters_parsed.get('building'),
            'cashback_only': filters_parsed.get('cashback_only', False),
            'renovation': filters_parsed.get('renovation', []),
            'object_classes': filters_parsed.get('object_classes', []),
            'building_types': filters_parsed.get('building_types', []),
            'floor_options': filters_parsed.get('floor_options', []),
            'deal_type': filters_parsed.get('deal_type'),
            'search': filters_parsed.get('search')
        }
        
        # Remove None values from filters
        repo_filters = {k: v for k, v in repo_filters.items() if v is not None and v != [] and v != ''}
        
        # Pagination parameters
        page = request.args.get('page', default=1, type=int)
        page = max(1, page)
        per_page = request.args.get('per_page', default=20, type=int)
        per_page = min(max(1, per_page), 10000)  # Limit to 10000 max (for map view)
        offset = (page - 1) * per_page
        
        # Sorting
        sort_type = request.args.get('sort', 'price_asc').replace('_', '-').replace('-', '_')
        sort_by = 'price'
        sort_order = 'asc'
        
        if sort_type == 'price_desc':
            sort_by, sort_order = 'price', 'desc'
        elif sort_type == 'price_asc':
            sort_by, sort_order = 'price', 'asc'
        elif sort_type == 'area_asc':
            sort_by, sort_order = 'area', 'asc'
        elif sort_type == 'area_desc':
            sort_by, sort_order = 'area', 'desc'
        elif sort_type == 'date_desc':
            sort_by, sort_order = 'date', 'desc'
        
        # Get total count using PropertyRepository
        total = PropertyRepository.count_active(filters=repo_filters)
        
        # Get properties using PropertyRepository
        properties_orm = PropertyRepository.get_all_active(
            limit=per_page,
            offset=offset,
            filters=repo_filters,
            sort_by=sort_by,
            sort_order=sort_order
        )
        
        # Format properties for JSON response (maintain backward compatibility)
        properties = []
        for prop in properties_orm:
            # Parse gallery images
            main_image = 'https://via.placeholder.com/400x300?text=No+Photo'
            gallery = [main_image]
            
            if prop.gallery_images:
                try:
                    photos_raw = json.loads(prop.gallery_images)
                    if photos_raw and isinstance(photos_raw, list) and len(photos_raw) > 0:
                        main_image = photos_raw[0]
                        gallery = photos_raw[:5]
                except:
                    pass
            elif prop.main_image:
                main_image = prop.main_image
                gallery = [main_image]
            
            # Format room type
            rooms = int(prop.rooms or 0)
            room_type = "Студия" if rooms == 0 else f"{rooms}-комн"
            
            # Format floor info
            floor = int(prop.floor or 1)
            total_floors = int(prop.total_floors or floor)
            floor_text = f"{floor}/{total_floors}"
            
            # Get cashback rate from residential complex
            cashback_rate = None
            if prop.residential_complex:
                cashback_rate = float(prop.residential_complex.cashback_rate) if prop.residential_complex.cashback_rate else None
            
            # Build property object
            prop_dict = {
                'id': prop.inner_id or str(prop.id),
                'price': int(prop.price or 0),
                'area': float(prop.area or 0),
                'rooms': rooms,
                'floor': floor,
                'total_floors': total_floors,
                'room_type': room_type,
                'floor': floor_text,
                'floor_min': floor,
                'floor_max': total_floors,
                'title': f"{room_type}, {prop.area} м²",
                'address': prop.address or '',
                'complex_name': prop.residential_complex.name if prop.residential_complex else '',
                'residential_complex': prop.residential_complex.name if prop.residential_complex else '',
                'developer': prop.developer.name if prop.developer else '',
                'district': prop.district.name if prop.district else '',
                'image': main_image,
                'gallery': gallery,
                'object_class': '',  # Can add if needed
                'renovation': PropertyRepository.get_renovation_display_name(prop.renovation_type),
                'cashback_rate': cashback_rate,
                'cashback_available': bool(cashback_rate and cashback_rate > 0),
                'url': f'/object/{prop.inner_id or prop.id}',
                # Coordinates for map
                'lat': float(prop.latitude) if prop.latitude else None,
                'lon': float(prop.longitude) if prop.longitude else None,
                'coordinates': {
                    'lat': float(prop.latitude) if prop.latitude else None,
                    'lng': float(prop.longitude) if prop.longitude else None
                } if prop.latitude and prop.longitude else None
            }
            
            properties.append(prop_dict)
        
        total_pages = (total + per_page - 1) // per_page if total > 0 else 0
        
        return jsonify({
            'success': True,
            'properties': properties,
            'total': total,
            'page': page,
            'per_page': per_page,
            'total_pages': total_pages,
            'filters_applied': filters_parsed
        })
        
    except Exception as e:
        print(f"❌ Error in /api/properties/filter: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e),
            'properties': [],
            'total': 0
        }), 500

@api_bp.route('/property/<int:property_id>/cashback')
def api_property_cashback(property_id):
    """✅ MIGRATED - Get cashback information using PropertyRepository"""
    try:
        # Get property using PropertyRepository
        prop = PropertyRepository.get_by_id(property_id)
        
        if not prop:
            return jsonify({'success': False, 'error': 'Property not found'})
        
        # Extract data from Property model
        price = int(prop.price or 0)
        rooms = int(prop.rooms or 0)
        complex_name = prop.residential_complex.name if prop.residential_complex else "Не указан"
        
        # Get cashback rate from ResidentialComplex
        cashback_percent = 0
        if prop.residential_complex and prop.residential_complex.cashback_rate:
            cashback_percent = float(prop.residential_complex.cashback_rate)
        
        # Calculate cashback amount
        cashback_amount = price * (cashback_percent / 100)
        
        # Format property name
        room_text = f"{rooms}-комнатная квартира" if rooms > 0 else "Студия"
        property_name = f"{room_text} в ЖК «{complex_name}»"
        
        return jsonify({
            'success': True,
            'property_id': property_id,
            'property_name': property_name,
            'property_price': price,
            'cashback_percent': cashback_percent,
            'cashback_amount': int(cashback_amount),
            'complex_name': complex_name,
            'rooms': rooms
        })
        
    except Exception as e:
        print(f"Error getting property cashback: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': 'Server error'})

# Custom Jinja2 filters
def street_slug(street_name):
    """Convert street name to URL slug with transliteration"""
    import re
    
    # Transliteration mapping for Russian to Latin
    translit_map = {
        'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'yo',
        'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm',
        'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
        'ф': 'f', 'х': 'kh', 'ц': 'ts', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
        'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'
    }
    
    # Clean the name
    name = str(street_name).strip().lower()
    # Remove extra characters
    name = re.sub(r'[«»"\(\)\.,:;]', '', name)
    
    # Transliterate
    result = ''
    for char in name:
        result += translit_map.get(char, char)
    
    # Replace spaces with hyphens and clean up
    result = re.sub(r'\s+', '-', result)
    result = re.sub(r'-+', '-', result)
    result = result.strip('-')
    
    return result

def number_format(value):
    """Format number with space separators"""
    try:
        if isinstance(value, str):
            value = int(value)
        return f"{value:,}".replace(',', ' ')
    except (ValueError, TypeError):
        return str(value)

@app.template_filter('developer_slug')
def developer_slug(developer_name):
    """Convert developer name to URL slug with transliteration"""
    import re
    if not developer_name:
        return ""
    
    # Transliteration mapping for Russian to Latin
    translit_map = {
        'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'yo',
        'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm',
        'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
        'ф': 'f', 'х': 'kh', 'ц': 'ts', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
        'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya',
        'А': 'A', 'Б': 'B', 'В': 'V', 'Г': 'G', 'Д': 'D', 'Е': 'E', 'Ё': 'YO',
        'Ж': 'ZH', 'З': 'Z', 'И': 'I', 'Й': 'Y', 'К': 'K', 'Л': 'L', 'М': 'M',
        'Н': 'N', 'О': 'O', 'П': 'P', 'Р': 'R', 'С': 'S', 'Т': 'T', 'У': 'U',
        'Ф': 'F', 'Х': 'KH', 'Ц': 'TS', 'Ч': 'CH', 'Ш': 'SH', 'Щ': 'SCH',
        'Ъ': '', 'Ы': 'Y', 'Ь': '', 'Э': 'E', 'Ю': 'YU', 'Я': 'YA'
    }
    
    # Remove extra spaces and clean
    name = str(developer_name).strip()
    # Remove quotes, parentheses, dots, commas
    name = re.sub(r'[«»"\(\)\.,:;]', '', name)  
    
    # Transliterate cyrillic to latin
    result = ''
    for char in name:
        result += translit_map.get(char, char)
    
    # Replace spaces with hyphens and clean up
    result = re.sub(r'\s+', '-', result)  # Replace spaces with hyphens
    result = re.sub(r'-+', '-', result)   # Replace multiple hyphens with single
    result = result.strip('-')  # Remove leading/trailing hyphens
    return result.lower()

@app.template_filter('from_json')
def from_json_filter(json_string):
    """Парсит JSON строку в объект Python"""
    if not json_string:
        return []
    try:
        if isinstance(json_string, str):
            return json.loads(json_string)
        return json_string
    except (json.JSONDecodeError, TypeError):
        return []

@app.template_filter('crop_watermark')
def crop_watermark_filter(image_url, crop_percent=8):
    """
    Convert image URL to proxied URL with watermark cropped
    Usage in template: {{ image_url | crop_watermark(10) }}
    """
    if not image_url:
        return image_url
    
    from urllib.parse import quote
    encoded_url = quote(image_url, safe='')
    return f"/api/image-proxy?url={encoded_url}&crop={crop_percent}"

def format_room_display(rooms):
    """Format room count for display"""
    if rooms == 0:
        return "Студия"
    else:
        return f"{rooms}-комнатная квартира"

app.jinja_env.filters['street_slug'] = street_slug
app.jinja_env.filters['number_format'] = number_format
app.jinja_env.filters['developer_slug'] = developer_slug

# Initialize Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'  # type: ignore
login_manager.login_message = 'Войдите в аккаунт для доступа к этой странице.'
login_manager.login_message_category = 'info'



# Property data loading functions with cache
_properties_cache = None
_cache_timestamp = None
CACHE_TIMEOUT = 300  # 5 minutes

def load_properties():
    """✅ MIGRATED TO NORMALIZED TABLES: Load properties from Property → ResidentialComplex → Developer"""
    global _properties_cache, _cache_timestamp
    import time
    
    # Check if we have valid cached data
    if (_properties_cache is not None and _cache_timestamp is not None and 
        time.time() - _cache_timestamp < CACHE_TIMEOUT):
        # Cache hit - fast path
        return _properties_cache
    
    # Ensure we have app context
    from flask import has_app_context
    if not has_app_context():
        with app.app_context():
            return load_properties()
    
    try:
        # ✅ MIGRATED: Load from normalized tables using PropertyRepository
        properties = PropertyRepository.get_all_active(
            limit=500,  # ⚡ OPTIMIZED: Reduced from 10000
            filters={'min_price': 1},  # price > 0
            sort_by='price',
            sort_order='asc'
        )
        
        excel_properties = properties
        
        if excel_properties and len(excel_properties) > 0:
            # ✅ MIGRATED: No need for max_floors query, data is in normalized tables
            
            # Convert Property ORM objects to dictionary format (backward compatibility)
            db_properties = []
            for prop in excel_properties:
                # Convert ORM object to dict-like structure
                # Property has relationships: residential_complex, developer, district
                complex_obj = prop.residential_complex
                developer_obj = prop.developer
                district_obj = prop.district
                
                prop_dict = {
                    'inner_id': prop.inner_id,
                    'complex_name': complex_obj.name if complex_obj else 'ЖК Без названия',
                    'developer_name': developer_obj.name if developer_obj else 'Не указан',
                    'object_rooms': prop.rooms,
                    'object_area': prop.area,
                    'price': prop.price,
                    'object_min_floor': prop.floor,
                    'object_max_floor': prop.total_floors,
                    'address_display_name': prop.address,
                    'address_position_lat': prop.latitude,
                    'address_position_lon': prop.longitude,
                    'address_locality_display_name': district_obj.name if district_obj else '',
                    'photos': prop.gallery_images or '[]',
                    'complex_object_class_display_name': complex_obj.object_class_display_name if complex_obj else '',
                    'renovation_type': prop.renovation_type,
                    'renovation_display_name': PropertyRepository.get_renovation_display_name(prop.renovation_type),
                    'complex_with_renovation': bool(prop.renovation_type),
                    'complex_building_end_build_year': complex_obj.end_build_year if complex_obj else None,
                    'complex_building_end_build_quarter': complex_obj.end_build_quarter if complex_obj else None,
                    'complex_building_name': prop.complex_building_name,
                    'address_subways': None,
                    'trade_in': False,  # Not in Property model yet
                    'deal_type': prop.deal_type,
                    'square_price': prop.price_per_sqm,
                    'mortgage_price': None,  # Not in Property model yet
                    'object_is_apartment': True,
                    'max_price': prop.price,
                    'min_price': prop.price,
                    'complex_has_green_mortgage': False,  # Not in Property model yet
                    'placement_type': '',  # Not in Property model yet
                    'description': prop.description,
                    'parsed_district': district_obj.name if district_obj else '',
                    'parsed_city': 'Краснодар',  # Default city
                    'city_id': prop.city_id,  # Multi-city support
                    'complex_id': prop.complex_id,
                    'complex_min_rate': complex_obj.cashback_rate if complex_obj else 0
                }
                
                # Parse photos field (JSON array format)
                photos_raw = prop_dict.get('photos', '')
                main_image = '/static/images/no-photo.jpg'
                
                if photos_raw and photos_raw.strip():
                    try:
                        # Try to parse as JSON array first (current database format)
                        if photos_raw.startswith('[') and photos_raw.endswith(']'):
                            images = json.loads(photos_raw)
                            if images and isinstance(images, list) and len(images) > 0:
                                main_image = images[0].strip() if images[0] else '/static/images/no-photo.jpg'
                        # Fallback: PostgreSQL array format {url1,url2,url3}
                        elif photos_raw.startswith('{') and photos_raw.endswith('}'):
                            images_str = photos_raw[1:-1]  # Remove braces
                            if images_str:
                                images = [img.strip().strip('"') for img in images_str.split(',') if img.strip()]
                                main_image = images[0] if images else '/static/images/no-photo.jpg'
                        # Single image URL
                        else:
                            main_image = photos_raw.strip()
                    except (json.JSONDecodeError, ValueError, IndexError) as e:
                        print(f"Error parsing photos for property {prop_dict.get('inner_id')}: {e}")
                        main_image = '/static/images/no-photo.jpg'
                
                # ✅ MIGRATED: Get total floors directly from Property object (already in normalized tables)
                complex_total_floors = prop_dict.get('object_max_floor', 1)
                
                # Format property data  
                rooms = prop_dict.get('object_rooms', 0)
                area = prop_dict.get('object_area', 0) 
                floor = prop_dict.get('object_min_floor') or '—'
                
                # Format floor display (handle None values)
                if floor != '—' and complex_total_floors and complex_total_floors != 1:
                    floor_display = f"{floor}/{complex_total_floors} эт."
                elif floor != '—':
                    floor_display = f"{floor} эт."
                else:
                    floor_display = "Этаж не указан"
                
                # Create title with proper format: "Студия, 23.40 м², 1/12 эт."
                if rooms == 0:
                    title = f"Студия, {area} м², {floor_display}"
                else:
                    title = f"{rooms}-комн, {area} м², {floor_display}"
                
                # Enhanced completion date from building data
                completion_date = 'Не указана'
                if prop_dict.get('complex_building_end_build_year') and prop_dict.get('complex_building_end_build_quarter'):
                    year = prop_dict.get('complex_building_end_build_year')
                    quarter = prop_dict.get('complex_building_end_build_quarter')
                    completion_date = f"{quarter} кв. {year} г."
                elif prop_dict.get('complex_building_end_build_year'):
                    year = prop_dict.get('complex_building_end_build_year')  
                    completion_date = f"{year} г."
                
                # Enhanced finishing information
                finishing = prop_dict.get('renovation_display_name') or prop_dict.get('renovation_type', 'Не указана')
                if prop_dict.get('complex_with_renovation'):
                    finishing = finishing if finishing != 'Не указана' else 'С отделкой'
                
                formatted_prop = {
                    'id': prop_dict.get('inner_id'),
                    'title': title,
                    'rooms': prop_dict.get('object_rooms', 0),
                    'area': prop_dict.get('object_area', 0),
                    'price': prop_dict.get('price', 0),
                    # Use database square_price if available, fallback to calculation
                    'price_per_sqm': prop_dict.get('square_price') or (int(prop_dict.get('price', 0) / prop_dict.get('object_area', 1)) if prop_dict.get('object_area', 0) > 0 else 0),
                    'floor': prop_dict.get('object_min_floor', 1),
                    'total_floors': complex_total_floors,
                    'address': prop_dict.get('address_display_name', ''),
                    'coordinates': {
                        'lat': float(prop_dict.get('address_position_lat') or 45.0448),
                        'lng': float(prop_dict.get('address_position_lon') or 38.9728)
                    },
                    'cashback': calculate_cashback(
                        prop_dict.get('price', 0),
                        complex_id=prop_dict.get('complex_id'),
                        complex_name=prop_dict.get('complex_name')
                    ),
                    'cashback_rate': float(prop_dict.get('complex_min_rate', 0)) if prop_dict.get('complex_min_rate') else 0,
                    'cashback_available': True,
                    'status': 'available',
                    'property_type': 'Квартира' if prop_dict.get('object_is_apartment', True) else 'Недвижимость',
                    'developer': prop_dict.get('developer_name', 'Не указан'),
                    'residential_complex': prop_dict.get('complex_name', 'ЖК Без названия'),
                    'district': prop_dict.get('parsed_district') or prop_dict.get('parsed_city') or prop_dict.get('address_locality_display_name', 'Район не указан'),
                    'main_image': main_image,
                    'url': f"/object/{prop_dict.get('inner_id')}",
                    'complex_name': prop_dict.get('complex_name', 'ЖК Без названия'),
                    'type': 'property',
                    # NEW ENHANCED FIELDS FROM DATABASE:
                    'finishing': finishing,
                    'renovation_type': prop_dict.get('renovation_type'),
                    'completion_date': completion_date,
                    'complex_class': prop_dict.get('complex_object_class_display_name', ''),
                    'building_name': prop_dict.get('complex_building_name', ''),
                    'nearest_metro': prop_dict.get('address_subways', ''),
                    'trade_in_available': bool(prop_dict.get('trade_in', False)),
                    'deal_type': prop_dict.get('deal_type', ''),
                    'mortgage_price': prop_dict.get('mortgage_price'),
                    'max_price': prop_dict.get('max_price'),
                    'min_price': prop_dict.get('min_price'),
                    'green_mortgage_available': bool(prop_dict.get('complex_has_green_mortgage', False)),
                    'placement_type': prop_dict.get('placement_type', ''),
                    'description': prop_dict.get('description', ''),
                    'complex_with_renovation': bool(prop_dict.get('complex_with_renovation', False))
                }
                db_properties.append(formatted_prop)
            
            # Successfully loaded properties from database
            # Cache the data
            _properties_cache = db_properties  
            _cache_timestamp = time.time()
            return db_properties
            
    except Exception as e:
        # Database error logged  
        print(f"CRITICAL: load_properties() database error: {e}")
        import traceback
        traceback.print_exc()
        pass
        
    # No fallback - only database data from now on
    # No properties found
    return []

def load_residential_complexes():
    """Load residential complexes from database enriched with statistics from excel_properties"""
    try:
        # First try to load from database
        from models import ResidentialComplex, Developer, District
        
        complexes = ResidentialComplex.query.all()
        
        if complexes and len(complexes) > 0:
            # Convert database complexes to dictionary format
            db_complexes = []
            
            # Bulk query for available room types (optimize N+1)
            from collections import defaultdict
            rooms_by_complex = defaultdict(list)
            try:
                from models import Property
                
                # Helper function to convert room number to filter format
                def room_number_to_filter(rooms):
                    if rooms == 0:
                        return "студия"
                    elif rooms == 1:
                        return "1-комн"
                    elif rooms == 2:
                        return "2-комн"
                    elif rooms == 3:
                        return "3-комн"
                    elif rooms and rooms >= 4:
                        return "4+-комн"
                    return None
                
                bulk_rooms_query = db.session.query(
                    Property.complex_id,
                    Property.rooms
                ).filter(
                    Property.complex_id.in_([c.id for c in complexes]),
                    Property.is_active == True,
                    Property.rooms.isnot(None)
                ).distinct().all()
                
                for complex_id, room_number in bulk_rooms_query:
                    room_filter = room_number_to_filter(room_number)
                    if room_filter and room_filter not in rooms_by_complex[complex_id]:
                        rooms_by_complex[complex_id].append(room_filter)
                print(f"✅ Loaded room types for {len(rooms_by_complex)} complexes in bulk")
            except Exception as e:
                print(f"⚠️ Could not load room types in bulk: {e}")
                db.session.rollback()
            
            # FOR LOOP OUTSIDE except - process all complexes
            for complex in complexes:
                try:
                    from models import Property
                    stats_query = (
                        db.session.query(
                            func.min(Property.price).label('min_price'),
                            func.max(Property.price).label('max_price'),
                            func.count(Property.id).label('apartments_count')
                        )
                        .filter(Property.complex_id == complex.id, Property.is_active == True)
                        .first()
                    )
                    
                    min_price = stats_query.min_price if stats_query else None
                    max_price = stats_query.max_price if stats_query else None
                    apartments_count = int(stats_query.apartments_count) if stats_query and stats_query.apartments_count else 0
                    
                    # Use bulk query results
                    available_rooms = rooms_by_complex.get(complex.id, [])
                except Exception as e:
                    print(f"Warning: Could not load stats for complex {complex.id}: {e}")
                    db.session.rollback()  # Rollback failed transaction
                    min_price = None
                    max_price = None
                    apartments_count = 0
                    available_rooms = []
                
                complex_dict = {
                    'id': complex.id,
                    'name': complex.name,
                    'slug': complex.slug,
                    'complex_type': complex.complex_type or 'residential',
                    'district': complex.district.name if complex.district else 'Не указан',
                    'district_id': complex.district_id,
                    'developer': complex.developer.name if complex.developer else 'Не указан',
                    'developer_id': complex.developer_id,
                    'cashback_rate': complex.cashback_rate or 5.0,
                    'cashback_percent': complex.cashback_rate or 5.0,
                    'class': complex.object_class_display_name or 'Комфорт',
                    'description': f'ЖК от застройщика {complex.developer.name if complex.developer else "Не указан"}',
                    'start_year': complex.start_build_year,
                    'completion_year': complex.end_build_year,
                    'quarter': complex.end_build_quarter,
                    'features': {
                        'accreditation': complex.has_accreditation,
                        'green_mortgage': complex.has_green_mortgage,
                        'big_check': complex.has_big_check,
                        'with_renovation': complex.with_renovation,
                        'financing_sber': complex.financing_sber,
                    },
                    'phones': {
                        'complex': complex.complex_phone,
                        'sales': complex.sales_phone,
                    },
                    'sales_address': complex.sales_address,
                    'image': 'https://via.placeholder.com/800x600/0088CC/FFFFFF?text=' + complex.name.replace(' ', '+'),  # Placeholder for now
                    'address': complex.sales_address or 'Адрес уточняется',
                    'location': complex.sales_address or 'Краснодар',  # Add missing location field
                    # Add statistics from excel_properties
                    'min_price': min_price,
                    'available_apartments_count': apartments_count,
                    'total_apartments': apartments_count,
                    # Coordinates
                    'latitude': complex.latitude,
                    'longitude': complex.longitude,
                    'coordinates': {
                        'lat': complex.latitude if complex.latitude else 45.0448,
                        'lng': complex.longitude if complex.longitude else 38.9760
                    },
                    # Images
                    'main_image': complex.main_image,
                    'gallery_images': complex.gallery_images,
                    # Status based on completion dates
                    'status': 'Сдан' if complex.end_build_year and complex.end_build_year <= 2024 else ('Строится' if complex.end_build_year else 'Планируется'),
                    # URL
                    'url': f'/residential-complex/{complex.slug}',
                    # Developer name
                    'developer_name': complex.developer.name if complex.developer else 'Не указан',
                    # Additional fields
                    'buildings_count': complex.buildings_count or 1,
                    'price_from': min_price,
                    'max_price': max_price,
                    'price_to': max_price,
                    'apartments_count': apartments_count,
                    'available_rooms': available_rooms,
                    'properties_count': apartments_count,
                }
                db_complexes.append(complex_dict)
            
            # Complexes loaded successfully
            print(f"✅ load_residential_complexes returning {len(db_complexes)} complexes")
            return db_complexes
            
    except Exception as e:
        # Error loading complexes
        print(f"Error in load_residential_complexes: {e}")
        import traceback
        traceback.print_exc()
    
    # No fallback - only database data from now on
    # No complexes found
    return []

def load_blog_articles():
    """Load blog articles from JSON file"""
    try:
        with open('data/blog_articles.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def load_blog_categories():
    """Load blog categories from JSON file"""
    try:
        with open('data/blog_categories.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def load_search_data():
    """Load search data from JSON file"""
    try:
        with open('data/search_data.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def load_streets():
    """Load streets from JSON file"""
    try:
        with open('data/streets.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def load_developers():
    """Load developers from residential complexes data"""
    try:
        complexes = load_residential_complexes()
        developers = {}
        
        for complex in complexes:
            dev_name = complex.get('developer', 'Неизвестный застройщик')
            if dev_name not in developers:
                developers[dev_name] = {
                    'name': dev_name,
                    'projects_count': 0,
                    'complexes': []
                }
            developers[dev_name]['projects_count'] += 1
            developers[dev_name]['complexes'].append(complex['name'])
        
        return list(developers.values())
    except Exception:
        return []

def search_global(query):
    """Global search across all types: ЖК, districts, developers, streets"""
    if not query or len(query.strip()) < 2:
        return []
    
    search_data = load_search_data()
    results = []
    query_lower = query.lower().strip()
    
    # Search through all categories
    for category in ['residential_complexes', 'districts', 'developers', 'streets']:
        items = search_data.get(category, [])
        for item in items:
            # Search in name and keywords
            name_match = query_lower in item['name'].lower()
            keyword_match = any(query_lower in keyword.lower() for keyword in item.get('keywords', []))
            
            if name_match or keyword_match:
                # Calculate relevance score
                score = 0
                if query_lower in item['name'].lower():
                    score += 10  # Higher score for name matches
                if query_lower == item['name'].lower():
                    score += 20  # Even higher for exact matches
                    
                result = {
                    'id': item['id'],
                    'name': item['name'],
                    'type': item['type'],
                    'url': item['url'],
                    'score': score
                }
                
                # Add additional context based on type
                if item['type'] == 'residential_complex':
                    result['district'] = item.get('district', '')
                    result['developer'] = item.get('developer', '')
                elif item['type'] == 'street':
                    result['district'] = item.get('district', '')
                    
                results.append(result)
    
    # Sort by relevance score (highest first)
    results.sort(key=lambda x: x['score'], reverse=True)
    return results[:10]  # Return top 10 results

def get_article_by_slug(slug):
    """Get a single article by slug"""
    articles = load_blog_articles()
    for article in articles:
        if article['slug'] == slug:
            return article
    return None

def search_articles(query, category=None):
    """Search articles by title, excerpt, content, and tags"""
    articles = load_blog_articles()
    if not query and not category:
        return articles
    
    filtered_articles = []
    for article in articles:
        # Filter by category if specified
        if category and article['category'].lower() != category.lower():
            continue
        
        # If no search query, return all articles in category
        if not query:
            filtered_articles.append(article)
            continue
        
        # Search in title, excerpt, content, and tags
        query_lower = query.lower()
        if (query_lower in article['title'].lower() or 
            query_lower in article['excerpt'].lower() or 
            query_lower in article['content'].lower() or 
            any(query_lower in tag.lower() for tag in article['tags'])):
            filtered_articles.append(article)
    
    return filtered_articles

def _extract_first_photo(photos_json):
    """Extract first photo from photos JSON string"""
    if not photos_json:
        return None
    
    try:
        import json
        if isinstance(photos_json, str):
            photos_list = json.loads(photos_json)
        else:
            photos_list = photos_json
            
        return photos_list[0] if photos_list and len(photos_list) > 0 else None
    except:
        return None

def calculate_cashback(price, complex_id=None, complex_name=None):
    """Calculate cashback amount based on property price and complex cashback rate"""
    if not price or price == 0:
        return 0
    
    try:
        from models import ResidentialComplex
        
        # If complex_id provided, use its cashback rate from database (backwards compatibility)
        if complex_id:
            complex_obj = ResidentialComplex.query.filter_by(id=str(complex_id)).first()
            if complex_obj and complex_obj.cashback_rate:
                rate = float(complex_obj.cashback_rate) / 100  # Convert percentage to decimal
                return int(price * rate)
        
        # If complex_name provided, look up by name
        if complex_name:
            complex_obj = ResidentialComplex.query.filter_by(name=complex_name).first()
            if complex_obj and complex_obj.cashback_rate:
                rate = float(complex_obj.cashback_rate) / 100  # Convert percentage to decimal
                return int(price * rate)
    except Exception as e:
        print(f"Error getting complex cashback rate: {e}")
    
    # Fallback to default 5% calculation if no complex found or error
    return int(price * 0.05)  # 5% default cashback

def get_property_by_id(property_id):
    """✅ MIGRATED TO NORMALIZED TABLES: Get property from Property → ResidentialComplex → Developer"""
    try:
        # ✅ MIGRATED: Use PropertyRepository to get property with all relationships
        prop = PropertyRepository.get_by_id(property_id)
        
        if not prop:
            return None
        
        # Extract related objects
        complex_obj = prop.residential_complex
        developer_obj = prop.developer
        district_obj = prop.district
        
        # Map to old variable names for backward compatibility
        inner_id = prop.inner_id
        price = prop.price
        area = prop.area
        rooms = prop.rooms
        min_floor = prop.floor
        max_floor = prop.total_floors
        address = prop.address
        renovation = PropertyRepository.get_renovation_display_name(prop.renovation_type)
        cashback_rate = complex_obj.cashback_rate if complex_obj else 0
        square_price = prop.price_per_sqm
        mortgage_price = None  # Not in Property model yet
        class_type = complex_obj.object_class_display_name if complex_obj else None
        photos = prop.gallery_images
        developer_name = developer_obj.name if developer_obj else None
        complex_name = complex_obj.name if complex_obj else None
        complex_end_year = complex_obj.end_build_year if complex_obj else None
        complex_end_quarter = complex_obj.end_build_quarter if complex_obj else None
        building_end_year = complex_obj.end_build_year if complex_obj else None
        building_end_quarter = complex_obj.end_build_quarter if complex_obj else None
        lat = prop.latitude
        lon = prop.longitude
        description = prop.description
        district_name = district_obj.name if district_obj else None
        
        # Parse photos JSON
        images = []
        floor_plan = None
        complex_photos = []
        
        try:
            if photos:
                photos_data = json.loads(photos)
                if isinstance(photos_data, list):
                    # If it's a simple list of photo URLs (like in this case)
                    images = photos_data
                    # First photo is always the floor plan
                    if len(images) > 0:
                        floor_plan = images[0]  # First image is floor plan
                elif isinstance(photos_data, dict):
                    # Get apartment gallery photos from dict structure
                    images = photos_data.get('apartment_gallery', [])
                    # Get floor plan 
                    floor_plans = photos_data.get('floor_plans', [])
                    if floor_plans and len(floor_plans) > 0:
                        floor_plan = floor_plans[0]  # Take first floor plan
                    # Get complex photos
                    complex_photos = photos_data.get('complex_gallery', [])
        except Exception as e:
            print(f"Error parsing photos for property {property_id}: {e}")
            pass
        
        # Build completion date
        completion_date = 'Уточняется'
        if building_end_year and building_end_quarter:
            completion_date = f"{building_end_year} г., {building_end_quarter} кв."
        elif building_end_year:
            completion_date = f"{building_end_year} г."
        elif complex_end_year:
            completion_date = f"{complex_end_year} г."
        
        # Create property data structure matching PDF template expectations
        property_data = {
            'id': property_id,  # ✅ Database PK для корректного удаления
            'inner_id': inner_id,  # Внешний ID для справки
            'title': f"{'Студия' if rooms == 0 else f'{rooms}-к. квартира'}, {area} м²",
            'price': price or 0,
            'area': area or 0,
            'rooms': rooms or 0,
            'floor': min_floor or 1,
            'total_floors': max_floor or min_floor or 1,
            'address': address or f"{district_name}, Краснодар" if district_name else 'Краснодар',
            'developer': developer_name or 'Не указан',
            'residential_complex': complex_name or 'Не указан',
            'district': district_name or 'Краснодар',
            'status': 'Свободна',
            'property_type': 'Студия' if rooms == 0 else 'Квартира',
            'renovation_type': renovation or 'Уточняется',
            'finishing': renovation or 'Предчистовая',
            'completion_date': completion_date,
            'cashback_rate': cashback_rate or 0,
            'mortgage_rate': f"{cashback_rate}%" if cashback_rate else '3.5%',
            'square_price': square_price,
            'mortgage_payment': mortgage_price,
            'class_type': class_type or 'Не указан',
            'description': description or '',
            'residential_complex_description': f"Современный жилой комплекс от застройщика {developer_name}" if developer_name else None,
            'mortgage_available': True,
            'installment_available': False,
            'cashback_available': True,
            # Photos for PDF
            'image': images[0] if images else None,  # Main photo
            'gallery': images,  # All apartment photos
            'floor_plan': floor_plan,  # Floor plan photo
            'complex_photos': complex_photos,  # Complex photos
            # Additional fields expected by PDF template
            'bathroom_type': 'Совмещенный',
            'has_balcony': True,
            'windows_type': 'Пластиковые', 
            'elevators': '2 пассажирских',
            'parking_type': 'Наземная',
            'developer_inn': 'ИНН не указан',
            'complex_name': complex_name  # Add complex_name for cashback calculation
        }
        
        return property_data
        
    except Exception as e:
        print(f"Error getting property {property_id}: {e}")
        return None

def get_filtered_properties(filters):
    """Filter properties based on criteria including regional filters"""
    properties = load_properties()
    filtered = []
    
    for prop in properties:
        # Keywords filter (для типов недвижимости, классов, материалов)
        if filters.get('keywords') and len(filters['keywords']) > 0:
            keywords_matched = False
            for keyword in filters['keywords']:
                keyword_lower = keyword.lower()
                
                # Check property type
                prop_type_lower = prop.get('property_type', 'Квартира').lower()
                if keyword_lower == 'дом' and prop_type_lower == 'дом':
                    keywords_matched = True
                    break
                elif keyword_lower == 'таунхаус' and prop_type_lower == 'таунхаус':
                    keywords_matched = True
                    break
                elif keyword_lower == 'пентхаус' and prop_type_lower == 'пентхаус':
                    keywords_matched = True
                    break
                elif keyword_lower == 'апартаменты' and prop_type_lower == 'апартаменты':
                    keywords_matched = True
                    break
                elif keyword_lower == 'студия' and (prop_type_lower == 'студия' or prop.get('rooms') == 0):
                    keywords_matched = True
                    break
                elif keyword_lower == 'квартира' and prop_type_lower == 'квартира':
                    keywords_matched = True
                    break
                
                # Check property class
                elif keyword_lower == prop.get('property_class', '').lower():
                    keywords_matched = True
                    break
                
                # Check wall material
                elif keyword_lower in prop.get('wall_material', '').lower():
                    keywords_matched = True
                    break
                
                # Check features
                elif any(keyword_lower in feature.lower() for feature in prop.get('features', [])):
                    keywords_matched = True
                    break
                
                # Check in property type as fallback  
                elif keyword_lower in (f"{prop.get('rooms', 0)}-комн" if prop.get('rooms', 0) > 0 else "студия").lower():
                    keywords_matched = True
                    break
                    
            if not keywords_matched:
                continue
        
        # Text search with improved room number matching and word-based search
        if filters.get('search'):
            search_term = filters['search'].lower()
            
            # Create multiple variations for room descriptions
            rooms = prop.get('rooms', 0)
            if rooms == 0:
                room_variations = ["студия", "studio"]
            else:
                room_variations = [
                    f"{rooms}-комн",
                    f"{rooms}-комнатная",
                    f"{rooms} комн",
                    f"{rooms} комнатная"
                ]
                
                # Add spelled out numbers for 1-3 rooms
                if rooms == 1:
                    room_variations.extend(["однокомнатная", "1-комнатная", "одна комната"])
                elif rooms == 2:
                    room_variations.extend(["двухкомнатная", "2-комнатная", "две комнаты"])
                elif rooms == 3:
                    room_variations.extend(["трехкомнатная", "3-комнатная", "три комнаты"])
            
            # Create searchable text with all variations
            property_title = f"{prop.get('rooms', 0)}-комн" if prop.get('rooms', 0) > 0 else "студия"
            searchable_text = f"{property_title} {' '.join(room_variations)} {prop.get('developer_name', prop.get('developer', ''))} {prop.get('address_locality_name', prop.get('district', ''))} {prop.get('complex_name', prop.get('residential_complex', ''))} {prop.get('location', '')} квартира".lower()
            
            # Split search term into words and check if all words are found
            search_words = search_term.split()
            match_found = True
            
            for word in search_words:
                if word not in searchable_text:
                    match_found = False
                    break
            
            if not match_found:
                continue
        
        # Rooms filter - handle both single value and array
        if filters.get('rooms'):
            rooms_filter = filters['rooms']
            # ✅ ИСПРАВЛЕНО: используем object_rooms вместо rooms
            property_rooms = prop.get('object_rooms', prop.get('rooms', 0))
            
            # Helper function to parse room filter value
            def parse_room_filter(room_value):
                """Convert room filter to integer: '2-комн' -> 2, 'студия' -> 0, '2' -> 2"""
                if not room_value:
                    return None
                room_str = str(room_value).lower().strip()
                
                # Handle special cases
                if room_str in ['студия', 'studio']:
                    return 0
                if room_str in ['4+-комн', '4+', '4+ комнат']:
                    return 4  # Will be handled as >= 4
                
                # Handle "X-комн" format
                if '-комн' in room_str:
                    try:
                        return int(room_str.split('-')[0])
                    except (ValueError, IndexError):
                        return None
                
                # Handle numeric string
                try:
                    return int(room_str)
                except (ValueError, TypeError):
                    return None
            
            # Handle array of rooms from saved searches
            if isinstance(rooms_filter, list):
                rooms_match = False
                for room_filter in rooms_filter:
                    room_num = parse_room_filter(room_filter)
                    if room_num is None:
                        continue
                    
                    # Special case for 4+ rooms
                    if str(room_filter).lower() in ['4+-комн', '4+', '4+ комнат']:
                        if property_rooms >= 4:
                            rooms_match = True
                            break
                    # Exact match
                    elif property_rooms == room_num:
                        rooms_match = True
                        break
                
                if not rooms_match:
                    continue
            else:
                # Handle single room value
                room_num = parse_room_filter(rooms_filter)
                if room_num is None:
                    continue
                    
                # Special case for 4+ rooms
                if str(rooms_filter).lower() in ['4+-комн', '4+', '4+ комнат']:
                    if property_rooms < 4:
                        continue
                # Exact match
                elif property_rooms != room_num:
                    continue
        
        # Price filter - handle both raw rubles and millions
        if filters.get('price_min') and filters['price_min']:
            try:
                min_price = int(filters['price_min'])
                # If value is small, assume it's in millions
                if min_price < 1000:
                    min_price = min_price * 1000000
                if prop['price'] < min_price:
                    continue
            except (ValueError, TypeError):
                pass
        if filters.get('price_max') and filters['price_max']:
            try:
                max_price = int(filters['price_max'])
                # If value is small, assume it's in millions
                if max_price < 1000:
                    max_price = max_price * 1000000
                if prop['price'] > max_price:
                    continue
            except (ValueError, TypeError):
                pass
        
        # District filter
        if filters.get('district') and prop['district'] != filters['district']:
            continue
        
        # Developer filter
        if filters.get('developer') and prop['developer'] != filters['developer']:
            continue
        
        # Residential complex filter
        if filters.get('residential_complex'):
            residential_complex = filters['residential_complex'].lower()
            prop_complex = prop.get('complex_name', '').lower()
            if residential_complex not in prop_complex:
                continue
        
        # Street filter
        if filters.get('street'):
            street = filters['street'].lower()
            prop_location = prop.get('location', '').lower()
            prop_address = prop.get('full_address', '').lower()
            if street not in prop_location and street not in prop_address:
                continue
        
        # Mortgage filter
        if filters.get('mortgage') and not prop.get('mortgage_available', False):
            continue
        
        filtered.append(prop)
    
    return filtered

def build_property_filters(request_args):
    """
    Unified property filtering function for /properties and /map routes.
    
    Args:
        request_args: Flask request.args object
        
    Returns:
        tuple: (where_conditions, params, filters_dict)
            - where_conditions: list of SQL WHERE clause strings
            - params: dict of parameterized values for SQL query
            - filters_dict: dict of parsed filter values for template/debugging
    """
    from datetime import datetime
    
    # Parse all filter parameters (унифицируем названия)
    filters = {}
    
    # Price filters (поддержка всех форматов: price_min, priceFrom, price_from)
    filters['price_min'] = request_args.get('price_min', request_args.get('priceFrom', request_args.get('price_from', '')))
    filters['price_max'] = request_args.get('price_max', request_args.get('priceTo', request_args.get('price_to', '')))
    
    # Area filters (поддержка всех форматов)
    filters['area_min'] = request_args.get('area_min', request_args.get('areaFrom', request_args.get('area_from', '')))
    filters['area_max'] = request_args.get('area_max', request_args.get('areaTo', request_args.get('area_to', '')))
    
    # Floor filters (поддержка всех форматов)
    filters['floor_min'] = request_args.get('floor_min', request_args.get('floorFrom', request_args.get('floor_from', '')))
    filters['floor_max'] = request_args.get('floor_max', request_args.get('floorTo', request_args.get('floor_to', '')))
    
    # Rooms filter (может прийти как "1,2,3" или как список)
    rooms_param = request_args.get('rooms', '')
    if rooms_param:
        filters['rooms'] = rooms_param.split(',') if ',' in rooms_param else [rooms_param]
    else:
        filters['rooms'] = request_args.getlist('rooms') or []
    
    # Multi-select filters
    filters['districts'] = request_args.getlist('districts') or []
    filters['developers'] = request_args.getlist('developers') or []
    
    # Support developer_id parameter (single developer by ID)
    developer_id = request_args.get('developer_id', '')
    if developer_id and developer_id not in filters['developers']:
        filters['developers'].append(developer_id)
    filters['completion'] = request_args.getlist('completion') or request_args.getlist('completion[]') or []
    filters['building_types'] = request_args.getlist('building_types') or []
    filters['delivery_years'] = request_args.getlist('delivery_years') or []
    filters['features'] = request_args.getlist('features') or request_args.getlist('features[]') or []
    # Object classes filter (может прийти как "Бизнес,Комфорт" или как список)
    object_classes_param = request_args.get('object_class', '') or request_args.get('object_classes', '')
    if object_classes_param:
        filters['object_classes'] = object_classes_param.split(',') if ',' in object_classes_param else [object_classes_param]
    else:
        filters['object_classes'] = request_args.getlist('object_classes') or request_args.getlist('object_class') or []
    filters['renovation'] = request_args.getlist('renovation') or request_args.getlist('renovation[]') or []
    filters['building_released'] = request_args.getlist('building_released') or request_args.getlist('building_released[]') or []
    filters['floor_options'] = request_args.getlist('floor_options') or request_args.getlist('floor_options[]') or []  # not_first, not_last
    
    # Boolean filters
    filters['cashback_only'] = request_args.get('cashback_only', '').lower() in ['true', '1', 'yes']
    
    # Single value filters
    filters['developer'] = request_args.get('developer', '')
    filters['district'] = request_args.get('district', '')
    filters['residential_complex'] = request_args.get('residential_complex', '')
    filters['building'] = request_args.get('building', '')
    
    # Building floors filters
    filters['building_floors_min'] = request_args.get('building_floors_min', request_args.get('maxFloorFrom', ''))
    filters['building_floors_max'] = request_args.get('building_floors_max', request_args.get('maxFloorTo', ''))
    
    # Build year filters
    filters['build_year_min'] = request_args.get('build_year_min', request_args.get('buildYearFrom', ''))
    filters['build_year_max'] = request_args.get('build_year_max', request_args.get('buildYearTo', ''))
    
    # Regional filters
    filters['regions'] = request_args.getlist('regions') or []
    filters['cities'] = request_args.getlist('cities') or []
    filters['city'] = request_args.get('city', '')
    filters['city_id'] = request_args.get('city_id', '')  # Support city_id parameter
    filters['city'] = request_args.get('city', '')
    
    # Search query
    # Search query (поддержка обоих параметров: 'q' и 'search')
    filters['search'] = request_args.get('q', request_args.get('search', ''))
    
    # Auto-detect room filters from search queries (for mobile/direct URL access)
    if filters['search']:
        import re
        search_lower = filters['search'].lower().strip()
        
        # Studio patterns: "студия", "studio"
        if re.search(r'\bстуди[яюи]\b', search_lower):
            if '0' not in filters['rooms']:
                filters['rooms'].append('0')
        
        # 1 room patterns: "1 комн", "1комн", "1к", "1-комн", "однокомн"
        if re.search(r'\b1[\s\-]?к(омн(атная|ат)?)?\b|\bодно[\s\-]?комн', search_lower):
            if '1' not in filters['rooms']:
                filters['rooms'].append('1')
        
        # 2 room patterns: "2 комн", "2комн", "2к", "2-комн", "двухкомн"
        if re.search(r'\b2[\s\-]?к(омн(атная|ат)?)?\b|\bдвух[\s\-]?комн', search_lower):
            if '2' not in filters['rooms']:
                filters['rooms'].append('2')
        
        # 3 room patterns: "3 комн", "3комн", "3к", "трехкомн"
        if re.search(r'\b3[\s\-]?к(омн(атная|ат)?)?\b|\bтр[её]х[\s\-]?комн', search_lower):
            if '3' not in filters['rooms']:
                filters['rooms'].append('3')
        
        # 4 room patterns: "4 комн", "4комн", "4к", "четырехкомн"
        if re.search(r'\b4[\s\-]?к(омн(атная|ат)?)?\b|\bчетыр[её]х[\s\-]?комн', search_lower):
            if '4' not in filters['rooms']:
                filters['rooms'].append('4')
    
    # 🔥 FIX: Clear search parameter if it was a pure room query
    # to avoid conflicting text search that returns 0 results
    if filters['rooms'] and filters['search']:
        import re
        search_lower = filters['search'].lower().strip()
        # Patterns for pure room queries (only room number, nothing else)
        room_only_patterns = [
            r'^\s*студи[яюи]\s*$',  # Just "студия"
            r'^\s*\d+[\s\-]?к(омн(атная|ат)?)?\s*$',  # Just "1к", "2 комн", etc.
            r'^\s*(одно|дву[хт]|тр[её]х|четыр[её]х)[\s\-]?комн(атная|ат)?\s*$'  # Just "однокомн", etc.
        ]
        if any(re.search(pattern, search_lower) for pattern in room_only_patterns):
            filters['search'] = ''  # Clear search to avoid text search interference
            print(f"✅ Cleared search parameter after detecting pure room query: '{search_lower}'")
    
    # Build SQL WHERE conditions and parameters
    where_conditions = []
    params = {}
    
    # Price filters (пользователь вводит в миллионах)
    if filters.get('price_min'):
        try:
            params['price_min'] = float(filters['price_min']) * 1000000
            where_conditions.append('price >= :price_min')
        except:
            pass
    
    if filters.get('price_max'):
        try:
            params['price_max'] = float(filters['price_max']) * 1000000
            where_conditions.append('price <= :price_max')
        except:
            pass
    
    # Area filters
    if filters.get('area_min'):
        try:
            params['area_min'] = float(filters['area_min'])
            where_conditions.append('object_area >= :area_min')
        except:
            pass
    
    if filters.get('area_max'):
        try:
            params['area_max'] = float(filters['area_max'])
            where_conditions.append('object_area <= :area_max')
        except:
            pass
    
    # Floor filters
    if filters.get('floor_min'):
        try:
            params['floor_min'] = int(filters['floor_min'])
            where_conditions.append('object_min_floor >= :floor_min')
        except:
            pass
    
    if filters.get('floor_max'):
        try:
            params['floor_max'] = int(filters['floor_max'])
            where_conditions.append('object_min_floor <= :floor_max')
        except:
            pass
    
    # Floor options (не первый/не последний этаж)
    if filters.get('floor_options'):
        floor_option_conditions = []
        for option in filters['floor_options']:
            if option == 'not_first':
                floor_option_conditions.append('object_min_floor > 1')
            elif option == 'not_last':
                # Not on last floor: floor < total_floors
                floor_option_conditions.append('object_min_floor < object_max_floor')
            elif option == 'last':
                # Last floor: floor == total_floors
                floor_option_conditions.append('object_min_floor = object_max_floor')
        
        if floor_option_conditions:
            where_conditions.append(f"({' AND '.join(floor_option_conditions)})")
    
    # Cashback only filter (только объекты с кешбеком)
    if filters.get('cashback_only'):
        where_conditions.append('(min_rate > 0 AND min_rate IS NOT NULL)')
    
    # Rooms filter - support various formats
    if filters.get('rooms'):
        room_conditions = []
        for room_filter in filters['rooms']:
            if isinstance(room_filter, str):
                normalized = room_filter.lower().strip()
                if normalized in ['студия', '0', 'studio']:
                    room_conditions.append('object_rooms = 0')
                elif normalized.endswith('-комн'):
                    try:
                        room_num = int(normalized.split('-')[0])
                        room_conditions.append(f'object_rooms = {room_num}')
                    except:
                        pass
                elif normalized in ['4+', '4+-комн']:
                    room_conditions.append('object_rooms >= 4')
                elif normalized.isdigit():
                    room_conditions.append(f'object_rooms = {int(normalized)}')
        
        if room_conditions:
            where_conditions.append(f"({' OR '.join(room_conditions)})")
    
    # Building types filter (этажность дома)
    if filters.get('building_types'):
        building_conditions = []
        for building_type in filters['building_types']:
            if building_type == 'малоэтажный':
                building_conditions.append('object_max_floor <= 5')
            elif building_type == 'среднеэтажный':
                building_conditions.append('(object_max_floor >= 6 AND object_max_floor <= 12)')
            elif building_type == 'многоэтажный':
                building_conditions.append('object_max_floor >= 13')
        
        if building_conditions:
            where_conditions.append(f"({' OR '.join(building_conditions)})")
    
    # Districts filter (array)
    if filters.get('districts'):
        district_conditions = []
        for idx, district in enumerate(filters['districts']):
            param_name = f'district_{idx}'
            params[param_name] = f'%{district.lower()}%'
            district_conditions.append(f'LOWER(address_locality_name) LIKE :{param_name}')
        
        if district_conditions:
            where_conditions.append(f"({' OR '.join(district_conditions)})")
    
    # Single district filter
    if filters.get('district'):
        params['district'] = f'%{filters["district"].lower()}%'
        where_conditions.append('LOWER(address_locality_name) LIKE :district')
    
    # Developers filter (array)
    if filters.get('developers'):
        developer_conditions = []
        for idx, developer in enumerate(filters['developers']):
            param_name = f'developer_{idx}'
            params[param_name] = f'%{developer.lower()}%'
            developer_conditions.append(f'LOWER(developer_name) LIKE :{param_name}')
        
        if developer_conditions:
            where_conditions.append(f"({' OR '.join(developer_conditions)})")
    
    # Single developer filter
    if filters.get('developer'):
        params['developer'] = f'%{filters["developer"].lower()}%'
        where_conditions.append('LOWER(developer_name) LIKE :developer')
    
    # Residential complex filter
    if filters.get('residential_complex'):
        params['complex'] = f'%{filters["residential_complex"].lower()}%'
        where_conditions.append('LOWER(complex_name) LIKE :complex')
    
    # Building filter
    if filters.get('building'):
        params['building'] = f'%{filters["building"].lower()}%'
        where_conditions.append('LOWER(complex_building_name) LIKE :building')
    
    # Completion year filters
    if filters.get('completion') or filters.get('delivery_years'):
        years = filters.get('completion') or filters.get('delivery_years')
        year_conditions = []
        for year in years:
            if year != 'Сдан':
                try:
                    # Convert string to integer for proper SQL comparison
                    year_int = int(year)
                    year_conditions.append(f'complex_building_end_build_year = {year_int}')
                except (ValueError, TypeError):
                    pass
        
        if year_conditions:
            where_conditions.append(f"({' OR '.join(year_conditions)})")
    
    # Object classes filter
    if filters.get('object_classes'):
        class_conditions = []
        for idx, obj_class in enumerate(filters['object_classes']):
            param_name = f'class_{idx}'
            params[param_name] = f'%{obj_class.lower()}%'
            class_conditions.append(f'LOWER(complex_object_class_display_name) LIKE :{param_name}')
        
        if class_conditions:
            where_conditions.append(f"({' OR '.join(class_conditions)})")
    
    # Renovation filter
    if filters.get('renovation'):
        renovation_conditions = []
        for idx, renovation in enumerate(filters['renovation']):
            param_name = f'renovation_{idx}'
            params[param_name] = f'%{renovation.lower()}%'
            renovation_conditions.append(f'LOWER(renovation_display_name) LIKE :{param_name}')
        
        if renovation_conditions:
            where_conditions.append(f"({' OR '.join(renovation_conditions)})")
    
    # Features filter
    if filters.get('features'):
        feature_conditions = []
        for feature in filters['features']:
            if feature == 'accreditation':
                # Filter by bank accreditation
                feature_conditions.append('complex_has_accreditation = true')
            elif feature == 'green_mortgage':
                # Filter by green mortgage availability
                feature_conditions.append('complex_has_green_mortgage = true')
            else:
                # For other features, search in description
                idx = len(params)
                param_name = f'feature_{idx}'
                params[param_name] = f'%{feature.lower()}%'
                feature_conditions.append(f'LOWER(description) LIKE :{param_name}')
        
        if feature_conditions:
            where_conditions.append(f"({' OR '.join(feature_conditions)})")
    
    # Building released filter (сдан/не сдан)
    if filters.get('building_released'):
        released_conditions = []
        now = datetime.now()
        current_year = now.year
        current_quarter = (now.month - 1) // 3 + 1
        
        for status in filters['building_released']:
            if status.lower() in ['сдан', 'delivered', 'ready']:
                released_conditions.append(f'''(
                    complex_end_build_year < {current_year} OR 
                    (complex_end_build_year = {current_year} AND 
                     (complex_end_build_quarter IS NULL OR complex_end_build_quarter < {current_quarter})) OR
                    complex_building_end_build_year < {current_year} OR
                    (complex_building_end_build_year = {current_year} AND 
                     (complex_building_end_build_quarter IS NULL OR complex_building_end_build_quarter < {current_quarter}))
                )''')
            elif status.lower() in ['строится', 'under_construction', 'building']:
                released_conditions.append(f'''(
                    complex_end_build_year > {current_year} OR
                    (complex_end_build_year = {current_year} AND 
                     (complex_end_build_quarter IS NULL OR complex_end_build_quarter >= {current_quarter})) OR
                    complex_building_end_build_year > {current_year} OR
                    (complex_building_end_build_year = {current_year} AND 
                     (complex_building_end_build_quarter IS NULL OR complex_building_end_build_quarter >= {current_quarter}))
                )''')
        
        if released_conditions:
            where_conditions.append(f"({' OR '.join(released_conditions)})")
    
    # Building floors filters
    if filters.get('building_floors_min'):
        try:
            params['building_floors_min'] = int(filters['building_floors_min'])
            where_conditions.append('object_max_floor >= :building_floors_min')
        except:
            pass
    
    if filters.get('building_floors_max'):
        try:
            params['building_floors_max'] = int(filters['building_floors_max'])
            where_conditions.append('object_max_floor <= :building_floors_max')
        except:
            pass
    
    # Build year filters
    if filters.get('build_year_min'):
        try:
            params['build_year_min'] = int(filters['build_year_min'])
            where_conditions.append('(complex_end_build_year >= :build_year_min OR complex_building_end_build_year >= :build_year_min)')
        except:
            pass
    
    if filters.get('build_year_max'):
        try:
            params['build_year_max'] = int(filters['build_year_max'])
            where_conditions.append('(complex_end_build_year <= :build_year_max OR complex_building_end_build_year <= :build_year_max)')
        except:
            pass
    
    # Regional filters
    regional_conditions = []
    
    if filters.get('regions'):
        for idx, region in enumerate(filters['regions']):
            param_name = f'region_{idx}'
            params[param_name] = f'%{region.lower()}%'
            regional_conditions.append(f'LOWER(address_display_name) LIKE :{param_name}')
    
    if filters.get('region'):
        params['region'] = f'%{filters["region"].lower()}%'
        regional_conditions.append('LOWER(address_display_name) LIKE :region')
    
    # City filtering - use city_id instead of inefficient LIKE on address_display_name
    city_context = resolve_city_context(city_id=filters.get('city_id'), city_slug=filters.get('city'))
    if city_context:
        filters['city_id'] = city_context.id
        filters['city_name'] = city_context.name
        params['city_id'] = city_context.id
        where_conditions.append('city_id = :city_id')
    
    if regional_conditions:
        where_conditions.append(f"({' OR '.join(regional_conditions)})")
    
    # Search filter (multiple fields)
    if filters.get('search'):
        params['search'] = f'%{filters["search"].lower()}%'
        where_conditions.append('''(
            LOWER(address_display_name) LIKE :search OR
            LOWER(developer_name) LIKE :search OR
            LOWER(complex_name) LIKE :search OR
            LOWER(address_locality_name) LIKE :search OR
            LOWER(complex_building_name) LIKE :search
        )''')
    
    return where_conditions, params, filters

def get_developers_list():
    """⚡ OPTIMIZED: Get list of unique developers from database"""
    from models import Developer
    developers = Developer.query.filter(Developer.name != None, Developer.name != '').all()
    # Deduplicate names using dict, then create dict objects for template
    unique_names = {}
    for d in developers:
        if d.name and d.name not in unique_names:
            unique_names[d.name] = {
                'id': d.id,
                'name': d.name,
                'slug': d.slug if hasattr(d, 'slug') and d.slug else d.name.lower().replace(' ', '-')
            }
    return sorted(unique_names.values(), key=lambda x: x['name'])

def get_districts_list():
    """⚡ OPTIMIZED: Get list of unique districts from database"""
    from models import District
    districts = District.query.filter(District.name != None, District.name != '').all()
    # Deduplicate names using dict, then create dict objects for template
    unique_names = {}
    for d in districts:
        if d.name and d.name not in unique_names:
            unique_names[d.name] = {
                'id': d.id,
                'name': d.name,
                'slug': d.slug if hasattr(d, 'slug') and d.slug else d.name.lower().replace(' ', '-')
            }
    return sorted(unique_names.values(), key=lambda x: x['name'])

def sort_properties(properties, sort_type):
    """Sort properties by specified criteria with None safety"""
    if sort_type == 'price_asc':
        return sorted(properties, key=lambda x: x.get('price') or 0)
    elif sort_type == 'price_desc':
        return sorted(properties, key=lambda x: x.get('price') or 0, reverse=True)
    elif sort_type == 'cashback_desc':
        return sorted(properties, key=lambda x: calculate_cashback(x.get('price') or 0), reverse=True)
    elif sort_type == 'area_asc':
        return sorted(properties, key=lambda x: x.get('area') or 0)
    elif sort_type == 'area_desc':
        return sorted(properties, key=lambda x: x.get('area') or 0, reverse=True)
    else:
        return properties

def get_similar_properties(property_id, district, limit=3):
    """Get similar properties in the same district"""
    properties = load_properties()
    similar = []
    
    for prop in properties:
        if str(prop['id']) != str(property_id) and prop['district'] == district:
            similar.append(prop)
            if len(similar) >= limit:
                break
    
    return similar


# ✅ КРИТИЧНО: Отключаем кэширование HTML для правильной загрузки обновлений
@app.after_request
def add_security_headers(response):
    """Add security and no-cache headers"""
    # HSTS: Force HTTPS for 1 year (31536000 seconds)
    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains; preload'
    
    # Prevent MIME type sniffing
    response.headers['X-Content-Type-Options'] = 'nosniff'
    
    # Prevent clickjacking (allow same origin for iframes)
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    
    # XSS Protection (legacy but still useful for older browsers)
    response.headers['X-XSS-Protection'] = '1; mode=block'
    
    # Referrer policy for privacy
    response.headers['Referrer-Policy'] = 'strict-origin-when-cross-origin'
    
    # Content Security Policy (basic, can be enhanced later)
    response.headers['Permissions-Policy'] = 'geolocation=(), microphone=(), camera=()'
    
    # No-cache headers for HTML pages to prevent stale content
    if response.content_type and 'text/html' in response.content_type:
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, max-age=0'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
    
    return response

# Routes
@app.route('/')
def index():
    """Home page with featured content"""
    # Админы и менеджеры МОГУТ видеть основной сайт (убрали редирект)
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )

    # ⚡ OPTIMIZATION: Removed global load_properties() - replaced with targeted queries
    
    # ✅ MIGRATED: Load residential complexes using normalized tables
    exclusive_complexes = []
    try:
        # Get active residential complexes with property stats
        # ✅ OPTIMIZED: Filter by city in SQL instead of Python
        city_id = current_city.id if current_city else None
        complexes_orm = ResidentialComplexRepository.get_all_active(limit=20, city_id=city_id)
        
        # Get aggregated property stats for all complexes (single query, no N+1)
        # ✅ OPTIMIZED: Only load stats for complexes in current city
        property_stats = PropertyRepository.get_all_property_stats(city_id=city_id)









        
        # Build list of complexes with stats
        complexes_with_stats = []
        for complex_obj in complexes_orm:
            stats = property_stats.get(complex_obj.id, {})
            
            # Skip complexes without properties
            if not stats or stats.get('total_count', 0) == 0:
                continue
            
            # Calculate sorting keys
            end_year = complex_obj.end_build_year or 9999
            end_quarter = complex_obj.end_build_quarter or 4
            is_future = (end_year == 2025 and end_quarter == 4)
            price_from = stats.get('min_price', 0)
            
            complexes_with_stats.append({
                'complex': complex_obj,
                'stats': stats,
                'sort_future': 1 if is_future else 0,
                'sort_price': price_from
            })
        
        # Sort: ready complexes first, then by price
        complexes_with_stats.sort(key=lambda x: (x['sort_future'], x['sort_price']))
        
        # Take top 6 complexes
        for item in complexes_with_stats[:6]:
            complex_obj = item['complex']
            stats = item['stats']
            # ✅ MIGRATED: Format complex data from ORM objects
            # Photo loading strategy: complex.main_image → complex.gallery_images → properties.sample_photos → no-photo.jpg
            photos_list = []
            main_photo = None
            
            # Try complex main_image first
            if complex_obj.main_image:
                main_photo = complex_obj.main_image
                photos_list = [main_photo]
            
            # Try complex gallery_images
            if complex_obj.gallery_images:
                try:
                    photos_raw = json.loads(complex_obj.gallery_images) if isinstance(complex_obj.gallery_images, str) else complex_obj.gallery_images
                    if photos_raw and isinstance(photos_raw, list) and len(photos_raw) > 0:
                        photos_list = photos_raw[:3]
                        main_photo = photos_list[0]
                except:
                    pass
            
            # Fallback: use photos from properties
            if not photos_list or len(photos_list) == 0:
                sample_photos = stats.get('sample_photos', [])
                if sample_photos and len(sample_photos) > 0:
                    photos_list = sample_photos[:3]
                    main_photo = photos_list[0]
            
            # Final fallback: no-photo.jpg
            if not main_photo:
                main_photo = '/static/images/no-photo.jpg'
            if not photos_list or len(photos_list) == 0:
                photos_list = [main_photo]
            
            # Determine completion status
            current_year = 2025
            current_quarter = 4
            
            is_completed = False
            completion_date = 'Не указан'
            
            if complex_obj.end_build_year and complex_obj.end_build_quarter:
                build_year = int(complex_obj.end_build_year)
                build_quarter = int(complex_obj.end_build_quarter)
                
                if build_year < current_year:
                    is_completed = True
                elif build_year == current_year and build_quarter < current_quarter:
                    is_completed = True
                
                quarter_names = {1: 'I', 2: 'II', 3: 'III', 4: 'IV'}
                quarter = quarter_names.get(build_quarter, build_quarter)
                completion_date = f"{quarter} кв. {build_year} г."
            
            # Determine room types based on area range
            room_types = []
            area_from = stats.get('min_area', 0)
            area_to = stats.get('max_area', 0)
            
            if area_from and area_to:
                if area_from < 35:
                    room_types.append("Студии")
                if area_from <= 45 and area_to >= 35:
                    room_types.append("1К")
                if area_to >= 55:
                    room_types.append("2-3К")
            else:
                room_types = ["Студии", "1-3К"]
            
            room_type_display = " - ".join(room_types) if room_types else "Различные"
            
            # Safe image handling
            safe_images = photos_list if photos_list and len(photos_list) > 0 else ['/static/images/no-photo.jpg']
            safe_main_image = safe_images[0] if safe_images else '/static/images/no-photo.jpg'
            
            # Clean address - remove "Сочи" prefix
            clean_address = complex_obj.sales_address or stats.get('sample_address', '') or ''
            if clean_address and clean_address.startswith('Сочи, '):
                clean_address = clean_address[6:]
            elif clean_address and clean_address.startswith('г. Сочи, '):
                clean_address = clean_address[9:]
            
            # Cashback from admin panel
            cashback_percent = float(complex_obj.cashback_rate) if complex_obj.cashback_rate else 5.0
            
            # Calculate cashback amount based on max price
            max_price = stats.get('max_price', 0)
            cashback_amount = int(max_price * (cashback_percent / 100)) if max_price else 0
            
            complex_dict = {
                'id': complex_obj.id,
                'name': complex_obj.name or 'Без названия',
                'price_from': int(stats.get('min_price', 0)),
                'price_to': int(stats.get('max_price', 0)),
                'area_from': int(stats.get('min_area', 0)),
                'area_to': int(stats.get('max_area', 0)),
                'room_type': room_type_display,
                'address': clean_address,
                'developer': complex_obj.developer.name if complex_obj.developer else 'Не указан',
                'photos': safe_images,
                'images': safe_images,
                'image': safe_main_image,
                'main_photo': safe_main_image,
                'main_image': safe_main_image,
                'apartments_count': stats.get('total_count', 0),
                'completion_date': completion_date,
                'is_completed': is_completed,
                'cashback_amount': int(cashback_amount),
                'cashback_percent': float(cashback_percent),
                'cashback_max': int(cashback_amount),
                'buildings_count': stats.get('buildings_count', 1)
            }
            exclusive_complexes.append(complex_dict)
            
        print(f"✅ Загружено {len(exclusive_complexes)} эксклюзивных ЖК для главной страницы")
        
    except Exception as e:
        print(f"❌ Error loading exclusive complexes: {e}")
        import traceback
        traceback.print_exc()
        exclusive_complexes = []
    
    complexes = load_residential_complexes()  # Для совместимости со старым кодом
    developers_file = os.path.join('data', 'developers.json')
    with open(developers_file, 'r', encoding='utf-8') as f:
        developers = json.load(f)
    
    # Загружаем статьи блога из базы данных для главной страницы
    blog_articles = []
    try:
        from models import BlogPost
        from sqlalchemy import desc
        
        # Получаем опубликованные статьи только из BlogPost с категорией
        blog_posts = BlogPost.query.filter_by(status='published').order_by(desc(BlogPost.published_at)).limit(4).all()
        
        # Преобразуем в единый формат для шаблона
        for post in blog_posts:
            blog_articles.append({
                'title': post.title,
                'slug': post.slug,
                'excerpt': post.excerpt or 'Интересная статья о недвижимости',
                'featured_image': post.featured_image or 'https://images.unsplash.com/photo-1560518883-ce09059eeffa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80',
                'published_at': post.published_at or post.created_at,
                'reading_time': getattr(post, 'reading_time', 5),
                'category': post.category or 'Недвижимость',
                'url': f'/blog/{post.slug}'
            })
        
    except Exception as e:
        print(f"Error loading blog articles for index: {e}")
        # Fallback статьи если база недоступна
        blog_articles = [
            {
                'title': 'Ипотека мурабаха: что это и как оформить',
                'slug': 'ipoteka-murabaha',
                'excerpt': 'Ипотека мурабаха — это исламская ипотека без процентов, где банк покупает недвижимость и продает ее клиенту с наценкой.',
                'featured_image': 'https://images.unsplash.com/photo-1560518883-ce09059eeffa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80',
                'published_at': datetime.now(),
                'reading_time': 5,
                'category': 'Ипотека',
                'url': '/blog/ipoteka-murabaha'
            }
        ]
    
    # ✅ MIGRATED: Получаем 6 случайных объектов из normalized Property table
    try:
        import random
        from models import Property
        
        # Get random featured properties using PropertyRepository
        # ✅ SECURITY FIX: Always filter by city_id to prevent cross-city data leakage
        all_properties = PropertyRepository.get_all_active(
            limit=100,
            filters={
                'city_id': current_city.id,  # Restored: prevent cross-city data leakage
                'min_price': 1  # Only properties with price > 0
            }
        )
        
        # Filter properties with area and residential complex
        # ✅ FIX: Make gallery_images and coordinates optional
        # (city_id=1 has no coordinates, but still show properties)
        valid_properties = [
            p for p in all_properties
            if p.area and p.residential_complex
        ]
        
        # Shuffle and limit to 8 properties
        random.shuffle(valid_properties)
        result = valid_properties[:8]
        
        featured_properties = []
        for prop_orm in result:
            try:
                # Parse gallery images
                main_image = 'https://via.placeholder.com/400x300?text=Фото+скоро'
                gallery = [main_image]
                
                if prop_orm.gallery_images:
                    try:
                        photos_raw = json.loads(prop_orm.gallery_images)
                        if photos_raw and isinstance(photos_raw, list) and len(photos_raw) > 0:
                            main_image = photos_raw[0]
                            gallery = photos_raw[:5]
                    except:
                        pass
                
                # Property details
                rooms = int(prop_orm.rooms or 0)
                area = float(prop_orm.area or 0)
                price = int(prop_orm.price or 0)
                
                # Floor info
                floor_min = int(prop_orm.floor or 1)
                floor_max = int(prop_orm.total_floors or floor_min)
                floor_text = f"{floor_min}/{floor_max} эт."
                
                # Room type
                room_type = "Студия" if rooms == 0 else f"{rooms}-комн"
                
                # Completion date and status
                current_year = 2025
                build_quarter = prop_orm.residential_complex.end_build_quarter if prop_orm.residential_complex else None
                build_year = prop_orm.residential_complex.end_build_year if prop_orm.residential_complex else None
                
                if build_year and build_quarter:
                    quarter_text = f"{build_quarter}кв. {build_year}г."
                    status_text = "Сдан" if build_year < current_year or (build_year == current_year and build_quarter <= 1) else "Строится"
                else:
                    quarter_text = "Уточняется"
                    status_text = "Строится"
                
                # Build property dict
                prop = {
                    'id': prop_orm.inner_id or str(prop_orm.id),
                    'price': price,
                    'area': area,
                    'rooms': rooms,
                    'title': f"{room_type}, {area} м², {floor_text}",
                    'complex': prop_orm.residential_complex.name if prop_orm.residential_complex else 'ЖК не указан',
                    'developer': prop_orm.developer.name if prop_orm.developer else '',
                    'address': prop_orm.address or '',
                    'image': main_image,
                    'gallery': gallery,
                    'cashback': int(price * 0.02),
                    'cashback_amount': int(price * 0.02),
                    'completion_date': quarter_text,
                    'status': status_text,
                    'floor_info': floor_text
                }
                featured_properties.append(prop)
                if len(featured_properties) >= 6:
                    break
                
            except Exception as e:
                print(f"Error processing property {prop_orm.id}: {e}")
                continue
        
        if featured_properties:
            print(f"✅ Загружено {len(featured_properties)} реальных объектов из базы")
        else:
            raise Exception("No properties loaded")
            
    except Exception as e:
        print(f"❌ Ошибка загрузки реальных объектов: {e}")
        # Fallback к старым данным
        # ⚡ OPTIMIZATION: Direct query instead of loading all properties
        fallback_props = PropertyRepository.get_all_active(limit=6, sort_by='price', sort_order='desc')
        featured_properties = []
        for prop_orm in fallback_props:
            price = prop_orm.price or 0
            featured_properties.append({
                'price': price,
                'cashback_amount': int(price * 0.02),
                'complex_id': prop_orm.complex_id,
                'residential_complex': prop_orm.residential_complex.name if prop_orm.residential_complex else ''
            })
        for prop in featured_properties:
            prop['cashback'] = calculate_cashback(
                prop['price'],
                complex_id=prop.get('complex_id'),
                complex_name=prop.get('residential_complex')
            )
    
    # Get districts with statistics
    districts_data = {}
    for complex in complexes:
        district = complex['district']
        if district not in districts_data:
            districts_data[district] = {
                'name': district,
                'complexes_count': 0,
                'price_from': float('inf'),
                'apartments_count': 0
            }
        districts_data[district]['complexes_count'] += 1
        complex_price = complex.get('price_from') or 0
        if complex_price > 0:  # Only update if we have a valid price
            districts_data[district]['price_from'] = min(districts_data[district]['price_from'], complex_price)
        districts_data[district]['apartments_count'] += complex.get('apartments_count', 0) or 0
    
    districts = sorted(districts_data.values(), key=lambda x: x['complexes_count'], reverse=True)[:8]
    
    # Get featured developers (top 3 with most complexes)
    featured_developers = []
    for developer in developers[:3]:
        developer_complexes = [c for c in complexes if c.get('developer_id') == developer['id']]
        # ⚡ OPTIMIZATION: Direct query by developer_id instead of loading all properties
        complex_ids = [c['id'] for c in developer_complexes]
        developer_properties_count = Property.query.filter(Property.complex_id.in_(complex_ids)).count() if complex_ids else 0
        
        # ⚡ Safe query for price_from - prevents AttributeError if no properties found
        first_prop = Property.query.filter(Property.complex_id.in_(complex_ids), Property.price > 0).order_by(Property.price).first() if complex_ids else None
        
        developer_info = {
            'id': developer['id'],
            'name': developer['name'],
            'complexes_count': len(developer_complexes),
            'apartments_count': developer_properties_count,
            'price_from': first_prop.price if first_prop else 0,
            'max_cashback': max([c.get('cashback_percent', 5) for c in developer_complexes]) if developer_complexes else 5
        }
        featured_developers.append(developer_info)
    
    # Загружаем категории блога для главной страницы
    blog_categories = []
    try:
        from models import Category
        blog_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
    except Exception as e:
        print(f"Error loading blog categories for index: {e}")
    
    return render_template('index.html',
                             current_city=current_city,
                         featured_properties=featured_properties,
                         districts=districts,
                         featured_developers=featured_developers,
                         residential_complexes=complexes[:3],
                         exclusive_complexes=exclusive_complexes,
                         blog_articles=blog_articles,
                         blog_categories=blog_categories)

@app.route('/properties')
def properties():
    """Legacy route - redirects to city-based URL"""
    return redirect_to_city_based('properties_city')

@app.route('/object/<int:property_id>')
def property_detail(property_id):
    """Legacy route - redirects to city-based URL with correct city"""
    # Get city from property's actual location
    city_slug = get_city_slug_for_resource('property', resource_id=property_id)
    if not city_slug:
        city_slug = get_redirect_city_slug()  # fallback to session/default
    
    return redirect(
        url_for('property_detail_city', city_slug=city_slug, property_id=property_id),
        code=301
    )

@app.route('/residential_complex/<int:complex_id>')
@app.route('/residential-complex/<int:complex_id>')  # Support both formats
@app.route('/residential-complex/<complex_name>')  # Support name-based routing
@app.route('/zk/<slug>')  # New SEO-friendly format: /zk/zhk-kislorod
def residential_complex_detail(complex_id=None, complex_name=None, slug=None):
    """Legacy route - redirects to city-based URL with correct city"""
    from models import ResidentialComplex
    
    # Get city from complex's actual location and retrieve slug if needed
    city_slug = None
    complex_slug = slug  # Use provided slug if available
    
    if complex_id:
        # Look up complex to get both city and slug
        complex_obj = ResidentialComplex.query.get(complex_id)
        if complex_obj:
            city_slug = complex_obj.city.slug if complex_obj.city else None
            complex_slug = complex_obj.slug  # Get slug from database
    elif slug:
        city_slug = get_city_slug_for_resource('complex', slug=slug)
    
    if not city_slug:
        city_slug = get_redirect_city_slug()  # fallback to session/default
    
    return redirect(
        url_for('residential_complex_by_slug_city', city_slug=city_slug, slug=complex_slug),
        code=301
    )

@app.route('/developer/<int:developer_id>')
def developer_detail(developer_id):
    """Individual developer page"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    try:
        # Load developer data from JSON file instead of DB to avoid conflicts
        with open('data/developers.json', 'r', encoding='utf-8') as f:
            developers_data = json.load(f)
        
        # Find developer by ID
        developer = None
        for dev in developers_data:
            if dev['id'] == developer_id:
                developer = dev
                break
        
        if not developer:
            return "Застройщик не найден", 404
        
        # Add missing template fields for new developers
        if 'total_apartments_sold' not in developer:
            developer['total_apartments_sold'] = 150
        if 'projects_completed' not in developer:
            developer['projects_completed'] = 8
        if 'years_experience' not in developer:
            developer['years_experience'] = 10
        if 'rating' not in developer:
            developer['rating'] = 4.5
        if 'construction_technology' not in developer:
            developer['construction_technology'] = 'Монолитно-каркасная'
        if 'warranty_years' not in developer:
            developer['warranty_years'] = 5
        if 'advantages' not in developer:
            developer['advantages'] = [
                'Качественное строительство',
                'Соблюдение сроков сдачи',
                'Развитая инфраструктура',
                'Выгодные условия покупки'
            ]
        
        # Get all complexes by this developer
        complexes = load_residential_complexes()
        developer_complexes = [c for c in complexes if c.get('developer_id') == developer_id or c.get('developer') == developer['name']]
        
        # ⚡ OPTIMIZATION: Direct query by developer instead of loading all properties
        developer_properties = Property.query.filter_by(developer_id=developer_id).limit(100).all()
        # Convert to dict format for template compatibility
        developer_properties = [
            {
                'inner_id': p.inner_id,
                'price': p.price,
                'area': p.area,
                'rooms': p.rooms,
                'floor': p.floor,
                'total_floors': p.total_floors,
                'address': p.address,
                'developer': developer['name']
            }
            for p in developer_properties
        ]
        
        return render_template('developer_detail.html',
                             developer=developer,
                             complexes=developer_complexes,
                             properties=developer_properties)
    except Exception as e:
        print(f"ERROR in developer_detail route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

def crop_watermark(image_url, crop_bottom_percent=8):
    """
    Crop watermark from image by removing bottom portion
    
    Args:
        image_url: URL of the image to crop
        crop_bottom_percent: Percentage of image height to crop from bottom (default 8%)
    
    Returns:
        PIL Image object with watermark cropped
    """
    try:
        # Download image
        response = requests.get(image_url, timeout=10)
        response.raise_for_status()
        
        # Open image
        img = Image.open(io.BytesIO(response.content))
        
        # Calculate crop dimensions
        width, height = img.size
        crop_height = int(height * (crop_bottom_percent / 100))
        new_height = height - crop_height
        
        # Crop image (remove bottom portion with watermark)
        cropped_img = img.crop((0, 0, width, new_height))
        
        return cropped_img
    except Exception as e:
        print(f"Error cropping watermark from {image_url}: {e}")
        return None

def generate_qr_code(url):
    """Generate QR code for given URL and return as base64 string"""
    try:
        # Create QR code instance
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        
        # Add data to QR code
        qr.add_data(url)
        qr.make(fit=True)
        
        # Create image
        qr_image = qr.make_image(fill_color="black", back_color="white")
        
        # Convert to base64
        buffer = io.BytesIO()
        qr_image.save(buffer, format='PNG')
        qr_base64 = base64.b64encode(buffer.getvalue()).decode()
        
        return qr_base64
    except Exception as e:
        print(f"Error generating QR code: {e}")
        return None

@app.route('/object/<int:property_id>/pdf')
def property_pdf(property_id):
    """Property PDF card page with QR code"""
    property_data = get_property_by_id(property_id)
    if not property_data:
        return redirect(url_for('properties'))
    
    # Calculate cashback for this property using complex_name
    cashback = calculate_cashback(property_data['price'], complex_name=property_data.get('complex_name'))
    
    # Add cashback data to property_data for PDF template
    property_data['cashback_amount'] = cashback
    
    # Get cashback percent from residential complex
    try:
        if property_data.get('complex_name'):
            from models import ResidentialComplex
            complex = ResidentialComplex.query.filter_by(name=property_data['complex_name']).first()
            if complex and complex.cashback_rate:
                property_data['cashback_percent'] = float(complex.cashback_rate)
            else:
                property_data['cashback_percent'] = 5.0  # Default 5%
        else:
            property_data['cashback_percent'] = 5.0  # Default 5%
    except:
        property_data['cashback_percent'] = 5.0  # Default 5%
    
    # Get current date for PDF generation
    current_date = datetime.now().strftime('%d.%m.%Y')
    
    # Generate QR code with link to object page
    # Use custom domain from environment variable or fall back to current request domain
    custom_domain = os.environ.get('QR_DOMAIN')
    if custom_domain:
        # Remove trailing slash and ensure it starts with http:// or https://
        custom_domain = custom_domain.rstrip('/')
        if not custom_domain.startswith(('http://', 'https://')):
            custom_domain = 'https://' + custom_domain
        object_url = custom_domain + url_for('property_detail', property_id=property_id)
    else:
        # Default behavior - use current request domain
        object_url = request.url_root.rstrip('/') + url_for('property_detail', property_id=property_id)
    
    qr_code_base64 = generate_qr_code(object_url)
    
    # Add missing fields for PDF template
    property_data['name'] = property_data.get('title', 'Объект недвижимости')
    
    # Get layout image from residential complex (first photo from gallery)
    complex_layout_image = None
    try:
        if property_data.get('complex_name'):
            from models import ResidentialComplex
            complex = ResidentialComplex.query.filter_by(name=property_data['complex_name']).first()
            if complex and complex.gallery_images:
                try:
                    import json
                    gallery = json.loads(complex.gallery_images)
                    if gallery and isinstance(gallery, list) and len(gallery) > 0:
                        complex_layout_image = gallery[0]
                except (json.JSONDecodeError, TypeError, IndexError) as e:
                    print(f"Error parsing gallery images for complex {property_data.get('complex_name')}: {e}")
    except Exception as e:
        print(f"Error loading complex layout image: {e}")
    
    # Create presentation object for PDF template
    presentation = {
        'title': 'InBack.ru - Кэшбек при покупке недвижимости'
    }
    
    # Create property_images structure expected by PDF template
    property_images = {
        'photos': property_data.get('gallery', []),  # All apartment photos
        'floor_plan': property_data.get('floor_plan')  # Floor plan photo
    }
    
    return render_template('property_pdf.html', 
                         property=property_data,
                         property_images=property_images,
                         presentation=presentation,
                         cashback=cashback,
                         current_date=current_date,
                         qr_code=qr_code_base64,
                         object_url=object_url,
                         complex_layout_image=complex_layout_image)

@app.route('/about')
def about():
    """About page"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('about.html', current_city=current_city)

@app.route('/how-it-works')
def how_it_works():
    """How it works page"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    return render_template('how-it-works.html', current_city=current_city)

@app.route('/reviews')
def reviews():
    """Reviews page"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    return render_template('reviews.html')

@app.route('/contacts')
def contacts():
    """Contacts page"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )

    return render_template('contacts.html', current_city=current_city)

@app.route('/blog')
def blog():
    """Blog main page with articles listing, search, and categories"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    from models import BlogPost, Category
    from sqlalchemy import text
    
    # Get search parameters  
    search_query = request.args.get('search', '')
    category_filter = request.args.get('category', '')
    page = int(request.args.get('page', 1))
    per_page = 6
    
    # Загрузка статей только из BlogPost с категорией
    all_articles = []
    
    try:
        # Получаем статьи только из BlogPost с категорией
        blog_posts = BlogPost.query.filter_by(status='published').all()
        for post in blog_posts:
            # Получаем название категории
            category_name = None
            if post.category_id:
                category_obj = Category.query.get(post.category_id)
                if category_obj:
                    category_name = category_obj.name
            
            all_articles.append({
                'id': post.id,
                'title': post.title,
                'slug': post.slug,
                'excerpt': post.excerpt or 'Интересная статья о недвижимости',
                'content': post.content,
                'featured_image': post.featured_image or 'https://images.unsplash.com/photo-1560518883-ce09059eeffa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80',
                'published_at': post.published_at or post.created_at,
                'created_at': post.created_at,
                'reading_time': getattr(post, 'reading_time', 5),
                'category_id': post.category_id,
                'category_name': category_name,
                'url': f'/blog/{post.slug}',
                'source': 'BlogPost'
            })
        
    except Exception as e:
        print(f"Error loading unified articles for blog: {e}")
    
    # Применяем фильтры
    filtered_articles = all_articles.copy()
    
    # Поиск по тексту
    if search_query:
        filtered_articles = [
            article for article in filtered_articles
            if search_query.lower() in article['title'].lower() or 
               search_query.lower() in (article['excerpt'] or '').lower() or
               search_query.lower() in (article['content'] or '').lower()
        ]
    
    # Фильтр по категории
    if category_filter:
        category = Category.query.filter_by(name=category_filter, is_active=True).first()
        if category:
            filtered_articles = [
                article for article in filtered_articles
                if article['category_id'] == category.id
            ]
    
    # Сортировка по дате
    filtered_articles.sort(key=lambda x: x['published_at'] or x['created_at'], reverse=True)
    
    # Ручная пагинация
    total_articles = len(filtered_articles)
    start_idx = (page - 1) * per_page
    end_idx = start_idx + per_page
    articles_page = filtered_articles[start_idx:end_idx]
    
    # Создаем объект похожий на paginate для совместимости
    class PaginationMock:
        def __init__(self, items, page, per_page, total):
            self.items = items
            self.page = page
            self.per_page = per_page
            self.total = total
    
    articles = PaginationMock(articles_page, page, per_page, total_articles)
    
    total_pages = math.ceil(len(all_articles) / per_page) if len(all_articles) > 0 else 1
    # Если нет фильтрации, показываем все статьи просто списком
    if not search_query and not category_filter:
        # Get all active categories for navigation
        all_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
        
        # Показываем все статьи простым списком
        articles_to_show = articles_page
        return render_template('blog.html',
                                 current_city=current_city,
                             articles=articles_to_show,  # Первые статьи для отображения
                             all_categories=all_categories,  # Категории для навигации
                             search_query=search_query,
                             category_filter=category_filter,
                             current_page=page,
                             total_articles=len(all_articles),
                             total_pages=total_pages,
                             show_category_sections=False)  # Показываем простым списком
    else:
        # Если есть фильтрация - показываем обычным списком
        # Get all active categories for dynamic navigation
        all_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
        
        return render_template('blog.html',
                             articles=articles_page,
                             all_categories=all_categories,
                             search_query=search_query,
                             category_filter=category_filter,
                             current_page=page,
                             total_articles=total_articles,
                             total_pages=math.ceil(total_articles / per_page) if total_articles > 0 else 1,
                             show_category_sections=False)

# Removed duplicate blog route - using blog_post function at line 7515

@app.route('/blog/category/<category_slug>')
def blog_category(category_slug):
    """Blog category page with search functionality"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    try:
        from models import BlogPost, Category
        
        # Сначала проверяем, не является ли это slug статьи
        article = BlogPost.query.filter_by(slug=category_slug, status='published').first()
        if article:
            # Это статья, а не категория - перенаправляем на правильный маршрут
            return redirect(url_for('blog_post', slug=category_slug))
        
        # Поиск категории по slug или по имени
        category = Category.query.filter(
            (Category.slug == category_slug) | 
            (Category.name.ilike(f'%{category_slug}%'))
        ).first()
        
        if not category:
            return redirect(url_for('blog'))
        
        # Get search query from URL parameters
        search_query = request.args.get('q', '').strip()
        
        # Get articles in this category
        page = int(request.args.get('page', 1))
        per_page = 6
        
        # Base query - articles in this category using foreign key
        articles_query = BlogPost.query.filter_by(status='published', category_id=category.id)
        
        # Add search filter if query provided
        if search_query:
            from sqlalchemy import or_, func
            search_filter = f"%{search_query.lower()}%"
            articles_query = articles_query.filter(
                or_(
                    func.lower(BlogPost.title).like(search_filter),
                    func.lower(BlogPost.excerpt).like(search_filter),
                    func.lower(BlogPost.content).like(search_filter)
                )
            )
        
        # Order by date descending
        articles_query = articles_query.order_by(BlogPost.created_at.desc())
        
        articles = articles_query.paginate(
            page=page, per_page=per_page, error_out=False
        )
        
        # Get all categories for navigation
        all_categories = Category.query.filter_by(is_active=True).order_by(Category.sort_order, Category.name).all()
        
        return render_template('blog.html',
                             articles=articles.items,
                             all_categories=all_categories,
                             current_category=category,
                             featured_articles=[],
                             search_query=search_query,
                             category_filter=category_slug,
                             current_page=page,
                             total_pages=articles.pages,
                             total_articles=articles.total)
                             
    except Exception as e:
        # Log error for debugging
        import traceback
        print(f"[ERROR] Exception in blog_category ({category_slug}): {str(e)}")
        print(f"[ERROR] Traceback: {traceback.format_exc()}")
        # Graceful fallback - redirect to main blog page
        flash('Произошла ошибка при загрузке категории. Попробуйте позже.', 'error')
        return redirect(url_for('blog'))

@app.route('/news')
def news():
    """News article page"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    return render_template('news.html')

@app.route('/streets')
def streets():
    """Streets page - только для Краснодара (SEO)"""
    # Resolve city context
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    
    # Эта страница только для Краснодара (создана для SEO)
    # Данные пока только для Краснодара
    streets_data = []
    if not current_city or current_city.slug != 'krasnodar':
        # Для других городов показываем пустую заглушку
        return render_template('streets.html', current_city=current_city, streets=[])
    
    # Load streets from database with slugs
    streets_db = db.session.execute(text("""
        SELECT name, slug, district_id 
        FROM streets 
        ORDER BY name
    """)).fetchall()
    
    # Get district names
    districts_db = db.session.execute(text("""
        SELECT id, name FROM districts
    """)).fetchall()
    districts_map = {d.id: d.name for d in districts_db}
    
    # Format streets data
    streets_data = []
    for street in streets_db:
        # Get first letter for grouping
        first_char = street.name[0].upper() if street.name else 'А'
        
        streets_data.append({
            'name': street.name,
            'slug': street.slug,  # Use slug from database
            'district': districts_map.get(street.district_id, ''),
            'letter': first_char,
            'properties_count': 0,  # Can be calculated if needed
            'new_buildings': 0  # Can be calculated if needed
        })
    
    return render_template('streets.html', 
                             current_city=current_city,
                         streets=streets_data)

# Redirect from /streets/<street_name> to /street/<slug>
@app.route('/streets/<path:street_name>')
def streets_redirect(street_name):
    """Редирект с /streets/ на /street/ для обратной совместимости"""
    import urllib.parse
    
    # Декодируем URL-encoded имя
    decoded_name = urllib.parse.unquote(street_name)
    
    # Используем ту же логику что и street_slug() для создания slug
    translit_map = {
        'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'yo',
        'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm',
        'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
        'ф': 'f', 'х': 'kh', 'ц': 'ts', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
        'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'
    }
    
    # Очищаем имя
    name = decoded_name.strip().lower()
    name = re.sub(r'[«»"\(\)\.,:;]', '', name)
    
    # Транслитерация
    result = ''
    for char in name:
        result += translit_map.get(char, char)
    
    # Заменяем пробелы на дефисы и чистим
    result = re.sub(r'\s+', '-', result)
    result = re.sub(r'-+', '-', result)
    slug = result.strip('-')
    
    # Редирект на правильный URL
    return redirect(url_for('street_detail', street_name=slug), code=301)

@app.route('/street/<path:street_name>')
def street_detail(street_name):
    """Страница конкретной улицы с описанием и картой"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    
    try:
        # Сначала ищем улицу в базе данных по slug
        street_db = db.session.execute(text("""
            SELECT name, slug, latitude, longitude, zoom_level, geometry, geometry_source
            FROM streets 
            WHERE slug = :street_slug
        """), {'street_slug': street_name}).fetchone()
        
        if street_db:
            # Вычисление динамических переменных для SEO
            import math
            
            # Определяем тип улицы
            street_type = 'улице'
            street_type_nominative = 'улица'
            name_lower = street_db.name.lower()
            if 'проезд' in name_lower:
                street_type = 'проезде'
                street_type_nominative = 'проезд'
            elif 'переулок' in name_lower or 'пер.' in name_lower:
                street_type = 'переулке'
                street_type_nominative = 'переулок'
            elif 'бульвар' in name_lower:
                street_type = 'бульваре'
                street_type_nominative = 'бульвар'
            elif 'площадь' in name_lower:
                street_type = 'площади'
                street_type_nominative = 'площадь'
            elif 'шоссе' in name_lower:
                street_type = 'шоссе'
                street_type_nominative = 'шоссе'
            
            # Вычисляем расстояние до центра Краснодара
            distance_to_center = 0
            if street_db.latitude and street_db.longitude:
                center_lat, center_lng = 45.0448, 38.9760
                lat_diff = street_db.latitude - center_lat
                lng_diff = street_db.longitude - center_lng
                distance_to_center = round(math.sqrt(lat_diff**2 + lng_diff**2) * 111, 1)  # примерно в км
                
                coordinates = {
                    'lat': float(street_db.latitude),
                    'lng': float(street_db.longitude)
                }
            else:
                coordinates = {
                    'lat': 45.0448,
                    'lng': 38.9760
                }
            
            # Определяем зону города по расстоянию
            location_zone = 'центре города'
            if distance_to_center < 3:
                location_zone = 'центре города'
            elif distance_to_center < 7:
                location_zone = 'средней зоне города'
            else:
                location_zone = 'отдалённой зоне города'
            
            # Вариации описаний на основе первой буквы (для уникальности)
            first_letter_ord = ord(street_db.name[0].upper()) if street_db.name else 0
            variation = first_letter_ord % 4
            
            advantages = [
                ['современными ЖК', 'развитой инфраструктурой', 'отличной транспортной доступностью'],
                ['проверенными застройщиками', 'высоким инвестиционным потенциалом', 'удобным расположением'],
                ['качественными новостройками', 'перспективным районом', 'близостью к центру'],
                ['надёжными девелоперами', 'комфортной средой', 'активным развитием района']
            ][variation]
            
            why_buy_variants = [
                'выгодное расположение и хорошая транспортная доступность',
                'развитая инфраструктура и близость ко всем необходимым объектам',
                'перспективный район с высоким инвестиционным потенциалом',
                'комфортные условия для жизни и активное развитие территории'
            ][variation]
            
            # Используем данные из базы данных
            street = {
                'name': street_db.name,
                'slug': street_db.slug,
                'district': '',
                'description': f'{street_type_nominative.capitalize()} {street_db.name} в Краснодаре',
                'geometry': street_db.geometry if street_db.geometry else None,
                'geometry_source': street_db.geometry_source if street_db.geometry_source else None,
                'street_type': street_type,
                'street_type_nominative': street_type_nominative,
                'distance_to_center': distance_to_center,
                'location_zone': location_zone,
                'advantages': advantages,
                'why_buy': why_buy_variants
            }
                
            app.logger.debug(f"Found street in database: {street['name']} with coordinates: {coordinates}")
            
            # Загружаем данные о свойствах для этой улицы (если есть)
            properties_on_street = []
            try:
                with open('data/properties_new.json', 'r', encoding='utf-8') as f:
                    properties_data = json.load(f)
                
                # Фильтруем свойства по улице
                for prop in properties_data:
                    if (street['name'].lower() in prop.get('location', '').lower() or
                        street['name'].lower() in prop.get('full_address', '').lower()):
                        properties_on_street.append(prop)
            except:
                pass
            
            return render_template('street_detail.html',
                                     current_city=current_city,
                                 street=street,
                                 coordinates=coordinates,
                                 properties=properties_on_street,
                                 title=f'{street["name"]} - новостройки с кэшбеком | InBack',
                                 yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
        else:
            # Ищем в JSON файле как резервный вариант
            streets_data = load_streets()
            
            # Ищем улицу по имени (учитываем URL-кодирование)
            street_name_decoded = street_name.replace('-', ' ').replace('_', ' ')
            street = None
            
            # Логируем для отладки
            app.logger.debug(f"Looking for street: {street_name} -> {street_name_decoded}")
        
        # Функция транслитерации для поиска старых URL
        def translit_to_latin(text):
            translit_map = {
                'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'e',
                'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'i', 'к': 'k', 'л': 'l', 'м': 'm',
                'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
                'ф': 'f', 'х': 'h', 'ц': 'ts', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
                'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'
            }
            result = ''
            for char in text.lower():
                result += translit_map.get(char, char)
            return result
        
        for s in streets_data:
            # Создаем URL-slug точно так же, как в фильтре (с кириллицей)
            street_slug_generated = s['name'].lower().replace(' ', '-').replace('.', '').replace('(', '').replace(')', '').replace(',', '')
            
            # Создаем полную транслитерацию для обратной совместимости
            translit_name = translit_to_latin(s['name'])
            translit_slug = translit_name.replace(' ', '-').replace('.', '').replace('(', '').replace(')', '').replace(',', '')
            
            # Простая замена символов (как было раньше)
            simple_translit = s['name'].lower().replace(' ', '-').replace('.', '').replace('ё', 'e').replace('й', 'i').replace('а', 'a').replace('г', 'g').replace('р', 'r').replace('и', 'i').replace('н', 'n').replace('(', '').replace(')', '').replace(',', '')
            
            # Множественные варианты поиска
            if (street_slug_generated == street_name.lower() or
                translit_slug == street_name.lower() or
                simple_translit == street_name.lower() or
                s['name'].lower() == street_name_decoded.lower() or
                s['name'].lower().replace(' ул.', '').replace(' ул', '') == street_name_decoded.lower().replace(' ул.', '').replace(' ул', '')):
                street = s
                app.logger.debug(f"Found street: {s['name']} with slug: {street_slug_generated}, translit: {translit_slug}")
                break
        
        if not street:
            # Пробуем найти частичное совпадение
            for s in streets_data:
                street_name_clean = street_name_decoded.lower().replace('ул', '').replace('.', '').strip()
                street_db_clean = s['name'].lower().replace('ул.', '').replace('ул', '').replace('.', '').strip()
                
                if (street_name_clean in street_db_clean or 
                    street_db_clean in street_name_clean or
                    street_name_decoded.lower() in s['name'].lower()):
                    street = s
                    app.logger.debug(f"Found street by partial match: {s['name']}")
                    break
        
        if not street:
            app.logger.error(f"Street not found: {street_name} ({street_name_decoded})")
            abort(404)
        
        # Получаем координаты из базы данных
        from models import Street
        
        # Ищем улицу в базе данных по названию
        street_db = Street.query.filter_by(name=street['name']).first()
        
        if street_db and street_db.latitude and street_db.longitude:
            coordinates = {
                'lat': float(street_db.latitude),
                'lng': float(street_db.longitude)
            }
        else:
            # Если координат нет, используем центр Краснодара
            coordinates = {
                'lat': 45.035470,
                'lng': 38.975313
            }
        
        # Загружаем данные о свойствах для этой улицы (если есть)
        properties_on_street = []
        try:
            with open('data/properties_new.json', 'r', encoding='utf-8') as f:
                properties_data = json.load(f)
            
            # Фильтруем свойства по улице
            for prop in properties_data:
                if (street['name'].lower() in prop.get('location', '').lower() or
                    street['name'].lower() in prop.get('full_address', '').lower()):
                    properties_on_street.append(prop)
        except:
            pass
        
        return render_template('street_detail.html',
                             street=street,
                             coordinates=coordinates,
                             properties=properties_on_street,
                             title=f'{street["name"]} - новостройки с кэшбеком | InBack',
                             yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
    
    except Exception as e:
        app.logger.error(f"Error loading street detail: {e}")
        abort(404)

@app.route('/sitemap.xml')
@cache.cached(timeout=3600)
def sitemap():
    """
    Dynamic sitemap generator with database integration.
    
    Includes:
    - Homepage
    - Static pages (properties, residential-complexes, developers, map, about, etc.)
    - All active properties (/{city_slug}/object/{inner_id})
    - All active residential complexes (/{city_slug}/residential-complex/{slug})
    - Multi-city pages (/{city_slug}/properties, /{city_slug}/residential-complexes)
    - Published blog posts (/blog/{slug})
    
    Cached for 1 hour for performance.
    Max 50,000 URLs per sitemap standard.
    """
    try:
        from models import Property as PropertyModel, ResidentialComplex, BlogPost, City
        
        # Canonical base URL
        base_url = CANONICAL_BASE_URL
        today = datetime.utcnow().strftime('%Y-%m-%d')
        generation_time = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')
        
        # Separate lists for URL counting
        static_urls = []
        property_urls = []
        complex_urls = []
        blog_urls = []
        
        # 1. Homepage (priority: 1.0, changefreq: daily)
        static_urls.append({
            'loc': f'{base_url}/',
            'lastmod': today,
            'changefreq': 'daily',
            'priority': '1.0'
        })
        
        # 2. Static pages (priority: 0.7-0.8, changefreq: weekly/monthly)
        static_pages = [
            ('properties', 'daily', '0.9'),
            ('residential-complexes', 'daily', '0.9'),
            ('developers', 'weekly', '0.8'),
            ('map', 'weekly', '0.8'),
            ('about', 'monthly', '0.7'),
            ('how-it-works', 'monthly', '0.7'),
            ('reviews', 'weekly', '0.7'),
            ('contacts', 'monthly', '0.8'),
            ('blog', 'daily', '0.8'),
        ]
        
        for page, changefreq, priority in static_pages:
            static_urls.append({
                'loc': f'{base_url}/{page}',
                'lastmod': today,
                'changefreq': changefreq,
                'priority': priority
            })
        
        # 3. Get all active cities for multi-city URLs
        cities = City.query.filter_by(is_active=True).all()
        
        # 4. Multi-city pages (/{city_slug}/properties, /{city_slug}/residential-complexes)
        for city in cities:
            static_urls.append({
                'loc': f'{base_url}/{city.slug}/properties',
                'lastmod': today,
                'changefreq': 'daily',
                'priority': '0.9'
            })
            static_urls.append({
                'loc': f'{base_url}/{city.slug}/residential-complexes',
                'lastmod': today,
                'changefreq': 'daily',
                'priority': '0.9'
            })
        
        # 5. All active properties (/{city_slug}/object/{inner_id})
        # Limit to needed fields for performance
        properties = PropertyModel.query.filter_by(is_active=True).with_entities(
            PropertyModel.inner_id,
            PropertyModel.city_id,
            PropertyModel.updated_at,
            PropertyModel.created_at
        ).limit(40000).all()
        
        # Create city_id to slug mapping for fast lookup
        city_slugs = {city.id: city.slug for city in cities}
        
        for prop in properties:
            if prop.inner_id and prop.city_id in city_slugs:
                lastmod = (prop.updated_at or prop.created_at or datetime.utcnow()).strftime('%Y-%m-%d')
                property_urls.append({
                    'loc': f'{base_url}/{city_slugs[prop.city_id]}/object/{prop.inner_id}',
                    'lastmod': lastmod,
                    'changefreq': 'weekly',
                    'priority': '0.8'
                })
        
        # 6. All active residential complexes (/{city_slug}/residential-complex/{slug})
        complexes = ResidentialComplex.query.filter_by(is_active=True).with_entities(
            ResidentialComplex.slug,
            ResidentialComplex.city_id,
            ResidentialComplex.updated_at,
            ResidentialComplex.created_at
        ).limit(5000).all()
        
        for complex in complexes:
            if complex.slug and complex.city_id in city_slugs:
                lastmod = (complex.updated_at or complex.created_at or datetime.utcnow()).strftime('%Y-%m-%d')
                complex_urls.append({
                    'loc': f'{base_url}/{city_slugs[complex.city_id]}/residential-complex/{complex.slug}',
                    'lastmod': lastmod,
                    'changefreq': 'weekly',
                    'priority': '0.8'
                })
        
        # 7. Published blog posts (/blog/{slug})
        blog_posts = BlogPost.query.filter_by(status='published').with_entities(
            BlogPost.slug,
            BlogPost.updated_at,
            BlogPost.published_at,
            BlogPost.created_at
        ).limit(5000).all()
        
        for post in blog_posts:
            if post.slug:
                lastmod = (post.updated_at or post.published_at or post.created_at or datetime.utcnow()).strftime('%Y-%m-%d')
                blog_urls.append({
                    'loc': f'{base_url}/blog/{post.slug}',
                    'lastmod': lastmod,
                    'changefreq': 'monthly',
                    'priority': '0.7'
                })
        
        # 8. Calculate URL counts
        url_counts = {
            'static': len(static_urls),
            'properties': len(property_urls),
            'complexes': len(complex_urls),
            'blog_posts': len(blog_urls),
            'total': len(static_urls) + len(property_urls) + len(complex_urls) + len(blog_urls)
        }
        
        # 9. Logging and warnings
        print(f"📊 Sitemap generated: {url_counts['total']} URLs")
        print(f"   - Static pages: {url_counts['static']}")
        print(f"   - Properties: {url_counts['properties']}")
        print(f"   - Residential Complexes: {url_counts['complexes']}")
        print(f"   - Blog posts: {url_counts['blog_posts']}")
        print(f"   - Capacity: {url_counts['total']/50000*100:.2f}% (limit: 50,000)")
        
        # Warnings for approaching limits
        if url_counts['total'] > 30000:
            print("⚠️  WARNING: Consider switching to Sitemap Index (30k+ URLs)")
        if url_counts['total'] > 45000:
            print("🔴 CRITICAL: Approaching 50k URL limit! Switch to Sitemap Index NOW")
        
        # 10. Combine all URLs
        all_urls = static_urls + property_urls + complex_urls + blog_urls
        
        # 11. Generate XML content with statistics comment
        xml_lines = ['<?xml version="1.0" encoding="UTF-8"?>']
        xml_lines.append('<!-- ')
        xml_lines.append(f'  InBack Sitemap - Generated: {generation_time}')
        xml_lines.append(f'  Total URLs: {url_counts["total"]}')
        xml_lines.append(f'  - Static pages: {url_counts["static"]}')
        xml_lines.append(f'  - Properties: {url_counts["properties"]}')
        xml_lines.append(f'  - Residential Complexes: {url_counts["complexes"]}')
        xml_lines.append(f'  - Blog posts: {url_counts["blog_posts"]}')
        xml_lines.append('  ')
        xml_lines.append('  Note: Sitemap Index recommended at 30,000+ URLs')
        xml_lines.append(f'  Current capacity: {url_counts["total"]} / 50,000 ({url_counts["total"]/50000*100:.2f}%)')
        xml_lines.append('-->')
        xml_lines.append('<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">')
        
        # Limit to 50,000 URLs per sitemap standard
        for url in all_urls[:50000]:
            xml_lines.append('  <url>')
            xml_lines.append(f'    <loc>{url["loc"]}</loc>')
            xml_lines.append(f'    <lastmod>{url["lastmod"]}</lastmod>')
            xml_lines.append(f'    <changefreq>{url["changefreq"]}</changefreq>')
            xml_lines.append(f'    <priority>{url["priority"]}</priority>')
            xml_lines.append('  </url>')
        
        xml_lines.append('</urlset>')
        xml_content = '\n'.join(xml_lines)
        
        # 12. Return XML response with proper headers
        response = app.response_class(
            response=xml_content,
            status=200,
            mimetype='application/xml'
        )
        response.headers['Content-Type'] = 'application/xml; charset=utf-8'
        
        app.logger.info(f"Sitemap generated successfully with {url_counts['total']} URLs")
        return response
        
    except Exception as e:
        app.logger.error(f"Error generating dynamic sitemap: {e}")
        import traceback
        app.logger.error(traceback.format_exc())
        abort(500)

@app.route('/google873bf5c5df6b6710.html')
def google_verification():
    """Google Search Console verification file"""
    return 'google-site-verification: google873bf5c5df6b6710.html'


@app.route('/sitemap-stats')
def sitemap_stats():
    """
    Debug endpoint for sitemap statistics.
    Only available in debug mode for security.
    Returns JSON with URL counts by type.
    """
    # Only allow in debug mode
    if not app.debug:
        abort(404)
    
    try:
        from models import Property as PropertyModel, ResidentialComplex, BlogPost, City
        
        # Count static pages
        static_pages_count = 10  # Homepage + 9 static pages
        
        # Count cities
        cities_count = City.query.filter_by(is_active=True).count()
        multi_city_pages_count = cities_count * 2  # /properties and /residential-complexes per city
        
        # Count properties
        properties_count = PropertyModel.query.filter_by(is_active=True).count()
        
        # Count residential complexes
        complexes_count = ResidentialComplex.query.filter_by(is_active=True).count()
        
        # Count blog posts
        blog_posts_count = BlogPost.query.filter_by(status='published').count()
        
        # Calculate totals
        total_static = static_pages_count + multi_city_pages_count
        total_urls = total_static + properties_count + complexes_count + blog_posts_count
        
        # Build response
        url_counts = {
            'static': total_static,
            'static_breakdown': {
                'homepage_and_pages': static_pages_count,
                'multi_city_pages': multi_city_pages_count,
                'cities': cities_count
            },
            'properties': properties_count,
            'complexes': complexes_count,
            'blog_posts': blog_posts_count,
            'total': total_urls,
            'capacity': {
                'current': total_urls,
                'limit': 50000,
                'percentage': round(total_urls / 50000 * 100, 2),
                'warning_threshold': 30000,
                'critical_threshold': 45000,
                'status': 'critical' if total_urls > 45000 else 'warning' if total_urls > 30000 else 'ok'
            },
            'recommendations': []
        }
        
        # Add recommendations based on URL count
        if total_urls > 45000:
            url_counts['recommendations'].append('🔴 CRITICAL: Approaching 50k URL limit! Switch to Sitemap Index NOW')
        elif total_urls > 30000:
            url_counts['recommendations'].append('⚠️  WARNING: Consider switching to Sitemap Index (30k+ URLs)')
        else:
            url_counts['recommendations'].append('✅ URL count is healthy. No action needed.')
        
        return jsonify(url_counts)
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/comparison')
@login_required
def comparison():
    """Unified comparison page for properties and complexes"""
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('comparison.html', current_city=current_city)

@app.route('/comparison-new')
@login_required
def comparison_new():
    """New improved comparison page for properties and complexes"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    return render_template('comparison_new.html')

@app.route('/thank-you')
def thank_you():
    """Thank you page after form submission"""
    return render_template('thank_you.html')

@app.route('/api/property/<int:property_id>')
def api_property_detail(property_id):
    """API endpoint to get property data for comparison"""
    property_data = get_property_by_id(property_id)
    
    if not property_data:
        return jsonify({'error': 'Property not found'}), 404
    
    
    # Use cashback_rate from excel_properties (already loaded in property_data)
    cashback_rate = property_data.get('cashback_rate', 5.0)
    
    # Calculate cashback amount using the actual cashback_rate from database
    if property_data.get('price'):
        property_data['cashback'] = round(property_data['price'] * cashback_rate / 100)
    else:
        property_data['cashback'] = 0
    
    # Add fields expected by comparison interface
    property_data['object_min_floor'] = property_data.get('floor')
    property_data['object_max_floor'] = property_data.get('total_floors')
    property_data['complex_name'] = property_data.get('residential_complex')
    
    return jsonify(property_data)

@app.route('/api/property/<int:property_id>/request-cashback', methods=['POST'])
@require_json_csrf
def api_property_request_cashback(property_id):
    """Handle cashback request for a property"""
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['name', 'phone', 'email']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'error': f'Поле {field} обязательно'}), 400
        
        # Get property data
        property_data = get_property_by_id(property_id)
        if not property_data:
            return jsonify({'error': 'Объект не найден'}), 404
        
        # Prepare notification data
        name = data.get('name')
        phone = data.get('phone')
        email = data.get('email')
        property_title = data.get('property_title', property_data.get('title', 'Объект'))
        property_address = data.get('property_address', property_data.get('address', ''))
        property_price = data.get('property_price', property_data.get('price', 0))
        
        # Send email notification
        try:
            from email_service import send_email
            
            email_subject = f"Заявка на кэшбек - {property_title}"
            email_content = f"""
            <h2>Новая заявка на получение кэшбека</h2>
            <p><strong>Клиент:</strong> {name}</p>
            <p><strong>Телефон:</strong> {phone}</p>
            <p><strong>Email:</strong> {email}</p>
            <hr>
            <p><strong>Объект:</strong> {property_title}</p>
            <p><strong>Адрес:</strong> {property_address}</p>
            <p><strong>Цена:</strong> {property_price:,.0f} ₽</p>
            <p><strong>ID объекта:</strong> {property_id}</p>
            """
            
            send_email(
                to_email='bithome@mail.ru',
                subject=email_subject,
                template_name='emails/general_notification.html',
                message=email_content,
                title=email_subject
            )
        except Exception as e:
            print(f"Error sending email: {e}")
        
        # Send Telegram notification
        try:
            import requests
            TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')
            TELEGRAM_CHAT_ID = os.environ.get('TELEGRAM_CHAT_ID')
            
            if TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID:
                telegram_message = f"""💰 <b>Заявка на кэшбек</b>

👤 Клиент: {name}
📞 Телефон: {phone}
📧 Email: {email}

🏠 Объект: {property_title}
📍 Адрес: {property_address}
💵 Цена: {property_price:,.0f} ₽
🆔 ID: {property_id}"""
                
                telegram_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
                telegram_payload = {
                    'chat_id': TELEGRAM_CHAT_ID,
                    'text': telegram_message,
                    'parse_mode': 'HTML'
                }
                
                requests.post(telegram_url, data=telegram_payload, timeout=10)
        except Exception as e:
            print(f"Error sending Telegram notification: {e}")
        
        return jsonify({
            'success': True,
            'message': 'Заявка успешно отправлена'
        })
        
    except Exception as e:
        print(f"Error in cashback request: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': 'Ошибка сервера'}), 500


@app.route('/api/property/<int:property_id>/request-online-showing', methods=['POST'])
@require_json_csrf
def api_property_request_online_showing(property_id):
    """Handle online showing request for a property"""
    try:
        data = request.get_json()
        
        # Validate required fields
        required_fields = ['name', 'phone', 'email', 'datetime']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'error': f'Поле {field} обязательно'}), 400
        
        # Get property data
        property_data = get_property_by_id(property_id)
        if not property_data:
            return jsonify({'error': 'Объект не найден'}), 404
        
        # Prepare notification data
        name = data.get('name')
        phone = data.get('phone')
        email = data.get('email')
        showing_datetime = data.get('datetime')
        property_title = data.get('property_title', property_data.get('title', 'Объект'))
        property_address = data.get('property_address', property_data.get('address', ''))
        property_price = data.get('property_price', property_data.get('price', 0))
        
        # Parse datetime for better display
        try:
            from datetime import datetime
            dt = datetime.fromisoformat(showing_datetime.replace('Z', '+00:00'))
            showing_datetime_formatted = dt.strftime('%d.%m.%Y в %H:%M')
        except:
            showing_datetime_formatted = showing_datetime
        
        # Send email notification
        try:
            from email_service import send_email
            
            email_subject = f"Заявка на онлайн показ - {property_title}"
            email_content = f"""
            <h2>Новая заявка на онлайн показ</h2>
            <p><strong>Клиент:</strong> {name}</p>
            <p><strong>Телефон:</strong> {phone}</p>
            <p><strong>Email:</strong> {email}</p>
            <p><strong>Желаемое время:</strong> {showing_datetime_formatted}</p>
            <hr>
            <p><strong>Объект:</strong> {property_title}</p>
            <p><strong>Адрес:</strong> {property_address}</p>
            <p><strong>Цена:</strong> {property_price:,.0f} ₽</p>
            <p><strong>ID объекта:</strong> {property_id}</p>
            """
            
            send_email(
                to_email='bithome@mail.ru',
                subject=email_subject,
                template_name='emails/general_notification.html',
                message=email_content,
                title=email_subject
            )
        except Exception as e:
            print(f"Error sending email: {e}")
        
        # Send Telegram notification
        try:
            import requests
            TELEGRAM_BOT_TOKEN = os.environ.get('TELEGRAM_BOT_TOKEN')
            TELEGRAM_CHAT_ID = os.environ.get('TELEGRAM_CHAT_ID')
            
            if TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID:
                telegram_message = f"""🏠 <b>Заявка на онлайн показ</b>

👤 Клиент: {name}
📞 Телефон: {phone}
📧 Email: {email}
🕐 Желаемое время: {showing_datetime_formatted}

🏠 Объект: {property_title}
📍 Адрес: {property_address}
💵 Цена: {property_price:,.0f} ₽
🆔 ID: {property_id}"""
                
                telegram_url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
                telegram_payload = {
                    'chat_id': TELEGRAM_CHAT_ID,
                    'text': telegram_message,
                    'parse_mode': 'HTML'
                }
                
                requests.post(telegram_url, data=telegram_payload, timeout=10)
        except Exception as e:
            print(f"Error sending Telegram notification: {e}")
        
        return jsonify({
            'success': True,
            'message': 'Заявка успешно отправлена'
        })
        
    except Exception as e:
        print(f"Error in online showing request: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': 'Ошибка сервера'}), 500



@require_json_csrf
@app.route('/api/properties/batch', methods=['POST'])
def api_properties_batch():
    """Batch API endpoint to get multiple properties at once - OPTIMIZED"""
    try:
        data = request.get_json()
        property_ids = data.get('ids', [])
        
        if not property_ids or not isinstance(property_ids, list):
            return jsonify({'error': 'Invalid request, expected {"ids": [1, 2, 3]}'}), 400
        
        # Convert string IDs to integers
        try:
            property_ids = [int(pid) for pid in property_ids if pid]
        except (ValueError, TypeError) as e:
            return jsonify({'error': f'Invalid ID format: {str(e)}'}), 400
        
        # ✅ SINGLE QUERY: Load all properties at once using bulk repository method
        properties_dict = PropertyRepository.get_by_ids_batch(property_ids)
        
        results = {}
        for property_id in property_ids:
            prop = properties_dict.get(property_id)
            if prop:
                # Convert ORM object to dict (same format as get_property_by_id)
                property_data = {
                    'id': prop.id,
                    'inner_id': prop.inner_id,
                    'title': prop.title,
                    'price': prop.price,
                    'rooms': prop.rooms,
                    'area': prop.area,
                    'floor': prop.floor,
                    'total_floors': prop.total_floors,
                    'main_image': prop.main_image,
                    'gallery_images': prop.gallery_images,
                    'residential_complex': prop.residential_complex.name if prop.residential_complex else 'Не указано',
                    'developer': prop.developer.name if prop.developer else 'Не указано',
                    'district': prop.district.name if prop.district else 'Не указано',
                    'address': prop.address,
                    'cashback_rate': prop.residential_complex.cashback_rate if prop.residential_complex else 5.0,
                    'latitude': prop.latitude,
                    'longitude': prop.longitude,
                }
                
                # Add cashback calculation
                cashback_rate = property_data.get('cashback_rate', 5.0)
                if property_data.get('price'):
                    property_data['cashback'] = round(property_data['price'] * cashback_rate / 100)
                else:
                    property_data['cashback'] = 0
                
                # Add comparison fields
                property_data['object_min_floor'] = property_data.get('floor')
                property_data['object_max_floor'] = property_data.get('total_floors')
                property_data['complex_name'] = property_data.get('residential_complex')
                
                results[str(property_id)] = property_data
        
        return jsonify({'success': True, 'items': results})
    except Exception as e:
        print(f"❌ Error in batch properties: {e}")
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500

@app.route('/complex-comparison')
def complex_comparison():
    """Complex comparison page"""
    return render_template('complex_comparison.html', current_city=current_city)


@app.route('/favorites')
def favorites():
    """Favorites page with animated heart pulse effects"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    return render_template('favorites.html', current_city=current_city)



@app.route('/robots.txt')
def robots_txt():
    """Robots.txt for search engine crawlers"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
    city_id=request.args.get('city_id'),
    city_slug=request.args.get('city')
    )

    robots_content = """User-agent: *
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/
Disallow: /dashboard

Sitemap: https://inback.ru/sitemap.xml

# Crawl-delay for better server performance
Crawl-delay: 1

# Specific rules for major search engines
User-agent: Googlebot
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/

User-agent: Yandex
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/

User-agent: Bingbot
Allow: /
Disallow: /admin/
Disallow: /auth/
Disallow: /api/
Disallow: /manager/"""
    
    return app.response_class(
        response=robots_content,
        status=200,
        mimetype='text/plain'
    )

# Old blog search function removed - using updated version at bottom of file


@app.route('/api/residential-complexes')
def api_residential_complexes():
    """API endpoint for getting residential complexes for cashback calculator using normalized tables"""
    from repositories.property_repository import ResidentialComplexRepository, PropertyRepository
    
    try:
        # Resolve city context for filtering
        city_context = resolve_city_context(
            city_id=request.args.get('city_id'),
            city_slug=request.args.get('city'),
            default_if_none=True
        )
        city_name = city_context.name if city_context else 'Краснодар'
        city_id_filter = city_context.id if city_context else None
        complexes = ResidentialComplexRepository.get_all_active() if not city_id_filter else [
            c for c in ResidentialComplexRepository.get_all_active() 
            if c.city_id == city_id_filter
        ]
        all_stats = PropertyRepository.get_all_property_stats()
        
        api_complexes = []
        for complex in complexes:
            cashback_rate = complex.cashback_rate if complex.cashback_rate else 5.0
            stats = all_stats.get(complex.id, {'min_price': 0})
            
            api_complexes.append({
                'id': complex.id,
                'name': complex.name,
                'cashback_rate': cashback_rate,
                'price_from': stats['min_price'],
                'district': complex.district or (city_context.name if 'city_context' in locals() else 'Краснодар')
            })
        
        print(f"API residential-complexes loaded from database: {len(api_complexes)} complexes")
        return jsonify({'complexes': api_complexes})
    
    except Exception as e:
        # Load all residential complexes from JSON data
        try:
            complexes = load_residential_complexes()
            api_complexes = []
            
            for complex in complexes:
                # Extract unique name and calculate cashback rate
                complex_name = complex.get('name', 'Неизвестный ЖК')
                cashback_rate = 5.0  # Default rate
                
                # Try to get rate from complex data or calculate based on price
                if 'cashback_rate' in complex:
                    cashback_rate = float(complex['cashback_rate'])
                elif complex.get('real_price_from'):
                    # Calculate rate based on price range (higher price = lower rate)
                    price = complex.get('real_price_from', 5000000)
                    if price < 3000000:
                        cashback_rate = 5.0
                    elif price < 8000000:
                        cashback_rate = 4.5
                    else:
                        cashback_rate = 4.0
                
                api_complexes.append({
                    'id': complex.get('id', len(api_complexes) + 1),
                    'name': complex_name,
                    'cashback_rate': cashback_rate,
                    'price_from': complex.get('real_price_from'),
                    'district': complex.get('district', city_context.name if 'city_context' in locals() else 'Краснодар')
                })
            
            # Remove duplicates by name
            unique_complexes = {}
            for complex in api_complexes:
                name = complex['name']
                if name not in unique_complexes:
                    unique_complexes[name] = complex
            
            return jsonify({'complexes': list(unique_complexes.values())})
        
        except Exception as json_error:
            print(f"Error loading JSON complexes: {json_error}")
            # Final fallback to simple list
            return jsonify({
                'complexes': [
                    {'id': 1, 'name': 'ЖК «Летний»', 'cashback_rate': 5.0},
                    {'id': 2, 'name': 'ЖК «Чайные холмы»', 'cashback_rate': 4.5},
                    {'id': 3, 'name': 'ЖК «Кислород»', 'cashback_rate': 5.0},
                    {'id': 4, 'name': 'ЖК «Гранд Каскад»', 'cashback_rate': 4.0}
                ]
            })

@app.route('/api/residential-complexes-full')
def api_residential_complexes_full():
    """API endpoint for getting all residential complexes using normalized tables"""
    from repositories.property_repository import ResidentialComplexRepository
    
    try:
        complexes = ResidentialComplexRepository.get_all_active() if not city_id_filter else [
            c for c in ResidentialComplexRepository.get_all_active() 
            if c.city_id == city_id_filter
        ]
        all_stats = PropertyRepository.get_all_property_stats()
        
        complexes_data = []
        for complex in complexes:
            stats = all_stats.get(complex.id, {
                'min_price': 0,
                'max_price': 0,
                'total_properties': 0
            })
            
            complex_dict = {
                'id': complex.id,
                'name': complex.name,
                'cashback_rate': complex.cashback_rate if complex.cashback_rate else 5.0,
                'district': complex.district or (city_context.name if 'city_context' in locals() else 'Краснодар'),
                'address': complex.address or 'Адрес не указан',
                'developer': complex.developer.name if complex.developer else 'Не указан',
                'min_price': stats['min_price'],
                'max_price': stats['max_price'],
                'real_price_from': stats['min_price'],
                'real_price_to': stats['max_price'],
                'available_apartments': stats['total_properties']
            }
            complexes_data.append(complex_dict)
        
        return jsonify({'complexes': complexes_data})
    except Exception as e:
        print(f"Error loading residential complexes: {e}")
        return jsonify({'complexes': []}), 500

@app.route('/api/cashback/calculate', methods=['POST'])
# @csrf.exempt  # CSRF disabled  # Disable CSRF for API endpoint
def api_calculate_cashback():
    """API endpoint for calculating cashback"""
    try:
        data = request.get_json()
        price = float(data.get('price', 0))
        complex_id = data.get('complex_id')
        
        if not price or price <= 0:
            return jsonify({'error': 'Invalid price'}), 400
        
        # Get cashback rate from database
        cashback_rate = 5.0  # default
        
        if complex_id:
            try:
                # Ищем комплекс в JSON данных
                import json
                import os
                
                residential_complexes_file = 'static/data/residential_complexes.json'
                if os.path.exists(residential_complexes_file):
                    with open(residential_complexes_file, 'r', encoding='utf-8') as file:
                        json_complexes = json.load(file)
                    
                    for complex in json_complexes:
                        if str(complex.get('id')) == str(complex_id):
                            if 'cashback_rate' in complex:
                                cashback_rate = float(complex['cashback_rate'])
                            elif complex.get('real_price_from'):
                                # Calculate rate based on price range
                                complex_price = complex.get('real_price_from', 5000000)
                                if complex_price < 3000000:
                                    cashback_rate = 5.0
                                elif complex_price < 8000000:
                                    cashback_rate = 4.5
                                else:
                                    cashback_rate = 4.0
                            break
                            
                # Если не нашли в JSON, используем fallback ставки по ID
            except:
                # Fallback rates
                complex_rates = {
                    1: 5.5, 2: 6.0, 3: 7.0, 4: 5.0,
                    5: 6.5, 6: 5.5, 7: 7.5, 8: 8.0
                }
                cashback_rate = complex_rates.get(int(complex_id), 5.0)
        
        cashback_amount = price * (cashback_rate / 100)
        
        # Cap at maximum
        max_cashback = 500000
        if cashback_amount > max_cashback:
            cashback_amount = max_cashback
        
        return jsonify({
            'cashback_amount': int(cashback_amount),
            'cashback_rate': cashback_rate,
            'price': int(price),
            'formatted_amount': f"{int(cashback_amount):,}".replace(',', ' ')
        })
    
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/cashback/apply', methods=['POST'])
@login_required
# @csrf.exempt  # CSRF disabled  # Disable CSRF for API endpoint
def api_apply_cashback():
    """API endpoint for submitting cashback application"""
    try:
        from models import CashbackApplication, UserActivity, CallbackRequest
        
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Неверный формат данных'}), 400
            
        price = data.get('price')
        complex_id = data.get('complex_id')  # Может быть null для калькулятора
        complex_name = data.get('complex_name', 'Не указан')
        cashback_amount = data.get('cashback_amount')
        cashback_rate = data.get('cashback_rate', 2.5)
        user_phone = data.get('phone', '')
        user_name = data.get('name', '')
        
        # Validate required fields (complex_id опционален)
        if not all([price, cashback_amount, user_phone, user_name]):
            return jsonify({'error': 'Заполните все обязательные поля'}), 400
        
        # Validate data types
        try:
            price = float(price)
            cashback_amount = float(cashback_amount)
            cashback_rate = float(cashback_rate)
        except (ValueError, TypeError):
            return jsonify({'error': 'Неверный формат числовых данных'}), 400
        
        # Create cashback application
        cashback_app = CashbackApplication(
            user_id=current_user.id,
            property_name=f"Квартира в {complex_name}",
            property_type="Квартира",
            property_size=50.0,  # Default size, can be improved later
            property_price=int(price),
            complex_name=complex_name,
            developer_name=data.get('developer_name', 'Не указан'),
            cashback_amount=int(cashback_amount),
            cashback_percent=cashback_rate,
            status='В обработке'
        )
        
        db.session.add(cashback_app)
        
        # Record user activity
        UserActivity.log_activity(
            user_id=current_user.id,
            activity_type='cashback_application',
            description=f'Подана заявка на кешбек {int(cashback_amount):,} ₽ по объекту в {complex_name}'.replace(',', ' '),
            complex_id=complex_id
        )
        
        # Create callback request for manager
        callback = CallbackRequest(
            name=user_name,
            phone=user_phone,
            notes=f"Заявка на кешбек {int(cashback_amount):,} ₽ при покупке квартиры в {complex_name} стоимостью {int(price):,} ₽".replace(',', ' ')
        )
        
        db.session.add(callback)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Заявка успешно отправлена! Менеджер свяжется с вами в ближайшее время.'
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': f'Ошибка при отправке заявки: {str(e)}'}), 500

@app.route('/api/image-proxy')
def image_proxy():
    """
    Proxy endpoint to serve images with watermark cropped out
    Usage: /api/image-proxy?url=<image_url>&crop=<percent>
    """
    image_url = request.args.get('url')
    crop_percent = request.args.get('crop', '8')  # Default 8%
    
    if not image_url:
        return jsonify({'error': 'No image URL provided'}), 400
    
    try:
        crop_percent = int(crop_percent)
        
        # Crop watermark from image
        cropped_img = crop_watermark(image_url, crop_bottom_percent=crop_percent)
        
        if cropped_img is None:
            # If cropping failed, redirect to original image
            return redirect(image_url)
        
        # Convert to bytes
        img_io = io.BytesIO()
        cropped_img.save(img_io, format='JPEG', quality=90, optimize=True)
        img_io.seek(0)
        
        # Return image with caching headers
        response = make_response(send_file(img_io, mimetype='image/jpeg'))
        response.headers['Cache-Control'] = 'public, max-age=2592000'  # Cache for 30 days
        response.headers['X-Content-Type-Options'] = 'nosniff'
        
        return response
        
    except Exception as e:
        print(f"Error in image proxy: {e}")
        # Fallback to original image on error
        return redirect(image_url)

@app.route('/api/search/suggestions')
def search_suggestions():
    """API endpoint for search suggestions (autocomplete) - REAL DATABASE VERSION"""
    query = request.args.get('query', request.args.get('q', '')).lower().strip()
    if not query or len(query) < 2:
        return jsonify([])
    
    # ✅ Get city context from URL parameter or session
    city_id = request.args.get('city_id', type=int)
    city_name_genitive = None
    if not city_id and 'city_id' in session:
        city_id = session['city_id']
    
    if city_id:
        from models import City
        city_obj = City.query.get(city_id)
        if city_obj:
            city_name_genitive = city_obj.name_genitive or city_obj.name
    
    suggestions = []
    

    def get_plural_form(count, singular, few, many):
        """Russian plural forms: 1 квартира, 2-4 квартиры, 5+ квартир"""
        count = abs(count) % 100
        if 11 <= count <= 14:
            return many
        last_digit = count % 10
        if last_digit == 1:
            return singular
        elif 2 <= last_digit <= 4:
            return few
        else:
            return many

    try:
        # 1. Search by room types (PRIORITY - user's main request)
        room_suggestions = {
            'студ': 'Студия',
            '1-к': '1-комнатная',
            '1-ком': '1-комнатная', 
            '1комн': '1-комнатная',
            '1к': '1-комнатная',
            '1 к': '1-комнатная',
            'одн': '1-комнатная',
            '2-к': '2-комнатная',
            '2-ком': '2-комнатная',
            '2комн': '2-комнатная',
            '2к': '2-комнатная',
            '2 к': '2-комнатная', 
            'двух': '2-комнатная',
            '3-к': '3-комнатная',
            '3-ком': '3-комнатная',
            '3комн': '3-комнатная',
            '3к': '3-комнатная',
            '3 к': '3-комнатная',
            'трех': '3-комнатная',
            'трёх': '3-комнатная',
            '4-к': '4-комнатная',
            '4-ком': '4-комнатная',
            '4комн': '4-комнатная',
            '4к': '4-комнатная',
            'четыр': '4-комнатная'
        }
        
        for pattern, room_type in room_suggestions.items():
            if pattern in query:
                # ✅ MIGRATED: Count properties by room type using PropertyRepository
                if 'студ' in pattern:
                    count = PropertyRepository.count_active(filters={'rooms': [0], 'city_id': city_id}) if city_id else PropertyRepository.count_active(filters={'rooms': [0]})
                else:
                    room_num = room_type.split('-')[0] if '-' in room_type else '1'
                    count = PropertyRepository.count_active(filters={'rooms': [int(room_num)], 'city_id': city_id}) if city_id else PropertyRepository.count_active(filters={'rooms': [int(room_num)]})
                
                # Создаем URL с тем же параметром что быстрые фильтры
                if 'студ' in pattern:
                    room_param = '0'
                else:
                    room_param = room_type.split('-')[0] if '-' in room_type else '1'
                
                
                # Build subtitle with correct city and plural form
                plural_form = get_plural_form(count, 'квартира', 'квартиры', 'квартир')
                if city_name_genitive:
                    subtitle = f'Найдено {count} {plural_form} для {city_name_genitive}'
                else:
                    subtitle = f'Найдено {count} {plural_form}'
                
                suggestions.append({
                    'type': 'rooms', 
                    'text': room_type,
                    'title': room_type,  # Добавляем title для совместимости
                    'subtitle': subtitle,
                    'url': url_for('properties', rooms=room_param)  # rooms=1 как быстрые фильтры
                })
        
        # ✅ MIGRATED: Search in residential complexes using ORM
        from models import ResidentialComplex, Property
        complexes_query = (
            db.session.query(ResidentialComplex.name, func.count(Property.id).label('count'))
            .join(Property, Property.complex_id == ResidentialComplex.id, isouter=True)
            .filter(
                ResidentialComplex.name.ilike(f'%{query}%'),
                Property.is_active == True
            )
            .group_by(ResidentialComplex.name)
            .order_by(func.count(Property.id).desc())
            .limit(5)
            .all()
        )
        
        for row in complexes_query:
            if row[0] and len(row[0]) > 2:  # Skip empty/short names
                suggestions.append({
                    'type': 'complex',
                    'text': row[0],
                    'subtitle': f'{row[1]} квартир доступно',
                    'url': url_for('properties', residential_complex=row[0])
                })
        
        # ✅ MIGRATED: Search in developers using ORM
        from models import Developer
        developers_query = (
            db.session.query(Developer.name, func.count(Property.id).label('count'))
            .join(Property, Property.developer_id == Developer.id, isouter=True)
            .filter(
                Developer.name.ilike(f'%{query}%'),
                Property.is_active == True
            )
            .group_by(Developer.name)
            .order_by(func.count(Property.id).desc())
            .limit(3)
            .all()
        )
        
        for row in developers_query:
            if row[0] and len(row[0]) > 2:
                suggestions.append({
                    'type': 'developer',
                    'text': row[0],
                    'subtitle': f'Застройщик • {row[1]} проектов',
                    'url': url_for('properties', developer=row[0])
                })
        
        # ✅ NEW: Search districts from District reference table (shows all districts, not just those with properties)
        from models import District
        district_ref_filter = [District.name.ilike(f'%{query}%')]
        
        if city_id:
            district_ref_filter.append(District.city_id == city_id)
        
        district_ref_query = (
            db.session.query(District.name, District.id)
            .filter(*district_ref_filter)
            .limit(5)
            .all()
        )
        
        for district_row in district_ref_query:
            district_name = district_row[0]
            district_id = district_row[1]
            
            if district_name and 'Краснодарский' not in district_name:
                clean_district = district_name.replace('Россия, ', '').replace('Краснодарский край, ', '')
                
                display_text = clean_district
                if 'мкр' not in clean_district.lower() and 'микрорайон' not in clean_district.lower():
                    display_text = f'Район {clean_district}'
                
                count = PropertyRepository.count_active(filters={'district_id': district_id})
                plural_form = get_plural_form(count, 'квартира', 'квартиры', 'квартир')
                
                suggestions.append({
                    'type': 'district',
                    'text': display_text,
                    'subtitle': f'{count} {plural_form}' if count > 0 else 'Район города',
                    'url': url_for('properties', district=clean_district)
                })
        

        # ✅ MIGRATED: Search in districts using ORM with city filtering
        from models import District
        districts_filter = [
            District.name.ilike(f'%{query}%'),
            Property.is_active == True
        ]
        
        # ✅ Filter by current city if city_id is set
        if city_id:
            districts_filter.append(District.city_id == city_id)
        
        districts_query = (
            db.session.query(District.name, func.count(Property.id).label('count'))
            .join(Property, Property.district_id == District.id, isouter=True)
            .filter(*districts_filter)
            .group_by(District.name)
            .order_by(func.count(Property.id).desc())
            .limit(5)
            .all()
        )
        
        for row in districts_query:
            if row[0] and 'Краснодарский' not in row[0]:  # Skip generic region name
                clean_district = row[0].replace('Россия, ', '').replace('Краснодарский край, ', '')
                
                # Format like Yandex.Недвижимость: "Район Западный" or "мкр. Бытха"
                display_text = clean_district
                if 'мкр' not in clean_district.lower() and 'микрорайон' not in clean_district.lower():
                    display_text = f'Район {clean_district}'
                
                plural_form = get_plural_form(row[1], 'квартира', 'квартиры', 'квартир')
                
                already_added = any(s['text'] == display_text for s in suggestions if s.get('type') == 'district')
                
                if not already_added:
                    suggestions.append({
                    'type': 'district',
                    'text': display_text,
                    'subtitle': f'{row[1]} {plural_form}',
                    'url': url_for('properties', district=clean_district)
                })
        
        # Search by property types (квартира, пентхаус, таунхаус, дом)
        property_type_keywords = {
            'квартир': 'Квартира',
            'пентхаус': 'Пентхаус',
            'таунхаус': 'Таунхаус',
            'дом': 'Дом',
            'house': 'Дом',
            'townhouse': 'Таунхаус'
        }
        
        for keyword, prop_type in property_type_keywords.items():
            if keyword in query:
                # Count properties of this type
                try:
                    count_query = (
                        db.session.query(func.count(Property.id))
                        .filter(
                            Property.property_type.ilike(f'%{prop_type}%'),
                            Property.is_active == True
                        )
                    )
                    count = count_query.scalar() or 0
                    
                    if count > 0:  # Only show if there are results
                        suggestions.append({
                            'type': 'property_type',
                            'text': prop_type,
                            'subtitle': f'Найдено {count} объектов',
                            'url': url_for('properties', property_type=prop_type)
                        })
                except Exception as e:
                    print(f"Property type search error: {e}")
                    pass
        
        # DaData address suggestions (cities, streets, districts)
        dadata = get_dadata_client()
        if dadata.is_available():
            try:
                dadata_suggestions = dadata.suggest_address(
                    query,
                    count=5,
                    # ✅ NO city_id filter - universal search for ALL cities (like Avito/Cian)
                )
                for item in dadata_suggestions:
                    addr_type = item['type']

                    # ✅ CRITICAL FIX: Skip districts from DaData - we use local District table instead!
                    # DaData returns districts from ALL cities in the region (e.g., Mostovskoy, Beloglinskiy)
                    # which confuses users. Our District table has curated city-specific data.
                    if addr_type == 'district':
                        continue

                    # Map DaData types to UI-friendly names
                    type_map = {
                        'city': 'Город',
                        'street': 'Улица', 
                        'district': 'Район',
                        'settlement': 'Населенный пункт',
                        'region': 'Регион'
                    }
                    suggestions.append({
                        'type': addr_type,
                        'text': item['text'],
                        'subtitle': type_map.get(addr_type, addr_type),
                        'url': url_for('properties', search=item['text']),
                        'source': 'dadata'
                    })
                app.logger.info(f"✅ DaData added {len(dadata_suggestions)} address suggestions")
            except Exception as e:
                app.logger.warning(f"DaData suggestions failed (fallback to DB): {e}")
        
        # Sort by relevance with proper priority:
        # 1. Room types (highest priority)
        # 2. Exact matches
        # 3. DaData addresses (cities, streets, districts)
        # 4. DB results (complexes, developers, districts)
        suggestions.sort(key=lambda x: (
            0 if x['type'] == 'room_type' else 
            1 if x['text'].lower().startswith(query) else
            2 if x.get('source') == 'dadata' else 3,
            len(x['text'])
        ))
        
        return jsonify(suggestions[:10])  # Return top 10 suggestions
        
    except Exception as e:
        app.logger.error(f"Error in search suggestions: {e}")
        return jsonify([])


@require_json_csrf
@app.route('/api/search/history/save', methods=['POST'])
def save_search_history():
    """Save user's search query to history"""
    try:
        from models import SearchHistory, SearchAnalytics, Manager
        
        data = request.get_json() or {}
        query = data.get('query', '').strip()
        result_count = data.get('result_count', 0)
        
        if not query:
            return jsonify({'success': False, 'error': 'Query is required'}), 400
        
        # Determine user or manager using proper isinstance check
        user_id = None
        manager_id = None
        
        if current_user.is_authenticated:
            current_obj = current_user._get_current_object()
            if isinstance(current_obj, Manager):
                manager_id = current_user.id
            else:
                user_id = current_user.id
        
        # Only save history for authenticated users
        if user_id or manager_id:
            # Save to search history
            history_entry = SearchHistory(
                query=query,
                user_id=user_id,
                manager_id=manager_id,
                result_count=result_count
            )
            db.session.add(history_entry)
            
            # Record in analytics
            SearchAnalytics.record_search(query, result_count)
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': 'Search saved to history'
            })
        else:
            # Unauthorized - require authentication for search history
            return jsonify({'success': False, 'error': 'Authentication required'}), 401
    
    except Exception as e:
        app.logger.error(f"Error saving search history: {e}")
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/search/history/list')
def get_search_history():
    """Get user's search history (last 20 searches)"""
    try:
        from models import SearchHistory, Manager
        
        if not current_user.is_authenticated:
            return jsonify({'success': False, 'history': [], 'error': 'Not authenticated'}), 401
        
        # Determine if user or manager using proper isinstance check
        current_obj = current_user._get_current_object()
        if isinstance(current_obj, Manager):
            history = db.session.query(SearchHistory).filter_by(
                manager_id=current_user.id
            ).order_by(SearchHistory.created_at.desc()).limit(20).all()
        else:
            history = db.session.query(SearchHistory).filter_by(
                user_id=current_user.id
            ).order_by(SearchHistory.created_at.desc()).limit(20).all()
        
        return jsonify({
            'success': True,
            'history': [h.to_dict() for h in history]
        })
    
    except Exception as e:
        app.logger.error(f"Error getting search history: {e}")
        return jsonify({'success': False, 'history': [], 'error': str(e)}), 500


@app.route('/api/search/popular')
def get_popular_searches():
    """Get popular search queries from real user data"""
    try:
        from models import SearchAnalytics
        
        limit = request.args.get('limit', default=10, type=int)
        limit = min(limit, 20)  # Cap at 20
        
        # Get popular searches from analytics
        popular = SearchAnalytics.get_popular_searches(limit=limit, min_results=1)
        
        # Format for frontend
        suggestions = []
        for analytics in popular:
            # Create room type button if it's a room search
            query = analytics.query
            icon = '🔥'
            
            # Detect room types for appropriate icons
            if any(word in query for word in ['студ', 'studio']):
                icon = '🏠'
            elif any(word in query for word in ['1', 'одн', 'один']):
                icon = '🏠'
            elif any(word in query for word in ['2', 'двух', 'два']):
                icon = '🏠'
            elif any(word in query for word in ['3', 'трех', 'три', 'трёх']):
                icon = '🏠'
            elif any(word in query for word in ['центр', 'цен']):
                icon = '📍'
            elif any(word in query for word in ['парк', 'сквер']):
                icon = '🌳'
            
            suggestions.append({
                'query': query,
                'icon': icon,
                'count': int(analytics.result_count_avg),
                'search_count': analytics.search_count
            })
        
        return jsonify({
            'success': True,
            'popular': suggestions
        })
    
    except Exception as e:
        app.logger.error(f"Error getting popular searches: {e}")
        return jsonify({'success': False, 'popular': []})
@app.route('/family-mortgage')
def family_mortgage():
    """Family mortgage page"""
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('family_mortgage.html', current_city=current_city)

@app.route('/it-mortgage')
def it_mortgage():
    """IT mortgage page"""
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('it_mortgage.html', current_city=current_city)

@app.route('/insurance')
def insurance():
    """Insurance page"""
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('insurance.html', current_city=current_city)


@app.route('/appraisal')
@app.route('/otsenka')
def appraisal():
    """Property appraisal (оценка недвижимости) page"""
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('appraisal.html', current_city=current_city)
@app.route('/submit-insurance-application', methods=['POST'])
def submit_insurance_application():
    """Submit insurance application with CSRF protection and enhanced validation"""
    try:
        # Validate CSRF token for form submissions
        try:
            validate_csrf(request.form.get('csrf_token'))
        except Exception:
            return jsonify({'success': False, 'error': 'CSRF token missing or invalid'}), 400
        
        # Get form data
        name = request.form.get('name', '').strip()
        phone = request.form.get('phone', '').strip()
        bank = request.form.get('bank', '').strip()
        credit_amount = request.form.get('credit_amount', '').strip()
        birth_date = request.form.get('birth_date', '').strip()
        gender = request.form.get('gender', '').strip()
        comment = request.form.get('comment', '').strip()
        
        # Enhanced validation for required fields
        if not all([name, phone, bank, credit_amount, birth_date, gender]):
            return jsonify({'success': False, 'error': 'Заполните все обязательные поля'}), 400
        
        # Validate name (2-50 characters, only letters and spaces)
        if not re.match(r'^[а-яА-ЯёЁa-zA-Z\s]{2,50}$', name):
            return jsonify({'success': False, 'error': 'Некорректное имя'}), 400
        
        # Validate phone (Russian phone number format)
        phone_clean = re.sub(r'[^\d]', '', phone)
        if not re.match(r'^[78]\d{10}$', phone_clean):
            return jsonify({'success': False, 'error': 'Некорректный номер телефона'}), 400
        
        # Validate credit amount (numeric, reasonable range)
        try:
            credit_amount_num = float(re.sub(r'[^\d.]', '', credit_amount))
            if credit_amount_num < 100000 or credit_amount_num > 50000000:
                return jsonify({'success': False, 'error': 'Сумма кредита должна быть от 100 000 до 50 000 000 рублей'}), 400
        except (ValueError, TypeError):
            return jsonify({'success': False, 'error': 'Некорректная сумма кредита'}), 400
        
        # Validate birth date
        try:
            from datetime import datetime
            birth_dt = datetime.strptime(birth_date, '%Y-%m-%d')
            age = (datetime.now() - birth_dt).days / 365.25
            if age < 18 or age > 100:
                return jsonify({'success': False, 'error': 'Возраст должен быть от 18 до 100 лет'}), 400
        except ValueError:
            return jsonify({'success': False, 'error': 'Некорректная дата рождения'}), 400
        
        # Validate gender
        if gender not in ['Мужчина', 'Женщина']:
            return jsonify({'success': False, 'error': 'Некорректный пол'}), 400
        
        # Format credit amount for display
        try:
            credit_amount_num = int(credit_amount)
            credit_amount_formatted = f"{credit_amount_num:,}".replace(",", " ") + " ₽"
        except:
            credit_amount_formatted = credit_amount + " ₽"
        
        # Dual notification: send to both email and Telegram
        current_time = datetime.now().strftime('%d.%m.%Y %H:%M')
        
        # Send email notification
        email_success = False
        try:
            email_success = send_email(
                'bithome@mail.ru', 
                f'Новая заявка на страхование от {name}', 
                'emails/insurance_application.html', 
                name=name, 
                phone=phone, 
                bank=bank, 
                credit_amount=credit_amount_formatted, 
                birth_date=birth_date, 
                gender=gender, 
                comment=comment, 
                submitted_at=datetime.now(),
                current_time=current_time
            )
        except Exception as email_error:
            app.logger.error(f"Error sending insurance application email: {email_error}")
        
        # Send Telegram notification
        telegram_success = False
        try:
            from email_service import send_telegram_insurance_notification
            telegram_success = send_telegram_insurance_notification(
                name=name,
                phone=phone,
                bank=bank,
                credit_amount=credit_amount_formatted,
                birth_date=birth_date,
                gender=gender,
                comment=comment,
                current_time=current_time
            )
        except Exception as telegram_error:
            app.logger.error(f"Error sending insurance application Telegram: {telegram_error}")
        
        # Determine response based on both results
        if email_success and telegram_success:
            return jsonify({'success': True, 'message': 'Заявка успешно отправлена на email и в Telegram'})
        elif email_success and not telegram_success:
            return jsonify({'success': True, 'message': 'Заявка отправлена на email, но не удалось отправить в Telegram', 'warning': True})
        elif not email_success and telegram_success:
            return jsonify({'success': True, 'message': 'Заявка отправлена в Telegram, но не удалось отправить на email', 'warning': True})
        else:
            return jsonify({'success': False, 'error': 'Ошибка отправки заявки и на email, и в Telegram'}), 500
            
    except Exception as e:
        app.logger.error(f"Error in insurance application: {e}")
        return jsonify({'success': False, 'error': 'Внутренняя ошибка сервера'}), 500

@app.route('/api/check-it-company', methods=['POST'])
@csrf.exempt
def check_it_company():
    """Check if company is in IT companies list by INN or company name"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'Нет данных для проверки'}), 400
            
        inn = data.get('inn', '').strip()
        company_name = data.get('company_name', '').strip()
        
        if not inn and not company_name:
            return jsonify({'error': 'Необходимо указать ИНН или название компании'}), 400
        
        # Поиск по ИНН
        if inn:
            try:
                inn_int = int(inn)
                company = db.session.execute(text("""
                    SELECT inn, name FROM it_companies 
                    WHERE inn = :inn LIMIT 1
                """), {'inn': inn_int}).fetchone()
                
                if company:
                    return jsonify({
                        'found': True,
                        'inn': company[0],
                        'company_name': company[1],
                        'message': 'Компания найдена в реестре ИТ-организаций'
                    })
            except ValueError:
                pass
        
        # Поиск по названию компании (частичное совпадение)
        if company_name:
            company = db.session.execute(text("""
                SELECT inn, name FROM it_companies 
                WHERE LOWER(name) LIKE LOWER(:company_name) 
                LIMIT 1
            """), {'company_name': f'%{company_name}%'}).fetchone()
            
            if company:
                return jsonify({
                    'found': True,
                    'inn': company[0],
                    'company_name': company[1],
                    'message': 'Компания найдена в реестре ИТ-организаций'
                })
        
        return jsonify({
            'found': False,
            'message': 'Компания не найдена в реестре ИТ-организаций. Проверьте правильность ИНН или названия компании.'
        })
        
    except Exception as e:
        print(f"Error checking IT company: {e}")
        return jsonify({'error': 'Ошибка при проверке компании'}), 500

@app.route('/api/suggest-it-companies', methods=['POST'])
@csrf.exempt
def suggest_it_companies():
    """Get IT company suggestions for autocomplete"""
    try:
        data = request.get_json()
        query = data.get('query', '').strip().lower()
        
        if len(query) < 2:
            return jsonify({'suggestions': []})
            
        # Search for companies matching the query
        suggestions = db.session.execute(text("""
            SELECT DISTINCT name FROM it_companies 
            WHERE LOWER(name) LIKE :query 
            ORDER BY name 
            LIMIT 10
        """), {'query': f'%{query}%'}).fetchall()
        
        return jsonify({
            'suggestions': [suggestion[0] for suggestion in suggestions]
        })
        
    except Exception as e:
        print(f"Error in suggest_it_companies: {str(e)}")
        return jsonify({'suggestions': []})

@app.route('/api/detect-city', methods=['GET'])
@csrf.exempt
def detect_city():
    """Detect user's city by IP address and auto-set session['city_id']"""
    from models import City
    
    # Словарь для перевода транслита городов в русские названия
    city_translations = {
        'Krasnodar': 'Краснодар',
        'Moscow': 'Москва',
        'Saint Petersburg': 'Санкт-Петербург',
        'Novosibirsk': 'Новосибирск',
        'Yekaterinburg': 'Екатеринбург',
        'Nizhny Novgorod': 'Нижний Новгород',
        'Kazan': 'Казань',
        'Chelyabinsk': 'Челябинск',
        'Omsk': 'Омск',
        'Samara': 'Самара',
        'Rostov-on-Don': 'Ростов-на-Дону',
        'Ufa': 'Уфа',
        'Krasnoyarsk': 'Красноярск',
        'Voronezh': 'Воронеж',
        'Perm': 'Пермь',
        'Volgograd': 'Волгоград',
        'Saratov': 'Саратов',
        'Tyumen': 'Тюмень',
        'Tolyatti': 'Тольятти',
        'Izhevsk': 'Ижевск',
        'Barnaul': 'Барнаул',
        'Ulyanovsk': 'Ульяновск',
        'Irkutsk': 'Иркутск',
        'Khabarovsk': 'Хабаровск',
        'Yaroslavl': 'Ярославль',
        'Vladivostok': 'Владивосток',
        'Makhachkala': 'Махачкала',
        'Tomsk': 'Томск',
        'Orenburg': 'Оренбург',
        'Kemerovo': 'Кемерово',
        'Novokuznetsk': 'Новокузнецк',
        'Ryazan': 'Рязань',
        'Astrakhan': 'Астрахань',
        'Naberezhnye Chelny': 'Набережные Челны',
        'Penza': 'Пенза',
        'Lipetsk': 'Липецк',
        'Kirov': 'Киров',
        'Cheboksary': 'Чебоксары',
        'Kaliningrad': 'Калининград',
        'Tula': 'Тула',
        'Kursk': 'Курск',
        'Sochi': 'Сочи',
        'Stavropol': 'Ставрополь',
        'Ulan-Ude': 'Улан-Удэ',
        'Tver': 'Тверь',
        'Magnitogorsk': 'Магнитогорск',
        'Bryansk': 'Брянск',
        'Ivanovo': 'Иваново',
        'Belgorod': 'Белгород'
    }
    
    # Словарь для перевода регионов
    region_translations = {
        'Krasnodar Krai': 'Краснодарский край',
        'Krasnodar Territory': 'Краснодарский край',
        'Moscow': 'Москва',
        'Saint Petersburg': 'Санкт-Петербург',
        'Moscow Oblast': 'Московская область',
        'Sverdlovsk Oblast': 'Свердловская область',
        'Novosibirsk Oblast': 'Новосибирская область',
        'Rostov Oblast': 'Ростовская область',
        'Tatarstan': 'Республика Татарстан',
        'Bashkortostan': 'Республика Башкортостан',
        'Chelyabinsk Oblast': 'Челябинская область'
    }
    
    # Map of supported cities (in our database) to their Russian names
    supported_cities = {
        'Краснодар': 'krasnodar',
        'Сочи': 'sochi',
        'Анапа': 'anapa',
        'Геленджик': 'gelendzhik',
        'Новороссийск': 'novorossiysk',
        'Армавир': 'armavir',
        'Туапсе': 'tuapse',
        'Майкоп': 'maykop'
    }
    
    def set_city_in_session(city_name):
        """Helper function to set city_id in session based on city name"""
        # Find city in database
        detected_city_slug = supported_cities.get(city_name)
        
        if detected_city_slug:
            # City is supported - find in database
            city_obj = City.query.filter_by(slug=detected_city_slug, is_active=True).first()
            if city_obj:
                session['city_id'] = city_obj.id
                print(f"✅ Auto-detected city: {city_obj.name} (ID: {city_obj.id})")
                return city_obj.id
        
        # If city not supported or not found, use default (Krasnodar)
        default_city = City.query.filter_by(slug='krasnodar', is_active=True).first()
        if default_city:
            session['city_id'] = default_city.id
            print(f"✅ Using default city: {default_city.name} (ID: {default_city.id})")
            return default_city.id
        
        return None
    
    try:
        # Get user's IP address from request
        user_ip = request.headers.get('X-Forwarded-For', request.remote_addr)
        if ',' in user_ip:
            user_ip = user_ip.split(',')[0].strip()
        
        # Skip localhost/private IPs
        if user_ip in ['127.0.0.1', 'localhost', '::1'] or user_ip.startswith('192.168.') or user_ip.startswith('10.'):
            city_name = 'Краснодар'
            city_id = set_city_in_session(city_name)
            return jsonify({
                'success': True,
                'city': city_name,
                'region': 'Краснодарский край',
                'country': 'Россия',
                'detected': False,
                'city_id': city_id,
                'message': 'Локальный IP, используется город по умолчанию'
            })
        
        # Use ipwhois.io API (free, no API key required, 10,000 requests/month)
        api_url = f'http://ipwho.is/{user_ip}'
        response = requests.get(api_url, timeout=3)
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get('success', False):
                city_en = data.get('city', 'Krasnodar')
                region_en = data.get('region', 'Krasnodar Krai')
                
                # Переводим город и регион на русский
                city = city_translations.get(city_en, city_en if not city_en else 'Краснодар')
                region = region_translations.get(region_en, region_en if not region_en else 'Краснодарский край')
                
                # Set city in session
                city_id = set_city_in_session(city)
                
                return jsonify({
                    'success': True,
                    'city': city,
                    'region': region,
                    'country': 'Россия',
                    'detected': True if supported_cities.get(city) else False,
                    'city_id': city_id,
                    'ip': user_ip
                })
        
        # Fallback to default city
        city_name = 'Краснодар'
        city_id = set_city_in_session(city_name)
        return jsonify({
            'success': True,
            'city': city_name,
            'region': 'Краснодарский край',
            'country': 'Россия',
            'detected': False,
            'city_id': city_id,
            'message': 'Не удалось определить город, используется город по умолчанию'
        })
        
    except Exception as e:
        print(f"Error detecting city: {e}")
        # Make sure to set default city on error too
        city_name = 'Краснодар'
        city_id = set_city_in_session(city_name)
        return jsonify({
            'success': True,
            'city': city_name,
            'region': 'Краснодарский край',
            'country': 'Россия',
            'detected': False,
            'city_id': city_id,
            'error': str(e)
        })


# =============================================================================
# Geocoding API Endpoints
# =============================================================================

@app.route('/api/geocode/autocomplete', methods=['GET'])
@csrf.exempt
def geocode_autocomplete():
    """
    Address autocomplete API endpoint
    Returns address suggestions as user types
    """
    query = request.args.get('query', '').strip()
    
    if not query or len(query) < 2:
        return jsonify({'suggestions': []})
    
    # Optional geolocation bias to Krasnodar
    lat = request.args.get('lat', type=float)
    lon = request.args.get('lon', type=float)
    
    # Default to Krasnodar center if no coordinates provided
    if not lat or not lon:
        lat = 45.0355  # Krasnodar center
        lon = 38.9753
    
    try:
        geocoding_service = get_geocoding_service()
        suggestions = geocoding_service.autocomplete(
            query=query,
            latitude=lat,
            longitude=lon,
            results=7
        )
        
        return jsonify({
            'success': True,
            'suggestions': suggestions,
            'count': len(suggestions)
        })
        
    except Exception as e:
        logger.error(f"Autocomplete error: {e}")
        return jsonify({
            'success': False,
            'error': str(e),
            'suggestions': []
        }), 500


@app.route('/api/geocode/reverse', methods=['GET'])
@csrf.exempt
def geocode_reverse():
    """
    Reverse geocoding API endpoint
    Convert coordinates to address components
    """
    lat = request.args.get('lat', type=float)
    lon = request.args.get('lon', type=float)
    
    if not lat or not lon:
        return jsonify({
            'success': False,
            'error': 'Latitude and longitude are required'
        }), 400
    
    try:
        geocoding_service = get_geocoding_service()
        result = geocoding_service.enrich_property_address(lat, lon)
        
        if result:
            return jsonify({
                'success': True,
                'address': result
            })
        else:
            return jsonify({
                'success': False,
                'error': 'Address not found'
            }), 404
            
    except Exception as e:
        logger.error(f"Reverse geocoding error: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/geocode/forward', methods=['GET'])
@csrf.exempt
def geocode_forward():
    """
    Forward geocoding API endpoint
    Convert address to coordinates
    """
    address = request.args.get('address', '').strip()
    
    if not address:
        return jsonify({
            'success': False,
            'error': 'Address is required'
        }), 400
    
    try:
        geocoding_service = get_geocoding_service()
        result = geocoding_service.forward_geocode(address)
        
        if result:
            return jsonify({
                'success': True,
                'result': result
            })
        else:
            return jsonify({
                'success': False,
                'error': 'Coordinates not found'
            }), 404
            
    except Exception as e:
        logger.error(f"Forward geocoding error: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500



@app.route('/api/geocode/enrich-properties', methods=['POST'])
@login_required
def enrich_properties():
    """
    Admin endpoint to batch-enrich properties with parsed address components
    Updates properties that have coordinates but missing parsed address fields
    """
    # Only allow for admin users (you can add role check here)
    # if not current_user.is_admin:
    #     return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    limit = request.args.get('limit', type=int, default=50)
    
    try:
        from models import Property
        geocoding_service = get_geocoding_service()
        
        # Find properties with coordinates but missing parsed address data
        properties = Property.query.filter(
            Property.latitude.isnot(None),
            Property.longitude.isnot(None),
            (Property.parsed_city.is_(None) | Property.parsed_district.is_(None))
        ).limit(limit).all()
        
        updated_count = 0
        errors = []
        
        for prop in properties:
            try:
                enriched = geocoding_service.enrich_property_address(
                    prop.latitude, 
                    prop.longitude
                )
                
                if enriched:
                    prop.parsed_city = enriched.get('parsed_city', '')
                    prop.parsed_district = enriched.get('parsed_district', '')
                    prop.parsed_street = enriched.get('parsed_street', '')
                    
                    # Update full address if missing
                    if not prop.address:
                        prop.address = enriched.get('full_address', '')
                    
                    updated_count += 1
                    
            except Exception as e:
                errors.append(f"Property {prop.id}: {str(e)}")
                logger.error(f"Error enriching property {prop.id}: {e}")
        
        db.session.commit()
        
        # Get service stats
        stats = geocoding_service.get_stats()
        
        return jsonify({
            'success': True,
            'updated_count': updated_count,
            'total_checked': len(properties),
            'errors': errors,
            'geocoding_stats': stats
        })
        
    except Exception as e:
        db.session.rollback()
        logger.error(f"Batch enrichment error: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/geocode/stats', methods=['GET'])
def geocode_stats():
    """Get geocoding service statistics"""
    try:
        geocoding_service = get_geocoding_service()
        stats = geocoding_service.get_stats()
        
        return jsonify({
            'success': True,
            'stats': stats
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/military-mortgage')
def military_mortgage():
    """Military mortgage page"""
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('military_mortgage.html', current_city=current_city)

@app.route('/developer-mortgage')
def developer_mortgage():
    """Developer mortgage page"""
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('developer_mortgage.html', current_city=current_city)

@app.route('/maternal-capital')
def maternal_capital():
    """Maternal capital page"""
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('maternal_capital.html', current_city=current_city)


@app.route('/ipoteka')
def ipoteka():
    """Ipoteka (mortgage programs) overview page"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('ipoteka.html', current_city=current_city)

@app.route('/cashback-terms')
@app.route('/usloviya-keshbeka')
def cashback_terms():
    """Cashback terms and conditions page - detailed legal info"""
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('cashback_terms.html', current_city=current_city)
@app.route('/tax-deduction')
def tax_deduction():
    """Tax deduction page"""
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    return render_template('tax_deduction.html', current_city=current_city)

@app.route('/residential')
def residential():
    """Residential complexes page"""
    return render_template('residential.html')

@app.route('/residential-complexes')
def residential_complexes():
    """Legacy route - redirects to city-based URL"""
    return redirect_to_city_based('residential_complexes_city')

@app.route('/map')
def map_view():
    """Enhanced interactive map view page using real Excel data"""
    # Map route processing
    
    try:
        # ✅ MIGRATED: Load properties with coordinates using repository
        properties_data = PropertyRepository.get_properties_with_coordinates()
        
        properties = []
        for prop_row in properties_data:
            # Unpack RowProxy data
            prop_id = prop_row.id
            inner_id = prop_row.inner_id
            title = prop_row.title
            price = prop_row.price or 0
            rooms = prop_row.rooms or 0
            area = prop_row.area or 0
            floor = prop_row.floor
            total_floors = prop_row.total_floors
            main_image = prop_row.main_image
            gallery_images = prop_row.gallery_images
            lat = prop_row.latitude
            lng = prop_row.longitude
            complex_name = prop_row.complex_name or ''
            cashback_rate = prop_row.cashback_rate or 0
            developer_name = prop_row.developer_name or ''
            
            # Calculate cashback
            cashback_amount = int(price * (cashback_rate / 100)) if cashback_rate > 0 else 0
            
            # Format title
            room_label = 'Студия' if rooms == 0 else f'{rooms}-комн'
            formatted_title = f"{room_label}, {area} м²" if title else title
            
            # Format data for map
            property_data = {
                'id': inner_id or prop_id,
                'price': price,
                'area': area,
                'rooms': rooms,
                'title': formatted_title,
                'address': '',  # Will be filled from Property model if available
                'residential_complex': complex_name,
                'complex_name': complex_name,
                'developer': developer_name,
                'district': 'Краснодарский край',
                'coordinates': {
                    'lat': float(lat),
                    'lng': float(lng)
                },
                'url': f"/object/{inner_id or prop_id}",
                'type': 'property',
                'cashback': cashback_amount,
                'cashback_rate': cashback_rate,
                'cashback_available': cashback_rate > 0,
                'status': 'available',
                'property_type': 'Квартира',
                'main_image': main_image or '/static/images/no-photo.jpg',
                'gallery_images': gallery_images,
                'floor': floor,
                'total_floors': total_floors
            }
            
            properties.append(property_data)
        
        # ✅ MIGRATED: Load residential complexes with coordinates
        complexes_data = ResidentialComplexRepository.get_with_coordinates()
        
        residential_complexes = []
        for idx, row in enumerate(complexes_data):
            complex_data = {
                'id': row.id,
                'name': row.name or '',
                'developer': row.developer_name or '',
                'address': '',  # Not in the query result
                'district': 'Краснодарский край',
                'apartments_count': 0,  # Will be calculated if needed
                'price_from': 0,  # Will be calculated if needed
                'coordinates': {
                    'lat': float(row.latitude) if row.latitude else 45.0448,
                    'lng': float(row.longitude) if row.longitude else 38.9760
                },
                'url': f'/zk/{row.slug}' if hasattr(row, 'slug') and row.slug else f'/residential-complex/{row.id}',
                'type': 'complex'
            }
            residential_complexes.append(complex_data)
        
        # ✅ Применяем фильтры к данным
        developers_filter = request.args.get('developers', '')
        if developers_filter:
            developers_list = [d.strip() for d in developers_filter.split(',')]
            developers_list = [d.strip() for d in developers_filter.split(',')]
            properties = [p for p in properties if p.get('developer') in developers_list]
            print(f"🔍 Фильтр по застройщикам: {developers_list}, найдено объектов: {len(properties)}")
        
        # Фильтры для интерфейса
        all_districts = sorted(list(set(prop.get('district', 'Не указан') for prop in properties if prop.get('district'))))
        all_developers = sorted(list(set(prop.get('developer', 'Не указан') for prop in properties if prop.get('developer'))))
        all_complexes = sorted(list(set(prop.get('residential_complex', 'Не указан') for prop in properties if prop.get('residential_complex'))))
        
        filters = {
            'rooms': request.args.getlist('rooms'),
            'price_min': request.args.get('price_min', ''),
            'price_max': request.args.get('price_max', ''),
            'district': request.args.get('district', ''),
            'developer': request.args.get('developer', ''),
            'developers': developers_filter,
            'residential_complex': request.args.get('residential_complex', ''),
        }
        
        # Map data loaded
        
        return render_template('map.html', 
                             properties=properties, 
                             residential_complexes=residential_complexes,
                             all_districts=all_districts,
                             all_developers=all_developers,
                             all_complexes=all_complexes,
                             filters=filters)
                             
    except Exception as e:
        print(f"ERROR in map route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500


# ==========================================
# CITY-BASED SEO-FRIENDLY ROUTES
# ==========================================
# These routes provide city-specific URLs for better SEO
# Format: /<city_slug>/properties, /<city_slug>/object/123, etc.
@app.route('/<city_slug>')
def city_redirect(city_slug):
    """Redirect from /<city_slug> to /<city_slug>/properties"""
    return redirect(url_for('properties_city', city_slug=city_slug))


@app.route('/<city_slug>/properties')
def properties_city(city_slug):
    """City-based properties listing page - SEO-friendly URL version"""
    # Resolve city context using city_slug from URL
    current_city = resolve_city_context(city_slug=city_slug)
    
    # If city not found, redirect to default properties page
    if not current_city:
        flash('Город не найден. Показываем результаты для Краснодара.', 'warning')
        return redirect(url_for('properties'))
    
    # ✅ АВТОМАТИЧЕСКОЕ ПЕРЕКЛЮЧЕНИЕ ГОРОДА при поиске (как Avito/Cian)
    search_query = request.args.get('search', '').strip()
    if search_query:
        detected_city = smart_search.detect_city_from_query(search_query)
        if detected_city and detected_city['slug'] != city_slug:
            # Город в запросе отличается от города в URL - переключаем автоматически!
            print(f"🔄 Автопереключение: {city_slug} -> {detected_city['slug']} (search: {search_query})")
            # Убираем параметр search из редиректа - пользователь уже на странице нужного города
            redirect_args = {k: v for k, v in request.args.items() if k != 'search'}
            return redirect(url_for('properties_city', city_slug=detected_city['slug'], **redirect_args))
    
    
    # Only update session city if it changed or not set (preserve user's city choice)
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    
    # Save manager if provided in URL (for manager referral links)
    if 'manager_id' in request.args:
        try:
            manager_id = int(request.args.get('manager_id'))
            session['manager_id'] = manager_id
            print(f"✅ Manager {manager_id} saved to session from URL")
        except (ValueError, TypeError):
            pass
    
    try:
        import json
        from repositories.property_repository import PropertyRepository, ResidentialComplexRepository, DeveloperRepository
        from models import Developer, ResidentialComplex, Property
        from services.dadata_client import DaDataClient
        
        # Parse filters using existing function
        _, _, filters = build_property_filters(request.args)
        print(f"🔍 DEBUG: URL параметры: {dict(request.args)}")
        print(f"🔍 DEBUG: Распарсенные фильтры: {filters}")
        
        # Pagination
        page = request.args.get('page', default=1, type=int)
        page = max(1, page)
        per_page = 20
        offset = (page - 1) * per_page
        
        # Sorting
        sort_type = request.args.get('sort', 'price-asc').replace('_', '-')
        
        # Convert filters to Repository format
        repo_filters = {}
        if filters.get('price_min'):
            try:
                repo_filters['min_price'] = int(float(filters['price_min']) * 1000000)
            except:
                pass
        if filters.get('price_max'):
            try:
                repo_filters['max_price'] = int(float(filters['price_max']) * 1000000)
            except:
                pass
        if filters.get('area_min'):
            try:
                repo_filters['min_area'] = float(filters['area_min'])
            except:
                pass
        if filters.get('area_max'):
            try:
                repo_filters['max_area'] = float(filters['area_max'])
            except:
                pass
        if filters.get('rooms'):
            try:
                rooms_list = []
                for r in filters['rooms']:
                    if isinstance(r, str):
                        r_stripped = r.strip()
                        if r_stripped:
                            rooms_list.append(int(r_stripped))
                    elif isinstance(r, int):
                        rooms_list.append(r)
                if rooms_list:
                    repo_filters['rooms'] = rooms_list
                    print(f"✅ /properties_city: Rooms filter applied: {rooms_list}")
            except Exception as e:
                print(f"❌ /properties_city: Error processing rooms filter: {e}")
                pass
        
        # Developers filter
        if filters.get('developers'):
            repo_filters['developers'] = filters['developers']
        if filters.get('developer'):
            if 'developers' not in repo_filters:
                repo_filters['developers'] = []
            if filters['developer'] not in repo_filters['developers']:
                repo_filters['developers'].append(filters['developer'])
        
        # Districts filter
        if filters.get('districts'):
            repo_filters['districts'] = filters['districts']
        
        # Residential complex filter
        if filters.get('residential_complex'):
            repo_filters['residential_complex'] = filters['residential_complex']
        
        # Completion dates filter
        if filters.get('completion'):
            years = []
            for c in filters['completion']:
                try:
                    year_str = c.strip().split()[-1]
                    year = int(year_str)
                    years.append(year)
                except:
                    pass
            if years:
                repo_filters['delivery_years'] = years
        
        # Floor range
        if filters.get('floor_min'):
            try:
                repo_filters['floor_min'] = int(filters['floor_min'])
            except:
                pass
        if filters.get('floor_max'):
            try:
                repo_filters['floor_max'] = int(filters['floor_max'])
            except:
                pass
        
        # Building floors range
        if filters.get('building_floors_min'):
            try:
                repo_filters['building_floors_min'] = int(filters['building_floors_min'])
            except:
                pass
        if filters.get('building_floors_max'):
            try:
                repo_filters['building_floors_max'] = int(filters['building_floors_max'])
            except:
                pass
        
        # Additional filters
        if filters.get('cashback_only'):
            repo_filters['cashback_only'] = True
        if filters.get('renovation'):
            repo_filters['renovation'] = filters['renovation']
        if filters.get('object_classes'):
            repo_filters['object_classes'] = filters['object_classes']
        if filters.get('building_types'):
            repo_filters['building_types'] = filters['building_types']
        if filters.get('floor_options'):
            repo_filters['floor_options'] = filters['floor_options']
        if filters.get('features'):
            repo_filters['features'] = filters['features']
        if filters.get('deal_type'):
            repo_filters['deal_type'] = filters['deal_type']
        
        # Search filter with smart matching
        if filters.get('search'):
            search_text = filters['search'].strip()
            search_applied = False
            
            if search_text:
                # Smart search: Try to match ResidentialComplex first
                complex_match = db.session.query(ResidentialComplex).filter(
                    ResidentialComplex.name.ilike(f'%{search_text}%')
                ).first()
                
                if complex_match:
                    repo_filters['residential_complex'] = complex_match.name
                    print(f"🏢 Smart search: Detected ЖК '{complex_match.name}' from query '{search_text}'")
                    search_applied = True
                
                # Try to match Developer
                if not search_applied:
                    developer_match = db.session.query(Developer).filter(
                        Developer.name.ilike(f'%{search_text}%')
                    ).first()
                    
                    if developer_match:
                        if 'developers' not in repo_filters:
                            repo_filters['developers'] = []
                        repo_filters['developers'].append(developer_match.name)
                        print(f"👔 Smart search: Detected застройщик '{developer_match.name}' from query '{search_text}'")
                        search_applied = True
                
                # If no smart match, use address/text search
                if not search_applied:
                    if any(prefix in search_text for prefix in ['г ', 'р-н ', 'ул', 'мкр', 'пер', 'улиц']):
                        tokens = DaDataClient.normalize_address_for_search(search_text)
                        if tokens:
                            import re
                            clean_tokens = []
                            for token in tokens:
                                cleaned = re.sub(r'^(улиц[аы]|ул\.?|просп(ект)?\.?|мкр\.?|пер\.?|г\.?|р-н)\s*', '', token, flags=re.IGNORECASE).strip()
                                if cleaned:
                                    clean_tokens.append(cleaned)
                            
                            if clean_tokens:
                                repo_filters['search'] = clean_tokens[-1]
                                print(f"🔍 Normalized search: '{search_text}' → '{clean_tokens[-1]}'")
                            else:
                                repo_filters['search'] = search_text
                        else:
                            repo_filters['search'] = search_text
                    else:
                        repo_filters['search'] = search_text
        
        # Parse sort_type
        sort_by = 'price'
        sort_order = 'asc'
        if sort_type:
            parts = sort_type.split('-')
            if len(parts) == 2:
                sort_by = parts[0]
                sort_order = parts[1]
        
        # Add city filter
        if current_city:
            repo_filters['city_id'] = current_city.id
            print(f"✅ /properties_city: Filtering by city: {current_city.name} (ID: {current_city.id})")
        
        # Get properties
        properties_list = PropertyRepository.get_all_active(
            limit=per_page,
            offset=offset,
            filters=repo_filters,
            sort_by=sort_by,
            sort_order=sort_order
        )
        
        total_properties = PropertyRepository.count_active(filters=repo_filters)
        
        # Convert to template format
        properties_data = []
        for prop in properties_list:
            try:
                complex_obj = prop.residential_complex
                developer_obj = prop.developer
                
                # Parse photos
                photos_list = []
                main_image = 'https://via.placeholder.com/400x300'
                
                if prop.main_image:
                    main_image = prop.main_image
                
                if prop.gallery_images:
                    try:
                        if isinstance(prop.gallery_images, list):
                            photos_list = prop.gallery_images
                        elif isinstance(prop.gallery_images, str):
                            photos_list = json.loads(prop.gallery_images)
                        
                        if photos_list and not prop.main_image:
                            main_image = photos_list[0]
                    except Exception as e:
                        print(f"Error parsing photos for property {prop.id}: {e}")
                
                # Calculate cashback
                cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 3.5
                cashback_amount = int(prop.price * (cashback_rate / 100)) if prop.price else 0
                
                property_dict = {
                    'id': prop.id,
                    'price': prop.price or 0,
                    'price_formatted': prop.formatted_price,
                    'area': prop.area or 0,
                    'rooms': prop.rooms or 0,
                    'room_description': prop.room_description,
                    'floor': prop.floor if prop.floor is not None else 1,
                    'total_floors': prop.total_floors if prop.total_floors is not None else 1,
                    'address': prop.address or (complex_obj.address if complex_obj else ''),
                    'renovation': prop.renovation_type or 'no_renovation',
                    'renovation_display_name': PropertyRepository.get_renovation_display_name(prop.renovation_type),
                    'price_per_sqm': prop.price_per_sqm or (int(prop.price / prop.area) if prop.price and prop.area else 0),
                    'gallery': photos_list,
                    'image': main_image,
                    'latitude': prop.latitude or (complex_obj.latitude if complex_obj else None),
                    'longitude': prop.longitude or (complex_obj.longitude if complex_obj else None),
                    'complex_name': complex_obj.name if complex_obj else '',
                    'residential_complex': complex_obj.name if complex_obj else '',
                    'developer': developer_obj.name if developer_obj else '',
                    'developer_name': developer_obj.name if developer_obj else '',
                    'cashback_rate': cashback_rate,
                    'cashback': cashback_amount,
                    'cashback_available': True,
                    'district': prop.district.name if prop.district else '',
                    'deal_type': prop.deal_type or 'sale',
                    'object_class': complex_obj.object_class_display_name if complex_obj else '',
                }
                
                properties_data.append(property_dict)
            except Exception as e:
                print(f"Error formatting property {prop.id}: {e}")
                import traceback
                traceback.print_exc()
                continue
        
        # Pagination data
        total_pages = (total_properties + per_page - 1) // per_page if total_properties > 0 else 0
        pagination = SimpleNamespace(
            page=page,
            total_pages=total_pages,
            per_page=per_page,
            total=total_properties,
            has_prev=page > 1,
            has_next=page < total_pages,
            prev_num=page - 1 if page > 1 else None,
            next_num=page + 1 if page < total_pages else None
        )
        
        # Get developers and complexes for filters
        developers = DeveloperRepository.get_all_active()
        residential_complexes = ResidentialComplexRepository.get_all_active()
        
        # Get manager if logged in
        manager_data = None
        if current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager):
            manager = current_user._get_current_object()
            manager_data = {
                'id': manager.id,
                'name': manager.name,
                'phone': manager.phone,
                'email': manager.email,
                'photo': manager.profile_image
            }
        
        # Calculate max cashback
        max_cashback = 0
        if properties_data:
            for prop_dict in properties_data:
                if prop_dict.get('cashback'):
                    if prop_dict['cashback'] > max_cashback:
                        max_cashback = prop_dict['cashback']
        
        if max_cashback == 0 and residential_complexes:
            for rc in residential_complexes:
                if rc.cashback_rate:
                    estimated_cashback = int(15000000 * (rc.cashback_rate / 100))
                    if estimated_cashback > max_cashback:
                        max_cashback = estimated_cashback
        
        if max_cashback == 0:
            max_cashback = 500000
        
        # Get current manager
        current_manager = current_user._get_current_object() if (current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager)) else None
        
        # Generate canonical URL for SEO (always use production domain)
        canonical_url = CANONICAL_BASE_URL + url_for('properties_city', city_slug=city_slug)
        
        response = make_response(render_template('properties.html',
                                 current_city=current_city,
                                 properties=properties_data,
                                 pagination=pagination,
                                 filters=filters,
                                 developers=developers,
                                 residential_complexes=residential_complexes,
                                 manager=manager_data,
                                 total_pages=total_pages,
                                 total_properties=total_properties,
                                 max_cashback=max_cashback,
                                 user_authenticated=current_user.is_authenticated,
                                 manager_authenticated=isinstance(current_user._get_current_object(), Manager) if current_user.is_authenticated else False,
                                 admin_authenticated=isinstance(current_user._get_current_object(), Admin) if current_user.is_authenticated else False,
                                 current_manager=current_manager,
                                 canonical_url=canonical_url,
                                 yandex_maps_api_key=os.environ.get('YANDEX_MAPS_API_KEY', '')))
        
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate, max-age=0'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        return response
        
    except Exception as e:
        print(f"ERROR in /properties_city: {e}")
        import traceback
        traceback.print_exc()
        return render_template('error.html', 
                             error_code=500, 
                             error_message='Ошибка при загрузке страницы с квартирами',
                             current_city=current_city), 500


@app.route('/<city_slug>/residential-complexes')
def residential_complexes_city(city_slug):
    """City-based residential complexes page - SEO-friendly URL version"""
    from repositories.property_repository import ResidentialComplexRepository, PropertyRepository, DeveloperRepository, DistrictRepository
    import json
    from datetime import datetime
    
    # Resolve city context using city_slug from URL
    current_city = resolve_city_context(city_slug=city_slug)
    
    # If city not found, redirect to default page
    if not current_city:
        flash('Город не найден. Показываем результаты для Краснодара.', 'warning')
        return redirect(url_for('residential_complexes'))
    
    # Only update session city if it changed or not set (preserve user's city choice)
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    
    # Save manager if provided in URL (for manager referral links)
    if 'manager_id' in request.args:
        try:
            manager_id = int(request.args.get('manager_id'))
            session['manager_id'] = manager_id
            print(f"✅ Manager {manager_id} saved to session from URL")
        except (ValueError, TypeError):
            pass
    
    try:
        # Filter complexes by city
        from models import ResidentialComplex
        all_complexes = (
            db.session.query(ResidentialComplex)
            .filter(ResidentialComplex.city_id == current_city.id)
            .filter(ResidentialComplex.is_active == True)
            .limit(100)
            .all()
        )
        print(f"✅ /residential-complexes_city: Filtering by city: {current_city.name} (ID: {current_city.id})")
        
        # Get property stats
        property_stats_by_complex = PropertyRepository.get_all_property_stats(city_id=current_city.id)
        
        # Current date for status
        current_year = 2025
        current_quarter = 4
        
        complexes = []
        
        for complex_obj in all_complexes:
            stats = property_stats_by_complex.get(complex_obj.id, {})
            
            # Format completion date and determine status
            completion_date = 'Не указан'
            is_completed = False
            build_year = None
            
            if complex_obj.end_build_year and complex_obj.end_build_quarter:
                build_year = int(complex_obj.end_build_year)
                build_quarter = int(complex_obj.end_build_quarter)
                
                if build_year < current_year:
                    is_completed = True
                elif build_year == current_year and build_quarter < current_quarter:
                    is_completed = True
                else:
                    is_completed = False
                    
                quarter_names = {1: 'I', 2: 'II', 3: 'III', 4: 'IV'}
                quarter = quarter_names.get(build_quarter, build_quarter)
                completion_date = f"{quarter} кв. {build_year} г."
            elif complex_obj.end_build_year:
                build_year = int(complex_obj.end_build_year)
                is_completed = build_year < current_year
                completion_date = f"{build_year} г."
            
            # Get address and district
            # Don't duplicate city name if address already contains it
            full_address = complex_obj.address or 'Адрес не указан'
            
            # Only use city name as district if address doesn't contain it
            if current_city.name.lower() in full_address.lower() or f"г. {current_city.name}".lower() in full_address.lower():
                district_name = ""  # Address already has city name
            else:
                district_name = current_city.name
            
            if (not complex_obj.address or complex_obj.address == 'Адрес не указан') and stats.get('sample_address'):
                full_address = stats['sample_address']
                address_parts = full_address.split(',')
                if len(address_parts) >= 3:
                    district_name = address_parts[2].strip()
            
            # Build complete images list for slider
            images_list = []
            if complex_obj.gallery_images:
                try:
                    if isinstance(complex_obj.gallery_images, list):
                        images_list = complex_obj.gallery_images
                    elif isinstance(complex_obj.gallery_images, str) and complex_obj.gallery_images:
                        import json
                        images_list = json.loads(complex_obj.gallery_images)
                except:
                    pass
            
            # Fallback to main_image if no gallery
            if not images_list and complex_obj.main_image:
                images_list = [complex_obj.main_image]
            
            # Add default if still empty
            if not images_list:
                images_list = ['/static/images/no-photo.jpg']
            
            # Basic complex info
            complex_dict = {
                'id': complex_obj.id,
                'name': complex_obj.name,
                'available_apartments': stats.get('total_count', 0),
                'price_from': stats.get('min_price', 0) or 0,
                'price_to': stats.get('max_price', 0) or 0,
                'real_price_from': stats.get('min_price', 0) or 0,
                'real_price_to': stats.get('max_price', 0) or 0,
                'area_from': stats.get('min_area', 0) or 0,
                'area_to': stats.get('max_area', 0) or 0,
                'floor_from': stats.get('min_floor', 0) or 0,
                'floor_to': stats.get('max_floor', 0) or 0,
                'developer': complex_obj.developer.name if complex_obj.developer else 'Не указан',
                'developer_id': complex_obj.developer_id,
                'developer_name': complex_obj.developer.name if complex_obj.developer else 'Не указан',
                'address': full_address,
                'district': district_name,
                'district_name': district_name,
                'completion_date': completion_date,
                'is_completed': is_completed,
                'build_year': build_year,
                'cashback_rate': complex_obj.cashback_rate or 0,
                'object_class': complex_obj.object_class_display_name or 'Комфорт',
                'latitude': complex_obj.latitude,
                'longitude': complex_obj.longitude,
                'main_image': complex_obj.main_image or '/static/images/no-photo.jpg',
                'gallery_images': complex_obj.gallery_images,
                'images': images_list,
                'image': images_list[0] if images_list else '/static/images/no-photo.jpg',
                'real_room_distribution': stats.get('room_distribution', {}),
                'room_details': stats.get('room_details', {}),
                'status': 'Сдан' if is_completed else 'Строится',
                'description': complex_obj.description or 'Современный жилой комплекс',
                'location': full_address,
                'buildings_count': stats.get('buildings_count', 1),
                'slug': complex_obj.slug or create_slug(complex_obj.name),
                'url': f'/{city_slug}/zk/{complex_obj.slug or create_slug(complex_obj.name)}',
            }
            
            complexes.append(complex_dict)
        
        # Load properties for map
        properties_list = PropertyRepository.get_all_active(
            limit=500,
            filters={'city_id': current_city.id},
            sort_by='price',
            sort_order='asc'
        )
        
        properties = []
        for prop in properties_list:
            complex_obj = prop.residential_complex
            developer_obj = prop.developer
            
            # Parse photos
            photos_list = []
            main_image = 'https://via.placeholder.com/400x300'
            
            if prop.main_image:
                main_image = prop.main_image
            
            if prop.gallery_images:
                try:
                    if isinstance(prop.gallery_images, list):
                        photos_list = prop.gallery_images
                    elif isinstance(prop.gallery_images, str):
                        photos_list = json.loads(prop.gallery_images)
                    
                    if photos_list and not prop.main_image:
                        main_image = photos_list[0]
                except Exception as e:
                    print(f"Error parsing photos: {e}")
            
            floor = prop.floor if prop.floor is not None else 1
            total_floors = prop.total_floors if prop.total_floors is not None else 1
            
            property_data = {
                'id': prop.id,
                'price': prop.price or 0,
                'area': prop.area or 0,
                'rooms': prop.rooms or 0,
                'floor': floor,
                'total_floors': total_floors,
                'address': prop.address or '',
                'residential_complex': complex_obj.name if complex_obj else '',
                'developer': developer_obj.name if developer_obj else '',
                'district': prop.district.name if prop.district else '',
                'latitude': prop.latitude,
                'longitude': prop.longitude,
                'main_image': main_image or '/static/images/no-photo.jpg',
                'gallery_images': photos_list,
                'floor': f"{floor}/{total_floors}",
                'floor_min': floor,
                'floor_max': total_floors
            }
            
            properties.append(property_data)
        
        # Use complexes list for residential_complexes (they contain the same data)
        # FIXED: Just copy complexes list instead of rebuilding it - avoids duplication and ensures consistency
        residential_complexes = complexes.copy()
        
        # Apply filters
        developers_filter = request.args.get('developers', '')
        if developers_filter:
            developers_list = [d.strip() for d in developers_filter.split(',')]
            if complexes: print(f"DEBUG: All complex keys: {list(complexes[0].keys())}")
            properties = [p for p in properties if p.get('developer') in developers_list]
            print(f"🔍 Фильтр по застройщикам: {developers_list}, найдено объектов: {len(properties)}")
        
        # Filter options
        all_districts = sorted(list(set(prop.get('district', 'Не указан') for prop in properties if prop.get('district'))))
        all_developers = sorted(list(set(prop.get('developer', 'Не указан') for prop in properties if prop.get('developer'))))
        all_complexes_list = sorted(list(set(prop.get('residential_complex', 'Не указан') for prop in properties if prop.get('residential_complex'))))
        
        filters = {
            'rooms': request.args.getlist('rooms'),
            'price_min': request.args.get('price_min', ''),
            'price_max': request.args.get('price_max', ''),
            'district': request.args.get('district', ''),
            'developer': request.args.get('developer', ''),
            'developers': developers_filter,
            'residential_complex': request.args.get('residential_complex', ''),
        }
        # Generate canonical URL for SEO (always use production domain)
        canonical_url = CANONICAL_BASE_URL + url_for('residential_complexes_city', city_slug=city_slug)
        # DEBUG: Check complexes data before template
        print(f"DEBUG: Passing {len(complexes)} complexes to template for {current_city.name}")
        if complexes:
            print(f"DEBUG: First complex keys: {list(complexes[0].keys())[:15]}")
        
        return render_template('residential_complexes.html',
                             current_city=current_city,
                             complexes=complexes,
                             properties=properties,
                             residential_complexes=residential_complexes,
                             all_districts=all_districts,
                             all_developers=all_developers,
                             all_complexes=all_complexes_list,
                             filters=filters,
                             canonical_url=canonical_url,
                             yandex_maps_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
                             
    except Exception as e:
        print(f"ERROR in /residential-complexes_city: {e}")
        import traceback
        traceback.print_exc()
        return render_template('error.html',
                             error_code=500,
                             error_message='Ошибка при загрузке страницы ЖК',
                             current_city=current_city), 500


@app.route('/<city_slug>/object/<int:property_id>')
def property_detail_city(city_slug, property_id):
    """City-based individual property page - SEO-friendly URL version"""
    # Resolve city context using city_slug from URL
    current_city = resolve_city_context(city_slug=city_slug)
    
    # If city not found, redirect to default page
    if not current_city:
        flash('Город не найден. Показываем результаты для Краснодара.', 'warning')
        return redirect(url_for('property_detail', property_id=property_id))
    
    # Only update session city if it changed or not set (preserve user's city choice)
    if 'city_id' not in session or session.get('city_id') != current_city.id:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    
    # Save manager if provided in URL (for manager referral links)
    if 'manager_id' in request.args:
        try:
            manager_id = int(request.args.get('manager_id'))
            session['manager_id'] = manager_id
            print(f"✅ Manager {manager_id} saved to session from URL")
        except (ValueError, TypeError):
            pass
    try:
        import json
        from sqlalchemy import func
        from repositories.property_repository import PropertyRepository
        from models import Property, ResidentialComplex
        
        # Get property
        prop = PropertyRepository.get_by_id(property_id)
        
        if not prop:
            print(f"Property {property_id} not found")
            return redirect(url_for('properties_city', city_slug=city_slug))
        
        # Get related objects
        complex_obj = prop.residential_complex
        developer_obj = prop.developer
        
        # Parse photos
        images = []
        main_image = 'https://via.placeholder.com/400x300/f3f4f6/9ca3af?text=Фото+недоступно'
        
        if prop.main_image:
            main_image = prop.main_image
        
        if prop.gallery_images:
            try:
                if isinstance(prop.gallery_images, list):
                    images = prop.gallery_images
                elif isinstance(prop.gallery_images, str):
                    images = json.loads(prop.gallery_images)
                
                if images and not prop.main_image:
                    main_image = images[0]
            except Exception as e:
                print(f"Error parsing photos: {e}")
        
        # Create completion date
        completion_date = 'Уточняется'
        if complex_obj:
            if complex_obj.end_build_year and complex_obj.end_build_quarter:
                completion_date = f"{complex_obj.end_build_year} г., {complex_obj.end_build_quarter} кв."
            elif complex_obj.end_build_year:
                completion_date = f"{complex_obj.end_build_year} г."
        
        # Calculate cashback
        cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 3.5
        cashback_amount = int(prop.price * (cashback_rate / 100)) if prop.price else 0
        
        # Parse complex infrastructure and amenities
        infrastructure_list = []
        advantages_list = []
        if complex_obj:
            if complex_obj.infrastructure:
                try:
                    if isinstance(complex_obj.infrastructure, str):
                        infrastructure_list = json.loads(complex_obj.infrastructure)
                    elif isinstance(complex_obj.infrastructure, list):
                        infrastructure_list = complex_obj.infrastructure
                except:
                    pass
            
            if complex_obj.amenities:
                try:
                    if isinstance(complex_obj.amenities, str):
                        advantages_list = json.loads(complex_obj.amenities)
                    elif isinstance(complex_obj.amenities, list):
                        advantages_list = complex_obj.amenities
                except:
                    pass
        
        # Build property data
        property_data = {
            'id': prop.inner_id or prop.id,
            'complex_id': complex_obj.id if complex_obj else None,
            'title': prop.title or (f"Студия {prop.area} м²" if prop.rooms == 0 else f"{prop.rooms}-комнатная квартира {prop.area} м²"),
            'description': prop.description or (complex_obj.description if complex_obj else None),
            'detailed_description': complex_obj.detailed_description if complex_obj else None,
            'price': prop.price or 0,
            'cashback_percent': cashback_rate,
            'gallery': images,
            'area': prop.area or 0,
            'rooms': prop.rooms or 0,
            'floor': prop.floor if prop.floor is not None else 1,
            'total_floors': prop.total_floors if prop.total_floors is not None else 1,
            'address': prop.address or (complex_obj.address if complex_obj else 'Адрес уточняется'),
            'full_address': prop.address or (complex_obj.address if complex_obj else 'Адрес уточняется'),
            'short_address': prop.address or (complex_obj.address if complex_obj else 'Адрес уточняется'),
            'locality_name': complex_obj.district if complex_obj else current_city.name,
            'district': complex_obj.district if complex_obj else current_city.name,
            'developer': developer_obj.name if developer_obj else 'Не указан',
            'complex_name': complex_obj.name if complex_obj else 'Не указан',
            'building_name': prop.complex_building_name or 'Корпус 1',
            'building_released': True,
            'renovation_type': PropertyRepository.get_renovation_display_name(prop.renovation_type),
            'finishing': PropertyRepository.get_renovation_display_name(prop.renovation_type),
            'completion_date': completion_date,
            'mortgage_rate': '3.5%',
            'square_price': prop.price_per_sqm or (int(prop.price / prop.area) if prop.price and prop.area else 0),
            'mortgage_payment': prop.mortgage_price or 0,
            'class_type': complex_obj.object_class_display_name if complex_obj else 'Комфорт',
            'cashback_amount': cashback_amount,
            'images': images,
            'image': main_image,
            'latitude': prop.latitude or (complex_obj.latitude if complex_obj else None),
            'longitude': prop.longitude or (complex_obj.longitude if complex_obj else None),
            'address_position_lat': prop.latitude or (complex_obj.latitude if complex_obj else None),
            'address_position_lon': prop.longitude or (complex_obj.longitude if complex_obj else None),
            'infrastructure': infrastructure_list,
            'advantages': advantages_list,
            'complex_total_apartments': Property.query.filter_by(complex_id=complex_obj.id, is_active=True).count() if complex_obj else 0,
        }
        
        # Get similar apartments
        similar_apartments = []
        if complex_obj:
            similar_props = PropertyRepository.get_by_complex_id(
                complex_obj.id,
                limit=6,
                sort_by='price',
                sort_order='asc'
            )
            
            for similar_prop in similar_props:
                if similar_prop.id != prop.id:
                    similar_main_image = 'https://via.placeholder.com/400x300'
                    if similar_prop.main_image:
                        similar_main_image = similar_prop.main_image
                    elif similar_prop.gallery_images:
                        try:
                            if isinstance(similar_prop.gallery_images, list):
                                similar_main_image = similar_prop.gallery_images[0] if similar_prop.gallery_images else similar_main_image
                            elif isinstance(similar_prop.gallery_images, str):
                                photos = json.loads(similar_prop.gallery_images)
                                similar_main_image = photos[0] if photos else similar_main_image
                        except:
                            pass
                    
                    
                    # Calculate cashback for similar apartment
                    similar_cashback = int(similar_prop.price * (cashback_rate / 100)) if similar_prop.price else 0
                    similar_apartments.append({
                        'id': similar_prop.inner_id or similar_prop.id,
                        'rooms': similar_prop.rooms or 0,
                        'area': similar_prop.area or 0,
                        'price': similar_prop.price or 0,
                        'floor': similar_prop.floor if similar_prop.floor is not None else 1,
                        'total_floors': similar_prop.total_floors if similar_prop.total_floors is not None else 1,
                        'image': similar_main_image,
                        'url': f'/{city_slug}/object/{similar_prop.inner_id or similar_prop.id}',
                        'cashback': similar_cashback
                    })
        
        # Get complex info
        complex_info = None
        if complex_obj:
            complex_photos = []
            if complex_obj.gallery_images:
                try:
                    if isinstance(complex_obj.gallery_images, list):
                        complex_photos = complex_obj.gallery_images
                    elif isinstance(complex_obj.gallery_images, str):
                        complex_photos = json.loads(complex_obj.gallery_images)
                except:
                    pass
            # Статистика ЖК
            total_apartments = Property.query.filter_by(complex_id=complex_obj.id, is_active=True).count()
            studios_count = Property.query.filter_by(complex_id=complex_obj.id, rooms=0, is_active=True).count()
            buildings_count_result = db.session.query(func.count(func.distinct(Property.complex_building_name))).filter(
                Property.complex_id == complex_obj.id,
                Property.is_active == True,
                Property.complex_building_name.isnot(None)
            ).scalar() or 1
            
            complex_info = {
                'id': complex_obj.id,
                'name': complex_obj.name,
                'developer': developer_obj.name if developer_obj else 'Не указан',
                'address': complex_obj.address or 'Адрес уточняется',
                'description': complex_obj.description or 'Описание отсутствует',
                'images': complex_photos,
                'latitude': complex_obj.latitude,
                'longitude': complex_obj.longitude,
                'cashback_rate': complex_obj.cashback_rate or 0,
                'url': f'/{city_slug}/zk/{complex_obj.slug or create_slug(complex_obj.name)}',
                'total_apartments': total_apartments,
                'studios_count': studios_count,
                'buildings_count': buildings_count_result
            }
        
        # Get manager for authenticated user
        manager_data = None
        if current_user.is_authenticated:
            from models import User, Manager
            # Check if current_user is a regular User (not Manager or Admin)
            current_obj = current_user._get_current_object()
            if isinstance(current_obj, User) and hasattr(current_obj, 'assigned_manager_id') and current_obj.assigned_manager_id:
                # Get assigned manager
                manager = Manager.query.get(current_obj.assigned_manager_id)
                if manager and manager.is_active:
                    manager_data = {
                        'id': manager.id,
                        'name': manager.full_name,
                        'phone': manager.phone,
                        'email': manager.email,
                        'photo': manager.profile_image
                    }
        # Generate canonical URL for SEO (always use production domain)
        canonical_url = CANONICAL_BASE_URL + url_for('property_detail_city', city_slug=city_slug, property_id=property_id)
        
        return render_template('property_detail.html',
                             current_city=current_city,
                             property=property_data,
                             complex_info=complex_info,
                             similar_apartments=similar_apartments,
                             manager=manager_data,
                             canonical_url=canonical_url)
        
    except Exception as e:
        print(f"ERROR in /property_detail_city: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500


@app.route('/<city_slug>/zk/<slug>')
def residential_complex_by_slug_city(city_slug, slug):
    """City-based residential complex detail page - SEO-friendly URL version - FULL IMPLEMENTATION"""
    # Resolve city context using city_slug from URL
    current_city = resolve_city_context(city_slug=city_slug)
    
    # If city not found, use default
    if not current_city:
        flash('Город не найден. Показываем результаты для Краснодара.', 'warning')
        current_city = resolve_city_context()  # Get default city
    
    # Store city in session
    if current_city:
        session['city_id'] = current_city.id
        session['city_slug'] = current_city.slug
    
    try:
        from repositories.property_repository import PropertyRepository, ResidentialComplexRepository
        from models import ResidentialComplex, Offer, MarketingMaterial, Manager, Admin
        
        # === STEP 1: Get ResidentialComplex by slug ===
        complex = None
        
        # Try exact slug match first
        complex = ResidentialComplexRepository.get_by_slug(slug)
        
        # If not found, try matching with create_slug() for transliteration support
        if not complex:
            all_complexes = ResidentialComplexRepository.get_all_active(limit=100)
            for c in all_complexes:
                if create_slug(c.name) == slug:
                    complex = c
                    break
        
        # If not found, redirect to properties page
        if not complex:
            print(f"Complex {slug} not found in residential_complexes table")
            return redirect(url_for('residential_complexes_city', city_slug=city_slug))
        
        # Convert ORM object to dict for template compatibility
        complex_data = {
            'id': complex.id,
            'name': complex.name,
            'slug': complex.slug,
            'complex_type': complex.complex_type or 'residential',
            'description': complex.description,
            'cashback_rate': complex.cashback_rate,
            'cashback_percent': complex.cashback_rate,  # Alias for template
            'developer_id': complex.developer_id,
            'developer_name': complex.developer.name if complex.developer else 'Не указан',
            'developer': complex.developer.name if complex.developer else 'Не указан',
            'developer_description': complex.developer.description if complex.developer else 'Застройщик с многолетним опытом работы на рынке недвижимости.',
            'developer_slug': complex.developer.slug if complex.developer else None,
            'developer_website': complex.developer.website if complex.developer else None,
            'object_class_display_name': complex.object_class_display_name or 'Комфорт',
            'sales_address': complex.sales_address,
            'district': complex.district.name if complex.district else (current_city.name if current_city else 'Краснодар'),
            'district_name': complex.district.name if complex.district else (current_city.name if current_city else 'Краснодар'),
            'start_build_year': complex.start_build_year,
            'start_build_quarter': complex.start_build_quarter,
            'end_build_year': complex.end_build_year,
            'end_build_quarter': complex.end_build_quarter,
            'latitude': complex.latitude,
            'longitude': complex.longitude,
            'main_image': complex.main_image,
            'gallery_images': complex.gallery_images,
            'videos': complex.videos,
            'uploaded_video': complex.uploaded_video,
            'nearby': complex.nearby,
            'detailed_description': complex.detailed_description,
            'advantages': complex.advantages,
            'ceiling_height': complex.ceiling_height,
            'construction_progress_images': complex.construction_progress_images,
            'construction_photos_updated_at': complex.construction_photos_updated_at,
            'location': complex.sales_address or complex.district.name if complex.district else ''
        }
        
        # === STEP 2: Get all properties for this complex using PropertyRepository ===
        properties = PropertyRepository.get_by_complex_id(complex.id, limit=500, sort_by='price', sort_order='asc')
        
        if not properties:
            print(f"No properties found for complex {complex.name}")
            complex_data['apartments_count'] = 0
            complex_data['total_apartments'] = 0
            complex_data['price_from'] = 0
            complex_data['price_to'] = 0
            complex_data['min_price'] = 0
            complex_data['max_price'] = 0
            complex_data['buildings_count'] = 0
            complex_data['images'] = []
            complex_data['coordinates'] = [complex.latitude or 45.0355, complex.longitude or 38.9753]
            complex_data['total_floors_in_complex'] = 25
        else:
            # Calculate aggregated stats from properties
            prices = [p.price for p in properties if p.price]
            areas = [p.area for p in properties if p.area]
            floors = [p.floor for p in properties if p.floor]
            total_floors_list = [p.total_floors for p in properties if p.total_floors]
            
            complex_data['apartments_count'] = len(properties)
            complex_data['total_apartments'] = len(properties)
            complex_data['price_from'] = int(min(prices)) if prices else 0
            complex_data['price_to'] = int(max(prices)) if prices else 0
            complex_data['min_price'] = complex_data['price_from']
            complex_data['max_price'] = complex_data['price_to']
            complex_data['real_price_from'] = complex_data['price_from']
            complex_data['real_price_to'] = complex_data['price_to']
            complex_data['real_area_from'] = float(min(areas)) if areas else 0
            complex_data['real_area_to'] = float(max(areas)) if areas else 0
            complex_data['real_floors_min'] = int(min(floors)) if floors else 1
            complex_data['real_floors_max'] = int(max(total_floors_list)) if total_floors_list else 25
            complex_data['total_floors_in_complex'] = complex_data['real_floors_max']
            
            # Count unique buildings by complex_building_name
            unique_buildings = set(p.complex_building_name for p in properties if p.complex_building_name)
            complex_data['buildings_count'] = max(len(unique_buildings), 1)
            
            # Set full address from sales_address or first property address
            complex_data['full_address'] = complex.sales_address or (properties[0].address if properties else '')
            
            # Set coordinates from complex or first property
            if complex.latitude and complex.longitude:
                complex_data['coordinates'] = [float(complex.latitude), float(complex.longitude)]
            elif properties and properties[0].latitude and properties[0].longitude:
                complex_data['coordinates'] = [float(properties[0].latitude), float(properties[0].longitude)]
            else:
                complex_data['coordinates'] = [45.0355, 38.9753]  # Default Krasnodar
            
            # Get images from complex or first property
            if complex.gallery_images:
                try:
                    import json
                    images_list = json.loads(complex.gallery_images) if isinstance(complex.gallery_images, str) else complex.gallery_images
                    complex_data['images'] = images_list[:10] if images_list else []
                    complex_data['image'] = images_list[0] if images_list else complex.main_image
                except:
                    complex_data['images'] = []
                    complex_data['image'] = complex.main_image
            elif properties and properties[0].gallery_images:
                try:
                    import json
                    images_list = json.loads(properties[0].gallery_images) if isinstance(properties[0].gallery_images, str) else []
                    complex_data['images'] = images_list[:10] if images_list else []
                    complex_data['image'] = images_list[0] if images_list else properties[0].main_image
                except:
                    complex_data['images'] = []
                    complex_data['image'] = properties[0].main_image if properties else None
            else:
                complex_data['images'] = []
                complex_data['image'] = complex.main_image
                
            print(f"Loaded {len(properties)} properties for {complex.name}: price from {complex_data['price_from']}, {complex_data['buildings_count']} buildings")
        
        # === STEP 3: Convert properties to template-compatible format ===
        complex_properties = []
        cashback_rate_decimal = complex_data.get('cashback_percent', 5.0) / 100.0
        
        for prop in properties:
            # Convert ORM Property object to dict for template
            prop_dict = {
                'id': prop.inner_id or prop.id,  # Use inner_id for compatibility
                'inner_id': prop.inner_id or prop.id,
                'price': prop.price or 0,
                'cashback_amount': int(prop.price * cashback_rate_decimal) if prop.price else 0,
                'complex_id': complex.id,
                'residential_complex': complex.name,
                'object_rooms': prop.rooms or 0,
                'object_area': prop.area or 0,
                'object_min_floor': prop.floor or 1,
                'floor': prop.floor or 1,
                'total_floors': prop.total_floors or complex_data['total_floors_in_complex'],
                'address': prop.address or '',
                'address_short_display_name': prop.address or '',
                'complex_building_name': prop.complex_building_name or 'Основной корпус',
                'property_type': 'Квартира',
                'deal_type': prop.deal_type or 'sale',
                'renovation_type': prop.renovation_type
            }
            
            # Format title
            rooms = prop.rooms or 0
            if rooms == 0:
                room_type = "Студия"
            else:
                room_type = f"{rooms}-комнатная квартира"
            
            apartment_floor = prop.floor or 1
            total_floors = prop.total_floors or complex_data['total_floors_in_complex']
            prop_dict['title'] = f"{room_type}, {prop.area or 0} м², {apartment_floor}/{total_floors} эт."
            prop_dict['type'] = f"{rooms}-комн" if rooms > 0 else "Студия"
            prop_dict['apartment_floor'] = apartment_floor
            prop_dict['total_floors_in_complex'] = total_floors
            
            # Parse gallery images
            try:
                import json
                if prop.gallery_images:
                    if isinstance(prop.gallery_images, str):
                        photos_list = json.loads(prop.gallery_images)
                    else:
                        photos_list = prop.gallery_images
                else:
                    photos_list = []
                
                prop_dict['image'] = photos_list[0] if photos_list else (prop.main_image or 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=Квартира')
                prop_dict['photos_list'] = photos_list
            except Exception as e:
                print(f"Error parsing photos for property {prop.id}: {e}")
                prop_dict['image'] = prop.main_image or 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=Квартира'
                prop_dict['photos_list'] = []
            
            complex_properties.append(prop_dict)
        
        # === STEP 4: Calculate room statistics ===
        properties_by_rooms = {}
        room_stats = {}
        for prop in complex_properties:
            rooms = prop.get('object_rooms', 0)
            room_key = 'Студия' if rooms == 0 else f'{rooms}-комн'
            
            if room_key not in properties_by_rooms:
                properties_by_rooms[room_key] = []
                room_stats[room_key] = {
                    'count': 0,
                    'prices': [],
                    'areas': [],
                    'price_from': 0,
                    'price_to': 0,
                    'area_from': 0,
                    'area_to': 0
                }
            
            properties_by_rooms[room_key].append(prop)
            room_stats[room_key]['count'] += 1
            if prop.get('price'):
                room_stats[room_key]['prices'].append(prop['price'])
            if prop.get('object_area'):
                room_stats[room_key]['areas'].append(prop['object_area'])
        
        # Calculate min/max for each room type
        for room_key, stats in room_stats.items():
            if stats['prices']:
                stats['price_from'] = min(stats['prices'])
                stats['price_to'] = max(stats['prices'])
            else:
                stats['price_from'] = 0
                stats['price_to'] = 0
            
            if stats['areas']:
                stats['area_from'] = min(stats['areas'])
                stats['area_to'] = max(stats['areas'])
            else:
                stats['area_from'] = 0
                stats['area_to'] = 0
        
        complex_data['room_stats'] = room_stats
        
        # === STEP 5: Group properties by complex_building_name ===
        properties_by_building_unsorted = {}
        for prop in complex_properties:
            building_name = prop.get('complex_building_name') or 'Основной корпус'
            if not building_name or building_name.strip() == '':
                building_name = 'Основной корпус'
            
            if building_name not in properties_by_building_unsorted:
                properties_by_building_unsorted[building_name] = []
            properties_by_building_unsorted[building_name].append(prop)
        
        # Sort buildings
        def sort_buildings(building_name):
            import re
            if not building_name or building_name == 'Основной корпус':
                return (999, building_name)
            match = re.search(r'(\d+)', building_name)
            if match:
                return (int(match.group(1)), building_name)
            return (999, building_name)
        
        properties_by_building = {}
        sorted_building_names = sorted(properties_by_building_unsorted.keys(), key=sort_buildings)
        for building_name in sorted_building_names:
            properties_by_building[building_name] = properties_by_building_unsorted[building_name]
        
        # === STEP 5.5: Create buildings dict with stats for template ===
        buildings_dict = {}
        for building_name, building_props in properties_by_building.items():
            if not building_props:
                continue
            
            # Calculate building stats from properties
            building_prices = [p.get('price', 0) for p in building_props if p.get('price')]
            building_areas = [p.get('area', 0) for p in building_props if p.get('area')]
            
            # Get building years/quarters from first property (they should be consistent per building)
            first_prop = building_props[0]
            end_build_year = first_prop.get('end_build_year') or complex_data.get('end_build_year')
            end_build_quarter = first_prop.get('end_build_quarter') or complex_data.get('end_build_quarter')
            start_build_year = first_prop.get('start_build_year') or complex_data.get('start_build_year')
            start_build_quarter = first_prop.get('start_build_quarter') or complex_data.get('start_build_quarter')
            
            # Determine building status based on completion date
            import datetime
            current_year = datetime.datetime.now().year
            current_quarter = (datetime.datetime.now().month - 1) // 3 + 1
            
            building_status = 'В процессе строительства'
            if end_build_year and end_build_quarter:
                try:
                    if int(end_build_year) < current_year or (int(end_build_year) == current_year and int(end_build_quarter) <= current_quarter):
                        building_status = 'Сдан'
                except (ValueError, TypeError):
                    pass
            
            # Get total_floors from properties in this building
            total_floors_list = [p.get('total_floors') or p.get('object_max_floor') for p in building_props if p.get('total_floors') or p.get('object_max_floor')]
            max_total_floors = max(total_floors_list) if total_floors_list else None
            
            # Create building info dict
            buildings_dict[building_name] = {
                'apartments_count': len(building_props),
                'price_from': int(min(building_prices)) if building_prices else 0,
                'price_to': int(max(building_prices)) if building_prices else 0,
                'area_from': int(min(building_areas)) if building_areas else 0,
                'area_to': int(max(building_areas)) if building_areas else 0,
                'end_build_year': end_build_year,
                'end_build_quarter': end_build_quarter,
                'start_build_year': start_build_year,
                'start_build_quarter': start_build_quarter,
                'building_status': building_status,
                'total_floors': max_total_floors
            }
        
        # Add buildings dict to complex_data for template
        complex_data['buildings'] = buildings_dict
        complex_data['current_year'] = datetime.datetime.now().year
        complex_data['current_quarter'] = (datetime.datetime.now().month - 1) // 3 + 1
        
        # === STEP 6: Find similar complexes ===
        similar_complexes = []
        try:
            other_complexes = (
                db.session.query(ResidentialComplex)
                .filter(ResidentialComplex.id != complex.id, ResidentialComplex.is_active == True)
                .limit(10)
                .all()
            )
            
            stats_by_complex = PropertyRepository.get_all_property_stats()
            
            for other_complex in other_complexes[:3]:
                stats = stats_by_complex.get(other_complex.id, {})
                
                image_url = other_complex.main_image
                if not image_url and other_complex.gallery_images:
                    try:
                        import json
                        images = json.loads(other_complex.gallery_images) if isinstance(other_complex.gallery_images, str) else []
                        image_url = images[0] if images else None
                    except:
                        pass
                
                if not image_url:
                    image_url = 'https://via.placeholder.com/400x300/0088CC/FFFFFF?text=' + quote(other_complex.name[:20])
                
                similar_complex = {
                    'id': other_complex.id,
                    'name': other_complex.name,
                    'slug': other_complex.slug,
                    'developer': other_complex.developer.name if other_complex.developer else 'Не указан',
                    'district': other_complex.district.name if other_complex.district else 'Краснодар',
                    'price_from': stats.get('min_price', 0),
                    'total_apartments': stats.get('count', 0),
                    'object_class': other_complex.object_class_display_name or 'Комфорт',
                    'image': image_url,
                    'completion_date': f"{other_complex.end_build_quarter or '3'} кв. {other_complex.end_build_year or '2025'}",
                    'cashback_percent': other_complex.cashback_rate or 5.0,
                    'url': f'/zk/{other_complex.slug}'
                }
                similar_complexes.append(similar_complex)
                
        except Exception as e:
            print(f"Error finding similar complexes: {e}")
            import traceback
            traceback.print_exc()
            similar_complexes = []
        
        # === STEP 7: Load active offers and marketing materials ===
        offers_objects = Offer.query.filter_by(
            residential_complex_id=complex.id, 
            is_active=True
        ).order_by(Offer.sort_order).all()
        
        offers = []
        for offer in offers_objects:
            offers.append({
                'id': offer.id,
                'title': offer.title,
                'description': offer.description or '',
                'image_url': offer.image_url,
                'is_active': offer.is_active,
                'sort_order': offer.sort_order
            })
        
        materials = MarketingMaterial.query.filter_by(
            residential_complex_id=complex.id,
            is_active=True
        ).order_by(MarketingMaterial.sort_order, MarketingMaterial.created_at.desc()).all()
        
        # Check if user is a manager or admin
        is_manager = isinstance(current_user._get_current_object(), Manager) if current_user.is_authenticated else False
        is_admin = isinstance(current_user._get_current_object(), Admin) if current_user.is_authenticated else False
        
        # === STEP 8: Render template ===
        return render_template('residential_complex_detail.html', 
                             current_city=current_city,
                             complex=complex_data,
                             properties=complex_properties,
                             properties_by_rooms=properties_by_rooms,
                             properties_by_building=properties_by_building,
                             similar_complexes=similar_complexes,
                             developer_info=complex.developer if complex.developer else None,
                             offers=offers,
                             materials=materials,
                             manager_authenticated=is_manager,
                             admin_authenticated=is_admin)
                             
    except Exception as e:
        print(f"ERROR in /residential_complex_by_slug_city: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

def extract_main_image_from_photos(photos_raw):
    """Извлекает основное изображение из поля photos, предпочитая внешние виды зданий"""
    if not photos_raw or not photos_raw.strip():
        return '/static/images/no-photo.jpg'
    
    try:
        import json
        # Попробуем парсить как JSON массив
        if photos_raw.startswith('[') and photos_raw.endswith(']'):
            images = json.loads(photos_raw)
            if not images:
                return '/static/images/no-photo.jpg'
            
            # Фильтруем изображения, предпочитая внешние виды
            # Берем последние изображения, так как первые часто планировки
            if len(images) > 5:
                # Берем из середины/конца массива, где обычно фото зданий
                return images[len(images)//2]
            elif len(images) > 2:
                return images[-1]  # Последнее фото
            else:
                return images[0]
        
        # PostgreSQL array format: {url1,url2,url3}
        elif photos_raw.startswith('{') and photos_raw.endswith('}'):
            images_str = photos_raw[1:-1]  # Remove braces
            if images_str:
                images = [img.strip().strip('"') for img in images_str.split(',') if img.strip()]
                return images[0] if images else '/static/images/no-photo.jpg'
            else:
                return '/static/images/no-photo.jpg'
        
        # Одиночная ссылка
        else:
            return photos_raw
            
    except (json.JSONDecodeError, IndexError) as e:
        print(f"Error parsing photos: {e}, raw data: {photos_raw[:100]}")
        return '/static/images/no-photo.jpg'

@app.route('/complexes-map')
def complexes_map():
    """Карта жилых комплексов"""
    try:
        # ✅ MIGRATED: Load residential complexes with coordinates using repository
        complexes_data = ResidentialComplexRepository.get_with_coordinates()
        property_stats = PropertyRepository.get_all_property_stats()
        
        residential_complexes = []
        current_year = 2025
        
        for row in complexes_data:
            complex_id = row.id
            stats = property_stats.get(complex_id, {})
            
            # Skip complexes without properties
            if not stats or stats.get('total_count', 0) == 0:
                continue
            
            # Determine status based on completion year - get from repository
            end_build_year = row.end_build_year
            end_build_quarter = row.end_build_quarter
            object_class_name = row.object_class_display_name
            status = 'Не указан'
            completion_date = 'Не указан'
            
            # Calculate status and completion date
            
            if end_build_year:
                if end_build_year <= current_year:
                    status = 'Сдан'
                else:
                    status = 'Строится'
                
                if end_build_quarter:
                    completion_date = f"{end_build_quarter} кв. {end_build_year}"
                else:
                    completion_date = f"{end_build_year} год"
            
            complex_data = {
                'id': complex_id,
                'name': row.name or '',
                'developer': row.developer_name or 'Не указан',
                'address': '',  # Not in get_with_coordinates()
                'district': 'Краснодарский край',
                'apartments_count': stats.get('total_count', 0),
                'price_from': int(stats.get('min_price', 0)),
                'coordinates': {
                    'lat': float(row.latitude) if row.latitude else 45.0448,
                    'lng': float(row.longitude) if row.longitude else 38.9760
                },
                'completion_date': completion_date,
                'status': status,
                'cashback_percent': float(row.cashback_rate) if row.cashback_rate else 0,
                'main_image': row.main_image or '/static/images/no-photo.jpg',
                'description': f"Жилой комплекс {row.name or ''}",
                'object_class': object_class_name or 'Комфорт',
                'housing_class': object_class_name or 'Комфорт',
                'max_floors': 0,
                'url': f'/zk/{row.slug}' if row.slug else f'/residential-complex/{complex_id}',
                'type': 'complex'
            }
            residential_complexes.append(complex_data)
        
        # Фильтры для интерфейса
        all_districts = sorted(list(set(complex.get('district', 'Не указан') for complex in residential_complexes)))
        all_developers = sorted(list(set(complex.get('developer', 'Не указан') for complex in residential_complexes)))
        all_statuses = ['Все', 'Сдан', 'Строится']
        
        print(f"DEBUG: Found {len(residential_complexes)} complexes for map")
        if residential_complexes:
            print(f"DEBUG: First complex: {residential_complexes[0]}")
        
        return render_template('complexes_map.html', 
                             residential_complexes=residential_complexes,
                             all_districts=all_districts,
                             all_developers=all_developers,
                             all_statuses=all_statuses)
                             
    except Exception as e:
        print(f"ERROR in complexes-map route: {e}")
        import traceback
        traceback.print_exc()
        return f"Error 500: {str(e)}", 500

# API Routes
@app.route('/api/properties')
@cache.cached(timeout=300, query_string=True)
def api_properties():
    """API endpoint for properties - NORMALIZED TABLES"""
    try:
        # Resolve city context for filtering
        city_context = resolve_city_context(
            city_id=request.args.get('city_id'),
            city_slug=request.args.get('city'),
            default_if_none=True
        )
        city_name = city_context.name if city_context else 'Краснодар'
        city_id_filter = city_context.id if city_context else None
        import json
        from sqlalchemy.orm import joinedload
        from repositories.property_repository import PropertyRepository
        from models import Property, ResidentialComplex
        
        # Pagination
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 50))
        offset = (page - 1) * per_page
        
        # Get properties with coordinates
        query = Property.query.join(
            ResidentialComplex, Property.complex_id == ResidentialComplex.id, isouter=True
        ).filter(
            Property.is_active == True,
            Property.latitude.isnot(None),
            Property.longitude.isnot(None)
        )
        
        # Apply city filter if specified
        if city_id_filter:
            query = query.filter(Property.city_id == city_id_filter)
        
        properties_list = query.options(
            joinedload(Property.residential_complex),
            joinedload(Property.developer)
        ).offset(offset).limit(per_page).all()
        
        # Count total
        total_count_query = Property.query.filter(
            Property.is_active == True,
            Property.latitude.isnot(None),
            Property.longitude.isnot(None)
        )
        if city_id_filter:
            total_count_query = total_count_query.filter(Property.city_id == city_id_filter)
        total_count = total_count_query.count()
        
        # Format response
        properties = []
        for prop in properties_list:
            complex_obj = prop.residential_complex
            developer_obj = prop.developer
            
            property_data = {
                'id': prop.id,
                'price': prop.price or 0,
                'area': prop.area or 0,
                'rooms': prop.rooms or 0,
                'title': prop.room_description + f", {prop.area} м²",
                'subtitle': f"{complex_obj.name if complex_obj else ''} • {city_name}",
                'address': prop.address or (complex_obj.address if complex_obj else ''),
                'residential_complex': complex_obj.name if complex_obj else '',
                'developer': developer_obj.name if developer_obj else '',
                'developer_name': developer_obj.name if developer_obj else '',
                'district': city_context.name if 'city_context' in locals() else 'Краснодар',
                'district': 'Краснодар',
                'renovation_display_name': prop.renovation_type or 'Без отделки',
                'object_min_floor': prop.floor,
                'object_max_floor': prop.total_floors,
                'coordinates': {
                    'lat': float(prop.latitude) if prop.latitude else 45.0448,
                    'lng': float(prop.longitude) if prop.longitude else 38.9760
                },
                'url': f"/object/{prop.id}",
                'type': 'property',
                'cashback': int((prop.price or 0) * (complex_obj.cashback_rate / 100 if complex_obj else 0.035)),
                'cashback_available': True,
                'status': 'available',
                'property_type': 'Квартира'
            }
            
            # Main image
            if prop.main_image:
                property_data['main_image'] = prop.main_image
            elif prop.gallery_images:
                try:
                    photos = json.loads(prop.gallery_images)
                    property_data['main_image'] = photos[0] if photos else 'https://via.placeholder.com/400x300'
                except:
                    property_data['main_image'] = 'https://via.placeholder.com/400x300'
            else:
                property_data['main_image'] = 'https://via.placeholder.com/400x300'
            
            properties.append(property_data)
        
        print(f"DEBUG: API returned {len(properties)} properties (page {page}, total {total_count})")
        return jsonify({
            'properties': properties,
            'total': total_count,
            'page': page,
            'per_page': per_page,
            'total_pages': (total_count + per_page - 1) // per_page,
            'success': True
        })
        
    except Exception as e:
        print(f"ERROR in api_properties: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500



@app.route('/api/search-suggestions-OLD-DISABLED')
def api_search_suggestions_old_disabled():
    """❌ СТАРЫЙ API endpoint - ОТКЛЮЧЁН, чтобы не мешал новому"""
    return jsonify([])  # ВСЕГДА ПУСТОЙ


# ===== СТАРЫЙ КОД ПОЛНОСТЬЮ УДАЛЁН =====

@app.route('/api/properties/list')
def api_properties_list():
    """AJAX API для получения списка объектов с сортировкой и фильтрами"""
    # Resolve city context for dynamic city display
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    
    try:
        import json
        from repositories.property_repository import PropertyRepository, ResidentialComplexRepository, DeveloperRepository
        
        # Parse filters
        _, _, filters = build_property_filters(request.args)
        
        # Pagination
        page = request.args.get('page', default=1, type=int)
        page = max(1, page)
        per_page = request.args.get('per_page', default=20, type=int)
        per_page = min(max(1, per_page), 1000)  # Limit between 1-1000
        offset = (page - 1) * per_page
        
        # Sorting
        sort_type = request.args.get('sort', 'price-asc').replace('_', '-')
        
        # Convert filters to Repository format (same logic as /properties route)
        repo_filters = {}
        
        # Price filters
        if filters.get('price_min'):
            try:
                repo_filters['min_price'] = int(float(filters['price_min']) * 1000000)
            except:
                pass
        if filters.get('price_max'):
            try:
                repo_filters['max_price'] = int(float(filters['price_max']) * 1000000)
            except:
                pass
                
        # Area filters
        if filters.get('area_min'):
            try:
                repo_filters['min_area'] = float(filters['area_min'])
            except:
                pass
        if filters.get('area_max'):
            try:
                repo_filters['max_area'] = float(filters['area_max'])
            except:
                pass
                
        # Rooms filter
        if filters.get('rooms'):
            try:
                # Поддержка и строк, и чисел в массиве rooms
                rooms_list = []
                for r in filters['rooms']:
                    if isinstance(r, str):
                        r_stripped = r.strip()
                        if r_stripped:
                            rooms_list.append(int(r_stripped))
                    elif isinstance(r, int):
                        rooms_list.append(r)
                if rooms_list:
                    repo_filters['rooms'] = rooms_list
                    app.logger.info(f"✅ Rooms filter applied: {rooms_list}")
            except Exception as e:
                app.logger.error(f"❌ Error processing rooms filter: {e}")
        if filters.get('developers'):
            repo_filters['developers'] = filters['developers']
        if filters.get('developer'):
            if 'developers' not in repo_filters:
                repo_filters['developers'] = []
            if filters['developer'] not in repo_filters['developers']:
                repo_filters['developers'].append(filters['developer'])
                
        # Districts filter
        if filters.get('districts'):
            repo_filters['districts'] = filters['districts']
        
        # Residential complex filter
        if filters.get('residential_complex'):
            repo_filters['residential_complex'] = filters['residential_complex']
        
        # Floor filters
        if filters.get('floor_min'):
            try:
                repo_filters['floor_min'] = int(filters['floor_min'])
            except:
                pass
        if filters.get('floor_max'):
            try:
                repo_filters['floor_max'] = int(filters['floor_max'])
            except:
                pass
        
        
        # Object classes filter
        if filters.get('object_classes'):
            repo_filters['object_classes'] = filters['object_classes']
        # Search filter
        search_text = filters.get('search', '').strip()
        if search_text:
            repo_filters['search'] = search_text
        
        # Parse sort_type (e.g. 'price-asc', 'area-desc')
        sort_by = 'price'
        sort_order = 'asc'
        if sort_type:
            parts = sort_type.split('-')
            if len(parts) == 2:
                sort_by = parts[0]
                sort_order = parts[1]
        
        # Get properties with Repository
        
        # ✅ ADD: Include city_id from session/context
        if current_city:
            repo_filters['city_id'] = current_city.id
            print(f"✅ /properties: Filtering by city: {current_city.name} (ID: {current_city.id})")

        properties_list = PropertyRepository.get_all_active(
            limit=per_page,
            offset=offset,
            filters=repo_filters,
            sort_by=sort_by,
            sort_order=sort_order
        )
        
        total_properties = PropertyRepository.count_active(filters=repo_filters)
        
        # Convert to JSON format
        properties_data = []
        for prop in properties_list:
            try:
                complex_obj = prop.residential_complex
                developer_obj = prop.developer
                
                # Parse photos
                photos_list = []
                main_image = 'https://via.placeholder.com/400x300'
                
                if prop.main_image:
                    main_image = prop.main_image
                
                if prop.gallery_images:
                    try:
                        if isinstance(prop.gallery_images, list):
                            photos_list = prop.gallery_images
                        elif isinstance(prop.gallery_images, str):
                            photos_list = json.loads(prop.gallery_images)
                        
                        if photos_list and not prop.main_image:
                            main_image = photos_list[0]
                    except:
                        pass
                
                # Calculate cashback
                cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 3.5
                cashback_amount = int(prop.price * (cashback_rate / 100)) if prop.price else 0
                
                property_dict = {
                    'id': prop.id,
                    'price': prop.price or 0,
                    'price_formatted': prop.formatted_price,
                    'area': prop.area or 0,
                    'rooms': prop.rooms or 0,
                    'room_description': prop.room_description,
                    'floor': prop.floor if prop.floor is not None else 1,
                    'total_floors': prop.total_floors if prop.total_floors is not None else 1,
                    'address': prop.address or (complex_obj.address if complex_obj else ''),
                    'renovation': prop.renovation_type or 'no_renovation',
                    'renovation_display_name': PropertyRepository.get_renovation_display_name(prop.renovation_type),
                    'price_per_sqm': prop.price_per_sqm or (int(prop.price / prop.area) if prop.price and prop.area else 0),
                    'gallery': photos_list,
                    'image': main_image,
                    'latitude': prop.latitude or (complex_obj.latitude if complex_obj else None),
                    'longitude': prop.longitude or (complex_obj.longitude if complex_obj else None),
                    'complex_name': complex_obj.name if complex_obj else '',
                    'residential_complex': complex_obj.name if complex_obj else '',
                    'developer': developer_obj.name if developer_obj else '',
                    'developer_name': developer_obj.name if developer_obj else '',
                    'cashback_rate': cashback_rate,
                    'cashback': cashback_amount,
                    'cashback_available': True,
                    'complex_object_class_display_name': complex_obj.object_class_display_name if complex_obj else 'Комфорт',
                    'deal_type': prop.deal_type or 'Первичка',
                    'description': prop.description or '',
                    'type': 'apartment',
                    'district': complex_obj.district if complex_obj else 'Краснодар',
                    'mortgage_available': True,
                    'completion_date': f"{complex_obj.end_build_quarter} кв. {complex_obj.end_build_year}" if complex_obj and complex_obj.end_build_year else 'Уточняется'
                }
                properties_data.append(property_dict)
            except Exception as e:
                print(f"Error processing property {prop.id}: {e}")
                continue
        
        # Pagination info
        total_pages = (total_properties + per_page - 1) // per_page
        
        print(f"✅ API /api/properties/list: returned {len(properties_data)} properties, page {page}/{total_pages}, sort={sort_type}")
        
        return jsonify({
            'success': True,
            'properties': properties_data,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total_properties,
                'total_pages': total_pages,
                'has_prev': page > 1,
                'has_next': page < total_pages
            },
            'filters': filters,
            'sort': sort_type
        })
        
    except Exception as e:
        print(f"ERROR in api_properties_list: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500



@app.route('/api/properties/count')
def api_properties_count():
    """API endpoint для подсчета количества объектов с учетом фильтров (БЕЗ полной выборки данных)"""
    try:
        import json
        from repositories.property_repository import PropertyRepository
        
        # Parse filters using the same build_property_filters function
        _, _, filters = build_property_filters(request.args)
        
        # Convert filters to Repository format (same logic as /properties and /api/properties/list)
        repo_filters = {}
        
        # Price filters
        if filters.get('price_min'):
            try:
                repo_filters['min_price'] = int(float(filters['price_min']) * 1000000)
            except:
                pass
        if filters.get('price_max'):
            try:
                repo_filters['max_price'] = int(float(filters['price_max']) * 1000000)
            except:
                pass
                
        # Area filters
        if filters.get('area_min'):
            try:
                repo_filters['min_area'] = float(filters['area_min'])
            except:
                pass
        if filters.get('area_max'):
            try:
                repo_filters['max_area'] = float(filters['area_max'])
            except:
                pass
                
        # Rooms filter - ИСПРАВЛЕНО: безопасная обработка смешанных типов
        if filters.get('rooms'):
            try:
                room_values = []
                for r in filters['rooms']:
                    # Обрабатываем и строки и числа безопасно
                    if isinstance(r, str):
                        r_clean = r.strip()
                        if r_clean:
                            room_values.append(int(r_clean))
                    elif isinstance(r, int):
                        room_values.append(r)
                if room_values:
                    repo_filters['rooms'] = room_values
            except Exception as e:
                print(f"Warning: error parsing rooms filter: {e}")
                pass
        
        # Developers filter
        if filters.get('developers'):
            repo_filters['developers'] = filters['developers']
        if filters.get('developer'):
            if 'developers' not in repo_filters:
                repo_filters['developers'] = []
            if filters['developer'] not in repo_filters['developers']:
                repo_filters['developers'].append(filters['developer'])
                
        # Districts filter
        if filters.get('districts'):
            repo_filters['districts'] = filters['districts']
        
        # Residential complex filter
        if filters.get('residential_complex'):
            repo_filters['residential_complex'] = filters['residential_complex']
        
        # Floor filters
        if filters.get('floor_min'):
            try:
                repo_filters['floor_min'] = int(filters['floor_min'])
            except:
                pass
        if filters.get('floor_max'):
            try:
                repo_filters['floor_max'] = int(filters['floor_max'])
            except:
                pass
        
        # Object class filter
        if filters.get('object_classes'):
            repo_filters['object_classes'] = filters['object_classes']
        
        # Renovation filter
        if filters.get('renovation'):
            repo_filters['renovation'] = filters['renovation']
        
        # Features filter
        if filters.get('features'):
            repo_filters['features'] = filters['features']
        
        # Building released filter
        if filters.get('building_released'):
            repo_filters['building_released'] = filters['building_released']
        
        # Completion filter
        if filters.get('completion'):
            repo_filters['completion'] = filters['completion']
        
        # Floor options filter
        if filters.get('floor_options'):
            repo_filters['floor_options'] = filters['floor_options']
        if filters.get('features'):
            repo_filters['features'] = filters['features']
        
        # Building floors filters
        if filters.get('building_floors_min'):
            try:
                repo_filters['building_floors_min'] = int(filters['building_floors_min'])
            except:
                pass
        if filters.get('building_floors_max'):
            try:
                repo_filters['building_floors_max'] = int(filters['building_floors_max'])
            except:
                pass
        
        # Build year filters
        if filters.get('build_year_min'):
            try:
                repo_filters['build_year_min'] = int(filters['build_year_min'])
            except:
                pass
        if filters.get('build_year_max'):
            try:
                repo_filters['build_year_max'] = int(filters['build_year_max'])
            except:
                pass
        
        # Search query filter
        search_query = request.args.get('q', '').strip()
        if search_query:
            repo_filters['search'] = search_query
        
        # ✅ КРИТИЧНО: City filter для правильного подсчета по городам
        if filters.get('city_id'):
            try:
                repo_filters['city_id'] = int(filters['city_id'])
            except (ValueError, TypeError):
                pass
        
        # Get total count from repository (optimized query - count only)
        total_count = PropertyRepository.get_filtered_count(**repo_filters)
        
        return jsonify({
            'success': True,
            'count': total_count,
            'filters': filters  # Return parsed filters for debugging
        })
        
    except Exception as e:
        print(f"Error in api_properties_count: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e), 'count': 0}), 500

@app.route('/api/residential-complexes-map')
def api_residential_complexes_map():
    """API endpoint for residential complexes with enhanced data for map"""
    # Get city context from session
    city_id = None
    if 'city_id' in session:
        city_id = session['city_id']
    
    # Filter complexes by city_id (inline query - DO NOT modify load_residential_complexes())
    from models import ResidentialComplex
    query = ResidentialComplex.query.filter_by(is_active=True)
    if city_id:
        query = query.filter_by(city_id=city_id)
    
    complexes_db = query.all()
    
    # Convert to dict format for existing processing logic
    complexes = []
    for complex in complexes_db:
        complexes.append({
            'id': complex.id,
            'name': complex.name,
            'slug': complex.slug,
            'latitude': complex.latitude,
            'longitude': complex.longitude,
            'cashback_rate': complex.cashback_rate,
            'main_image': complex.main_image,
            'district': complex.district.name if complex.district else 'Не указан',
            'developer': complex.developer.name if complex.developer else 'Не указан',
        })
    
    # Enhance complexes data for map
    for i, complex in enumerate(complexes):
        # Add coordinates if missing
        if 'coordinates' not in complex:
            base_lat = 45.0448
            base_lng = 38.9760
            lat_offset = (hash(str(i) + complex.get('name', '')) % 1000) / 8000 - 0.0625
            lng_offset = (hash(str(i) + complex.get('district', '')) % 1000) / 8000 - 0.0625
            complex['coordinates'] = {
                'lat': base_lat + lat_offset,
                'lng': base_lng + lng_offset
            }
        
        # ✅ ИСПРАВЛЕНО: Правильный подсчет корпусов из normalized tables
        if 'buildings_count' not in complex:
            # Получаем реальное количество корпусов из normalized tables
            try:
                result = db.session.execute(text("""
                    SELECT COUNT(DISTINCT p.complex_building_name) as buildings_count
                    FROM properties p
                    JOIN residential_complexes rc ON p.complex_id = rc.id
                    WHERE rc.name = :complex_name 
                      AND p.is_active = true 
                      AND p.complex_building_name IS NOT NULL
                """), {'complex_name': complex.get('name', '')})
                row = result.fetchone()
                complex['buildings_count'] = row[0] if row and row[0] else 1
            except:
                complex['buildings_count'] = 1  # По умолчанию 1 корпус
        if 'apartments_count' not in complex:
            complex['apartments_count'] = 100 + (i % 300)
            
    return jsonify({"complexes": complexes, "total": len(complexes)})

# Removed duplicate route - using api_property_detail instead

def _get_complex_data_normalized(complex_id):
    """
    Helper function to query complex data from normalized tables.
    Handles both residential_complexes.id and complex_id (legacy external ID).
    Returns tuple with result row and success boolean.
    """
    result = db.session.execute(text("""
        SELECT 
            rc.id,
            rc.name,
            MIN(p.price) as min_price,
            MAX(p.price) as max_price,
            COUNT(DISTINCT p.id) as apartments_count,
            COUNT(DISTINCT NULLIF(p.complex_building_name,'')) as buildings_count,
            d.name as developer_name,
            MIN(p.floor) as floors_min,
            MAX(p.total_floors) as floors_max,
            rc.end_build_year as completion_year,
            rc.end_build_quarter as completion_quarter,
            dis.name as district,
            COALESCE(MAX(p.address), rc.address) as address,
            rc.cashback_rate,
            COALESCE(rc.main_image, rc.gallery_images, MIN(p.gallery_images)) as photos,
            rc.object_class_display_name AS complex_object_class_display_name
        FROM properties p
        JOIN residential_complexes rc ON p.complex_id = rc.id
        JOIN developers d ON p.developer_id = d.id
        LEFT JOIN districts dis ON rc.district_id = dis.id
        WHERE (rc.id = :complex_id OR rc.complex_id = :complex_id_str)
            AND p.is_active = true
        GROUP BY rc.id, rc.name, d.name, rc.end_build_year, rc.end_build_quarter, 
                 dis.name, rc.address, rc.cashback_rate, rc.gallery_images, 
                 rc.main_image, rc.object_class_display_name
        LIMIT 1
    """), {'complex_id': complex_id, 'complex_id_str': str(complex_id)}).fetchone()
    
    return result


@app.route('/api/complex/<int:complex_id>')
def api_complex(complex_id):
    """API endpoint for single residential complex - MIGRATED TO NORMALIZED TABLES"""
    print(f"🔍 API /api/complex/{complex_id} called")
    
    try:
        # Query normalized tables (handles both rc.id and rc.complex_id)
        result = _get_complex_data_normalized(complex_id)
        
        if result:
            print(f"✅ Found complex {complex_id} in normalized tables: {result[1]}, apartments: {result[4]}, price: {result[2]}-{result[3]}")
            
            # Build completion date from year and quarter
            completion_date = 'Не указано'
            if result[9] and result[10]:  # year and quarter
                completion_date = f"{result[9]} г., {result[10]} кв."
            elif result[9]:  # only year
                completion_date = f"{result[9]} г."
            
            # ✅ Auto-calculate status based on completion date
            from datetime import datetime
            current_year = datetime.now().year
            current_quarter = (datetime.now().month - 1) // 3 + 1
            
            status = "Не указан"
            if result[9]:  # completion_year exists
                completion_year = int(result[9])
                if completion_year < current_year:
                    status = "Сдан"
                elif completion_year == current_year:
                    if result[10]:  # completion_quarter exists
                        completion_quarter = int(result[10])
                        if completion_quarter <= current_quarter:
                            status = "Сдан"
                        else:
                            status = "Строится"
                    else:
                        status = "Строится"
                else:
                    status = "Строится"
            
            # Extract first photo from photos array/string
            image_url = '/static/images/no-image.jpg'
            if result[14]:  # photos field
                try:
                    # Try parsing as JSON array
                    photos_data = json.loads(result[14])
                    if photos_data and isinstance(photos_data, list) and len(photos_data) > 0:
                        image_url = photos_data[0]
                except (json.JSONDecodeError, TypeError):
                    # If not JSON, treat as single image URL
                    if isinstance(result[14], str) and result[14].strip():
                        image_url = result[14]
            
            response_data = {
                'id': result[0],
                'name': result[1],
                'min_price': result[2],
                'price_from': result[2],
                'max_price': result[3],
                'price_to': result[3],
                'apartments_count': result[4],
                'properties_count': result[4],
                'buildings_count': result[5],
                'developer': result[6],
                'developer_name': result[6],

                'floors_min': result[7],
                'floors_max': result[8],
                'district': result[11] if len(result) > 11 else None,
                'address': result[12] if len(result) > 12 else None,
                'cashback_rate': result[13] if len(result) > 13 else None,
                'housing_class': result[15] if len(result) > 15 else None,
                'status': status,
                'completion_date': completion_date,
                'image_url': image_url,
                'image': image_url
            }
            return jsonify(response_data)
        else:
            return jsonify({'error': 'Complex not found'}), 404
    except Exception as e:
        print(f'Error in /api/complex endpoint: {e}')
        return jsonify({'error': 'Internal server error'}), 500

def _get_complexes_batch_optimized(complex_ids):
    """
    Bulk query for multiple complexes from normalized tables - SINGLE QUERY.
    Returns dict mapping complex_id -> result tuple (same format as _get_complex_data_normalized).
    """
    if not complex_ids:
        return {}
    
    # Single bulk query using IN clause
    results = db.session.execute(text("""
        SELECT 
            rc.id,
            rc.name,
            MIN(p.price) as min_price,
            MAX(p.price) as max_price,
            COUNT(DISTINCT p.id) as apartments_count,
            COUNT(DISTINCT NULLIF(p.complex_building_name,'')) as buildings_count,
            d.name as developer_name,
            MIN(p.floor) as floors_min,
            MAX(p.total_floors) as floors_max,
            rc.end_build_year as completion_year,
            rc.end_build_quarter as completion_quarter,
            dis.name as district,
            COALESCE(MAX(p.address), rc.address) as address,
            rc.cashback_rate,
            COALESCE(rc.main_image, rc.gallery_images, MIN(p.gallery_images)) as photos,
            rc.object_class_display_name AS complex_object_class_display_name
        FROM properties p
        JOIN residential_complexes rc ON p.complex_id = rc.id
        JOIN developers d ON p.developer_id = d.id
        LEFT JOIN districts dis ON rc.district_id = dis.id
        WHERE (rc.id IN :complex_ids OR rc.complex_id::text = ANY(ARRAY[:complex_ids_str]))
            AND p.is_active = true
        GROUP BY rc.id, rc.name, d.name, rc.end_build_year, rc.end_build_quarter, 
                 dis.name, rc.address, rc.cashback_rate, rc.gallery_images, 
                 rc.main_image, rc.object_class_display_name
    """), {
        'complex_ids': tuple(complex_ids),
        'complex_ids_str': [str(cid) for cid in complex_ids]
    }).fetchall()
    
    # Build dict mapping id -> result tuple
    result_dict = {}
    for row in results:
        result_dict[row[0]] = row  # row[0] is rc.id
    
    return result_dict

@require_json_csrf
@app.route('/api/complexes/batch', methods=['POST'])
def api_complexes_batch():
    """Batch API endpoint to get multiple complexes at once - OPTIMIZED"""
    try:
        data = request.get_json()
        complex_ids = data.get('ids', [])
        
        if not complex_ids or not isinstance(complex_ids, list):
            return jsonify({'error': 'Invalid request, expected {"ids": [1, 2, 3]}'}), 400
        
        # Convert string IDs to integers
        try:
            complex_ids = [int(cid) for cid in complex_ids if cid]
        except (ValueError, TypeError) as e:
            return jsonify({'error': f'Invalid ID format: {str(e)}'}), 400
        
        # ✅ SINGLE QUERY: Load all complexes at once using bulk helper function
        complexes_dict = _get_complexes_batch_optimized(complex_ids)
        
        results = {}
        for complex_id in complex_ids:
            result = complexes_dict.get(complex_id)
            if result:
                # Build completion date
                completion_date = 'Не указано'
                if result[9] and result[10]:
                    completion_date = f"{result[9]} г., {result[10]} кв."
                elif result[9]:
                    completion_date = f"{result[9]} г."
                
                # Extract image
                image_url = '/static/images/no-image.jpg'
                if result[14]:
                    try:
                        photos_data = json.loads(result[14])
                        if photos_data and isinstance(photos_data, list) and len(photos_data) > 0:
                            image_url = photos_data[0]
                    except (json.JSONDecodeError, TypeError):
                        if isinstance(result[14], str) and result[14].strip():
                            image_url = result[14]
                
                response_data = {
                    'id': result[0],
                    'name': result[1],
                    'min_price': result[2],
                    'price_from': result[2],
                    'max_price': result[3],
                    'price_to': result[3],
                    'apartments_count': result[4],
                    'properties_count': result[4],
                    'buildings_count': result[5],
                    'developer': result[6],
                    'developer_name': result[6],
                    'floors_min': result[7] if result[7] else 'Не указано',
                    'floors_max': result[8],
                    'completion_date': completion_date,
                    'district': result[11] or 'Не указано',
                    'address': result[12] or 'Не указано',
                    'cashback_rate': result[13] or 0,
                    'cashback_percent': result[13] or 0,
                    'object_class': result[15] or 'Не указано',
                    'status': 'В продаже',
                    'image': image_url,
                    'original_id': complex_id
                }
                results[str(complex_id)] = response_data
        
        return jsonify({'success': True, 'items': results})
    except Exception as e:
        print(f"❌ Error in batch complexes: {e}")
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500




@app.route('/api/mini-map/properties')
def api_mini_map_properties():
    """API endpoint for mini-map: return property coordinates - NORMALIZED TABLES"""
    from repositories.property_repository import PropertyRepository
    
    try:
        # Get city context from session
        city_id = None
        if 'city_id' in session:
            city_id = session['city_id']
            print(f"🗺️ Mini-map API: Using city_id from session: {city_id}")
        else:
            print(f"⚠️ Mini-map API: No city_id in session, loading all properties")
        
        # Build filters with city_id
        filters = {}
        if city_id:
            filters['city_id'] = city_id
        
        # Get coordinates from properties table using Repository with city filtering
        properties = PropertyRepository.get_all_active(limit=500, filters=filters)
        
        coordinates = []
        for prop in properties:
            # Check if property has coordinates (either direct or from complex)
            lat = prop.latitude
            lng = prop.longitude
            
            # If property doesn't have coordinates, try to get from residential complex
            if (not lat or not lng or lat == 0 or lng == 0) and prop.residential_complex:
                lat = prop.residential_complex.latitude
                lng = prop.residential_complex.longitude
            
            # Only add if we have valid coordinates
            if lat and lng and lat != 0 and lng != 0:
                coordinates.append({
                    'lat': float(lat),
                    'lng': float(lng)
                })
        
        print(f"✅ Mini-map: Loaded {len(coordinates)} property coordinates from normalized tables")
        return jsonify({'success': True, 'coordinates': coordinates, 'count': len(coordinates)})
    except Exception as e:
        print(f"❌ Error in mini-map properties: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/mini-map/complexes')
def api_mini_map_complexes():
    """API endpoint for mini-map: return complex coordinates - NORMALIZED TABLES"""
    from repositories.property_repository import ResidentialComplexRepository
    
    try:
        # Get coordinates from residential_complexes table using Repository
        complexes = ResidentialComplexRepository.get_all_active()
        
        coordinates = []
        for complex_obj in complexes:
            # Only add if complex has valid coordinates
            if complex_obj.latitude and complex_obj.longitude and complex_obj.latitude != 0 and complex_obj.longitude != 0:
                coordinates.append({
                    'name': complex_obj.name,
                    'lat': float(complex_obj.latitude),
                    'lng': float(complex_obj.longitude)
                })
        
        print(f"✅ Mini-map: Loaded {len(coordinates)} complex coordinates from normalized tables")
        return jsonify({'success': True, 'coordinates': coordinates, 'count': len(coordinates)})
    except Exception as e:
        print(f"❌ Error in mini-map complexes: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/property/<property_id>/pdf')
def download_property_pdf(property_id):
    """Generate and download PDF for property"""
    try:
        property_data = get_property_by_id(property_id)
        if not property_data:
            return jsonify({'error': 'Property not found'}), 404
        
        # Create simple HTML for PDF generation
        html_content = f"""
        <html>
        <head>
            <meta charset="UTF-8">
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ text-align: center; margin-bottom: 30px; }}
                .property-details {{ margin-bottom: 20px; }}
                .detail-row {{ margin-bottom: 10px; }}
                .label {{ font-weight: bold; }}
                .price {{ color: #0088CC; font-size: 24px; font-weight: bold; }}
                .cashback {{ color: #FF5722; font-size: 18px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>InBack - Информация о квартире</h1>
                <p>Квартира #{property_id}</p>
            </div>
            
            <div class="property-details">
                <div class="detail-row">
                    <span class="label">Тип:</span> {property_data.get('rooms', 'Не указано')}
                </div>
                <div class="detail-row">
                    <span class="label">Площадь:</span> {property_data.get('area', 'Не указана')} м²
                </div>
                <div class="detail-row">
                    <span class="label">Этаж:</span> {property_data.get('floor', 'Не указан')}
                </div>
                <div class="detail-row">
                    <span class="label">Застройщик:</span> {property_data.get('developer', 'Не указан')}
                </div>
                <div class="detail-row">
                    <span class="label">ЖК:</span> {property_data.get('residential_complex', 'Не указан')}
                </div>
                <div class="detail-row">
                    <span class="label">Район:</span> {property_data.get('district', 'Не указан')}
                </div>
                <div class="detail-row">
                    <span class="label">Адрес:</span> {property_data.get('location', 'Не указан')}
                </div>
                <div class="detail-row">
                    <span class="label">Статус:</span> {property_data.get('status', 'Не указан')}
                </div>
                
                <div class="detail-row" style="margin-top: 30px;">
                    <div class="price">Цена: {property_data.get('price', 0):,} ₽</div>
                </div>
                <div class="detail-row">
                    <div class="cashback">Кешбек: до {calculate_cashback(property_data.get('price', 0)):,} ₽ (5%)</div>
                </div>
            </div>
            
            <div style="margin-top: 50px; text-align: center; color: #666;">
                <p>InBack.ru - ваш кешбек за новостройки</p>
                <p>Телефон: +7 (800) 123-12-12</p>
            </div>
        </body>
        </html>
        """
        
        # Return HTML for PDF conversion (browser will handle PDF generation)
        # Create ASCII-safe filename
        ascii_filename = f'property-{property_id}.html'
        
        response = app.response_class(
            response=html_content,
            status=200,
            mimetype='text/html'
        )
        response.headers['Content-Disposition'] = f'attachment; filename="{ascii_filename}"'
        return response
        
    except Exception as e:
        print(f"Error generating PDF for property {property_id}: {e}")
        return jsonify({'error': 'Failed to generate PDF'}), 500

@app.route('/developers')
# @cache.cached(timeout=3600)  # Кэш временно отключен для тестирования
def developers():
    """Developers listing page with real database data"""
    try:
        # For /developers without city in URL, don't use session city - show all developers
        # Only filter by city if explicitly provided in URL params
        current_city = resolve_city_context(
            city_id=request.args.get('city_id'),
            city_slug=request.args.get('city'),
            default_if_none=False  # Don't use session city for /developers route
        )
        
        print(f"Loading developers from database for city: {current_city.name if current_city else 'All'}")
        
        from models import Developer, ResidentialComplex, Property
        from services.dadata_client import DaDataClient
        from sqlalchemy import func
        
        # Получаем застройщиков из базы данных с статистикой
        # Фильтруем по городу, если город выбран
        query = db.session.query(Developer, 
                            func.count(ResidentialComplex.id).label('complexes_count'),
                            func.count(Property.id).label('properties_count'))
        
        if current_city:
            # Фильтруем только те ЖК и объекты, которые принадлежат текущему городу
            query = query.outerjoin(ResidentialComplex, 
                                   (Developer.id == ResidentialComplex.developer_id) & 
                                   (ResidentialComplex.city_id == current_city.id))
            # Property связан с Developer через ResidentialComplex, не напрямую
            query = query.outerjoin(Property, 
                                   (ResidentialComplex.id == Property.complex_id) & 
                                   (Property.city_id == current_city.id))
        else:
            query = query.outerjoin(ResidentialComplex, Developer.id == ResidentialComplex.developer_id)
            # Property связан с Developer через ResidentialComplex
            query = query.outerjoin(Property, ResidentialComplex.id == Property.complex_id)
        
        # Применяем фильтр "только с объектами" только когда фильтруем по городу
        query = query.group_by(Developer.id)
        if current_city:
            query = query.having(func.count(Property.id) > 0)  # Показываем только застройщиков с объектами в этом городе
        
        developers_list = query.order_by(func.count(Property.id).desc()).all()
        
        # Формируем список застройщиков с данными
        developers_data = []
        for developer, complexes_count, properties_count in developers_list:
            developer_dict = {
                'id': developer.id,
                'name': developer.name,
                'slug': developer.slug,
                'description': developer.description or f"Застройщик {developer.name}",
                'logo_url': developer.logo_url or f"https://via.placeholder.com/200x100/3B82F6/FFFFFF?text={developer.name.replace(' ', '+')}",
                'website': developer.website,
                'phone': developer.phone,
                'email': developer.email,
                'address': developer.address,
                'complexes_count': complexes_count,
                'properties_count': properties_count,
                'established_year': developer.established_year,
                # Нужные поля для шаблона
                'max_cashback': 10,  # По умолчанию 10%
                'max_cashback_percent': 10,
                # Статистика для отображения
                'stats': {
                    'total_projects': complexes_count,
                    'total_apartments': properties_count,
                    'avg_price': None  # Добавим позже
                }
            }
            
            # ✅ MIGRATED: Get statistics using ORM Property model
            from sqlalchemy import func
            # Фильтруем статистику по текущему городу
            # Property связан с Developer через ResidentialComplex
            stats_query = db.session.query(
                func.count(Property.id).label('total_properties'),
                func.avg(Property.price).label('avg_price'),
                func.min(Property.price).label('min_price'),
                func.max(Property.price).label('max_price'),
                func.count(func.distinct(Property.complex_id)).label('total_complexes')
            ).join(
                ResidentialComplex, Property.complex_id == ResidentialComplex.id
            ).filter(
                ResidentialComplex.developer_id == developer.id,
                Property.is_active == True
            )
            
            if current_city:
                stats_query = stats_query.filter(Property.city_id == current_city.id)
            
            stats_result = stats_query.first()
            
            if stats_result and stats_result.total_properties:
                total_props, avg_price, min_price, max_price, total_complexes = stats_result
                developer_dict['properties_count'] = total_props or properties_count
                developer_dict['complexes_count'] = total_complexes or complexes_count
                developer_dict['stats'] = {
                    'total_projects': total_complexes or complexes_count,
                    'total_apartments': total_props or properties_count,
                    'avg_price': int(avg_price) if avg_price else None,
                    'min_price': int(min_price) if min_price else None,
                    'max_price': int(max_price) if max_price else None
                }
            else:
                # Fallback to basic database stats
                developer_dict['stats'] = {
                    'total_projects': complexes_count,
                    'total_apartments': properties_count,
                    'avg_price': None
                }
            
            developers_data.append(developer_dict)
        
        print(f"Found {len(developers_data)} developers in database")
        
        # Получаем общую статистику для страницы (по городу если выбран)
        if current_city:
            # Статистика по текущему городу
            total_developers = len(developers_data)  # Количество застройщиков с объектами в городе
            total_complexes = db.session.query(ResidentialComplex).filter(
                ResidentialComplex.city_id == current_city.id
            ).count()
            # Берем количество довольных клиентов пропорционально
            satisfied_clients = max(50, total_developers * 10)
        else:
            # Статистика по всей базе
            total_developers = db.session.query(Developer).count()
            total_complexes = db.session.query(ResidentialComplex).count()
            satisfied_clients = 500  # Берем значение с about.html
        
        return render_template('developers.html', 
                             developers=developers_data,
                             current_city=current_city,
                             total_developers=total_developers,
                             total_complexes=total_complexes,
                             satisfied_clients=satisfied_clients)
        
    except Exception as e:
        print(f"Error loading developers: {e}")
        current_city = resolve_city_context()
        return render_template('developers.html', developers=[], current_city=current_city)

@app.route('/developer/<developer_slug>')  
def developer_page(developer_slug):
    """Individual developer page by slug"""
    try:
        # Transliteration mapping for finding Cyrillic slugs from Latin input
        translit_map = str.maketrans('abcdefghijklmnopqrstuvwxyz', 'абцдефгхийклмнопкрствухызгк-неометрия'[:26])
        
        # Create variations of the developer name to search for
        developer_name_from_slug = developer_slug.replace('-', ' ')
        
        # Try to find developer in database using multiple search strategies
        # First try exact match with original slug
        developer = db.session.execute(
            text("""
            SELECT * FROM developers WHERE 
            LOWER(slug) = LOWER(:slug)
            OR LOWER(name) LIKE LOWER(:name_pattern)
            OR LOWER(REPLACE(name, ' ', '-')) = LOWER(:slug)
            LIMIT 1
            """),
            {
                "slug": developer_slug, 
                "name_pattern": f"%{developer_name_from_slug}%"
            }
        ).fetchone()
        
        # If not found, try searching by name matching (case insensitive)
        if not developer:
            # Try all developers and match by similarity
            all_devs = db.session.execute(text("SELECT * FROM developers")).fetchall()
            for dev in all_devs:
                dev_slug = dev.slug.lower() if dev.slug else ''
                dev_name = dev.name.lower().replace(' ', '-').replace('гк', 'gk')
                dev_name = dev_name.replace('неометрия', 'neometriya')
                
                if developer_slug.lower() in [dev_slug, dev_name]:
                    developer = dev
                    break
        
        if not developer:
            print(f"Developer not found in database: {developer_slug}")
            return redirect(url_for('developers'))
        
        # Convert row to dict-like object for template
        developer_dict = dict(developer._mapping)
        
        # ✅ MIGRATED: Get developer's complexes from normalized tables
        from models import ResidentialComplex
        developer_complexes_orm = (
            db.session.query(ResidentialComplex)
            .filter(ResidentialComplex.developer_id == developer.id)
            .all()
        )
        
        # Get property statistics for each complex using PropertyRepository
        developer_complexes_query = []
        for complex_orm in developer_complexes_orm:
            # Get properties for this complex
            complex_properties = PropertyRepository.get_by_complex_id(complex_orm.id, limit=10000)
            
            # Calculate statistics
            if complex_properties:
                min_price = min(p.price for p in complex_properties if p.price)
                max_price = max(p.price for p in complex_properties if p.price)
                avg_price = sum(p.price for p in complex_properties if p.price) / len(complex_properties)
                
                # Get unique buildings count
                buildings = set(p.complex_building_name for p in complex_properties if p.complex_building_name)
                buildings_count = len(buildings)
                
                # Get photos from first property
                main_image = 'https://images.unsplash.com/photo-1545324418-cc1a3fa10c00?w=800'
                images = [main_image]
                if complex_properties[0].gallery_images:
                    try:
                        photos_list = json.loads(complex_properties[0].gallery_images)
                        if photos_list and isinstance(photos_list, list):
                            images = photos_list
                            main_image = photos_list[0]
                    except:
                        pass
                
                # Get address from properties (fallback to complex address)
                property_address = complex_properties[0].address if complex_properties and complex_properties[0].address else None
                
                # Create complex data structure
                complex_data = type('obj', (object,), {
                    'name': complex_orm.name,
                    'id': complex_orm.name,
                    'location': property_address or complex_orm.address or 'Адрес не указан',
                    'apartments_count': len(complex_properties),
                    'buildings_count': buildings_count or 1,
                    'min_price': int(min_price),
                    'max_price': int(max_price),
                    'avg_price': int(avg_price),
                    'lat': complex_properties[0].latitude if complex_properties[0].latitude else None,
                    'lng': complex_properties[0].longitude if complex_properties[0].longitude else None,
                    'sales_address': property_address or complex_orm.address,
                    'images': images,
                    'image': main_image,
                    'completion_date': f"{complex_orm.end_build_quarter} кв. {complex_orm.end_build_year}" if complex_orm.end_build_quarter and complex_orm.end_build_year else 'Сдан',
                    'real_price_from': int(min_price),
                    'room_types_count': len(set(p.rooms for p in complex_properties)),
                    '_mapping': {
                        'name': complex_orm.name,
                        'id': complex_orm.name,
                        'location': property_address or complex_orm.address or 'Адрес не указан',
                        'apartments_count': len(complex_properties),
                        'buildings_count': buildings_count or 1,
                        'min_price': int(min_price),
                        'max_price': int(max_price),
                        'avg_price': int(avg_price),
                        'lat': complex_properties[0].latitude if complex_properties[0].latitude else None,
                        'lng': complex_properties[0].longitude if complex_properties[0].longitude else None,
                        'sales_address': property_address or complex_orm.address,
                        'images': images,
                        'image': main_image,
                        'completion_date': f"{complex_orm.end_build_quarter} кв. {complex_orm.end_build_year}" if complex_orm.end_build_quarter and complex_orm.end_build_year else 'Сдан',
                        'real_price_from': int(min_price),
                        'room_types_count': len(set(p.rooms for p in complex_properties))
                    }
                })()
                developer_complexes_query.append(complex_data)
        
        # Sort by apartments_count descending
        developer_complexes_query = sorted(developer_complexes_query, key=lambda x: x.apartments_count, reverse=True)
        
        developer_complexes = []
        for complex_row in developer_complexes_query:
            complex_dict = dict(complex_row._mapping)
            
            # ✅ MIGRATED: Get room distribution from PropertyRepository
            # Get all properties for this complex from the developer_complexes_query data
            complex_name = complex_dict['name']
            matching_complex = next((c for c in developer_complexes_orm if c.name == complex_name), None)
            
            room_distribution_query = []
            if matching_complex:
                complex_props = PropertyRepository.get_by_complex_id(matching_complex.id, limit=10000)
                
                # Group by rooms
                from collections import defaultdict
                room_groups = defaultdict(list)
                for p in complex_props:
                    room_groups[p.rooms].append(p)
                
                # Create room distribution data
                for rooms, props in sorted(room_groups.items()):
                    room_type = 'Студия' if rooms == 0 else f'{rooms}-комн.'
                    room_data = type('obj', (object,), {
                        'room_type': room_type,
                        'count': len(props),
                        'price_from': min(p.price for p in props if p.price),
                        'price_to': max(p.price for p in props if p.price),
                        'area_from': min(p.area for p in props if p.area),
                        'area_to': max(p.area for p in props if p.area),
                        '_mapping': {
                            'room_type': room_type,
                            'count': len(props),
                            'price_from': min(p.price for p in props if p.price),
                            'price_to': max(p.price for p in props if p.price),
                            'area_from': min(p.area for p in props if p.area),
                            'area_to': max(p.area for p in props if p.area)
                        }
                    })()
                    room_distribution_query.append(room_data)
            
            # Формируем данные о комнатности
            real_room_distribution = {}
            room_details = {}
            
            for room_row in room_distribution_query:
                room_data = dict(room_row._mapping)
                room_type = room_data['room_type']
                real_room_distribution[room_type] = room_data['count']
                room_details[room_type] = {
                    'price_from': room_data['price_from'],
                    'price_to': room_data['price_to'],
                    'area_from': room_data['area_from'],
                    'area_to': room_data['area_to']
                }
            
            complex_dict['real_room_distribution'] = real_room_distribution
            complex_dict['room_details'] = room_details
            developer_complexes.append(complex_dict)
        
        # ✅ MIGRATED: Get developer's properties from normalized tables
        developer_properties_orm = PropertyRepository.get_all_active(
            limit=10000,
            filters={'developer_id': developer.id},
            sort_by='price',
            sort_order='asc'
        )
        
        # Convert to old format for backward compatibility
        developer_properties = []
        for prop in developer_properties_orm:
            complex_obj = prop.residential_complex
            district_obj = prop.district
            
            # Format floor display properly: "X этаж из Y" or "Этаж не указан"
            if prop.floor and prop.total_floors:
                floor_display = f"{prop.floor} этаж из {prop.total_floors}"
            elif prop.total_floors:
                floor_display = f"Этаж не указан из {prop.total_floors}"
            else:
                floor_display = "Этаж не указан"
            
            prop_dict = {
                'inner_id': prop.inner_id,
                'price': prop.price,
                'object_area': prop.area,
                'object_rooms': prop.rooms,
                'object_min_floor': prop.floor,
                'object_max_floor': prop.total_floors,
                'floor_display': floor_display,  # New formatted field
                'complex_name': complex_obj.name if complex_obj else '',
                'developer_name': developer.name,
                'address_display_name': prop.address,
                'parsed_district': district_obj.name if district_obj else '',
                'photos': prop.gallery_images or '[]'
            }
            developer_properties.append(prop_dict)
        
        properties_count = len(developer_properties)
        min_price = min([p['price'] for p in developer_properties]) if developer_properties else 0
        
        # Parse features, infrastructure, and advantages if they exist
        import json as json_lib
        features = []
        infrastructure = []
        advantages = []
        
        if developer_dict.get('features'):
            try:
                features = json_lib.loads(developer_dict['features'])
            except:
                features = []
        
        if developer_dict.get('infrastructure'):
            try:
                infrastructure = json_lib.loads(developer_dict['infrastructure'])
            except:
                infrastructure = []
        
        if developer_dict.get('advantages'):
            try:
                advantages = json_lib.loads(developer_dict['advantages'])
            except:
                advantages = []
        
        # ✅ MIGRATED: Get statistics from normalized tables (properties + residential_complexes)
        from models import Property
        from sqlalchemy import func
        
        developer_stats = db.session.query(
            func.count(Property.id).label('total_properties'),
            func.avg(Property.price).label('avg_price'),
            func.min(Property.price).label('min_price'),
            func.max(Property.price).label('max_price'),
            func.count(func.distinct(Property.complex_id)).label('total_complexes')
        ).filter(
            Property.developer_id == developer.id,
            Property.is_active == True
        ).first()
        
        # Update statistics with real data from properties table
        if developer_stats and developer_stats.total_properties:
            developer_dict['properties_count'] = developer_stats.total_properties
            developer_dict['complexes_count'] = developer_stats.total_complexes
            developer_dict['min_price'] = int(developer_stats.min_price) if developer_stats.min_price else 12000000
            developer_dict['max_price'] = int(developer_stats.max_price) if developer_stats.max_price else 0
            developer_dict['avg_price'] = int(developer_stats.avg_price) if developer_stats.avg_price else 0
            print(f"DEBUG: Normalized stats for {developer.name}: min_price={developer_stats.min_price}, total_props={developer_stats.total_properties}")
        else:
            print(f"DEBUG: No properties found for {developer.name}")
        
        # Добавляем дефолтные значения для полей, которые могут отсутствовать
        developer_dict['total_projects'] = developer_dict.get('completed_projects', 0) or developer_dict.get('complexes_count', 0)
        developer_dict['rating'] = developer_dict.get('rating') or 4.2
        developer_dict['founded_year'] = developer_dict.get('founded_year') or developer_dict.get('established_year') or 2015
        developer_dict['detailed_description'] = developer_dict.get('description') or 'Надёжный застройщик с многолетним опытом строительства качественного жилья в регионе.'
        developer_dict['description'] = developer_dict.get('description') or developer_dict['detailed_description']
        developer_dict['logo'] = developer_dict.get('logo_url')  # Add logo field
        developer_dict['short_name'] = developer_dict.get('name', '')[:2].upper()  # First 2 letters for fallback logo
        
        # Use advantages from DB if exists, otherwise use defaults
        if not advantages:
            advantages = [
                'Собственное строительство без субподряда',
                'Сдача объектов точно в срок', 
                'Качественные материалы и технологии',
                'Полный пакет документов и сервисов'
            ]
        developer_dict['advantages'] = advantages
        
        return render_template('developer_detail.html', 
                             developer=developer_dict,
                             developer_name=developer_dict['name'],
                             complexes=developer_complexes,
                             apartments=developer_properties,
                             total_properties=properties_count,
                             min_price=min_price,
                             features=features,
                             infrastructure=infrastructure)
        
    except Exception as e:
        print(f"Error loading developer page for {developer_slug}: {e}")
        import traceback
        traceback.print_exc()
        return redirect(url_for('developers'))

# Districts routes
@app.route('/districts')
def districts():
    """Districts listing page"""
    # Импорт модели
    from models import District
    import json
    
    # Получаем все районы из базы данных
    districts_query = District.query.order_by(District.name).all()
    
    # Подготавливаем данные с парсингом JSON
    districts_list = []
    for district in districts_query:
        district_data = {
            'id': district.id,
            'name': district.name,
            'slug': district.slug,
            'description': district.description,
            'latitude': district.latitude,
            'longitude': district.longitude,
            'distance_to_center': district.distance_to_center,
            'infrastructure_data': {}
        }
        
        # Парсим JSON данные инфраструктуры
        if district.infrastructure_data:
            try:
                district_data['infrastructure_data'] = json.loads(district.infrastructure_data)
            except:
                district_data['infrastructure_data'] = {}
        
        districts_list.append(district_data)
    
    return render_template('districts.html', 
                         districts=districts_list,
                         yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY'))

# ========================================
# АДМИНИСТРАТИВНАЯ ПАНЕЛЬ ДЛЯ КООРДИНАТ
# ========================================

@app.route('/admin/coordinates')
def admin_coordinates():
    """Административная панель для редактирования координат районов"""
    from models import District
    
    # Получаем все районы
    districts = District.query.order_by(District.name).all()
    
    return render_template('admin/coordinates.html', 
                         districts=districts,
                         yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY'))

@app.route('/admin/update-coordinates', methods=['POST'])
def admin_update_coordinates():
    """API для обновления координат района"""
    from models import District
    import math
    
    try:
        district_id = request.form.get('district_id')
        latitude = float(request.form.get('latitude'))
        longitude = float(request.form.get('longitude'))
        
        # Вычисляем расстояние до центра
        theater_lat, theater_lon = 45.035180, 38.977414
        
        def haversine_distance(lat1, lon1, lat2, lon2):
            R = 6371
            dlat = math.radians(lat2 - lat1)
            dlon = math.radians(lon2 - lon1)
            a = math.sin(dlat/2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon/2)**2
            c = 2 * math.asin(math.sqrt(a))
            return R * c
        
        distance = haversine_distance(latitude, longitude, theater_lat, theater_lon)
        
        # Обновляем координаты
        district = District.query.get(district_id)
        if district:
            district.latitude = latitude
            district.longitude = longitude
            district.distance_to_center = distance
            db.session.commit()
            
            return jsonify({
                'success': True,
                'message': f'Координаты района {district.name} обновлены',
                'distance': round(distance, 1)
            })
        else:
            return jsonify({'success': False, 'message': 'Район не найден'})
            
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)})

# ========================================
# АЛИАСЫ ДЛЯ СТАРЫХ URL РАЙОНОВ
# ========================================

@app.route('/district/tec')
def district_tec_redirect():
    """Редирект со старого URL ТЭЦ на новый"""
    from flask import redirect, url_for
    return redirect(url_for('district_detail', district='tets'), code=301)

@app.route('/district/mkg')
def district_mkg_redirect():
    """Редирект со старого URL МКГ (МХГ) на новый"""
    from flask import redirect, url_for
    return redirect(url_for('district_detail', district='mhg'), code=301)

@app.route('/district/skhi')
def district_skhi_redirect():
    """Редирект для СХИ (Сельскохозяйственный институт)"""
    from flask import redirect, url_for
    return redirect(url_for('district_detail', district='shi'), code=301)

@app.route('/district/<district>')
def district_detail(district):
    """Individual district page - только для Краснодара (SEO)"""
    try:
        # Resolve city context
        current_city = resolve_city_context(
            city_id=request.args.get('city_id'),
            city_slug=request.args.get('city')
        )
        
        # Эта страница только для Краснодара (создана для SEO)
        # Данные пока только для Краснодара
        if not current_city or current_city.slug != 'krasnodar':
            # Для других городов показываем пустую заглушку
            return render_template('district_detail.html', 
                                 current_city=current_city,
                                 district='',
                                 district_name='',
                                 properties=[],
                                 complexes=[],
                                 empty_state=True)
        
        # Import District model
        from models import District
        
        # Get properties and complexes in this district
        properties = load_properties()
        complexes = load_residential_complexes()
        
        # Filter by district (simplified district matching)
        district_properties = [p for p in properties if district.replace('-', ' ').lower() in (p.get('address') or '').lower()]
        district_complexes = [c for c in complexes if district.replace('-', ' ').lower() in c.get('district', '').lower()]
        
        # Add cashback calculations
        for prop in district_properties:
            prop['cashback'] = calculate_cashback(
                prop['price'],
                complex_id=prop.get('complex_id'),
                complex_name=prop.get('residential_complex')
            )
        
        # District info mapping - all 54 districts
        district_names = {
            '40-let-pobedy': '40 лет Победы',
            '9i-kilometr': '9-й километр', 
            'aviagorodok': 'Авиагородок',
            'avrora': 'Аврора',
            'basket-hall': 'Баскет-холл',
            'berezovy': 'Березовый',
            'cheremushki': 'Черемушки',
            'dubinka': 'Дубинка',
            'enka': 'Энка',
            'festivalny': 'Фестивальный',
            'gidrostroitelei': 'Гидростроителей',
            'gorkhutor': 'Горхутор',
            'hbk': 'ХБК',
            'kalinino': 'Калинино',
            'karasunsky': 'Карасунский',
            'kolosisty': 'Колосистый',
            'komsomolsky': 'Комсомольский',
            'kozhzavod': 'Кожзавод',
            'krasnaya-ploshchad': 'Красная площадь',
            'krasnodarskiy': 'Краснодарский',
            'kubansky': 'Кубанский',
            'mkg': 'МКГ',
            'molodezhny': 'Молодежный',
            'muzykalny-mkr': 'Музыкальный микрорайон',
            'nemetskaya-derevnya': 'Немецкая деревня',
            'novoznamenskiy': 'Новознаменский',
            'panorama': 'Панорама',
            'pashkovskiy': 'Пашковский',
            'pashkovsky': 'Пашковский-2',
            'pokrovka': 'Покровка',
            'prikubansky': 'Прикубанский',
            'rayon-aeroporta': 'Район аэропорта',
            'repino': 'Репино',
            'rip': 'РИП',
            'severny': 'Северный',
            'shkolny': 'Школьный',
            'slavyansky': 'Славянский',
            'slavyansky2': 'Славянский-2',
            'solnechny': 'Солнечный',
            'tabachnaya-fabrika': 'Табачная фабрика',
            'tec': 'ТЭЦ',
            'tsentralnyy': 'Центральный',
            'uchhoz-kuban': 'Учхоз Кубань',
            'vavilova': 'Вавилова',
            'votochno-kruglikovskii': 'Восточно-Кругликовский',
            'yablonovskiy': 'Яблоновский',
            'zapadny': 'Западный',
            'zapadny-obhod': 'Западный обход',
            'zapadny-okrug': 'Западный округ',
            'zip-zhukova': 'ЗИП Жукова'
        }
        
        # Get district data from database with coordinates
        district_db = District.query.filter_by(slug=district).first()
        
        # Use district name from database if available, otherwise fallback to mapping
        if district_db and district_db.name:
            district_name = district_db.name
        else:
            district_name = district_names.get(district, district.replace('-', ' ').title())
        
        # Prepare district data for template
        infrastructure_data = None
        if district_db and district_db.infrastructure_data:
            try:
                import json
                if isinstance(district_db.infrastructure_data, str):
                    infrastructure_data = json.loads(district_db.infrastructure_data)
                else:
                    infrastructure_data = district_db.infrastructure_data
            except Exception as e:
                print(f"Infrastructure parsing error: {e}")
                infrastructure_data = None
        
        district_data = {
            'name': district_name,
            'slug': district,
            'latitude': district_db.latitude if district_db and district_db.latitude else None,
            'longitude': district_db.longitude if district_db and district_db.longitude else None,
            'zoom_level': district_db.zoom_level if district_db and district_db.zoom_level else 13,
            'description': district_db.description if district_db else None,
            'distance_to_center': getattr(district_db, 'distance_to_center', None) if district_db else None,
            'infrastructure_data': infrastructure_data,
            'geometry': getattr(district_db, 'geometry', None) if district_db else None,
            'geometry_source': getattr(district_db, 'geometry_source', None) if district_db else None
        }
        
        return render_template('district_detail.html', 
                             district=district,
                             district_name=district_name,
                             district_data=district_data,
                             properties=district_properties,
                             complexes=district_complexes,
                             yandex_api_key=os.environ.get('YANDEX_MAPS_API_KEY', ''))
    except Exception as e:
        # Log detailed error for debugging
        import traceback
        print(f"ERROR in district_detail route: {e}")
        print("Full traceback:")
        traceback.print_exc()
        
        # Return error page
        from flask import render_template_string
        error_template = """
        <html>
        <head><title>Ошибка - InBack.ru</title></head>
        <body>
            <h1>Произошла ошибка</h1>
            <p>К сожалению, не удалось загрузить страницу района {{ district }}.</p>
            <p>Ошибка: {{ error }}</p>
            <a href="/">Вернуться на главную</a>
        </body>
        </html>
        """
        return render_template_string(error_template, district=district, error=str(e)), 500


# Content pages routes are already defined above

# API endpoint for infrastructure data
@app.route('/api/infrastructure')
def get_infrastructure():
    """API endpoint to get infrastructure data for coordinates"""
    try:
        lat = request.args.get('lat', type=float)
        lng = request.args.get('lng', type=float)
        radius = request.args.get('radius', 2000, type=int)
        
        if not lat or not lng:
            return jsonify({'error': 'Coordinates required'}), 400
        
        # Import infrastructure functions
        from infrastructure_api import get_poi_around_coordinates
        
        # Get POI data
        poi_data = get_poi_around_coordinates(lat, lng, radius)
        
        return jsonify(poi_data)
        
    except Exception as e:
        print(f"Error getting infrastructure data: {e}")
        return jsonify({'error': 'Failed to get infrastructure data'}), 500

# API endpoint for district streets
@app.route('/api/streets/district/<district_slug>')
def get_district_streets(district_slug):
    """API endpoint to get streets for a specific district"""
    try:
        from models import Street, District
        
        # Получаем район по slug
        district = District.query.filter_by(slug=district_slug).first()
        if not district:
            return jsonify({'error': 'District not found'}), 404
        
        # Получаем улицы района с координатами
        streets = Street.query.filter_by(district_id=district.id).filter(
            Street.latitude.isnot(None),
            Street.longitude.isnot(None)
        ).all()
        
        streets_data = []
        for street in streets:
            streets_data.append({
                'id': street.id,
                'name': street.name,
                'slug': street.slug,
                'latitude': float(street.latitude) if street.latitude else None,
                'longitude': float(street.longitude) if street.longitude else None,
                'description': street.description
            })
        
        return jsonify(streets_data)
        
    except Exception as e:
        print(f"Error getting district streets: {e}")
        return jsonify({'error': 'Failed to get district streets'}), 500

# Privacy and legal pages
@app.route('/privacy-policy')
def privacy_policy():
    """Privacy policy page"""
    return render_template('privacy_policy.html')

def parse_user_agent(user_agent):
    """Простой парсинг User-Agent строки"""
    info = {
        'raw': user_agent,
        'browser': 'Неизвестно',
        'version': 'Неизвестно',
        'os': 'Неизвестно',
        'device': 'Неизвестно'
    }
    
    # Определяем браузер
    if 'Chrome' in user_agent and 'Edg' not in user_agent:
        info['browser'] = 'Chrome'
        if 'Chrome/' in user_agent:
            version = user_agent.split('Chrome/')[1].split()[0]
            info['version'] = version
    elif 'Firefox' in user_agent:
        info['browser'] = 'Firefox'
        if 'Firefox/' in user_agent:
            version = user_agent.split('Firefox/')[1].split()[0]
            info['version'] = version
    elif 'Edg' in user_agent:
        info['browser'] = 'Microsoft Edge'
        if 'Edg/' in user_agent:
            version = user_agent.split('Edg/')[1].split()[0]
            info['version'] = version
    elif 'Safari' in user_agent and 'Chrome' not in user_agent:
        info['browser'] = 'Safari'
        if 'Version/' in user_agent:
            version = user_agent.split('Version/')[1].split()[0]
            info['version'] = version
    
    # Определяем ОС
    if 'Windows NT' in user_agent:
        info['os'] = 'Windows'
        if 'Windows NT 10.0' in user_agent:
            info['os'] = 'Windows 10/11'
    elif 'Mac OS X' in user_agent:
        info['os'] = 'macOS'
    elif 'Linux' in user_agent:
        info['os'] = 'Linux'
    elif 'Android' in user_agent:
        info['os'] = 'Android'
    elif 'iPhone' in user_agent:
        info['os'] = 'iOS'
    
    # Определяем тип устройства
    if 'Mobile' in user_agent or 'Android' in user_agent or 'iPhone' in user_agent:
        info['device'] = 'Мобильное устройство'
    elif 'Tablet' in user_agent or 'iPad' in user_agent:
        info['device'] = 'Планшет'
    else:
        info['device'] = 'Десктоп'
    
    return info

@app.route('/technical-info')
def technical_info():
    """Страница технической информации с данными о сессии и устройстве"""
    import platform
    import socket
    import uuid
    import secrets
    from datetime import datetime
    from flask_login import current_user
    
    # Генерируем session_id если его нет
    if 'session_id' not in session:
        session['session_id'] = secrets.token_hex(16)
    
    # Парсим User-Agent для более детальной информации
    user_agent = request.headers.get('User-Agent', '')
    browser_info = parse_user_agent(user_agent)
    
    # Собираем техническую информацию
    tech_info = {
        'server_info': {
            'server_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'platform': platform.platform(),
            'python_version': platform.python_version(),
            'hostname': socket.gethostname(),
            'flask_version': '2.3.3',  # или получить динамически
            'environment': 'development'
        },
        'session_info': {
            'session_id': session.get('session_id'),
            'user_id': current_user.id if current_user.is_authenticated else 'Не авторизован',
            'username': current_user.full_name if current_user.is_authenticated and hasattr(current_user, 'full_name') else 'Гость',
            'is_authenticated': current_user.is_authenticated,
            'session_permanent': session.permanent
        },
        'request_info': {
            'user_agent': user_agent,
            'ip_address': request.environ.get('HTTP_X_FORWARDED_FOR', request.remote_addr),
            'method': request.method,
            'url': request.url,
            'referrer': request.headers.get('Referer', 'Прямой переход'),
            'accept_language': request.headers.get('Accept-Language', 'Неизвестно'),
            'accept_encoding': request.headers.get('Accept-Encoding', 'Неизвестно'),
            'content_type': request.headers.get('Content-Type', 'Неизвестно'),
            'host': request.headers.get('Host', 'Неизвестно')
        },
        'browser_info': browser_info
    }
    
    return render_template('technical_info.html', tech_info=tech_info)

@app.route('/data-processing-consent')
def data_processing_consent():
    """Data processing consent page"""
    return render_template('data_processing_consent.html')

# Override Flask-Login unauthorized handler for API routes
@login_manager.unauthorized_handler  
def handle_unauthorized():
    # Check if this is an API route
    if request.path.startswith('/api/'):
        return jsonify({'success': False, 'error': 'Не авторизован'}), 401
    # Regular redirect for web routes
    return redirect(url_for('login', next=request.url))

# User loader for Flask-Login
@login_manager.user_loader
def load_user(user_id):
    """ИСПРАВЛЕНО: Унифицированная загрузка пользователей через префиксы"""
    from models import User, Manager, Admin
    
    print(f"🔍 DEBUG load_user called with user_id: {user_id}")
    
    # Check prefix to determine user type
    if user_id.startswith('m_'):
        # Manager (prefix 'm_')
        manager_id = int(user_id[2:])
        print(f"🔍 DEBUG: Loading manager with ID {manager_id}")
        manager = Manager.query.get(manager_id)
        if manager:
            print(f"✅ DEBUG: Manager loaded successfully: {manager.email}")
            return manager
        else:
            print(f"❌ DEBUG: Manager with ID {manager_id} NOT FOUND in database")
    elif user_id.startswith('a_'):
        # Admin (prefix 'a_')
        admin_id = int(user_id[2:])
        print(f"🔍 DEBUG: Loading admin with ID {admin_id}")
        admin = Admin.query.get(admin_id)
        if admin:
            print(f"✅ DEBUG: Admin loaded successfully: {admin.email}")
            return admin
        else:
            print(f"❌ DEBUG: Admin with ID {admin_id} NOT FOUND in database")
    else:
        # Regular user (no prefix)
        print(f"🔍 DEBUG: Loading regular user with ID {user_id}")
        try:
            user = User.query.get(int(user_id))
            if user:
                print(f"✅ DEBUG: User loaded successfully: {user.email}")
                return user
            else:
                print(f"❌ DEBUG: User with ID {user_id} NOT FOUND in database")
        except ValueError:
            print(f"❌ DEBUG: ValueError parsing user_id: {user_id}")
            pass
    
    print(f"❌ DEBUG: load_user returning None for user_id: {user_id}")
    return None

@app.context_processor
def inject_user_role():
    """Inject user role information into all templates"""
    from models import Manager, Admin
    # Safe check: current_user might be None in background threads
    is_manager = isinstance(current_user._get_current_object(), Manager) if current_user and current_user.is_authenticated else False
    is_admin = isinstance(current_user._get_current_object(), Admin) if current_user and current_user.is_authenticated else False
    return dict(
        is_manager=is_manager,
        is_admin=is_admin,
        manager_authenticated=is_manager,
        admin_authenticated=is_admin
    )


def manager_required(f):
    """Decorator to require manager authentication - ИСПРАВЛЕНО: использует Flask-Login"""
    from functools import wraps
    from models import Manager
    
    @wraps(f)
    def decorated_function(*args, **kwargs):
        print(f"DEBUG: manager_required - checking Flask-Login authentication")
        print(f"DEBUG: manager_required - request.path: {request.path}")
        print(f"DEBUG: manager_required - request.method: {request.method}")
        print(f"DEBUG: manager_required - current_user.is_authenticated: {current_user.is_authenticated}")
        
        # Check if this is an AJAX or JSON request
        is_ajax = (request.headers.get('X-Requested-With') == 'XMLHttpRequest' or 
                   request.content_type == 'application/json' or
                   request.path.startswith('/api/'))
        
        # Check if manager is authenticated via Flask-Login
        if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
            print(f"DEBUG: manager_required - Manager not authenticated via Flask-Login")
            if is_ajax:
                return jsonify({'success': False, 'error': 'Authentication required'}), 401
            return redirect(url_for('manager_login'))
        
        print(f"DEBUG: manager_required - Success! Manager {current_user.email} authenticated via Flask-Login")
        return f(*args, **kwargs)
    return decorated_function

# Authentication routes
@app.route('/set-demo-password')
def set_demo_password():
    """Временный роут для установки правильного пароля демо пользователю"""
    from models import User
    from werkzeug.security import generate_password_hash
    
    # Найти демо пользователя
    demo_user = User.query.filter_by(email='demo@inback.ru').first()
    if demo_user:
        # Установить простой пароль "demo123"
        demo_user.password_hash = generate_password_hash('demo123')
        db.session.commit()
        return f"Пароль установлен для пользователя {demo_user.email}. Хэш: {demo_user.password_hash[:50]}..."
    else:
        return "Демо пользователь не найден"

@app.route('/set-managers-passwords')
def set_managers_passwords():
    """Временный роут для установки паролей всем менеджерам"""
    from models import Manager
    from werkzeug.security import generate_password_hash
    
    results = []
    
    # Найти всех менеджеров и установить простые пароли
    managers = Manager.query.all()
    for manager in managers:
        if 'anna' in manager.email.lower():
            password = 'anna123'
        elif 'sergey' in manager.email.lower():
            password = 'sergey123'  
        elif 'maria' in manager.email.lower():
            password = 'maria123'
        else:
            password = 'manager123'  # Для остальных менеджеров
            
        manager.password_hash = generate_password_hash(password)
        results.append(f"{manager.email} -> {password}")
    
    db.session.commit()
    return f"Пароли установлены для {len(managers)} менеджеров:<br>" + "<br>".join(results)

@app.route('/login', methods=['GET', 'POST'])
@csrf.exempt
def login():
    """Login page"""
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        from models import User
        email = request.form.get('email')
        password = request.form.get('password')
        remember = request.form.get('remember') == 'on'
        
        if not email or not password:
            flash('Заполните все поля', 'error')
            return render_template('auth/login.html')
        
        # Check if email or phone
        user = User.query.filter(
            (User.email == email) | (User.phone == email)
        ).first()
        
        if user:
            # Check if user needs to set password
            if user.needs_password_setup():
                session['temp_user_id'] = user.id
                flash('Необходимо установить пароль для входа', 'info')
                return redirect(url_for('setup_password'))
            
            # Check if email is verified
            if not user.is_verified:
                flash('Ваш аккаунт не подтвержден. Проверьте email или запросите новое письмо.', 'warning')
                # Pass user email to template for resend functionality
                return render_template('auth/login.html', unverified_email=user.email)
            
            # Normal password check
            password_valid = user.check_password(password)
            if password_valid:
                # Clear manager session data if exists
                session.pop('manager_id', None)
                session.pop('is_manager', None)
                
                login_user(user, remember=remember)
                session.permanent = True  # Ensure 30-day session lifetime
                user.last_login = datetime.utcnow()
                db.session.commit()
                
                # Redirect to next page or dashboard
                next_page = request.args.get('next')
                return redirect(next_page) if next_page else redirect(url_for('dashboard'))
            else:
                flash('Неверный email или пароль', 'error')
        else:
            flash('Пользователь не найден', 'error')
    
    return render_template('auth/login.html')

@app.route('/setup-password', methods=['GET', 'POST'])
def setup_password():
    """Setup password for users created by managers"""
    temp_user_id = session.get('temp_user_id')
    if not temp_user_id:
        flash('Сессия истекла', 'error')
        return redirect(url_for('login'))
    
    from models import User
    user = User.query.get(temp_user_id)
    if not user or not user.needs_password_setup():
        flash('Пользователь не найден или пароль уже установлен', 'error')
        return redirect(url_for('login'))
    
    if request.method == 'POST':
        password = request.form.get('password')
        confirm_password = request.form.get('confirm_password')
        
        if not password or not confirm_password:
            flash('Заполните все поля', 'error')
            return render_template('auth/setup_password.html', user=user)
        
        if len(password) < 8:
            flash('Пароль должен содержать минимум 8 символов', 'error')
            return render_template('auth/setup_password.html', user=user)
        
        if password != confirm_password:
            flash('Пароли не совпадают', 'error')
            return render_template('auth/setup_password.html', user=user)
        
        # Set password
        user.set_password(password)
        user.is_verified = True
        db.session.commit()
        
        # Clear temp session and manager data
        session.pop('temp_user_id', None)
        session.pop('manager_id', None)
        session.pop('is_manager', None)
        
        # Login user
        login_user(user)
        session.permanent = True  # Ensure 30-day session lifetime
        user.last_login = datetime.utcnow()
        db.session.commit()
        
        flash('Пароль успешно установлен!', 'success')
        return redirect(url_for('dashboard'))
    
    return render_template('auth/setup_password.html', user=user)

@app.route('/register', methods=['GET'])
def register_page():
    """Registration page - shows login page with registration form active"""
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    return render_template('auth/login.html', show_register=True)

@app.route('/register', methods=['POST'])
def register():
    """User registration"""
    from models import User
    
    full_name = request.form.get('full_name')
    email = request.form.get('email')
    phone = request.form.get('phone')
    password = request.form.get('password')
    confirm_password = request.form.get('confirm_password')
    terms = request.form.get('terms')
    
    # Validation
    if not all([full_name, email, password, confirm_password, terms]):
        flash('Заполните все обязательные поля', 'error')
        return redirect(url_for('login'))
    
    if password != confirm_password:
        flash('Пароли не совпадают', 'error')
        return redirect(url_for('login'))
    
    if not password or len(password) < 8:
        flash('Пароль должен содержать минимум 8 символов', 'error')
        return redirect(url_for('login'))
    
    # Check if user exists
    if User.query.filter_by(email=email).first():
        flash('Пользователь с таким email уже существует', 'error')
        return redirect(url_for('login'))
    
    # Create new user
    user = User(
        full_name=full_name,
        email=email,
        phone=phone
    )
    user.set_password(password)
    
    try:
        # Начислить регистрационный бонус 10,000₽ с Decimal precision (idempotent)
        from decimal import Decimal
        from models import BalanceTransaction
        
        # Сначала добавить пользователя в сессию и получить ID
        db.session.add(user)
        db.session.flush()  # Получить user.id для проверки
        
        # Проверить идемпотентность - уже был начислен бонус?
        existing_bonus = BalanceTransaction.query.filter_by(
            user_id=user.id,
            transaction_type='registration_bonus'
        ).first()
        
        if not existing_bonus:
            # Захватить баланс ДО начисления бонуса (для audit trail)
            balance_before = user.balance or Decimal('0')
            bonus_amount = Decimal('10000.00')
            
            # Начислить бонус (INCREMENT, не overwrite)
            user.balance = balance_before + bonus_amount
            user.registration_bonus = (user.registration_bonus or Decimal('0')) + bonus_amount
            user.total_earned = (user.total_earned or Decimal('0')) + bonus_amount
            
            # Вычислить баланс ПОСЛЕ (для audit trail)
            balance_after = user.balance
            
            # Создать транзакцию с РЕАЛЬНЫМИ значениями баланса
            transaction = BalanceTransaction(
                user_id=user.id,
                amount=bonus_amount,
                transaction_type='registration_bonus',
                description='Приветственный бонус за регистрацию',
                balance_before=balance_before,  # ✅ Реальное значение ДО
                balance_after=balance_after,    # ✅ Реальное значение ПОСЛЕ
                status='completed',
                processed_at=datetime.utcnow()
            )
            db.session.add(transaction)
        db.session.commit()
        
        # Send welcome notification with verification link
        try:
            from email_service import send_verification_email
            send_verification_email(user, base_url=request.url_root.rstrip('/'))
        except Exception as e:
            print(f"Error sending verification email: {e}")
        
        # Clear manager session data if exists
        session.pop('manager_id', None)
        session.pop('is_manager', None)
        
        # DON'T login user immediately - require email verification first
        # login_user(user)  # REMOVED - user must verify email first
        
        flash('Регистрация успешна! Проверьте email и перейдите по ссылке для подтверждения аккаунта.', 'success')
        return redirect(url_for('login'))
        
    except Exception as e:
        db.session.rollback()
        print(f"Registration error: {e}")
        flash(f'Ошибка при регистрации: {str(e)}', 'error')
        return redirect(url_for('login'))

@app.route('/confirm/<token>')
def confirm_email(token):
    """Email confirmation endpoint"""
    from models import User
    
    try:
        # Find user by verification token
        user = User.query.filter_by(verification_token=token).first()
        
        if not user:
            flash('Неверная или просроченная ссылка подтверждения', 'error')
            return redirect(url_for('login'))
        
        if user.is_verified:
            flash('Ваш аккаунт уже подтвержден', 'info')
            return redirect(url_for('login'))
        
        # Confirm user
        user.is_verified = True
        user.verification_token = None  # Clear the token
        db.session.commit()
        
        # Send welcome email after verification
        try:
            from email_service import send_welcome_email
            send_welcome_email(user, base_url=request.url_root.rstrip('/'))
        except Exception as e:
            print(f"Error sending welcome email: {e}")
        
        flash('Email успешно подтвержден! Теперь вы можете войти в аккаунт.', 'success')
        return redirect(url_for('login'))
        
    except Exception as e:
        print(f"Email confirmation error: {e}")
        flash('Ошибка при подтверждении email', 'error')
        return redirect(url_for('login'))

@app.route('/resend-verification', methods=['POST'])
@require_json_csrf
def resend_verification():
    """Resend verification email with rate limiting and enhanced security"""
    import re
    from models import User, EmailVerificationAttempt
    
    # Get request data - support both form and JSON
    if request.content_type == 'application/json':
        data = request.get_json() or {}
        email = data.get('email', '').strip().lower()
    else:
        email = request.form.get('email', '').strip().lower()
    
    # Get client info for logging
    ip_address = request.environ.get('HTTP_X_FORWARDED_FOR', request.environ.get('REMOTE_ADDR'))
    user_agent = request.headers.get('User-Agent', '')[:500]
    
    # Validate email format
    if not email:
        error_msg = 'Введите email для повторной отправки'
        EmailVerificationAttempt.log_attempt(email or 'empty', ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 400
        flash(error_msg, 'error')
        return redirect(url_for('login'))
    
    # Basic email format validation
    email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(email_regex, email):
        error_msg = 'Введите корректный email адрес'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 400
        flash(error_msg, 'error')
        return redirect(url_for('login'))
    
    # Check rate limiting (5 minutes between successful attempts)
    if not EmailVerificationAttempt.can_resend_verification(email, rate_limit_minutes=5):
        error_msg = 'Слишком частые запросы. Подождите 5 минут перед повторной отправкой.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 429
        flash(error_msg, 'warning')
        return redirect(url_for('login'))
    
    # Check for suspicious activity (more than 10 attempts in 1 hour)
    recent_attempts = EmailVerificationAttempt.get_recent_attempts_count(email, hours=1)
    if recent_attempts >= 10:
        error_msg = 'Превышен лимит попыток. Попробуйте позже или обратитесь в поддержку.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 429
        flash(error_msg, 'error')
        return redirect(url_for('login'))
    
    # Find user
    user = User.query.filter_by(email=email).first()
    
    if not user:
        # Don't reveal whether user exists for security
        success_msg = 'Если аккаунт с таким email существует, письмо с подтверждением будет отправлено.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, 'User not found')
        if request.content_type == 'application/json':
            return jsonify({'success': True, 'message': success_msg})
        flash(success_msg, 'info')
        return redirect(url_for('login'))
    
    if user.is_verified:
        error_msg = 'Ваш аккаунт уже подтвержден'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, error_msg)
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 400
        flash(error_msg, 'info')
        return redirect(url_for('login'))
    
    # Generate new verification token
    user.verification_token = secrets.token_urlsafe(32)
    db.session.commit()
    
    # Send new verification email
    try:
        from email_service import send_verification_email
        send_verification_email(user, base_url=request.url_root.rstrip('/'))
        
        # Log successful attempt
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, True, None)
        
        success_msg = 'Письмо с подтверждением отправлено повторно. Проверьте ваш email.'
        print(f"✅ VERIFICATION RESEND SUCCESS: Email sent to {email} from IP {ip_address}")
        
        if request.content_type == 'application/json':
            return jsonify({'success': True, 'message': success_msg})
        flash(success_msg, 'success')
        
    except Exception as e:
        error_msg = 'Ошибка при отправке письма. Попробуйте позже.'
        EmailVerificationAttempt.log_attempt(email, ip_address, user_agent, False, str(e)[:200])
        print(f"❌ VERIFICATION RESEND ERROR: {e} for email {email}")
        
        if request.content_type == 'application/json':
            return jsonify({'success': False, 'error': error_msg}), 500
        flash(error_msg, 'error')
    
    return redirect(url_for('login'))

@app.route('/quiz-registration')
def quiz_registration():
    """Show quiz registration page"""
    return render_template('quiz_registration.html')

@app.route('/callback-request')
def callback_request_page():
    """Show callback request page"""
    return render_template('callback_request.html')

@app.route('/api/property-selection', methods=['POST'])
def property_selection():
    """Property selection application"""
    from models import Application, User
    data = request.get_json()
    
    try:
        # Extract data
        email = data.get('email', '').strip().lower()
        name = data.get('name', '').strip()
        phone = data.get('phone', '').strip()
        
        # Application preferences
        preferred_district = data.get('preferred_district', '')
        property_type = data.get('property_type', '')
        room_count = data.get('room_count', '')
        budget_range = data.get('budget_range', '')
        
        # Property context information
        property_id = data.get('property_id')
        property_title = data.get('property_title', '')
        property_complex = data.get('property_complex', '')
        property_price = data.get('property_price')
        property_area = data.get('property_area')
        property_rooms = data.get('property_rooms')
        property_floor = data.get('property_floor')
        property_total_floors = data.get('property_total_floors')
        property_district = data.get('property_district', '')
        property_url = data.get('property_url', '')
        property_type_context = data.get('property_type_context', '')
        
        # Validation
        if not email or not name or not phone:
            return jsonify({'success': False, 'error': 'Все обязательные поля должны быть заполнены'})
        
        # Determine application type and build message
        is_specific_property = property_id and property_type_context == 'property'
        is_specific_complex = property_id and property_type_context == 'complex'
        
        if is_specific_property:
            # Specific property interest
            application_title = f"Интерес к квартире: {property_title}"
            complex_name = property_complex or 'Не указан'
            message = f"Заявка по конкретной квартире:\n"
            message += f"Имя: {name}\n"
            message += f"Email: {email}\n"
            message += f"Телефон: {phone}\n\n"
            message += f"=== ОБЪЕКТ ИНТЕРЕСА ===\n"
            message += f"Квартира: {property_title}\n"
            message += f"ЖК: {property_complex}\n"
            if property_price:
                try:
                    formatted_price = f"{int(property_price):,}".replace(',', ' ')
                    message += f"Цена: {formatted_price} ₽\n"
                except (ValueError, TypeError):
                    message += f"Цена: {property_price} ₽\n"
            if property_area:
                message += f"Площадь: {property_area} м²\n"
            if property_floor and property_total_floors:
                message += f"Этаж: {property_floor}/{property_total_floors}\n"
            if property_district:
                message += f"Район: {property_district}\n"
            if property_url:
                message += f"Ссылка: {property_url}\n"
            message += f"\n=== ДОПОЛНИТЕЛЬНЫЕ ПРЕДПОЧТЕНИЯ ===\n"
            message += f"Предпочитаемый район: {preferred_district or 'Не указан'}\n"
            message += f"Тип недвижимости: {property_type or 'Не указан'}\n"
            message += f"Комнат: {room_count or 'Не указано'}\n"
            message += f"Бюджет: {budget_range or 'Не указан'}"
        elif is_specific_complex:
            # Specific complex interest
            application_title = f"Интерес к ЖК: {property_title}"
            complex_name = property_title
            message = f"Заявка по жилому комплексу:\n"
            message += f"Имя: {name}\n"
            message += f"Email: {email}\n"
            message += f"Телефон: {phone}\n\n"
            message += f"=== ОБЪЕКТ ИНТЕРЕСА ===\n"
            message += f"ЖК: {property_title}\n"
            if property_district:
                message += f"Район: {property_district}\n"
            if property_url:
                message += f"Ссылка: {property_url}\n"
            message += f"\n=== ДОПОЛНИТЕЛЬНЫЕ ПРЕДПОЧТЕНИЯ ===\n"
            message += f"Предпочитаемый район: {preferred_district or 'Не указан'}\n"
            message += f"Тип недвижимости: {property_type or 'Не указан'}\n"
            message += f"Комнат: {room_count or 'Не указано'}\n"
            message += f"Бюджет: {budget_range or 'Не указан'}"
        else:
            # General property selection
            application_title = "Подбор квартиры"
            complex_name = "По предпочтениям"
            message = f"Заявка на подбор квартиры:\n"
            message += f"Имя: {name}\n"
            message += f"Email: {email}\n"
            message += f"Телефон: {phone}\n"
            message += f"Район: {preferred_district or 'Любой'}\n"
            message += f"Тип: {property_type or 'Не указан'}\n"
            message += f"Комнат: {room_count or 'Не указано'}\n"
            message += f"Бюджет: {budget_range or 'Не указан'}"
        
        # Create application
        application = Application(
            user_id=None,  # No user account needed for applications
            property_id=property_id,  # Store specific property ID if available
            property_name=application_title,
            complex_name=complex_name,
            message=message,
            status='new',
            contact_name=name,
            contact_email=email,
            contact_phone=phone
        )
        
        db.session.add(application)
        
        # Application submitted successfully
        db.session.commit()
        
        # Send Telegram notification
        try:
            from telegram_bot import send_telegram_message
            from datetime import datetime
            
            # Calculate potential cashback (2% of average budget)
            potential_cashback = ""
            if budget_range:
                if "млн" in budget_range:
                    # Extract average from range like "3-5 млн"
                    numbers = [float(x) for x in budget_range.replace(" млн", "").split("-") if x.strip().replace(".", "").replace(",", "").isdigit()]
                    if numbers:
                        avg_price = sum(numbers) / len(numbers) * 1000000
                        cashback = int(avg_price * 0.02)
                        formatted_cashback = f"{cashback:,}".replace(',', ' ')
                        potential_cashback = f"💰 *Потенциальный кэшбек:* {formatted_cashback} руб. (2%)\n"
            
            # Build telegram message based on application type
            if is_specific_property:
                telegram_message = f"""🏠 *ЗАЯВКА ПО КОНКРЕТНОЙ КВАРТИРЕ*

👤 *КОНТАКТНАЯ ИНФОРМАЦИЯ:*
• Имя: {name}
• Телефон: {phone}
• Email: {email}

🏡 *ОБЪЕКТ ИНТЕРЕСА:*
• Квартира: {property_title}
• ЖК: {property_complex}
{f"• Цена: {int(property_price):,} ₽".replace(',', ' ') if property_price else ''}
{f"• Площадь: {property_area} м²" if property_area else ''}
{f"• Этаж: {property_floor}/{property_total_floors}" if property_floor and property_total_floors else ''}
{f"• Ссылка: {property_url}" if property_url else ''}

🔍 *ДОПОЛНИТЕЛЬНЫЕ ПРЕДПОЧТЕНИЯ:*
• Район: {preferred_district or 'Не указан'}
• Тип недвижимости: {property_type or 'Не указан'}
• Количество комнат: {room_count or 'Не указано'}
• Бюджет: {budget_range or 'Не указан'}

{potential_cashback}📅 *ВРЕМЯ ЗАЯВКИ:* {datetime.now().strftime('%d.%m.%Y в %H:%M')}
🌐 *ИСТОЧНИК:* Страница квартиры на InBack.ru

📋 *СЛЕДУЮЩИЕ ШАГИ:*
1️⃣ Связаться с клиентом в течение 15 минут
2️⃣ Обсудить интересующую квартиру
3️⃣ Рассчитать кэшбек и условия покупки
4️⃣ Назначить встречу для просмотра

⚡ *ВАЖНО:* Клиент уже выбрал конкретную квартиру!"""
            elif is_specific_complex:
                telegram_message = f"""🏢 *ЗАЯВКА ПО ЖИЛОМУ КОМПЛЕКСУ*

👤 *КОНТАКТНАЯ ИНФОРМАЦИЯ:*
• Имя: {name}
• Телефон: {phone}
• Email: {email}

🏗️ *ОБЪЕКТ ИНТЕРЕСА:*
• ЖК: {property_title}
{f"• Район: {property_district}" if property_district else ''}
{f"• Ссылка: {property_url}" if property_url else ''}

🔍 *ДОПОЛНИТЕЛЬНЫЕ ПРЕДПОЧТЕНИЯ:*
• Район: {preferred_district or 'Не указан'}
• Тип недвижимости: {property_type or 'Не указан'}
• Количество комнат: {room_count or 'Не указано'}
• Бюджет: {budget_range or 'Не указан'}

{potential_cashback}📅 *ВРЕМЯ ЗАЯВКИ:* {datetime.now().strftime('%d.%m.%Y в %H:%M')}
🌐 *ИСТОЧНИК:* Страница ЖК на InBack.ru

📋 *СЛЕДУЮЩИЕ ШАГИ:*
1️⃣ Связаться с клиентом в течение 15 минут
2️⃣ Показать доступные квартиры в ЖК
3️⃣ Рассчитать кэшбек и условия покупки
4️⃣ Назначить встречу для просмотра

⚡ *ВАЖНО:* Клиент интересуется конкретным ЖК!"""
            else:
                telegram_message = f"""🏠 *НОВАЯ ЗАЯВКА НА ПОДБОР КВАРТИРЫ*

👤 *КОНТАКТНАЯ ИНФОРМАЦИЯ:*
• Имя: {name}
• Телефон: {phone}
• Email: {email}

🔍 *КРИТЕРИИ ПОИСКА:*
• Район: {preferred_district or 'Любой'}
• Тип недвижимости: {property_type or 'Не указан'}
• Количество комнат: {room_count or 'Не указано'}
• Бюджет: {budget_range or 'Не указан'}

{potential_cashback}📅 *ВРЕМЯ ЗАЯВКИ:* {datetime.now().strftime('%d.%m.%Y в %H:%M')}
🌐 *ИСТОЧНИК:* Форма на сайте InBack.ru

📋 *СЛЕДУЮЩИЕ ШАГИ:*
1️⃣ Связаться с клиентом в течение 15 минут
2️⃣ Уточнить дополнительные предпочтения
3️⃣ Подготовить подборку объектов
4️⃣ Назначить встречу для просмотра

⚡ *ВАЖНО:* Быстрая реакция повышает конверсию!"""
            
            send_telegram_message('730764738', telegram_message)
            
        except Exception as notify_error:
            print(f"Notification error: {notify_error}")
        
        return jsonify({
            'success': True,
            'message': 'Заявка отправлена! Менеджер свяжется с вами.'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Application error: {e}")
        return jsonify({'success': False, 'error': 'Ошибка при отправке заявки'})

@app.route('/api/callback-request', methods=['POST'])
def api_callback_request():
    """Submit callback request"""
    from models import CallbackRequest, Manager
    data = request.get_json()
    
    try:
        # Extract data
        name = data.get('name', '').strip()
        phone = data.get('phone', '').strip()
        email = data.get('email', '').strip()
        preferred_time = data.get('preferred_time', '')
        notes = data.get('notes', '').strip()
        
        # Quiz responses
        district = data.get('district', '').strip()
        interest = data.get('interest', '')
        budget = data.get('budget', '')
        timing = data.get('timing', '')
        
        # Validation
        if not name or not phone:
            return jsonify({'success': False, 'error': 'Имя и телефон обязательны для заполнения'})
        
        # ИСПРАВЛЕНО: Убираем строгую проверку района, делаем optional
        if not district:
            district = 'Не указан'
        
        # Create callback request
        callback_req = CallbackRequest(
            name=name,
            phone=phone,
            email=email or None,
            preferred_time=preferred_time,
            notes=notes,
            interest=interest,
            budget=budget,
            timing=timing
        )
        
        # Auto-assign to first available manager
        available_manager = Manager.query.filter_by(is_active=True).first()
        if available_manager:
            callback_req.assigned_manager_id = available_manager.id
        
        db.session.add(callback_req)
        db.session.commit()
        
        # Send notifications
        try:
            send_callback_notification_email(callback_req, available_manager)
            send_callback_notification_telegram(callback_req, available_manager)
        except Exception as e:
            print(f"Failed to send callback notifications: {e}")
        
        return jsonify({
            'success': True,
            'message': 'Заявка отправлена! Наш менеджер свяжется с вами в ближайшее время.'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Callback request error: {e}")
        return jsonify({'success': False, 'error': 'Ошибка при отправке заявки. Попробуйте еще раз.'})

@app.route('/api/booking', methods=['POST'])
def api_booking_request():
    """✅ MIGRATED TO NORMALIZED TABLES: Submit booking request for property"""
    from models import BookingRequest, Manager
    
    try:
        data = request.get_json()
        
        # Validate required fields
        property_id = data.get('property_id')
        client_name = data.get('client_name')
        client_phone = data.get('client_phone')
        presentation_id = data.get('presentation_id')
        
        if not all([property_id, client_name, client_phone]):
            return jsonify({'success': False, 'error': 'Не все обязательные поля заполнены'}), 400
        
        # ✅ MIGRATED: Find property details using PropertyRepository
        property_detail = PropertyRepository.get_by_id(property_id)
        if not property_detail:
            return jsonify({'success': False, 'error': 'Объект не найден'}), 404
        
        # Create booking request
        booking = BookingRequest()
        booking.property_id = property_id
        booking.client_name = client_name
        booking.client_phone = client_phone
        booking.client_email = data.get('client_email')
        booking.comment = data.get('comment')
        booking.presentation_id = presentation_id
        booking.property_price = property_detail.price
        booking.property_address = property_detail.address
        booking.complex_name = property_detail.residential_complex.name if property_detail.residential_complex else 'Не указан'
        booking.rooms_count = property_detail.rooms
        booking.area = property_detail.area
        booking.status = 'new'
        
        db.session.add(booking)
        db.session.commit()
        
        # Notify managers
        try:
            send_booking_notifications(booking, property_detail)
        except Exception as notification_error:
            print(f"Notification error: {notification_error}")
            # Don't fail the booking if notifications fail
        
        return jsonify({
            'success': True, 
            'message': 'Заявка на бронирование успешно отправлена!',
            'booking_id': booking.id
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Booking request error: {e}")
        return jsonify({'success': False, 'error': 'Ошибка при отправке заявки. Попробуйте еще раз.'}), 500

def send_booking_notifications(booking, property_detail):
    """Send notifications to managers about new booking request"""
    from models import Manager
    
    # Get all active managers
    managers = Manager.query.filter_by(is_active=True).all()
    
    # Email notification (if configured)
    try:
        import smtplib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        
        subject = f"🏠 Новая заявка на бронирование - {property_detail.complex_name}"
        
        # Prepare property details
        rooms_text = "Студия" if property_detail.object_rooms == 0 else f"{property_detail.object_rooms}-комнатная"
        
        body = f"""
🏠 Новая заявка на бронирование квартиры

📋 ИНФОРМАЦИЯ О КЛИЕНТЕ:
👤 Имя: {booking.client_name}
📱 Телефон: {booking.client_phone}
📧 Email: {booking.client_email or 'не указан'}
💬 Комментарий: {booking.comment or 'нет'}

🏢 ИНФОРМАЦИЯ О КВАРТИРЕ:
🏠 ЖК: {property_detail.complex_name}
🏠 Тип: {rooms_text} квартира
📐 Площадь: {property_detail.area} м²
🏢 Этаж: {property_detail.floor}/{property_detail.total_floors}
💰 Цена: {'{:,}'.format(int(property_detail.price)).replace(',', ' ')} ₽
📍 Адрес: {property_detail.address_display_name}
🏗️ Застройщик: {property_detail.developer_name}
🔗 ID объекта: {booking.property_id}

📅 Дата заявки: {booking.created_at.strftime('%d.%m.%Y %H:%M')}
🆔 ID заявки: {booking.id}

⏰ Рекомендуем связаться с клиентом в течение 15 минут!
        """.strip()
        
        for manager in managers:
            if manager.email:
                try:
                    send_email_notification(manager.email, subject, body)
                except Exception as email_error:
                    print(f"Failed to send email to {manager.email}: {email_error}")
                    
    except Exception as e:
        print(f"Email notification error: {e}")
    
    # Telegram notification (if bot configured)
    try:
        send_telegram_booking_notification(booking, property_detail, managers)
    except Exception as e:
        print(f"Telegram notification error: {e}")

def send_email_notification(email, subject, body):
    """Send email notification"""
    import smtplib
    from email.mime.text import MIMEText
    
    # Simple email sending (would need proper SMTP configuration in production)
    print(f"📧 Would send email to {email}: {subject}")
    print(f"Body: {body[:100]}...")

def send_telegram_booking_notification(booking, property_detail, managers):
    """Send Telegram notification to managers"""
    try:
        import requests
        
        bot_token = os.environ.get('TELEGRAM_BOT_TOKEN')
        if not bot_token:
            print("Telegram bot token not configured")
            return
        
        rooms_text = "Студия" if property_detail.object_rooms == 0 else f"{property_detail.object_rooms}-комнатная"
        
        message = f"""
🏠 <b>НОВАЯ ЗАЯВКА НА БРОНИРОВАНИЕ</b>

👤 <b>Клиент:</b> {booking.client_name}
📱 <b>Телефон:</b> {booking.client_phone}
📧 <b>Email:</b> {booking.client_email or 'не указан'}

🏢 <b>Квартира:</b> {rooms_text}, {property_detail.area} м²
🏠 <b>ЖК:</b> {property_detail.complex_name}
💰 <b>Цена:</b> {'{:,}'.format(int(property_detail.price)).replace(',', ' ')} ₽
📍 <b>Адрес:</b> {property_detail.address_display_name}

💬 <b>Комментарий:</b> {booking.comment or 'нет'}
🆔 <b>ID заявки:</b> {booking.id}

⏰ <b>Рекомендуем связаться в течение 15 минут!</b>
        """.strip()
        
        # Send to managers with telegram_chat_id
        for manager in managers:
            if hasattr(manager, 'telegram_chat_id') and manager.telegram_chat_id:
                try:
                    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                    payload = {
                        'chat_id': manager.telegram_chat_id,
                        'text': message,
                        'parse_mode': 'HTML'
                    }
                    requests.post(url, data=payload, timeout=5)
                    print(f"📱 Telegram notification sent to manager {manager.name}")
                except Exception as telegram_error:
                    print(f"Failed to send Telegram to manager {manager.name}: {telegram_error}")
                    
    except Exception as e:
        print(f"Telegram notification setup error: {e}")

@app.route('/forgot-password', methods=['POST'])
def forgot_password():
    """Password reset request"""
    email = request.form.get('email')
    
    if not email:
        flash('Введите email адрес', 'error')
        return redirect(url_for('login'))
    
    from models import User
    user = User.query.filter_by(email=email).first()
    
    if user:
        # Generate reset token and send email
        token = user.generate_verification_token()
        db.session.commit()
        
        try:
            from email_service import send_password_reset_email
            send_password_reset_email(user, token)
        except Exception as e:
            print(f"Error sending password reset email: {e}")
        
        flash('Инструкции по восстановлению пароля отправлены на ваш email', 'success')
    else:
        # Don't reveal that user doesn't exist
        flash('Инструкции по восстановлению пароля отправлены на ваш email', 'success')
    
    return redirect(url_for('login'))

# API endpoints for dashboard functionality
@app.route('/api/cashback-application', methods=['POST'])
@login_required
def create_cashback_application():
    """Create new cashback application"""
    from models import CashbackApplication
    data = request.get_json()
    
    try:
        app = CashbackApplication(
            user_id=current_user.id,
            property_name=data['property_name'],
            property_type=data['property_type'],
            property_size=float(data['property_size']),
            property_price=int(data['property_price']),
            complex_name=data['complex_name'],
            developer_name=data['developer_name'],
            cashback_amount=int(data['cashback_amount']),
            cashback_percent=float(data['cashback_percent'])
        )
        db.session.add(app)
        db.session.commit()
        
        return jsonify({'success': True, 'application_id': app.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/contact-manager', methods=['POST'])
@csrf.exempt  # CSRF disabled - отключено для простоты отправки заявок
def contact_manager():
    """API endpoint for contacting manager"""
    try:
        from models import Application
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'No data provided'}), 400
        
        # Validate required fields
        required_fields = ['name', 'phone']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'success': False, 'error': f'Field {field} is required'}), 400
        
        # Get current user if logged in
        user_id = session.get('user_id')
        
        # Create application with required fields
        application = Application(
            user_id=user_id,
            contact_name=data.get('name'),
            contact_email=data.get('email'),
            contact_phone=data.get('phone'),
            property_name=data.get('property_name', 'Заявка на подбор жилья'),
            complex_name=data.get('complex_name', 'По предпочтениям клиента'),
            status='new',
            message=data.get('message', f"Район: {data.get('district', '')}, Комнат: {data.get('rooms', '')}, Заселение: {data.get('completion', '')}, Оплата: {data.get('payment', '')}"),
            preferred_contact=data.get('preferred_contact', 'phone')
        )
        
        db.session.add(application)
        db.session.commit()
        
        # Send notification to manager (email and Telegram)
        try:
            from email_service import send_manager_notification
            send_manager_notification(
                name=data.get('name'),
                phone=data.get('phone'),
                email=data.get('email'),
                message=data.get('message', ''),
                application_id=application.id
            )
        except Exception as e:
            print(f"Failed to send manager notification email: {e}")
            
        # Send Telegram notification
        try:
            from telegram_bot import send_telegram_message
            from datetime import datetime
            
            # Check if this is for a specific property
            is_specific_property = data.get('property_id') and data.get('property_name')
            
            # Prepare Telegram message with quiz data or property info
            if is_specific_property:
                message_parts = [
                    "🏠 *ЗАЯВКА НА ПРОСМОТР КОНКРЕТНОЙ КВАРТИРЫ*",
                    "",
                    "👤 *КОНТАКТНАЯ ИНФОРМАЦИЯ:*",
                    f"• Имя: {data.get('name')}",
                    f"• Телефон: {data.get('phone')}",
                ]
                
                if data.get('email'):
                    message_parts.append(f"• Email: {data.get('email')}")
                    
                message_parts.extend([
                    "",
                    "🏢 *ИНТЕРЕСУЮЩАЯ КВАРТИРА:*",
                    f"• Объект: {data.get('property_name')}",
                ])
                
                if data.get('complex_name'):
                    message_parts.append(f"• ЖК: {data.get('complex_name')}")
                if data.get('property_price'):
                    price_formatted = f"{int(float(data.get('property_price'))):,}".replace(',', ' ')
                    message_parts.append(f"• Цена: {price_formatted} руб.")
                if data.get('property_area'):
                    message_parts.append(f"• Площадь: {data.get('property_area')} м²")
                if data.get('property_floor'):
                    message_parts.append(f"• Этаж: {data.get('property_floor')}")
                if data.get('property_district'):
                    message_parts.append(f"• Район: {data.get('property_district')}")
                if data.get('property_address'):
                    message_parts.append(f"• Адрес: {data.get('property_address')}")
                    
                # Calculate potential cashback
                if data.get('property_price'):
                    try:
                        price = float(data.get('property_price'))
                        cashback = price * 0.03  # 3% cashback
                        cashback_formatted = f"{int(cashback):,}".replace(',', ' ')
                        message_parts.append(f"💰 Потенциальный кэшбек: {cashback_formatted} руб. (3%)")
                    except:
                        pass
                        
                # Add property URL if available
                if data.get('property_url'):
                    message_parts.extend([
                        "",
                        f"🔗 *ССЫЛКА НА КВАРТИРУ:*",
                        f"{data.get('property_url')}"
                    ])
            else:
                message_parts = [
                    "🏠 *НОВАЯ ЗАЯВКА НА ПОДБОР ЖИЛЬЯ*",
                    "",
                    "👤 *КОНТАКТНАЯ ИНФОРМАЦИЯ:*",
                    f"• Имя: {data.get('name')}",
                    f"• Телефон: {data.get('phone')}",
                ]
                
                if data.get('email'):
                    message_parts.append(f"• Email: {data.get('email')}")
                    
                # Add quiz preferences if available
                if data.get('district'):
                    message_parts.extend([
                        "",
                        "🏘️ *ПРЕДПОЧТЕНИЯ КЛИЕНТА:*",
                        f"• Район: {data.get('district')}"
                    ])
                    
                if data.get('rooms'):
                    message_parts.append(f"• Комнат: {data.get('rooms')}")
                    
                if data.get('completion'):
                    message_parts.append(f"• Срок заселения: {data.get('completion')}")
                    
                if data.get('payment'):
                    message_parts.append(f"• Способ оплаты: {data.get('payment')}")
                
            message_parts.extend([
                "",
                f"📝 *ID заявки:* #{application.id}",
                f"📅 *Время:* {datetime.now().strftime('%d.%m.%Y %H:%M')}",
                "",
                "⚡ *ВАЖНО:* Быстрая реакция повышает конверсию!"
            ])
            
            telegram_message = "\n".join(message_parts)
            
            # Send to all manager telegram IDs from environment variable
            manager_telegram_ids = os.environ.get('MANAGER_TELEGRAM_IDS', '').split(',')
            for manager_id in manager_telegram_ids:
                manager_id = manager_id.strip()
                if manager_id:
                    send_telegram_message(manager_id, telegram_message)
            
        except Exception as notify_error:
            print(f"Telegram notification error: {notify_error}")
        
        return jsonify({
            'success': True,
            'message': 'Заявка отправлена! Менеджер свяжется с вами в ближайшее время.',
            'application_id': application.id
        })
        
    except Exception as e:
        print(f"Error creating manager contact application: {e}")
        db.session.rollback()
        return jsonify({'success': False, 'error': 'Internal server error'}), 500

@app.route('/api/favorites', methods=['POST'])
@login_required  
# @csrf.exempt  # CSRF disabled  # Disable CSRF for API endpoint
def add_to_favorites():
    """Add property to favorites"""
    from models import FavoriteProperty
    data = request.get_json()
    
    # Check if already in favorites
    existing = FavoriteProperty.query.filter_by(
        user_id=current_user.id,
        property_name=data['property_name']
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': 'Уже в избранном'})
    
    try:
        favorite = FavoriteProperty(
            user_id=current_user.id,
            property_name=data['property_name'],
            property_type=data['property_type'],
            property_size=float(data['property_size']),
            property_price=int(data['property_price']),
            complex_name=data['complex_name'],
            developer_name=data['developer_name'],
            property_image=data.get('property_image'),
            cashback_amount=int(data.get('cashback_amount', 0)),
            cashback_percent=float(data.get('cashback_percent', 0))
        )
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/favorites/<property_id>', methods=['DELETE'])
@login_required
@csrf.exempt  # ✅ FIXED: CSRF protection removed for delete action as requested
def remove_from_favorites(property_id):
    """Remove property from favorites"""
    from models import FavoriteProperty
    
    favorite = FavoriteProperty.query.filter_by(
        user_id=current_user.id,
        property_id=property_id
    ).first()
    
    if favorite:
        try:
            db.session.delete(favorite)
            db.session.commit()
            return jsonify({'success': True})
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)}), 400
    else:
        return jsonify({'success': False, 'error': 'Favorite not found'}), 404

def send_view_notification_to_manager(presentation, view):
    """Отправляет уведомление менеджеру о новом просмотре презентации"""
    try:
        manager = presentation.created_by
        if not manager:
            print(f"Manager not found for presentation {presentation.id}")
            return
            
        # Получаем информацию о просмотре
        client_info = "Неизвестный клиент"
        if presentation.client_name:
            client_info = presentation.client_name
        elif presentation.client_phone:
            client_info = presentation.client_phone
            
        # Формируем сообщение уведомления
        notification_text = f"""📊 Новый просмотр презентации!

📋 "{presentation.title}"
👤 Клиент: {client_info}
🔢 Всего просмотров: {presentation.view_count}
⏰ Время просмотра: {view.viewed_at.strftime('%d.%m.%Y %H:%M')}
🌐 IP: {view.view_ip}
📱 Устройство: {view.user_agent[:50] + '...' if view.user_agent and len(view.user_agent) > 50 else view.user_agent or 'Неизвестно'}

👀 Ссылка на презентацию: {request.url_root}presentation/modern/{presentation.unique_url}
🎯 Панель менеджера: {request.url_root}manager/dashboard"""

        # TODO: Интеграция с Telegram Bot API
        # if hasattr(manager, 'telegram_chat_id') and manager.telegram_chat_id:
        #     send_telegram_notification(manager.telegram_chat_id, notification_text)
        
        # TODO: Интеграция с Email
        # if manager.email:
        #     send_email_notification(manager.email, f"Новый просмотр: {presentation.title}", notification_text)
        
        # Пока просто логируем уведомление
        print(f"📧 NOTIFICATION TO MANAGER {manager.email}:")
        print(notification_text)
        print("-" * 50)
        
        # Отмечаем что уведомление отправлено
        view.notification_sent = True
        db.session.commit()
        
    except Exception as e:
        print(f"Error in send_view_notification_to_manager: {e}")

@app.route('/presentation/<string:unique_url>')
def redirect_old_presentation_url(unique_url):
    """Редирект со старого формата URL на новый для обратной совместимости"""
    return redirect(url_for('view_presentation', unique_id=unique_url), code=301)

@app.route('/presentation/view/<string:unique_id>')
def view_presentation(unique_id):
    """Публичная страница просмотра презентации по уникальной ссылке"""
    print(f"🔥 ROUTE HIT: /presentation/view/{unique_id}")
    print(f"🔥 CLIENT IP: {request.remote_addr}")
    print(f"🔥 USER AGENT: {request.headers.get('User-Agent', 'Unknown')}")
    from models import Collection, CollectionProperty, PresentationView
    
    # Находим презентацию по уникальной ссылке
    presentation = Collection.query.filter_by(
        unique_url=unique_id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return render_template('error.html', 
                             error="Презентация не найдена", 
                             message="Возможно, ссылка устарела или была удалена"), 404
    
    # Записываем просмотр
    try:
        view = PresentationView(
            collection_id=presentation.id,
            view_ip=request.remote_addr,
            user_agent=request.headers.get('User-Agent'),
            referer=request.headers.get('Referer')
        )
        db.session.add(view)
        
        # Увеличиваем счетчик просмотров (без автокоммита)
        presentation.increment_view_count()
        db.session.commit()  # Контролируем транзакцию на уровне view
        
        # Отправляем уведомление менеджеру о новом просмотре
        try:
            send_view_notification_to_manager(presentation, view)
        except Exception as e:
            print(f"Error sending view notification: {e}")
        
    except Exception as e:
        db.session.rollback()
        print(f"Error recording presentation view: {e}")
    
    print("DEBUG: Starting data loading phase...")
    
    # ✅ MIGRATED: Load properties using PostgreSQL (same as manager version)
    try:
        print("DEBUG: Loading presentation data from PostgreSQL...")
        enriched_properties = _load_presentation_properties_from_db(presentation.id)
        print(f"DEBUG: Loaded {len(enriched_properties)} enriched properties")
    except Exception as e:
        print(f"ERROR: Failed to load presentation data: {e}")
        import traceback
        traceback.print_exc()
        # Fallback to empty list to allow page rendering
        print("FALLBACK: Using empty data to allow page rendering")
        enriched_properties = []
    
    print(f"DEBUG: About to render template with {len(enriched_properties)} enriched properties")
    print(f"DEBUG: Presentation object: {presentation}")
    print(f"DEBUG: First property sample: {enriched_properties[0] if enriched_properties else 'No properties'}")
    
    # Format presentation data for template (same structure as manager version)
    presentation_data = {
        'id': presentation.id,
        'title': presentation.title,
        'description': presentation.description,
        'client_name': presentation.client_name,
        'client_phone': presentation.client_phone,
        'status': presentation.status,
        'created_at': presentation.created_at,
        'view_count': presentation.view_count,
        'last_viewed_at': presentation.last_viewed_at,
        'properties_count': len(enriched_properties),
        'properties': enriched_properties,
        'unique_url': presentation.unique_url
    }
    
    try:
        print(f"🔥 RENDERING: presentation_view.html with {len(enriched_properties)} properties")
        print(f"🔥 PRESENTATION: {presentation_data['title']}")
        print(f"🔥 VIEW COUNT: {presentation_data['view_count']}")
        
        template_result = render_template('presentation_view.html', 
                                        presentation=presentation_data,
                                        properties=enriched_properties,
                                        manager=presentation.created_by)
        print("🔥 TEMPLATE RENDERED: presentation_view.html success!")
        return template_result
    except Exception as e:
        print(f"ERROR in view_presentation template rendering: {e}")
        import traceback
        traceback.print_exc()
        return f"Template rendering error: {str(e)}", 500

@app.route('/presentation/modern/<string:unique_id>')
def view_modern_presentation(unique_id):
    """Современная версия публичной страницы просмотра презентации"""
    from models import Collection, CollectionProperty, PresentationView, ManagerNotification
    
    try:
        # Находим презентацию по уникальной ссылке
        presentation = Collection.query.filter_by(
            unique_url=unique_id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return render_template('error.html', 
                                 error="Презентация не найдена", 
                                 message="Возможно, ссылка устарела или была удалена"), 404
        
        print(f"DEBUG: view_modern_presentation - Found presentation ID: {presentation.id}")
        
        # Записываем просмотр
        try:
            view = PresentationView(
                collection_id=presentation.id,
                view_ip=request.remote_addr,
                user_agent=request.headers.get('User-Agent'),
                referer=request.headers.get('Referer')
            )
            db.session.add(view)
            presentation.increment_view_count()
            
            # Создаем уведомление для менеджера
            manager_id = presentation.created_by_manager_id
            client_name = presentation.client_name or 'Неизвестный клиент'
            presentation_title = presentation.title or 'Презентация'
            view_ip = request.remote_addr or 'Неизвестный IP'
            
            # Формируем текст уведомления
            notification_title = f"Просмотр презентации: {presentation_title}"
            notification_message = f"Клиент {client_name} просмотрел презентацию \"{presentation_title}\". IP адрес: {view_ip}"
            
            # Дополнительная информация в JSON
            extra_data = {
                'client_name': client_name,
                'presentation_title': presentation_title,
                'view_ip': view_ip,
                'user_agent': request.headers.get('User-Agent', ''),
                'referer': request.headers.get('Referer', ''),
                'presentation_url': f"/presentation/modern/{presentation.unique_url}",
                'view_count': presentation.view_count + 1  # +1 так как еще не сохранили
            }
            
            # Создаем уведомление
            notification = ManagerNotification(
                manager_id=manager_id,
                title=notification_title,
                message=notification_message,
                notification_type='presentation_view',
                presentation_id=presentation.id
            )
            notification.set_extra_data(extra_data)
            
            db.session.add(notification)
            db.session.commit()
            
            print(f"✅ Created notification for manager {manager_id}: {notification_title}")
            
        except Exception as e:
            db.session.rollback()
            print(f"Error recording presentation view or creating notification: {e}")
            import traceback
            traceback.print_exc()
        
        print(f"DEBUG: view_modern_presentation - Starting property loading")
        
        # ✅ MIGRATED: Get property data using repository
        enriched_properties = []
        all_complexes = {}  # Словарь для хранения всех уникальных ЖК
        
        for prop in presentation.properties:
            # Load property using repository
            property_obj_orm = PropertyRepository.get_by_id(int(prop.property_id))
            
            if property_obj_orm:
                # Get cashback rate from complex
                cashback_rate = property_obj_orm.residential_complex.cashback_rate if property_obj_orm.residential_complex else 5.0
                
                # Parse photos
                photos = []
                if property_obj_orm.gallery_images:
                    try:
                        import json
                        if isinstance(property_obj_orm.gallery_images, str):
                            if property_obj_orm.gallery_images.startswith('['):
                                photos = json.loads(property_obj_orm.gallery_images)
                            elif property_obj_orm.gallery_images.startswith('http'):
                                photos = [url.strip() for url in property_obj_orm.gallery_images.split(',') if url.strip()]
                        elif isinstance(property_obj_orm.gallery_images, list):
                            photos = property_obj_orm.gallery_images
                    except Exception as e:
                        photos = []
                
                # Format title
                rooms_text = ""
                if property_obj_orm.rooms == 0:
                    rooms_text = "Студия"
                elif property_obj_orm.rooms:
                    rooms_text = f"{property_obj_orm.rooms}-комнатная квартира"
                else:
                    rooms_text = "Квартира"
                
                # Calculate cashback
                cashback_amount = int((property_obj_orm.price or 0) * cashback_rate / 100)
                
                # Format property object for template
                property_obj = {
                    'property_id': property_obj_orm.inner_id,
                    'title': rooms_text,
                    'rooms': property_obj_orm.rooms or 0,
                    'area': property_obj_orm.area or 0,
                    'price': property_obj_orm.price or 0,
                    'floor': property_obj_orm.floor or 1,
                    'total_floors': property_obj_orm.total_floors or property_obj_orm.floor or 1,
                    'address': property_obj_orm.address or '',
                    'images': photos,
                    'complex_name': property_obj_orm.residential_complex.name if property_obj_orm.residential_complex else '',
                    'developer_name': property_obj_orm.developer.name if property_obj_orm.developer else '',
                    'deadline': '',
                    'renovation_type': property_obj_orm.renovation_type or 'Не указано',
                    'housing_class': property_obj_orm.residential_complex.object_class_display_name if property_obj_orm.residential_complex else 'Комфорт',
                    'cashback_percent': cashback_rate,
                    'cashback_amount': cashback_amount,
                    'manager_note': prop.manager_note if hasattr(prop, 'manager_note') else None
                }
                
                # Format deadline
                if property_obj_orm.residential_complex and property_obj_orm.residential_complex.end_build_year and property_obj_orm.residential_complex.end_build_quarter:
                    quarters = ['I', 'II', 'III', 'IV']
                    quarter_text = quarters[property_obj_orm.residential_complex.end_build_quarter - 1] if property_obj_orm.residential_complex.end_build_quarter <= 4 else 'IV'
                    property_obj['deadline'] = f"{quarter_text} кв. {property_obj_orm.residential_complex.end_build_year} г."
                
                enriched_properties.append(property_obj)
                
                # Collect unique complexes
                if property_obj_orm.residential_complex:
                    complex_key = property_obj_orm.residential_complex.name
                    if complex_key not in all_complexes:
                        all_complexes[complex_key] = {
                            'name': property_obj_orm.residential_complex.name,
                            'developer': property_obj_orm.developer.name if property_obj_orm.developer else '',
                            'address': property_obj_orm.address or '',
                            'end_year': property_obj_orm.residential_complex.end_build_year,
                            'end_quarter': property_obj_orm.residential_complex.end_build_quarter,
                            'photos': [],
                            'lat': float(property_obj_orm.latitude) if property_obj_orm.latitude else None,
                            'lon': float(property_obj_orm.longitude) if property_obj_orm.longitude else None,
                            'cashback_rate': cashback_rate
                        }
        
        # ✅ MIGRATED: Загружаем фотографии для каждого комплекса из normalized tables
        for complex_name in all_complexes.keys():
            # Находим объекты этого комплекса с фотографиями
            complex_photos = []
            complex_properties = PropertyRepository.get_all_active(
                filters={'residential_complex': complex_name},
                limit=10
            )
            
            for prop in complex_properties:
                if prop.gallery_images:
                    try:
                        import json
                        prop_photos = []
                        if isinstance(prop.gallery_images, str) and prop.gallery_images.startswith('['):
                            prop_photos = json.loads(prop.gallery_images)
                        elif isinstance(prop.gallery_images, list):
                            prop_photos = prop.gallery_images
                        elif isinstance(prop.gallery_images, str) and prop.gallery_images.startswith('http'):
                            prop_photos = [url.strip() for url in prop.gallery_images.split(',') if url.strip()]
                        
                        # Добавляем уникальные фотографии
                        for photo in prop_photos:
                            if photo not in complex_photos:
                                complex_photos.append(photo)
                                if len(complex_photos) >= 10:  # Максимум 10 фотографий на комплекс
                                    break
                        
                        if len(complex_photos) >= 10:
                            break
                            
                    except Exception as e:
                        continue
            
            # Обновляем фотографии комплекса
            all_complexes[complex_name]['photos'] = complex_photos
        
        print(f"DEBUG: view_modern_presentation - Loaded {len(enriched_properties)} properties")
        
        # Подготавливаем сводную информацию
        total_complexes = len(all_complexes)
        complex_names = list(all_complexes.keys())
        
        print(f"DEBUG: view_modern_presentation - Rendering template")
        
        # Подготавливаем данные для шаблона
        presentation_data = {
            'title': presentation.title,
            'client_name': presentation.client_name,
            'description': presentation.description,
            'created_at': presentation.created_at,
            'properties': enriched_properties,
            'total_objects': len(enriched_properties),
            'total_complexes': total_complexes,
            'complex_names': complex_names,
            'all_complexes': all_complexes
        }
        
        return render_template('modern_presentation_view.html', presentation=presentation_data)
        
    except Exception as e:
        print(f"ERROR in view_modern_presentation: {e}")
        import traceback
        traceback.print_exc()
        
        # Return detailed error for debugging
        return render_template('error.html',
                             error="Ошибка загрузки презентации",
                             message=f"Техническая информация: {str(e)}"), 500
@app.route('/api/manager/presentation/<int:presentation_id>/share', methods=['POST'])
@csrf.exempt
@manager_required
def share_presentation(presentation_id):
    """Получить данные для отправки презентации в мессенджеры (безопасная версия)"""
    from models import Collection
    from flask_login import current_user
    import urllib.parse
    
    current_manager = current_user
    
    print(f"DEBUG: share_presentation - presentation_id: {presentation_id}")
    print(f"DEBUG: share_presentation - current_user: {current_user}")
    print(f"DEBUG: share_presentation - current_manager.id: {current_manager.id}")
    print(f"DEBUG: share_presentation - request.method: {request.method}")
    print(f"DEBUG: share_presentation - request.content_type: {request.content_type}")
    
    try:
        data = request.get_json() or {}  # Пустой JSON валиден
        print(f"DEBUG: share_presentation - request data: {data}")
    except Exception as e:
        print(f"DEBUG: share_presentation - JSON parsing error: {e}")
        return jsonify({'success': False, 'error': f'Invalid JSON: {str(e)}'}), 400
    
    # Безопасное логирование после проверки аутентификации
    print(f"DEBUG: share_presentation - current_user.email: {getattr(current_user, 'email', 'Not authenticated')}")
    
    print(f"DEBUG: share_presentation - Looking for presentation {presentation_id} by manager {current_manager.id}")
    
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_manager.id,
        collection_type='presentation'
    ).first()
    
    print(f"DEBUG: share_presentation - Found presentation: {presentation}")
    
    if not presentation:
        # Try to find presentation regardless of owner for debugging
        any_presentation = Collection.query.filter_by(
            id=presentation_id,
            collection_type='presentation'
        ).first()
        print(f"DEBUG: share_presentation - Any presentation with this ID: {any_presentation}")
        if any_presentation:
            print(f"DEBUG: share_presentation - Presentation exists but belongs to manager {any_presentation.created_by_manager_id}")
        return jsonify({'success': False, 'error': 'Презентация не найдена или у вас нет прав доступа'}), 404
    
    client_name = data.get('client_name', presentation.client_name)
    print(f"DEBUG: share_presentation - Client name: {client_name}")
    
    # Обновляем имя клиента если передано
    if client_name and client_name != presentation.client_name:
        print(f"DEBUG: share_presentation - Updating client name from '{presentation.client_name}' to '{client_name}'")
        presentation.client_name = client_name
        db.session.commit()
    
    # Формируем ссылку
    base_url = request.url_root.rstrip('/')
    presentation_url = f"{base_url}/presentation/modern/{presentation.unique_url}"
    print(f"DEBUG: share_presentation - Presentation URL: {presentation_url}")
    
    # Формируем сообщение для отправки
    properties_count = len(presentation.properties) if presentation.properties else 0
    print(f"DEBUG: share_presentation - Properties count: {properties_count}")
    
    # Получаем телефон менеджера
    manager_phone = current_user.phone if hasattr(current_user, 'phone') and current_user.phone else None
    manager_name = f"{current_user.first_name} {current_user.last_name}" if hasattr(current_user, 'first_name') and hasattr(current_user, 'last_name') else "Менеджер InBack"
    
    # Формируем контактную информацию
    if manager_phone:
        contact_info = f"👤 {manager_name}\n📞 {manager_phone}"
    else:
        contact_info = "📞 +7 (XXX) XXX-XX-XX"
    
    message_text = f"""🏠 Презентация недвижимости от InBack

📋 {presentation.title}
{f'👤 Для: {client_name}' if client_name else ''}

🔢 Подобрано объектов: {properties_count}
📅 Создано: {presentation.created_at.strftime('%d.%m.%Y')}

👀 Смотреть презентацию:
{presentation_url}

💬 Есть вопросы? Свяжитесь с нами!
{contact_info}"""
    
    response_data = {
        'success': True,
        'share_url': presentation_url,
        'share_data': {
            'presentation_url': presentation_url,
            'message_text': message_text,
            'whatsapp_url': f"https://wa.me/?text={urllib.parse.quote(message_text)}",
            'telegram_url': f"https://t.me/share/url?url={presentation_url}&text={urllib.parse.quote(presentation.title)}",
            'client_name': client_name or 'Клиент',
            'properties_count': properties_count
        }
    }
    
    print(f"DEBUG: share_presentation - Returning response: {response_data}")
    return jsonify(response_data)

@app.route('/api/favorites/toggle', methods=['POST'])
@login_required
# @csrf.exempt  # CSRF disabled  # Disable CSRF for API endpoint
def toggle_favorite():
    """Toggle favorite status for property"""
    from models import FavoriteProperty
    data = request.get_json()
    property_id = data.get('property_id')
    
    if not property_id:
        return jsonify({'success': False, 'error': 'property_id required'}), 400
    
    print(f"DEBUG: Favorites toggle called by user {getattr(current_user, 'id', 'not_authenticated')} for property {property_id}")
    
    # Check if already in favorites
    existing = FavoriteProperty.query.filter_by(
        user_id=current_user.id,
        property_id=property_id
    ).first()
    
    try:
        if existing:
            # Remove from favorites
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'action': 'removed', 'is_favorite': False})
        else:
            # Add to favorites
            favorite = FavoriteProperty(
                user_id=current_user.id,
                property_id=property_id,
                property_name=data.get('property_name', ''),
                property_type=data.get('property_type', ''),
                property_size=float(data.get('property_size', 0)),
                property_price=int(data.get('property_price', 0)),
                complex_name=data.get('complex_name', ''),
                developer_name=data.get('developer_name', ''),
                property_image=data.get('property_image'),
                cashback_amount=int(data.get('cashback_amount', 0)),
                cashback_percent=float(data.get('cashback_percent', 0))
            )
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'action': 'added', 'is_favorite': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400



@app.route('/api/collections', methods=['POST'])
@login_required
def create_collection():
    """Create new property collection"""
    from models import Collection
    data = request.get_json()
    
    try:
        collection = Collection(
            user_id=current_user.id,
            title=data['name'],
            description=data.get('description'),
            image_url=data.get('image_url'),
            category=data.get('category')
        )
        db.session.add(collection)
        db.session.commit()
        
        return jsonify({'success': True, 'collection_id': collection.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/collections/<int:collection_id>', methods=['DELETE'])
@login_required
def delete_collection(collection_id):
    """Delete a collection"""
    from models import Collection
    collection = Collection.query.filter_by(
        id=collection_id,
        user_id=current_user.id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': 'Подборка не найдена'}), 404
    
    try:
        db.session.delete(collection)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/documents/upload', methods=['POST'])
@login_required
def upload_documents():
    """Upload documents"""
    from models import Document
    import os
    from werkzeug.utils import secure_filename
    from datetime import datetime
    
    if 'files' not in request.files:
        return jsonify({'success': False, 'error': 'Нет файлов для загрузки'}), 400
    
    files = request.files.getlist('files')
    uploaded_files = []
    
    # Create uploads directory if it doesn't exist
    upload_dir = 'instance/uploads'
    os.makedirs(upload_dir, exist_ok=True)
    
    for file in files:
        if file.filename == '':
            continue
        
        if file and file.filename and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            # Add timestamp to avoid conflicts
            timestamp = str(int(datetime.utcnow().timestamp()))
            filename = f"{timestamp}_{filename}"
            file_path = os.path.join(upload_dir, filename)
            
            try:
                file.save(file_path)
                file_size = os.path.getsize(file_path)
                file_ext = filename.rsplit('.', 1)[1].lower()
                
                # Create document record
                document = Document(
                    user_id=current_user.id,
                    original_filename=secure_filename(file.filename) if file.filename else 'unknown',
                    stored_filename=filename,
                    file_path=file_path,
                    file_size=file_size,
                    file_type=file_ext,
                    document_type=determine_document_type(file.filename),
                    status='На проверке'
                )
                db.session.add(document)
                uploaded_files.append({
                    'filename': file.filename,
                    'size': file_size
                })
            except Exception as e:
                return jsonify({'success': False, 'error': f'Ошибка загрузки файла {file.filename}: {str(e)}'}), 400
    
    try:
        db.session.commit()
        return jsonify({'success': True, 'uploaded_files': uploaded_files})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/documents/<int:document_id>', methods=['DELETE'])
@login_required
def delete_document(document_id):
    """Delete a document"""
    from models import Document
    import os
    
    document = Document.query.filter_by(
        id=document_id,
        user_id=current_user.id
    ).first()
    
    if not document:
        return jsonify({'success': False, 'error': 'Документ не найден'}), 404
    
    try:
        # Delete physical file
        if os.path.exists(document.file_path):
            os.remove(document.file_path)
        
        # Delete database record
        db.session.delete(document)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

def allowed_file(filename):
    ALLOWED_EXTENSIONS = {'pdf', 'doc', 'docx', 'jpg', 'jpeg', 'png'}
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def determine_document_type(filename):
    """Determine document type from filename"""
    filename_lower = filename.lower()
    if any(word in filename_lower for word in ['паспорт', 'passport']):
        return 'Паспорт'
    elif any(word in filename_lower for word in ['справка', 'доходы', 'income']):
        return 'Справка о доходах'
    elif any(word in filename_lower for word in ['договор', 'contract']):
        return 'Договор'
    elif any(word in filename_lower for word in ['снилс', 'снилс']):
        return 'СНИЛС'
    elif any(word in filename_lower for word in ['инн', 'inn']):
        return 'ИНН'
    else:
        return 'Другое'

# Manager authentication and dashboard routes
@app.route('/manager/logout')
def manager_logout():
    """Manager logout"""
    logout_user()
    flash('Вы успешно вышли из системы', 'success')
    return redirect(url_for('manager_login'))

@app.route('/switch-to-client')
def switch_to_client():
    """Switch from manager to client mode"""
    logout_user()
    flash('Переключились в режим клиента', 'info')
    return redirect(url_for('index'))

@app.route('/manager/login', methods=['GET', 'POST'])
@csrf.exempt  # CSRF disabled  # Temporarily disable CSRF for login
def manager_login():
    """Simplified manager login with step-by-step error isolation"""
    if request.method == 'POST':
        # Step 1: Import and basic validation
        try:
            print("STEP 1: Starting manager login process")
            email = request.form.get('email')
            password = request.form.get('password')
            print(f"STEP 1: Got email={email}, password={'*' * len(password) if password else 'None'}")
            
            if not email or not password:
                print("STEP 1: Missing credentials")
                flash('Заполните все поля', 'error')
                return render_template('auth/manager_login.html')
            print("STEP 1: Basic validation passed")
            
        except Exception as e:
            print(f"ERROR IN STEP 1: {e}")
            flash('Ошибка обработки данных', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 2: Database query
        try:
            print("STEP 2: Importing Manager model")
            from models import Manager
            print("STEP 2: Manager model imported successfully")
            
            print("STEP 2: Querying database for manager")
            manager = Manager.query.filter_by(email=email, is_active=True).first()
            print(f"STEP 2: Database query result: {manager is not None}")
            
            if not manager:
                print("STEP 2: Manager not found")
                flash('Неверные данные для входа', 'error')
                return render_template('auth/manager_login.html')
            
            print(f"STEP 2: Manager found - ID: {manager.id}, Email: {manager.email}")
            
        except Exception as e:
            print(f"ERROR IN STEP 2: {e}")
            import traceback
            traceback.print_exc()
            flash('Ошибка подключения к базе данных', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 3: Password verification
        try:
            print("STEP 3: Checking password")
            password_valid = manager.check_password(password)
            print(f"STEP 3: Password check result: {password_valid}")
            
            if not password_valid:
                print("STEP 3: Password invalid")
                flash('Неверные данные для входа', 'error')
                return render_template('auth/manager_login.html')
            
            print("STEP 3: Password verification passed")
            
        except Exception as e:
            print(f"ERROR IN STEP 3: {e}")
            import traceback
            traceback.print_exc()
            flash('Ошибка проверки пароля', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 4: Flask-Login авторизация (ИСПРАВЛЕНО)
        try:
            print("STEP 4: Using Flask-Login")
            login_user(manager, remember=True)  # Используем Flask-Login вместо ручных сессий
            session.permanent = True  # Ensure 30-day session lifetime
            print(f"STEP 4: Flask-Login successful, manager.get_id()={manager.get_id()}")
            
        except Exception as e:
            print(f"ERROR IN STEP 4: {e}")
            import traceback
            traceback.print_exc()
            flash('Ошибка авторизации', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 5: Database update
        try:
            print("STEP 5: Updating last login time")
            from datetime import datetime
            manager.last_login = datetime.utcnow()
            db.session.commit()
            print("STEP 5: Database commit successful")
            
        except Exception as e:
            print(f"ERROR IN STEP 5: {e}")
            import traceback
            traceback.print_exc()
            flash('Ошибка обновления базы данных', 'error')
            return render_template('auth/manager_login.html')
        
        # Step 6: Success redirect
        try:
            print("STEP 6: Preparing success response")
            flash('Добро пожаловать в систему!', 'success')
            print(f"STEP 6: Login successful for manager {manager.email}")
            return redirect(url_for('manager_dashboard'))
            
        except Exception as e:
            print(f"ERROR IN STEP 6: {e}")
            import traceback
            traceback.print_exc()
            flash('Ошибка перенаправления', 'error')
            return render_template('auth/manager_login.html')
    
    # GET request - show login form
    return render_template('auth/manager_login.html')



# Manager Comparison Routes
@app.route('/manager/property-comparison')
@manager_required
def manager_property_comparison():
    """Manager property comparison page"""
    from models import Manager
    
    current_manager = current_user
    
    return render_template('auth/manager_property_comparison.html', current_manager=current_manager)

@app.route('/manager/complex-comparison')
@manager_required
def manager_complex_comparison():
    """Manager complex comparison page"""
    from models import Manager
    
    current_manager = current_user
    
    return render_template('auth/manager_complex_comparison.html', current_manager=current_manager)

@app.route('/api/manager/favorites-properties')
@manager_required
def get_manager_favorite_properties():
    """Get properties with full characteristics for comparison"""
    try:
        # Check if specific IDs are requested for server-side filtering
        from flask import request
        requested_ids = request.args.get('ids', '')
        filter_ids_str = [id.strip() for id in requested_ids.split(',') if id.strip()] if requested_ids else []
        
        # ✅ MIGRATED: Load properties using repository (batch loading)
        import json
        
        try:
            from models import Property, ResidentialComplex, Developer, District
            from sqlalchemy.orm import joinedload
            
            properties_data = []
            
            # Load properties with eager loading of relationships
            query = Property.query.options(
                joinedload(Property.residential_complex),
                joinedload(Property.developer),
                joinedload(Property.district)
            )
            
            if filter_ids_str:
                # Filter by properties.id (primary key integer)
                filter_ids_int = [int(id) for id in filter_ids_str if id.isdigit()]
                query = query.filter(Property.id.in_(filter_ids_int[:10]))
            else:
                # Get all active properties (limited)
                query = query.filter(Property.status == 'available').limit(100)
            
            properties_orm = query.all()
            
            for prop in properties_orm:
                # Get photos
                photos_data = []
                if hasattr(prop, 'photos') and prop.photos:
                    try:
                        photos_data = json.loads(prop.photos) if isinstance(prop.photos, str) else prop.photos
                    except:
                        photos_data = []
                
                # Fallback to main_image or gallery_images
                if not photos_data:
                    if hasattr(prop, 'main_image') and prop.main_image:
                        photos_data = [prop.main_image]
                    elif hasattr(prop, 'gallery_images') and prop.gallery_images:
                        try:
                            gallery = json.loads(prop.gallery_images) if isinstance(prop.gallery_images, str) else prop.gallery_images
                            photos_data = gallery if isinstance(gallery, list) else []
                        except:
                            pass
                
                first_image = photos_data[0] if photos_data else '/static/images/no-photo.jpg'
                
                # Format room text
                rooms_count = prop.rooms or 0
                area_value = prop.area or 0
                rooms_text = "Студия" if rooms_count == 0 else f"{rooms_count}"
                
                # Format property name
                if rooms_count == 0:
                    property_name = f"Студия, {area_value} м²"
                else:
                    property_name = f"{rooms_count} комн, {area_value} м²"
                
                # Calculate cashback
                complex_name = prop.residential_complex.name if prop.residential_complex else ''
                cashback_value = calculate_cashback(prop.price or 0, complex_name=complex_name)
                
                property_data = {
                    'property_id': str(prop.inner_id or ''),
                    'property_name': property_name,
                    'property_type': prop.residential_complex.object_class_display_name if prop.residential_complex else 'Квартира',
                    'property_size': float(prop.area or 0),
                    'property_price': int(prop.price or 0),
                    'complex_name': complex_name or '',
                    'developer_name': prop.developer.name if prop.developer else 'Не указан',
                    'property_image': first_image,
                    'property_url': f'/object/{prop.inner_id}' if prop.inner_id else None,
                    'district': prop.district.name if prop.district else '',
                    'address': prop.address or '',
                    'floor': str(prop.floor or ''),
                    'total_floors': str(prop.total_floors or ''),
                    'floors_total': str(prop.total_floors or ''),
                    'rooms': str(rooms_count),
                    'living_area': '',
                    'kitchen_area': '',
                    'price_per_sqm': int(prop.price_per_sqm or 0) if prop.price_per_sqm else 0,
                    'condition': prop.renovation_type or '',
                    'ceiling_height': '',
                    'furniture': '',
                    'balcony': '',
                    'view_from_windows': '',
                    'parking': '',
                    'metro_distance': '',
                    'year_built': str(prop.residential_complex.end_build_year or '') if prop.residential_complex else '',
                    'building_type': prop.complex_building_name or '',
                    'decoration': prop.renovation_type or 'no_renovation',
                    'deal_type': prop.deal_type or 'sale',
                    'mortgage_available': 'Нет',
                    'added_at': 'Загружено из PostgreSQL',
                    'cashback_amount': cashback_value,
                    'cashback': cashback_value
                }
                properties_data.append(property_data)
            
            return jsonify({
                'success': True,
                'properties': properties_data,
                'count': len(properties_data)
            })
            
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)}), 500
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/favorites-complexes')
@manager_required
def get_manager_favorite_complexes():
    """Get manager's favorite complexes for comparison"""
    from models import ManagerFavoriteComplex
    
    try:
        current_manager = current_user
        
        # Get all favorite complexes for this manager
        favorites = ManagerFavoriteComplex.query.filter_by(
            manager_id=current_manager.id
        ).order_by(ManagerFavoriteComplex.created_at.desc()).all()
        
        complexes_data = []
        for fav in favorites:
            complexes_data.append({
                'id': fav.id,
                'complex_id': fav.complex_id,
                'complex_name': fav.complex_name,
                'developer_name': fav.developer_name,
                'complex_address': fav.complex_address,
                'district': fav.district,
                'min_price': fav.min_price,
                'max_price': fav.max_price,
                'complex_image': fav.complex_image,
                'complex_url': fav.complex_url,
                'added_at': fav.created_at.strftime('%d.%m.%Y %H:%M'),
                'object_class_display_name': fav.object_class_display_name,
            })
        
        return jsonify({
            'success': True,
            'complexes': complexes_data,
            'count': len(complexes_data)
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/manager/dashboard')
@manager_required
def manager_dashboard():
    from models import Manager, User, CashbackApplication, Document
    
    # ИСПРАВЛЕНО: используем Flask-Login вместо session
    current_manager = current_user
    print(f"DEBUG: Manager dashboard - current_manager: {current_manager.email if current_manager else None}")
    
    # Resolve city context to preserve city selection
    current_city = resolve_city_context(
        city_id=request.args.get('city_id'),
        city_slug=request.args.get('city')
    )
    
    # Get statistics (используем current_manager.id)
    print('DEBUG: Starting statistics queries...')
    print('DEBUG: Querying total_clients...')
    total_clients = User.query.filter_by(assigned_manager_id=current_manager.id).count()
    print(f'DEBUG: total_clients = {total_clients}')
    print('DEBUG: Querying new_clients_count...')
    new_clients_count = User.query.filter_by(
        assigned_manager_id=current_manager.id, 
        client_status='Новый'
    ).count()
    
    print('DEBUG: Querying pending_applications_count...')
    pending_applications_count = CashbackApplication.query.join(User).filter(
        User.assigned_manager_id == current_manager.id,
        CashbackApplication.status == 'На рассмотрении'
    ).count()
    
    print('DEBUG: Querying pending_documents_count...')
    pending_documents_count = Document.query.join(User).filter(
        User.assigned_manager_id == current_manager.id,
        Document.status == 'На проверке'
    ).count()
    
    # Calculate total approved cashback (оптимизировано - используем SQL SUM вместо загрузки в память)
    total_approved_cashback = 0
    try:
        from sqlalchemy import func
        from models import CashbackApplication, User
        total_approved_cashback = db.session.query(
            func.sum(CashbackApplication.cashback_amount)
        ).join(User).filter(
            User.assigned_manager_id == current_manager.id,
            CashbackApplication.status == 'Одобрена'
        ).scalar() or 0
    except Exception as e:
        print(f"Error calculating cashback: {e}")
        total_approved_cashback = 0
    
    # Recent activities (mock data for now)
    recent_activities = [
        {
            'message': 'Новый клиент Иван Петров зарегистрировался',
            'time_ago': '5 минут назад',
            'color': 'blue',
            'icon': 'user-plus'
        },
        {
            'message': 'Заявка на кешбек от Анны Сидоровой требует проверки',
            'time_ago': '1 час назад',
            'color': 'yellow',
            'icon': 'file-alt'
        }
    ]
    
    print('DEBUG: About to query collections...')
    # Get collections statistics  
    from models import Collection
    collections_count = Collection.query.filter_by(created_by_manager_id=current_manager.id).count()
    recent_collections = Collection.query.filter_by(created_by_manager_id=current_manager.id).order_by(Collection.created_at.desc()).limit(5).all()
    
    # Get presentations statistics
    presentations_count = Collection.query.filter_by(
        created_by_manager_id=current_manager.id, 
        collection_type='presentation'
    ).count()
    
    # Get deals statistics
    from models import Deal
    deals_count = Deal.query.filter_by(manager_id=current_manager.id).count()
    
    # Load data for manager filters
    districts = get_districts_list()
    developers = get_developers_list()
    
    print(f"DEBUG: Rendering dashboard with manager: {current_manager.full_name}")

    # Sidebar links для менеджера  
    # Load manager favorites and comparison counts
    from models import ManagerFavoriteProperty, ManagerFavoriteComplex, ManagerComparison, ComparisonComplex
    print("DEBUG: Loading manager favorites counts...")
    manager_favorites_count = ManagerFavoriteProperty.query.filter_by(manager_id=current_manager.id).count()
    manager_complexes_count = ManagerFavoriteComplex.query.filter_by(manager_id=current_manager.id).count()
    manager_comparison_properties = ManagerComparison.query.filter_by(manager_id=current_manager.id).count()
    manager_comparison_complexes = ComparisonComplex.query.join(ManagerComparison, ComparisonComplex.manager_comparison_id == ManagerComparison.id).filter(ManagerComparison.manager_id == current_manager.id).count()
    total_favorites = manager_favorites_count + manager_complexes_count
    total_comparison = manager_comparison_properties + manager_comparison_complexes
    
    print(f"DEBUG: Favorites counts loaded - total_favorites={total_favorites}, total_comparison={total_comparison}")
        # Sidebar links для менеджера  
    sidebar_links = [
        {'label': 'Главная', 'href': url_for('manager_dashboard'), 'page': 'dashboard', 'active': True, 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M10 2L3 7v11h3v-6h8v6h3V7l-7-5z"/></svg>'},
        {'label': 'Клиенты', 'href': '#clients', 'page': 'clients', 'badge': str(total_clients) if total_clients else '0', 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM17 6a3 3 0 11-6 0 3 3 0 016 0zM12.93 17c.046-.327.07-.66.07-1a6.97 6.97 0 00-1.5-4.33A5 5 0 0119 16v1h-6.07zM6 11a5 5 0 015 5v1H1v-1a5 5 0 015-5z"/></svg>'},
        {'label': 'Презентации', 'href': '#presentations', 'page': 'presentations', 'badge': str(presentations_count) if 'presentations_count' in locals() else '0', 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M3 4a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1V4zM3 10a1 1 0 011-1h6a1 1 0 011 1v6a1 1 0 01-1 1H4a1 1 0 01-1-1v-6zM14 9a1 1 0 00-1 1v6a1 1 0 001 1h2a1 1 0 001-1v-6a1 1 0 00-1-1h-2z"/></svg>'},
        {'label': 'Избранное', 'href': '#favorites', 'page': 'favorites', 'badge': str(total_favorites), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd"/></svg>'},
        {'label': 'Сделки', 'href': '#deals', 'page': 'deals', 'badge': str(deals_count) if 'deals_count' in locals() else '0', 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 108 0v-1a6 6 0 00-6-6H4a6 6 0 00-6 6v1a4 4 0 108 0z"/></svg>'},
        {'label': 'Настройки', 'href': url_for('profile'), 'page': 'settings', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"/></svg>'}
    ]
    
    # Managers don't have assigned managers
    assigned_manager = None

    user_profile = {'name': f"{current_manager.first_name} {current_manager.last_name}".strip() or current_manager.email.split('@')[0], 'role': 'Менеджер', 'initials': current_manager.first_name[0].upper() if current_manager.first_name else current_manager.email[0].upper(), 'href': url_for('profile'), 'avatar': None}
    try:
        # Balance data for template (manager doesn't have balance, set defaults)
        user_balance = 0
        balance_transactions = []
        
        print("DEBUG: About to render manager dashboard template")
        response = make_response(render_template('auth/manager_dashboard.html',
                             current_manager=current_manager,
                             current_city=current_city,
                             total_clients=total_clients,
                             new_clients_count=new_clients_count,
                             pending_applications_count=pending_applications_count,
                             pending_documents_count=pending_documents_count,
                             total_approved_cashback=total_approved_cashback,
                             recent_activities=recent_activities,
                             pending_notifications=pending_applications_count + pending_documents_count,
                             collections_count=collections_count,
                             presentations_count=presentations_count,
                             deals_count=deals_count,
                             recent_collections=recent_collections,
                             districts=districts,
                             developers=developers,
                             sidebar_links=sidebar_links,
                             user_profile=user_profile,
                             user_balance=user_balance,
                             balance_transactions=balance_transactions,
                             assigned_manager=assigned_manager))
        # Add anti-cache headers
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        return response
    except Exception as e:
        print(f"DEBUG: Error rendering dashboard: {e}")
        import traceback
        traceback.print_exc()
        return f"Error rendering dashboard: {e}", 500


@app.route('/manager/favorites')
@manager_required
def manager_favorites():
    """Manager favorites page - separate page like user favorites"""
    from models import Manager
    
    current_manager = current_user
    
    return render_template('manager/favorites.html', current_manager=current_manager)


@app.route('/manager/presentation/<int:presentation_id>')
@manager_required
def manager_presentation_view(presentation_id):
    """View presentation page inside manager dashboard"""
    from models import Collection, CollectionProperty, Manager
    
    current_manager = current_user
    print(f"DEBUG: Presentation view - manager_id: {current_manager.id}, presentation_id: {presentation_id}")
    
    # Get presentation data
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_manager.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        print(f"DEBUG: Presentation {presentation_id} not found or access denied")
        flash('Презентация не найдена или у вас нет доступа к ней', 'error')
        return redirect(url_for('manager_dashboard'))
    
    # Get presentation properties
    collection_properties = CollectionProperty.query.filter_by(
        collection_id=presentation_id
    ).order_by(CollectionProperty.order_index).all()
    
    print(f"DEBUG: Found {len(collection_properties)} properties in presentation")
    
    # ✅ MIGRATED: Load presentation properties from PostgreSQL using helper
    try:
        print("DEBUG: Loading presentation data from PostgreSQL...")
        enriched_properties = _load_presentation_properties_from_db(presentation.id)
        print(f"DEBUG: Loaded {len(enriched_properties)} enriched properties")
    except Exception as e:
        print(f"ERROR: Failed to load presentation data: {e}")
        import traceback
        traceback.print_exc()
        enriched_properties = []
    
    # Format presentation data for template
    presentation_data = {
        'id': presentation.id,
        'title': presentation.title,
        'description': presentation.description,
        'client_name': presentation.client_name,
        'client_phone': presentation.client_phone,
        'status': presentation.status,
        'created_at': presentation.created_at,
        'view_count': presentation.view_count,
        'last_viewed_at': presentation.last_viewed_at,
        'properties_count': len(enriched_properties),
        'properties': enriched_properties,
        'unique_url': presentation.unique_url
    }
    
    try:
        return render_template('manager/presentation_view.html',
                             manager=current_manager,
                             presentation=presentation_data)
    except Exception as e:
        print(f"DEBUG: Error rendering presentation view: {e}")
        import traceback
        traceback.print_exc()
        flash('Ошибка при загрузке презентации', 'error')
        return redirect(url_for('manager_dashboard'))


# API routes for manager actions
@app.route('/api/manager/clients')
@manager_required
def get_manager_clients_unified():
    """Get ONLY assigned clients for this manager"""
    current_manager = current_user
    
    try:
        print(f"DEBUG: Getting clients for manager {current_manager.id}")
        # Get ALL users assigned to this manager (regardless of role)
        clients = User.query.filter_by(assigned_manager_id=current_manager.id).all()
        print(f"DEBUG: Found {len(clients)} assigned clients for manager {current_manager.id}")
        clients_data = []
        
        for client in clients:
            # Get latest search as preference indicator
            latest_search = SavedSearch.query.filter_by(user_id=client.id).order_by(SavedSearch.last_used.desc()).first()
            
            client_data = {
                'id': client.id,
                'full_name': client.full_name,
                'email': client.email,
                'phone': client.phone or '',
                'created_at': client.created_at.isoformat() if client.created_at else None,
                'search_preferences': None,
                'status': 'active'  # Default status
            }
            
            if latest_search:
                # Create readable search description
                prefs = []
                if latest_search.property_type:
                    prefs.append(latest_search.property_type)
                if latest_search.location:
                    prefs.append(f"район {latest_search.location}")
                if latest_search.price_min or latest_search.price_max:
                    price_range = []
                    if latest_search.price_min:
                        price_range.append(f"от {latest_search.price_min:,} ₽")
                    if latest_search.price_max:
                        price_range.append(f"до {latest_search.price_max:,} ₽")
                    prefs.append(" ".join(price_range))
                
                client_data['search_preferences'] = ", ".join(prefs) if prefs else "Поиск сохранен"
            
            clients_data.append(client_data)
        
        print(f"DEBUG: Returning {len(clients_data)} clients data")
        return jsonify({
            'success': True,
            'clients': clients_data
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/update_client_status', methods=['POST'])
@manager_required
def update_client_status():
    from models import User
    
    current_manager = current_user
    
    data = request.get_json()
    client_id = data.get('client_id')
    new_status = data.get('status')
    notes = data.get('notes', '')
    
    client = User.query.get(client_id)
    if not client or client.assigned_manager_id != current_manager.id:
        return jsonify({'success': False, 'error': 'Клиент не найден'}), 404
    
    try:
        client.client_status = new_status
        if notes:
            client.client_notes = notes
        client.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/approve_cashback', methods=['POST'])
@manager_required
def approve_cashback():
    from models import CashbackApplication, Manager
    
    current_manager = current_user
    
    data = request.get_json()
    application_id = data.get('application_id')
    action = data.get('action')  # approve, reject
    manager_notes = data.get('manager_notes', '')
    
    application = CashbackApplication.query.get(application_id)
    if not application:
        return jsonify({'success': False, 'error': 'Заявка не найдена'}), 404
    
    # Check if client is assigned to this manager
    if application.user.assigned_manager_id != current_manager.id:
        return jsonify({'success': False, 'error': 'У вас нет доступа к этой заявке'}), 403
    
    try:
        if action == 'approve':
            # Check approval limits
            if current_manager and current_manager.max_cashback_approval and application.cashback_amount > current_manager.max_cashback_approval:
                return jsonify({
                    'success': False, 
                    'error': f'Сумма превышает ваш лимит на одобрение ({current_manager.max_cashback_approval:,} ₽)'
                }), 400
            
            application.status = 'Одобрена'
            application.approved_date = datetime.utcnow()
            application.approved_by_manager_id = current_manager.id
            
        elif action == 'reject':
            application.status = 'Отклонена'
        
        if manager_notes:
            application.manager_notes = manager_notes
        
        application.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/contact-requests')
@manager_required  
def get_manager_contact_requests():
    """Get contact manager applications for current manager"""
    try:
        from models import Application
        
        # Get all manager contact applications
        applications = Application.query.filter_by(
            application_type='manager_contact'
        ).order_by(Application.created_at.desc()).all()
        
        result = []
        for app in applications:
            result.append({
                'id': app.id,
                'contact_name': app.contact_name,
                'contact_email': app.contact_email,
                'contact_phone': app.contact_phone,
                'message': app.message,
                'preferred_contact_time': app.preferred_contact_time,
                'status': app.status,
                'created_at': app.created_at.isoformat() if app.created_at else None,
                'updated_at': app.updated_at.isoformat() if app.updated_at else None,
                # Property context if available
                'property_id': app.property_id,
                'property_type': app.property_type,
                'budget_min': app.budget_min,
                'budget_max': app.budget_max
            })
        
        return jsonify({
            'success': True,
            'applications': result,
            'total': len(result)
        })
        
    except Exception as e:
        print(f"Error getting manager contact requests: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/applications')
@manager_required
def get_manager_applications():
    from models import CashbackApplication, User
    
    current_manager = current_user
    
    applications = CashbackApplication.query.join(User).filter(
        User.assigned_manager_id == current_manager.id,
        CashbackApplication.status == 'На рассмотрении'
    ).all()
    
    applications_data = []
    for app in applications:
        applications_data.append({
            'id': app.id,
            'client_name': app.user.full_name,
            'client_email': app.user.email,
            'property_name': app.property_name,
            'complex_name': app.complex_name,
            'cashback_amount': app.cashback_amount,
            'cashback_percent': app.cashback_percent,
            'application_date': app.application_date.strftime('%d.%m.%Y'),
            'status': app.status
        })
    
    return jsonify({'applications': applications_data})

@app.route('/api/manager/documents')
@manager_required
def get_manager_documents():
    from models import Document, User
    
    current_manager = current_user
    
    documents = Document.query.join(User).filter(
        User.assigned_manager_id == current_manager.id,
        Document.status == 'На проверке'
    ).all()
    
    documents_data = []
    for doc in documents:
        documents_data.append({
            'id': doc.id,
            'client_name': doc.user.full_name,
            'client_email': doc.user.email,
            'document_type': doc.document_type or 'Не определен',
            'original_filename': doc.original_filename,
            'file_size': doc.file_size,
            'created_at': doc.created_at.strftime('%d.%m.%Y %H:%M'),
            'status': doc.status
        })
    
    return jsonify({'documents': documents_data})

@app.route('/api/manager/document_action', methods=['POST'])
@manager_required
def manager_document_action():
    from models import Document, Manager
    
    current_manager = current_user
    
    data = request.get_json()
    document_id = data.get('document_id')
    action = data.get('action')  # approve, reject
    notes = data.get('notes', '')
    
    document = Document.query.get(document_id)
    
    if not document:
        return jsonify({'success': False, 'error': 'Документ не найден'}), 404
    
    # Check if client is assigned to this manager
    if document.user.assigned_manager_id != current_manager.id:
        return jsonify({'success': False, 'error': 'У вас нет доступа к этому документу'}), 403
    
    try:
        if action == 'approve':
            document.status = 'Проверен'
        elif action == 'reject':
            document.status = 'Отклонен'
        
        document.reviewed_by_manager_id = current_manager.id
        document.reviewed_at = datetime.utcnow()
        if notes:
            document.reviewer_notes = notes
        
        document.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/application_action', methods=['POST'])
@manager_required
def manager_application_action():
    from models import CashbackApplication, Manager, User
    
    current_manager = current_user
    
    data = request.get_json()
    application_id = data.get('application_id')
    action = data.get('action')  # approve, reject
    notes = data.get('notes', '')
    
    application = CashbackApplication.query.get(application_id)
    
    if not application:
        return jsonify({'success': False, 'error': 'Заявка не найдена'}), 404
    
    # Check if client is assigned to this manager
    if application.user.assigned_manager_id != current_manager.id:
        return jsonify({'success': False, 'error': 'У вас нет доступа к этой заявке'}), 403
    
    try:
        if action == 'approve':
            application.status = 'Одобрена'
            # Add cashback to user's balance
            user = application.user
            user.total_cashback = (user.total_cashback or 0) + application.cashback_amount
        elif action == 'reject':
            application.status = 'Отклонена'
        
        application.reviewed_by_manager_id = current_manager.id
        application.reviewed_at = datetime.utcnow()
        if notes:
            application.manager_notes = notes
        
        application.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collections')
@manager_required
def get_manager_collections():
    from models import Collection, User
    
    current_manager = current_user
    
    collections = Collection.query.filter_by(created_by_manager_id=current_manager.id).all()
    
    collections_data = []
    for collection in collections:
        collections_data.append({
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status,
            'assigned_to_name': collection.assigned_to.full_name if collection.assigned_to else 'Не назначено',
            'assigned_to_id': collection.assigned_to_user_id,
            'properties_count': len(collection.properties),
            'created_at': collection.created_at.strftime('%d.%m.%Y'),
            'tags': collection.tags
        })
    
    return jsonify({'collections': collections_data})

@app.route('/api/manager/collection/create', methods=['POST'])
@manager_required
def api_create_collection():
    from models import Collection, User
    
    current_manager = current_user
    
    data = request.get_json()
    title = data.get('title')
    description = data.get('description', '')
    assigned_to_user_id = data.get('assigned_to_user_id')
    tags = data.get('tags', '')
    
    if not title:
        return jsonify({'success': False, 'error': 'Название подборки обязательно'}), 400
    
    try:
        collection = Collection()
        collection.title = title
        collection.description = description
        collection.created_by_manager_id = current_manager.id
        collection.assigned_to_user_id = assigned_to_user_id if assigned_to_user_id else None
        collection.tags = tags
        collection.status = 'Черновик'
        
        db.session.add(collection)
        db.session.commit()
        
        return jsonify({'success': True, 'collection_id': collection.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collection/<int:collection_id>/properties')
@manager_required
def get_collection_properties(collection_id):
    from models import Collection, CollectionProperty
    
    current_manager = current_user
    
    collection = Collection.query.filter_by(
        id=collection_id,
        created_by_manager_id=current_manager.id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': 'Подборка не найдена'}), 404
    
    properties_data = []
    for prop in collection.properties:
        properties_data.append({
            'id': prop.id,
            'property_id': prop.property_id,
            'property_name': prop.property_name,
            'property_price': prop.property_price,
            'complex_name': prop.complex_name,
            'property_type': prop.property_type,
            'property_size': prop.property_size,
            'manager_note': prop.manager_note,
            'order_index': prop.order_index
        })
    
    # Sort by order_index
    properties_data.sort(key=lambda x: x['order_index'])
    
    return jsonify({
        'collection': {
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status
        },
        'properties': properties_data
    })



@app.route('/api/searches/save', methods=['POST'])
@login_required
def api_save_search():
    """Save a search with filters"""
    from models import SavedSearch
    
    data = request.get_json()
    name = data.get('name')
    filters = data.get('filters', {})
    
    if not name:
        return jsonify({'success': False, 'error': 'Название поиска обязательно'}), 400
    
    try:
        search = SavedSearch()
        search.name = name
        search.filters = json.dumps(filters)
        search.user_id = current_user.id
        search.created_at = datetime.utcnow()
        
        db.session.add(search)
        db.session.commit()
        
        return jsonify({'success': True, 'search_id': search.id})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/searches', methods=['POST'])
@manager_required
def api_manager_save_search():
    """Save a search for a manager"""
    from models import ManagerSavedSearch, Manager, SentSearch
    
    current_manager = current_user
    
    data = request.get_json()
    name = data.get('name')
    filters = data.get('filters', {})
    client_email = data.get('client_email', '')
    
    if not name:
        return jsonify({'success': False, 'error': 'Название поиска обязательно'}), 400
    
    try:
        # Create saved search
        search = ManagerSavedSearch()
        search.name = name
        search.additional_filters = json.dumps(filters)
        search.manager_id = current_manager.id
        search.created_at = datetime.utcnow()
        
        db.session.add(search)
        db.session.commit()
        
        # If client email provided, also create sent search record and send notification
        if client_email:
            sent_search = SentSearch()
            sent_search.saved_search_id = search.id
            sent_search.recipient_email = client_email
            sent_search.sent_at = datetime.utcnow()
            sent_search.manager_id = current_manager.id
            
            db.session.add(sent_search)
            db.session.commit()
            
            # Send notification to client
            manager_name = current_manager.name if current_manager else "Менеджер"
            
            try:
                send_notification(
                    recipient_email=client_email,
                    subject=f"Новый подбор недвижимости от {manager_name}",
                    message=f"Менеджер {manager_name} подготовил для вас персональный подбор недвижимости '{name}'. Посмотрите варианты на сайте InBack.ru",
                    notification_type='saved_search',
                    user_id=None,
                    manager_id=current_manager.id
                )
                return jsonify({'success': True, 'search_id': search.id, 'sent_to_client': True})
            except Exception as email_error:
                print(f"Failed to send email notification: {email_error}")
                return jsonify({'success': True, 'search_id': search.id, 'sent_to_client': False, 'email_error': str(email_error)})
        
        return jsonify({'success': True, 'search_id': search.id, 'sent_to_client': False})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send_recommendation', methods=['POST'])
@manager_required
def api_manager_send_recommendation():
    """Send a recommendation (property or complex) to a client"""
    from models import Recommendation, Manager, User, RecommendationCategory
    from datetime import datetime
    
    current_manager = current_user
    
    data = request.get_json()
    title = data.get('title', '').strip()
    client_id = data.get('client_id')  # Now using client_id instead of email
    client_email = data.get('client_email', '').strip()
    recommendation_type = data.get('recommendation_type')  # 'property' or 'complex'
    item_id = data.get('item_id')
    item_name = data.get('item_name', '').strip()
    description = data.get('description', '').strip()
    manager_notes = data.get('manager_notes', '').strip()
    highlighted_features = data.get('highlighted_features', [])
    priority_level = data.get('priority_level', 'normal')
    category_id = data.get('category_id')  # New field for category
    category_name = data.get('category_name', '').strip()  # For creating new category
    
    # Debug logging (removing verbose logs for production)
    print(f"DEBUG: Recommendation sent - type={recommendation_type}, item_id={item_id}, client_id={client_id}")
    
    # Validation
    missing_fields = []
    if not title:
        missing_fields.append('заголовок')
    if not client_id:
        missing_fields.append('клиент')
    if not recommendation_type:
        missing_fields.append('тип рекомендации')
    if not item_id:
        missing_fields.append('ID объекта')
    if not item_name:
        missing_fields.append('название объекта')
    
    if missing_fields:
        return jsonify({'success': False, 'error': f'Заполните обязательные поля: {", ".join(missing_fields)}'}), 400
    
    if recommendation_type not in ['property', 'complex']:
        return jsonify({'success': False, 'error': 'Неверный тип рекомендации'}), 400
    
    try:
        # Find client by ID
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': 'Клиент не найден'}), 400
        
        # Handle category
        category = None
        if category_id == 'new' and category_name:
            # Create new category
            category = RecommendationCategory(
                name=category_name,
                manager_id=current_manager.id,
                client_id=client_id
            )
            db.session.add(category)
            db.session.flush()  # To get the ID
        elif category_id and category_id != 'new':
            # Use existing category
            category = RecommendationCategory.query.filter_by(
                id=category_id,
                manager_id=current_manager.id,
                client_id=client_id,
                is_active=True
            ).first()
        
        # Create recommendation
        recommendation = Recommendation()
        recommendation.manager_id = current_manager.id
        recommendation.client_id = client.id
        recommendation.title = title
        recommendation.description = description
        recommendation.recommendation_type = recommendation_type
        recommendation.item_id = item_id
        recommendation.item_name = item_name
        recommendation.manager_notes = manager_notes
        recommendation.highlighted_features = json.dumps(highlighted_features) if highlighted_features else None
        recommendation.priority_level = priority_level
        recommendation.item_data = json.dumps(data.get('item_data', {}))  # Store full item details
        recommendation.category_id = category.id if category else None
        
        db.session.add(recommendation)
        
        # Update category statistics
        if category:
            category.recommendations_count += 1
            category.last_used = datetime.utcnow()
        
        db.session.commit()
        
        # Send notification to client
        manager = Manager.query.get(manager_id)
        manager_name = manager.name if manager else "Менеджер"
        
        try:
            # Get priority text for notifications
            priority_texts = {
                'urgent': 'Срочно',
                'high': 'Высокий', 
                'normal': 'Обычный'
            }
            priority_text = priority_texts.get(priority_level, 'Обычный')
            
            send_notification(
                recipient_email=client_email,
                subject=f"Новая рекомендация от {manager_name}",
                message=f"Менеджер {manager_name} рекомендует вам: {title}",
                notification_type='recommendation',
                user_id=client.id,
                manager_id=current_manager.id,
                title=title,
                item_id=item_id,
                item_name=item_name,
                description=description,
                manager_name=manager_name,
                priority_text=priority_text,
                recommendation_type=recommendation_type
            )
            return jsonify({'success': True, 'recommendation_id': recommendation.id, 'sent_to_client': True})
        except Exception as email_error:
            print(f"Failed to send email notification: {email_error}")
            return jsonify({'success': True, 'recommendation_id': recommendation.id, 'sent_to_client': False, 'email_error': str(email_error)})
        
    except Exception as e:
        db.session.rollback()
        import traceback
        error_trace = traceback.format_exc()
        print(f"Error creating recommendation: {str(e)}")
        print(f"Full traceback: {error_trace}")
        return jsonify({'success': False, 'error': str(e), 'traceback': error_trace}), 400

@app.route('/api/manager/recommendations', methods=['GET'])
@manager_required
def api_manager_get_recommendations():
    """Get manager's sent recommendations with filters"""
    from models import Recommendation
    
    current_manager = current_user
    
    try:
        # Start with base query
        query = Recommendation.query.filter_by(manager_id=current_manager.id)
        
        # Apply filters from request params
        client_id = request.args.get('client_id')
        status = request.args.get('status')
        rec_type = request.args.get('type')
        priority = request.args.get('priority')
        
        if client_id:
            query = query.filter(Recommendation.client_id == client_id)
        if status:
            query = query.filter(Recommendation.status == status)
        if rec_type:
            query = query.filter(Recommendation.item_type == rec_type)
        if priority:
            query = query.filter(Recommendation.priority == priority)
        
        recommendations = query.order_by(Recommendation.sent_at.desc()).all()
        
        recommendations_data = []
        stats = {'sent': 0, 'viewed': 0, 'interested': 0, 'scheduled': 0}
        
        for rec in recommendations:
            rec_dict = rec.to_dict()
            rec_dict['client_email'] = rec.client.email
            rec_dict['client_name'] = rec.client.full_name
            recommendations_data.append(rec_dict)
            
            # Update stats
            stats['sent'] += 1
            if rec.status == 'viewed':
                stats['viewed'] += 1
            elif rec.status == 'interested':
                stats['interested'] += 1
            elif rec.status == 'scheduled_viewing':
                stats['scheduled'] += 1
        
        return jsonify({
            'success': True, 
            'recommendations': recommendations_data,
            'stats': stats
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/recommendations/<int:recommendation_id>', methods=['DELETE'])
@manager_required  
def api_manager_delete_recommendation(recommendation_id):
    """Delete a recommendation"""
    from models import Recommendation
    
    current_manager = current_user
    
    try:
        # Find recommendation that belongs to this manager
        recommendation = Recommendation.query.filter_by(
            id=recommendation_id, 
            manager_id=current_manager.id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': 'Рекомендация не найдена'}), 404
        
        db.session.delete(recommendation)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Рекомендация успешно удалена'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/clients-list', methods=['GET'])
@manager_required
def api_manager_get_clients_list():
    """Get manager's clients for filters"""
    from models import User
    
    current_manager = current_user
    
    try:
        # Get clients assigned to this manager or all buyers
        clients = User.query.filter_by(role='buyer').order_by(User.full_name).all()
        
        clients_data = []
        for client in clients:
            clients_data.append({
                'id': client.id,
                'full_name': client.full_name or 'Без имени',
                'email': client.email
            })
        
        return jsonify({
            'success': True,
            'clients': clients_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/properties/search', methods=['POST'])
@login_required
def api_search_properties():
    """Search properties with filters from dashboard"""
    data = request.get_json()
    filters = data.get('filters', {})
    
    try:
        # Convert collection filters to property filters
        property_filters = {}
        
        if filters.get('priceFrom'):
            property_filters['price_min'] = filters['priceFrom']
        if filters.get('priceTo'):
            property_filters['price_max'] = filters['priceTo']
        if filters.get('rooms'):
            property_filters['rooms'] = filters['rooms']
        if filters.get('districts') and filters['districts']:
            property_filters['district'] = filters['districts'][0]
        if filters.get('developers') and filters['developers']:
            property_filters['developer'] = filters['developers'][0]
        if filters.get('areaFrom'):
            property_filters['area_min'] = filters['areaFrom']
        if filters.get('areaTo'):
            property_filters['area_max'] = filters['areaTo']
        
        # Get filtered properties
        filtered_properties = get_filtered_properties(property_filters)
        
        # Add cashback to each property
        for prop in filtered_properties:
            prop['cashback'] = calculate_cashback(
                prop['price'],
                complex_id=prop.get('complex_id'),
                complex_name=prop.get('residential_complex')
            )
        
        # Sort by price ascending
        filtered_properties = sort_properties(filtered_properties, 'price_asc')
        
        return jsonify({
            'success': True,
            'properties': filtered_properties[:50],  # Limit to 50 results
            'total_count': len(filtered_properties)
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-property', methods=['POST'])
@manager_required
def api_send_property_to_client():
    """Send saved search results to client via email"""
    from models import SavedSearch, User, ClientPropertyRecommendation
    
    data = request.get_json()
    client_id = data.get('client_id')
    search_id = data.get('search_id')
    message = data.get('message', '')
    
    if not client_id or not search_id:
        return jsonify({'success': False, 'error': 'Клиент и поиск обязательны'}), 400
    
    try:
        # Get the search
        search = SavedSearch.query.get(search_id)
        if not search:
            return jsonify({'success': False, 'error': 'Поиск не найден'}), 404
        
        # Get the client
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': 'Клиент не найден'}), 404
        
        # Get search filters
        filters = json.loads(search.filters) if search.filters else {}
        
        # Filter properties based on search criteria
        properties = load_properties()
        filtered_properties = filter_properties(properties, filters)
        
        # Create recommendation record
        recommendation = ClientPropertyRecommendation()
        recommendation.client_id = client_id
        recommendation.manager_id = current_user.id
        recommendation.search_name = search.name
        recommendation.search_filters = search.filters
        recommendation.message = message
        recommendation.properties_count = len(filtered_properties)
        recommendation.sent_at = datetime.utcnow()
        
        db.session.add(recommendation)
        db.session.commit()
        
        # Send email with property recommendations
        send_property_email(client, search.name, filtered_properties, message)
        
        return jsonify({'success': True, 'properties_sent': len(filtered_properties)})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

def filter_properties(properties, filters):
    """Filter properties based on search criteria"""
    filtered = []
    
    for prop in properties:
        # Price filter
        if filters.get('priceFrom'):
            try:
                if prop.get('price', 0) < int(filters['priceFrom']):
                    continue
            except (ValueError, TypeError):
                pass
        
        if filters.get('priceTo'):
            try:
                if prop.get('price', 0) > int(filters['priceTo']):
                    continue
            except (ValueError, TypeError):
                pass
        
        # Rooms filter
        if filters.get('rooms'):
            prop_rooms = str(prop.get('rooms', ''))
            if filters['rooms'] == 'studio' and prop_rooms != 'studio':
                continue
            elif filters['rooms'] != 'studio' and prop_rooms != str(filters['rooms']):
                continue
        
        # District filter
        if filters.get('districts') and len(filters['districts']) > 0:
            prop_district = prop.get('district', '')
            if prop_district not in filters['districts']:
                continue
        
        # Area filter
        if filters.get('areaFrom'):
            try:
                if prop.get('area', 0) < int(filters['areaFrom']):
                    continue
            except (ValueError, TypeError):
                pass
        
        if filters.get('areaTo'):
            try:
                if prop.get('area', 0) > int(filters['areaTo']):
                    continue
            except (ValueError, TypeError):
                pass
        
        # Developer filter
        if filters.get('developers') and len(filters['developers']) > 0:
            prop_developer = prop.get('developer', '')
            if prop_developer not in filters['developers']:
                continue
        
        filtered.append(prop)
    
    return filtered

def send_property_email(client, search_name, properties, message):
    """Send email with property recommendations"""
    try:
        subject = f"Новая подборка недвижимости: {search_name}"
        
        properties_html = ""
        for prop in properties[:10]:  # Limit to first 10 properties
            properties_html += f"""
            <div style="border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
                <h3 style="margin: 0 0 8px 0; color: #1f2937;">{prop.get('name', 'Без названия')}</h3>
                <p style="margin: 0 0 4px 0; color: #6b7280;">ЖК: {prop.get('complex_name', 'Не указан')}</p>
                <p style="margin: 0 0 4px 0; color: #6b7280;">Цена: {prop.get('price', 0):,} ₽</p>
                <p style="margin: 0 0 4px 0; color: #6b7280;">Площадь: {prop.get('area', 0)} м²</p>
                <p style="margin: 0 0 8px 0; color: #6b7280;">Комнат: {prop.get('rooms', 'Не указано')}</p>
                <a href="https://inback.ru/properties/{prop.get('id', '')}" style="color: #0088cc; text-decoration: none;">Подробнее →</a>
            </div>
            """
        
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <h2 style="color: #0088cc;">Персональная подборка недвижимости</h2>
                
                <p>Здравствуйте, {client.full_name}!</p>
                
                <p>Ваш менеджер подготовил для вас подборку недвижимости: <strong>{search_name}</strong></p>
                
                {f'<div style="background: #f3f4f6; padding: 16px; border-radius: 8px; margin: 16px 0;"><p style="margin: 0; font-style: italic;">"{message}"</p></div>' if message else ''}
                
                <h3>Найденные варианты ({len(properties)} объектов):</h3>
                
                {properties_html}
                
                {f'<p style="color: #6b7280;">И еще {len(properties) - 10} объектов в полном каталоге...</p>' if len(properties) > 10 else ''}
                
                <div style="margin-top: 32px; padding: 20px; background: #f9fafb; border-radius: 8px; text-align: center;">
                    <h3 style="margin: 0 0 8px 0;">Нужна консультация?</h3>
                    <p style="margin: 0 0 16px 0;">Свяжитесь с вашим персональным менеджером</p>
                    <a href="mailto:manager@inback.ru" style="background: #0088cc; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">Написать менеджеру</a>
                </div>
                
                <div style="margin-top: 20px; text-align: center; color: #6b7280; font-size: 14px;">
                    <p>С уважением,<br>Команда InBack.ru</p>
                </div>
            </div>
        </body>
        </html>
        """
        
        return send_notification(
            client.email,
            subject,
            html_content,
            notification_type="property_recommendation",
            user_id=client.id
        )
    except Exception as e:
        print(f"Error sending property email: {e}")
        return False

@app.route('/api/manager/collection/<int:collection_id>/add_property', methods=['POST'])
@manager_required
def add_property_to_collection(collection_id):
    from models import Collection, CollectionProperty
    import json
    
    current_manager = current_user
    
    data = request.get_json()
    property_id = data.get('property_id')
    manager_note = data.get('manager_note', '')
    
    collection = Collection.query.filter_by(
        id=collection_id,
        created_by_manager_id=current_manager.id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': 'Подборка не найдена'}), 404
    
    # Load property data from JSON
    try:
        with open('data/properties.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        property_info = None
        for prop in properties_data:
            if str(prop['id']) == str(property_id):
                property_info = prop
                break
        
        if not property_info:
            return jsonify({'success': False, 'error': 'Квартира не найдена'}), 404
        
        # Check if property already in collection
        existing = CollectionProperty.query.filter_by(
            collection_id=collection_id,
            property_id=str(property_id)
        ).first()
        
        if existing:
            return jsonify({'success': False, 'error': 'Квартира уже добавлена в подборку'}), 400
        
        # Get max order_index
        max_order = db.session.query(db.func.max(CollectionProperty.order_index)).filter_by(
            collection_id=collection_id
        ).scalar() or 0
        
        # DUAL WRITE: Get Property object to access both database ID and inner_id
        from models import Property as PropertyModel
        property_obj, canonical_id = resolve_property_by_identifier(property_id)
        if not property_obj:
            return jsonify({'success': False, 'error': 'Объект не найден в базе данных'}), 404
        
        collection_property = CollectionProperty()
        collection_property.collection_id = collection_id
        collection_property.property_id = str(property_obj.id)  # Old: database ID
        collection_property.property_inner_id = property_obj.inner_id  # NEW: canonical inner_id
        collection_property.property_name = property_info['title']
        collection_property.property_price = property_info['price']
        collection_property.complex_name = property_info.get('residential_complex', 'ЖК не указан')
        collection_property.property_type = f"{property_info['rooms']}-комн"
        collection_property.property_size = property_info['area']
        collection_property.manager_note = manager_note
        collection_property.order_index = max_order + 1
        
        db.session.add(collection_property)
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collection/<int:collection_id>/send', methods=['POST'])
@manager_required
def send_collection(collection_id):
    from models import Collection
    
    current_manager = current_user
    
    collection = Collection.query.filter_by(
        id=collection_id,
        created_by_manager_id=current_manager.id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': 'Подборка не найдена'}), 404
    
    if not collection.assigned_to_user_id:
        return jsonify({'success': False, 'error': 'Клиент не назначен'}), 400
    
    if len(collection.properties) == 0:
        return jsonify({'success': False, 'error': 'В подборке нет квартир'}), 400
    
    try:
        collection.status = 'Отправлена'
        collection.sent_at = datetime.utcnow()
        collection.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/properties/search')
@manager_required
def search_properties():
    """Search properties using normalized tables"""
    from repositories.property_repository import PropertyRepository
    
    query = request.args.get('q', '').lower()
    limit = int(request.args.get('limit', 20))
    
    try:
        properties = PropertyRepository.get_all_active(limit=limit * 3)
        
        filtered_properties = []
        for prop in properties:
            prop_type = f"{prop.rooms}-комн" if prop.rooms > 0 else "Студия"
            complex_name = prop.residential_complex.name if prop.residential_complex else 'ЖК не указан'
            developer_name = prop.developer.name if prop.developer else ''
            district_name = prop.residential_complex.district if prop.residential_complex else ''
            
            property_title = f"{prop.rooms}-комн {prop.area} м²" if prop.rooms > 0 else f"Студия {prop.area} м²"
            
            if (query in property_title.lower() or 
                query in complex_name.lower() or 
                query in prop_type.lower() or
                query in developer_name.lower() or
                query in district_name.lower()):
                
                photos_list = []
                if prop.gallery_images:
                    try:
                        if isinstance(prop.gallery_images, list):
                            photos_list = prop.gallery_images
                        elif isinstance(prop.gallery_images, str):
                            photos_list = json.loads(prop.gallery_images)
                    except:
                        pass
                
                main_image = prop.main_image or (photos_list[0] if photos_list else '/static/images/property-placeholder.jpg')
                
                filtered_properties.append({
                    'id': prop.inner_id or prop.id,
                    'title': property_title,
                    'price': prop.price or 0,
                    'complex': complex_name,
                    'type': prop_type,
                    'size': prop.area or 0,
                    'image': main_image
                })
            
            if len(filtered_properties) >= limit:
                break
        
        return jsonify({'properties': filtered_properties})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/client/collections')
@login_required
def get_client_collections():
    """Get collections assigned to current user"""
    from models import Collection, CollectionProperty
    from datetime import datetime
    
    user_id = current_user.id
    
    collections = Collection.query.filter_by(assigned_to_user_id=user_id).all()
    
    collections_data = []
    for collection in collections:
        properties_count = len(collection.properties)
        
        # Mark as viewed if not already
        if collection.status == 'Отправлена':
            collection.status = 'Просмотрена'
            collection.viewed_at = datetime.utcnow()
            db.session.commit()
        
        collections_data.append({
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status,
            'created_by_manager_name': collection.created_by.full_name,
            'properties_count': properties_count,
            'created_at': collection.created_at.strftime('%d.%m.%Y'),
            'sent_at': collection.sent_at.strftime('%d.%m.%Y %H:%M') if collection.sent_at else None,
            'tags': collection.tags
        })
    
    return jsonify({'collections': collections_data})

@app.route('/api/client/collection/<int:collection_id>/properties')
@login_required
def get_client_collection_properties(collection_id):
    """Get properties in a collection for client view"""
    from models import Collection, CollectionProperty
    
    user_id = current_user.id
    
    collection = Collection.query.filter_by(
        id=collection_id,
        assigned_to_user_id=user_id
    ).first()
    
    if not collection:
        return jsonify({'success': False, 'error': 'Подборка не найдена'}), 404
    
    properties_data = []
    for prop in collection.properties:
        # Calculate potential cashback (example: 2% of price)
        cashback_percent = 2.0
        cashback_amount = int(prop.property_price * cashback_percent / 100)
        
        properties_data.append({
            'id': prop.id,
            'property_id': prop.property_id,
            'property_name': prop.property_name,
            'property_price': prop.property_price,
            'complex_name': prop.complex_name,
            'property_type': prop.property_type,
            'property_size': prop.property_size,
            'manager_note': prop.manager_note,
            'cashback_amount': cashback_amount,
            'cashback_percent': cashback_percent
        })
    
    # Sort by order_index
    properties_data.sort(key=lambda x: collection.properties[0].order_index if collection.properties else 0)
    
    return jsonify({
        'collection': {
            'id': collection.id,
            'title': collection.title,
            'description': collection.description,
            'status': collection.status,
            'manager_name': collection.created_by.full_name,
            'sent_at': collection.sent_at.strftime('%d.%m.%Y %H:%M') if collection.sent_at else None
        },
        'properties': properties_data
    })

@app.route('/dashboard')
@login_required
def dashboard():
    """User dashboard - ИСПРАВЛЕНО: редиректит админов и менеджеров"""
    from models import Admin, Manager
    
    # КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Проверяем тип пользователя
    # Админы и менеджеры НЕ должны попадать в пользовательский dashboard
    if isinstance(current_user._get_current_object(), Admin):
        return redirect(url_for('admin_dashboard'))
    elif isinstance(current_user._get_current_object(), Manager):
        return redirect(url_for('manager_dashboard'))
    
    try:
        from models import CashbackApplication, FavoriteProperty, FavoriteComplex, Document, Collection, Recommendation, SentSearch, SavedSearch, UserActivity, Deal, UserBalance, BalanceTransaction
        
        # Get user's data for dashboard
        cashback_apps = CashbackApplication.query.filter_by(user_id=current_user.id).all()
        favorites = FavoriteProperty.query.filter_by(user_id=current_user.id).all()
        complex_favorites = FavoriteComplex.query.filter_by(user_id=current_user.id).all()
        documents = Document.query.filter_by(user_id=current_user.id).all()
        collections = Collection.query.filter_by(assigned_to_user_id=current_user.id).order_by(Collection.created_at.desc()).all()
        
        # Get user's deals (сделки созданные менеджером для этого клиента)
        deals = Deal.query.filter_by(client_id=current_user.id).order_by(Deal.created_at.desc()).all()
        
        # Get recommendations from managers (exclude dismissed) with categories
        recommendations = Recommendation.query.filter(
            Recommendation.client_id == current_user.id,
            Recommendation.status != 'dismissed'
        ).options(db.joinedload(Recommendation.category)).order_by(Recommendation.created_at.desc()).all()
        
        # Get unique categories for the client (import here to avoid circular imports)
        from models import RecommendationCategory
        categories = RecommendationCategory.query.filter_by(client_id=current_user.id, is_active=True).all()
        
        # ОПТИМИЗАЦИЯ: Загружаем только нужные properties для recommendations из БД
        from models import Property, ResidentialComplex
        
        # Получаем ID нужных объектов
        property_ids = [rec.item_id for rec in recommendations if rec.recommendation_type == 'property' and rec.item_id]
        
        # Загружаем только нужные properties с JOIN (одним запросом!)
        properties_dict = {}
        if property_ids:
            properties_query = db.session.query(
                Property,
                ResidentialComplex.name.label('complex_name')
            ).outerjoin(
                ResidentialComplex, Property.complex_id == ResidentialComplex.id
            ).filter(
                Property.inner_id.in_(property_ids),
                Property.is_active == True
            ).all()
            
            for prop, complex_name in properties_query:
                properties_dict[prop.inner_id] = {
                    'id': str(prop.id),
                    'rooms': prop.rooms,
                    'area': prop.area,
                    'floor': prop.floor,
                    'total_floors': prop.total_floors,
                    'price': prop.price,
                    'main_image': prop.main_image,
                    'complex_name': complex_name,
                    'property_type': 'apartment',
                    'property_type_ru': 'Квартира'
                }
        
        # Enrich recommendations with property details
        for rec in recommendations:
            if rec.recommendation_type == 'property' and rec.item_id:
                try:
                    property_data = properties_dict.get(rec.item_id)
                    if property_data:
                        # Create a simple object to store property details
                        class PropertyDetails:
                            def __init__(self, data):
                                for key, value in data.items():
                                    setattr(self, key, value)
                                self.residential_complex = data.get('complex_name', 'Не указан')
                        
                        rec.property_details = PropertyDetails(property_data)
                        print(f"✅ Loaded property {rec.item_id}: {property_data.get('rooms')} комн, ЖК {property_data.get('complex_name')}")
                    else:
                        print(f"Property {rec.item_id} not found in database")
                        rec.property_details = None
                except Exception as e:
                    print(f"Error loading property details for recommendation {rec.id}: {e}")
                    rec.property_details = None
        
        # Get sent searches from managers
        sent_searches = SentSearch.query.filter_by(client_id=current_user.id).order_by(SentSearch.sent_at.desc()).all()
        
        # Get user's saved searches
        saved_searches = SavedSearch.query.filter_by(user_id=current_user.id).order_by(SavedSearch.created_at.desc()).all()
        
        # Calculate totals from DEALS (сделки от менеджеров - это реальные данные!)
        # Используем Decimal для точности!
        from decimal import Decimal
        
        # Выплаченный кешбек = сделки со статусом "completed"
        total_cashback = sum((deal.cashback_amount for deal in deals if deal.status == 'completed'), Decimal('0'))
        
        # В обработке = сделки со статусами new, reserved, mortgage (все кроме completed и rejected)
        pending_cashback = sum((deal.cashback_amount for deal in deals if deal.status in ['new', 'reserved', 'mortgage']), Decimal('0'))
        
        # Количество активных сделок (все кроме completed и rejected)
        active_apps = len([deal for deal in deals if deal.status not in ['completed', 'rejected']])
        
        # Также показываем количество заявок на кешбек (старая система)
        cashback_applications_count = len(cashback_apps)
        cashback_apps_pending = len([app for app in cashback_apps if app.status in ['На рассмотрении', 'Требуются документы']])
        
        # Get developer appointments
        from models import DeveloperAppointment, BalanceTransaction
        appointments = DeveloperAppointment.query.filter_by(user_id=current_user.id).order_by(DeveloperAppointment.appointment_date.desc()).limit(3).all()
        
        # Load data for manager filters
        districts = get_districts_list()
        developers = get_developers_list()
        
        # Get recent user activities
        recent_activities = UserActivity.get_recent_activities(current_user.id, limit=5)
        
        # Load balance data
        # ✅ ИСПРАВЛЕНО: Используем available_amount из UserBalance, а не общий balance
        user_balance_obj = UserBalance.query.filter_by(user_id=current_user.id).first()
        user_balance = float(user_balance_obj.available_amount) if user_balance_obj else 0
        balance_transactions = BalanceTransaction.query.filter_by(user_id=current_user.id).order_by(BalanceTransaction.created_at.desc()).limit(10).all()

        # Load comparison data (properties and complexes)
        from models import ComparisonProperty, ComparisonComplex, Property, UserComparison
        comparison_properties_count = db.session.query(ComparisonProperty).join(
            UserComparison, ComparisonProperty.user_comparison_id == UserComparison.id
        ).filter(UserComparison.user_id == current_user.id).count()
        
        comparison_complexes_count = db.session.query(ComparisonComplex).join(
            UserComparison, ComparisonComplex.user_comparison_id == UserComparison.id
        ).filter(UserComparison.user_id == current_user.id).count()
        
        total_comparison = comparison_properties_count + comparison_complexes_count
        
        # Load favorites with join to Property to exclude orphaned records
        favorites_with_properties = db.session.query(FavoriteProperty).join(
            Property, Property.inner_id == FavoriteProperty.property_id
        ).filter(
            FavoriteProperty.user_id == current_user.id,
            Property.is_active == True
        ).all()

        
        # Query complex favorites
        favorites_complexes = FavoriteComplex.query.filter_by(user_id=current_user.id).all()
        # Count collections (presentations) assigned to user
        collections_count = Collection.query.filter_by(assigned_to_user_id=current_user.id).count()

        # Sidebar links для покупателя
        sidebar_links = [
            {'label': 'Главная', 'href': '#dashboard', 'page': 'dashboard', 'active': True, 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg>'},
            {'label': 'Избранное', 'href': '#favorites', 'page': 'favorites', 'badge': str(len(favorites_with_properties) + len(favorites_complexes)), 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z" clip-rule="evenodd"/></svg>'},
            {'label': 'Сделки', 'href': '#deals', 'page': 'deals', 'badge': str(len(deals)) if deals else '0', 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3z"/></svg>'},
            {'label': 'Рекомендации', 'href': '#recommendations', 'page': 'recommendations', 'badge': str(collections_count) if collections_count else '0', 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/></svg>'},
            {'label': 'Баланс', 'href': '#balance', 'page': 'balance', 'badge': str(int(user_balance)) + ' ₽' if user_balance else '0 ₽', 'badge_color': 'gray', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path d="M4 4a2 2 0 00-2 2v1h16V6a2 2 0 00-2-2H4z"/><path fill-rule="evenodd" d="M18 9H2v5a2 2 0 002 2h12a2 2 0 002-2V9zM4 13a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zm5-1a1 1 0 100 2h1a1 1 0 100-2H9z" clip-rule="evenodd"/></svg>'},
            {'label': 'Настройки', 'href': '#settings', 'page': 'settings', 'icon': '<svg fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"/></svg>'}
        ]
        user_profile = {
            'name': current_user.full_name if hasattr(current_user, 'full_name') and current_user.full_name else (current_user.email.split('@')[0] if '@' in current_user.email else current_user.email[:15]), 
            'role': 'Покупатель', 
            'initials': current_user.full_name[0].upper() if hasattr(current_user, 'full_name') and current_user.full_name else (current_user.email[0].upper() if current_user.email else 'U'), 
            'href': url_for('profile'), 
            'avatar': current_user.profile_image if hasattr(current_user, 'profile_image') and current_user.profile_image else None
        }
        
        
        # Get assigned manager info for settings tab
        assigned_manager = None
        if current_user.assigned_manager_id:
            assigned_manager = Manager.query.get(current_user.assigned_manager_id)
        return render_template('auth/dashboard.html', 
                             cashback_applications=cashback_apps,
                             favorites=favorites,
                             complex_favorites=complex_favorites,
                             documents=documents,
                             collections=collections,
                             appointments=appointments,
                             recommendations=recommendations,
                             categories=categories,
                             sent_searches=sent_searches,
                             saved_searches=saved_searches,
                             deals=deals,
                             total_cashback=total_cashback,
                             pending_cashback=pending_cashback,
                             active_apps=active_apps,
                             districts=districts,
                             developers=developers,
                             recent_activities=recent_activities,
                             sidebar_links=sidebar_links,
                             user_profile=user_profile,
                             user_balance=user_balance,
                             balance=user_balance,
                             balance_transactions=balance_transactions,
                             assigned_manager=assigned_manager)
    except Exception as e:
        print(f"Dashboard error: {str(e)}")
        import traceback
        traceback.print_exc()
        # Return basic dashboard on error
        districts = get_districts_list()
        developers = get_developers_list()
        
        return render_template('auth/dashboard.html', 
                             cashback_applications=[],
                             favorites=[],
                             complex_favorites=[],
                             documents=[],
                             collections=[],
                             appointments=[],
                             recommendations=[],
                             sent_searches=[],
                             saved_searches=[],
                             deals=[],
                             total_cashback=0,
                             pending_cashback=0,
                             active_apps=0,
                             districts=districts,
                             developers=developers,
                             recent_activities=[])

@app.route('/logout')
@login_required
def logout():
    """Logout user - ИСПРАВЛЕНО: очищает ВСЕ сессии"""
    logout_user()  # Flask-Login logout
    
    # Очищаем все ручные сессии (legacy код)
    session.pop('manager_id', None)
    session.pop('admin_id', None)
    session.pop('is_manager', None)
    session.pop('is_admin', None)
    session.pop('user_id', None)
    session.pop('temp_user_id', None)
    
    flash('Вы успешно вышли из системы', 'success')
    return redirect(url_for('index'))

@app.route('/profile', methods=['GET', 'POST'])
@login_required
def profile():
    """User profile page - now integrated into dashboard settings tab"""
    
    if request.method == 'POST':
        try:
            # Update profile information
            current_user.full_name = request.form.get('full_name', current_user.full_name)
            current_user.phone = request.form.get('phone', current_user.phone)
            current_user.email = request.form.get('email', current_user.email)
            current_user.telegram_id = request.form.get('telegram_id', current_user.telegram_id)
            
            # Update password if provided
            new_password = request.form.get('new_password')
            if new_password:
                confirm_password = request.form.get('confirm_password')
                if new_password == confirm_password:
                    current_user.password_hash = generate_password_hash(new_password)
                    flash('Пароль успешно изменен', 'success')
                else:
                    flash('Пароли не совпадают', 'error')
                    return redirect(url_for('dashboard') + '#settings')
            
            db.session.commit()
            flash('Профиль успешно обновлен', 'success')
            return redirect(url_for('dashboard') + '#settings')
        except Exception as e:
            db.session.rollback()
            flash(f'Ошибка при обновлении профиля: {str(e)}', 'error')
            return redirect(url_for('dashboard') + '#settings')
    
    # GET request - redirect to dashboard settings tab
    return redirect(url_for('dashboard') + '#settings')

@app.route('/manager/profile', methods=['GET', 'POST'])
@manager_required
def manager_profile():
    """Manager profile page"""
    from models import Manager
    
    current_manager = current_user
    
    if request.method == 'POST':
        try:
            # Update profile information
            full_name = request.form.get('full_name', '')
            if full_name:
                name_parts = full_name.strip().split(maxsplit=1)
                current_manager.first_name = name_parts[0] if len(name_parts) > 0 else current_manager.first_name
                current_manager.last_name = name_parts[1] if len(name_parts) > 1 else current_manager.last_name
            
            current_manager.phone = request.form.get('phone', current_manager.phone)
            current_manager.email = request.form.get('email', current_manager.email)
            
            # Update password if provided
            new_password = request.form.get('new_password')
            if new_password:
                confirm_password = request.form.get('confirm_password')
                if new_password == confirm_password:
                    current_manager.password_hash = generate_password_hash(new_password)
                    flash('Пароль успешно изменен', 'success')
                else:
                    flash('Пароли не совпадают', 'error')
                    return redirect(url_for('manager_profile'))
            
            db.session.commit()
            flash('Профиль успешно обновлен', 'success')
            return redirect(url_for('manager_profile'))
        except Exception as e:
            db.session.rollback()
            flash(f'Ошибка при обновлении профиля: {str(e)}', 'error')
            return redirect(url_for('manager_profile'))
    
    return render_template('auth/manager_profile.html', 
                         manager=current_manager)

@app.route('/profile/upload-avatar', methods=['POST'])
@login_required
def upload_user_avatar():
    """Upload user avatar"""
    import os
    from werkzeug.utils import secure_filename
    
    if 'avatar' not in request.files:
        return jsonify({'success': False, 'error': 'Файл не выбран'}), 400
    
    file = request.files['avatar']
    
    if file.filename == '':
        return jsonify({'success': False, 'error': 'Файл не выбран'}), 400
    
    # Check file extension
    allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    filename = secure_filename(file.filename)
    if '.' not in filename or filename.rsplit('.', 1)[1].lower() not in allowed_extensions:
        return jsonify({'success': False, 'error': 'Недопустимый формат файла. Разрешены: PNG, JPG, JPEG, GIF, WEBP'}), 400
    
    # Check file size (max 5MB)
    file.seek(0, os.SEEK_END)
    file_size = file.tell()
    file.seek(0)
    if file_size > 5 * 1024 * 1024:
        return jsonify({'success': False, 'error': 'Размер файла превышает 5MB'}), 400
    
    try:
        # Generate unique filename
        import uuid
        ext = filename.rsplit('.', 1)[1].lower()
        new_filename = f"user_{current_user.id}_{uuid.uuid4().hex[:8]}.{ext}"
        
        # Save file
        upload_folder = os.path.join('static', 'uploads', 'avatars')
        os.makedirs(upload_folder, exist_ok=True)
        filepath = os.path.join(upload_folder, new_filename)
        file.save(filepath)
        
        # Update user profile_image in database
        avatar_url = f"/static/uploads/avatars/{new_filename}"
        current_user.profile_image = avatar_url
        db.session.commit()
        
        return jsonify({'success': True, 'avatar_url': avatar_url})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'Ошибка при загрузке файла: {str(e)}'}), 500

@app.route('/manager/profile/upload-avatar', methods=['POST'])
@manager_required
def upload_manager_avatar():
    """Upload manager avatar"""
    import os
    from werkzeug.utils import secure_filename
    from models import Manager
    
    current_manager = current_user
    
    if 'avatar' not in request.files:
        return jsonify({'success': False, 'error': 'Файл не выбран'}), 400
    
    file = request.files['avatar']
    
    if file.filename == '':
        return jsonify({'success': False, 'error': 'Файл не выбран'}), 400
    
    # Check file extension
    allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    filename = secure_filename(file.filename)
    if '.' not in filename or filename.rsplit('.', 1)[1].lower() not in allowed_extensions:
        return jsonify({'success': False, 'error': 'Недопустимый формат файла. Разрешены: PNG, JPG, JPEG, GIF, WEBP'}), 400
    
    # Check file size (max 5MB)
    file.seek(0, os.SEEK_END)
    file_size = file.tell()
    file.seek(0)
    if file_size > 5 * 1024 * 1024:
        return jsonify({'success': False, 'error': 'Размер файла превышает 5MB'}), 400
    
    try:
        # Generate unique filename
        import uuid
        ext = filename.rsplit('.', 1)[1].lower()
        new_filename = f"manager_{current_manager.id}_{uuid.uuid4().hex[:8]}.{ext}"
        
        # Save file
        upload_folder = os.path.join('static', 'uploads', 'avatars')
        os.makedirs(upload_folder, exist_ok=True)
        filepath = os.path.join(upload_folder, new_filename)
        file.save(filepath)
        
        # Update manager profile_image in database
        avatar_url = f"/static/uploads/avatars/{new_filename}"
        current_manager.profile_image = avatar_url
        db.session.commit()
        
        return jsonify({'success': True, 'avatar_url': avatar_url})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'Ошибка при загрузке файла: {str(e)}'}), 500

@app.route('/api/search')
def api_search():
    """API endpoint for global search"""
    query = request.args.get('q', '').strip()
    if not query:
        return jsonify([])
    
    results = search_global(query)
    return jsonify(results)

@app.route('/search')
def search_results():
    """Search results page"""
    query = request.args.get('q', '').strip()
    search_type = request.args.get('type', 'all')  # all, residential_complex, district, developer, street
    
    results = []
    if query:
        results = search_global(query)
        
        # Filter by type if specified
        if search_type != 'all':
            results = [r for r in results if r['type'] == search_type]
    
    return render_template('search_results.html', 
                         query=query, 
                         results=results,
                         search_type=search_type)


@app.route('/api/smart-search-suggestions')
def smart_search_suggestions():
    """API endpoint for search suggestions with intelligent keyword matching"""
    query = request.args.get('q', '').strip().lower()
    if not query or len(query) < 1:
        return jsonify({'suggestions': []})
    
    suggestions = []
    
    try:
        # Intelligent room type matching patterns
        room_patterns = {
            # Single room patterns
            ('1', '1-', '1-к', '1-ко', '1-ком', '1 к', '1 ко', '1 ком', 'одн', 'одно', 'однок', 'однокомн', 'однокомнат', 'однокомнатн', 'один', 'одной'): ('1-комнатная квартира', 'rooms', '1'),
            # Two room patterns  
            ('2', '2-', '2-к', '2-ко', '2-ком', '2 к', '2 ко', '2 ком', 'двух', 'двухк', 'двухком', 'двухкомн', 'двухкомнат', 'два', 'двой', 'двойн'): ('2-комнатная квартира', 'rooms', '2'),
            # Three room patterns
            ('3', '3-', '3-к', '3-ко', '3-ком', '3 к', '3 ко', '3 ком', 'трех', 'трёх', 'трехк', 'трёхк', 'трехком', 'трёхком', 'три', 'трой'): ('3-комнатная квартира', 'rooms', '3'),
            # Four room patterns
            ('4', '4-', '4-к', '4-ко', '4-ком', '4 к', '4 ко', '4 ком', 'четыр', 'четырех', 'четырёх', 'четырехк', 'четырёхк', 'четыре'): ('4-комнатная квартира', 'rooms', '4'),
            # Studio patterns
            ('студ', 'studio', 'студий', 'студия'): ('Студия', 'rooms', 'studio'),
        }
        
        # Check room type patterns first
        for patterns, (room_text, type_val, value) in room_patterns.items():
            for pattern in patterns:
                if query.startswith(pattern) or pattern in query:
                    suggestions.append({
                        'text': room_text,
                        'type': type_val,
                        'value': value,
                        'category': 'Тип квартиры'
                    })
                    break
        
        # Search in regional data first (regions and cities)
        from models import Region, City
        
        # Search regions
        regions = Region.query.filter(Region.name.ilike(f'%{query}%')).limit(5).all()
        for region in regions:
            suggestions.append({
                'text': region.name,
                'type': 'region',
                'value': region.slug,
                'category': 'Регион'
            })
        
        # Search cities
        cities = City.query.filter(City.name.ilike(f'%{query}%')).limit(5).all()
        for city in cities:
            suggestions.append({
                'text': f"{city.name} ({city.region.name if city.region else 'Неизвестный регион'})",
                'type': 'city',
                'value': city.slug,
                'category': 'Город'
            })

        # Search in database categories (districts, developers, complexes)
        cursor = db.session.execute(text("""
            SELECT name, category_type, slug 
            FROM search_categories 
            WHERE LOWER(name) LIKE :query 
            ORDER BY 
                CASE 
                    WHEN LOWER(name) LIKE :exact_start THEN 1
                    WHEN LOWER(name) LIKE :word_start THEN 2
                    ELSE 3
                END,
                LENGTH(name)
            LIMIT 10
        """), {
            'query': f'%{query}%',
            'exact_start': f'{query}%',
            'word_start': f'% {query}%'
        })
        
        category_names = {
            'district': 'Район',
            'developer': 'Застройщик', 
            'complex': 'ЖК',
            'rooms': 'Тип квартиры',
            'region': 'Регион',
            'city': 'Город'
        }
        
        for row in cursor:
            name, category_type, slug = row
            suggestions.append({
                'text': name,
                'type': category_type,
                'value': slug,
                'category': category_names.get(category_type, category_type.title())
            })
        
        # Remove duplicates while preserving order
        seen = set()
        unique_suggestions = []
        for s in suggestions:
            key = (s['text'], s['type'])
            if key not in seen:
                seen.add(key)
                unique_suggestions.append(s)
        
        return jsonify({'suggestions': unique_suggestions[:12]})
        
    except Exception as e:
        app.logger.error(f"Smart search error: {e}")
        return jsonify({'suggestions': []})

def init_search_data():
    """Initialize search data in database"""
    from models import District, Developer, ResidentialComplex, Street, RoomType
    
    # Districts
    districts_data = [
        ('Центральный', 'tsentralnyy'), ('Западный', 'zapadny'), 
        ('Карасунский', 'karasunsky'), ('Прикубанский', 'prikubansky'),
        ('Фестивальный', 'festivalny'), ('Юбилейный', 'yubileynyy'),
        ('Гидростроителей', 'gidrostroitelei'), ('Солнечный', 'solnechny'),
        ('Панорама', 'panorama'), ('Музыкальный', 'muzykalnyy')
    ]
    
    for name, slug in districts_data:
        if not District.query.filter_by(slug=slug).first():
            district = District(name=name, slug=slug)
            db.session.add(district)
    
    # Room types
    room_types_data = [
        ('Студия', 0), ('1-комнатная квартира', 1), 
        ('2-комнатная квартира', 2), ('3-комнатная квартира', 3), 
        ('4-комнатная квартира', 4), ('Пентхаус', 5)
    ]
    
    for name, rooms_count in room_types_data:
        if not RoomType.query.filter_by(name=name).first():
            room_type = RoomType(name=name, rooms_count=rooms_count)
            db.session.add(room_type)
    
    # Developers
    developers_data = [
        ('Краснодар Инвест', 'krasnodar-invest'),
        ('ЮгСтройИнвест', 'yugstroyinvest'),
        ('Флагман', 'flagman'),
        ('Солнечный город', 'solnechny-gorod'),
        ('Премьер', 'premier')
    ]
    
    for name, slug in developers_data:
        if not Developer.query.filter_by(slug=slug).first():
            developer = Developer(name=name, slug=slug)
            db.session.add(developer)
    
    # Residential complexes
    complexes_data = [
        ('Солнечный', 'solnechny', 1, 1),
        ('Панорама', 'panorama', 1, 2),
        ('Гармония', 'garmoniya', 2, 3),
        ('Европейский квартал', 'evropeyskiy-kvartal', 3, 1),
        ('Флагман', 'flagman', 4, 4)
    ]
    
    for name, slug, district_id, developer_id in complexes_data:
        if not ResidentialComplex.query.filter_by(slug=slug).first():
            complex = ResidentialComplex(name=name, slug=slug, district_id=district_id, developer_id=developer_id)
            db.session.add(complex)
    
    db.session.commit()


# ==================== ADMIN ROUTES ====================

@app.route('/admin/login', methods=['GET', 'POST'])
@csrf.exempt  # Exempt admin login from CSRF protection
def admin_login():
    """Admin login page - ИСПРАВЛЕНО: использует Flask-Login"""
    if request.method == 'POST':
        from models import Admin
        email = request.form.get('email')
        password = request.form.get('password')
        
        admin = Admin.query.filter_by(email=email, is_active=True).first()
        
        if admin and admin.check_password(password):
            # Используем Flask-Login вместо ручных сессий
            login_user(admin, remember=True)
            session.permanent = True  # Ensure 30-day session lifetime
            admin.last_login = datetime.utcnow()
            db.session.commit()
            flash('Добро пожаловать в панель администратора!', 'success')
            return redirect(url_for('admin_dashboard'))
        else:
            flash('Неверный email или пароль', 'error')
    
    return render_template('admin/admin_login.html')

@app.route('/admin/logout')
def admin_logout():
    """Admin logout - ИСПРАВЛЕНО: использует Flask-Login"""
    logout_user()  # Используем Flask-Login
    flash('Вы вышли из панели администратора', 'info')
    return redirect(url_for('admin_login'))

def admin_required(f):
    """Decorator to require admin authentication - ИСПРАВЛЕНО: проверяет тип модели"""
    from functools import wraps
    @wraps(f)
    def decorated_function(*args, **kwargs):
        from models import Admin
        # Проверяем что пользователь авторизован и это Admin
        if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Admin):
            # Для API endpoints возвращаем JSON
            if request.path.startswith('/api/'):
                return jsonify({'success': False, 'error': 'Требуется авторизация администратора'}), 403
            # Для обычных страниц делаем redirect
            return redirect(url_for('admin_login'))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/admin')
def admin_base():
    """Base admin route - redirects to dashboard or login - ИСПРАВЛЕНО: проверяет тип модели"""
    from models import Admin
    # Проверяем что пользователь авторизован и это Admin
    if current_user.is_authenticated and isinstance(current_user._get_current_object(), Admin):
        return redirect(url_for('admin_dashboard'))
    return redirect(url_for('admin_login'))

@app.route('/admin/client-management')
@admin_required
def admin_client_management():
    """Separate page for client-manager assignment"""
    try:
        from models import Admin
        
        # ИСПРАВЛЕНО: Используем Flask-Login current_user
        current_admin = current_user
        if not current_admin:
            flash('Админ не найден', 'error')
            return redirect(url_for('admin_login'))
        
        return render_template('admin/client_management.html', admin=current_admin)
        
    except Exception as e:
        print(f"ERROR in admin_client_management: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'Ошибка загрузки страницы: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))

@app.route('/admin/dashboard')
@admin_required
def admin_dashboard():
    """Admin dashboard with analytics - ИСПРАВЛЕНО: использует Flask-Login"""
    from models import Admin, User, Manager, CashbackApplication, CallbackRequest
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    if not current_admin:
        return redirect(url_for('admin_login'))
    
    # Analytics data
    stats = {
        'total_users': User.query.count(),
        'total_managers': Manager.query.count(),
        'total_applications': CashbackApplication.query.count(),
        'pending_applications': CashbackApplication.query.filter_by(status='На рассмотрении').count(),
        'approved_applications': CashbackApplication.query.filter_by(status='Одобрена').count(),
        'paid_applications': CashbackApplication.query.filter_by(status='Выплачена').count(),
        'total_cashback_approved': sum(app.cashback_amount for app in CashbackApplication.query.filter_by(status='Одобрена').all()),
        'total_cashback_paid': sum(app.cashback_amount for app in CashbackApplication.query.filter_by(status='Выплачена').all()),
        'active_users': User.query.filter_by(is_active=True).count(),
        'active_managers': Manager.query.filter_by(is_active=True).count(),
        'cashback_requests': CallbackRequest.query.filter(CallbackRequest.notes.contains('кешбек')).count(),
        'new_requests': CallbackRequest.query.filter_by(status='Новая').count(),
    }
    
    # Recent activity
    recent_applications = CashbackApplication.query.order_by(CashbackApplication.created_at.desc()).limit(10).all()
    recent_users = User.query.order_by(User.created_at.desc()).limit(10).all()
    recent_cashback_requests = CallbackRequest.query.filter(
        CallbackRequest.notes.contains('кешбек')
    ).order_by(CallbackRequest.created_at.desc()).limit(5).all()
    
    return render_template('admin/dashboard.html',
                         admin=current_admin,
                         stats=stats,
                         recent_applications=recent_applications,
                         recent_users=recent_users,
                         recent_cashback_requests=recent_cashback_requests,
                         current_date=datetime.now())

@app.route('/admin/balance-management')
@admin_required
def admin_balance_management():
    """Admin panel for balance and withdrawal management"""
    try:
        from models import User, WithdrawalRequest, UserBalance
        from services.withdrawal_service import WithdrawalService
        
        # Get statistics
        total_users_with_balance = db.session.query(UserBalance).filter(
            (UserBalance.available_amount > 0) | (UserBalance.pending_amount > 0)
        ).count()
        
        total_available = db.session.query(db.func.sum(UserBalance.available_amount)).scalar() or 0
        total_pending = db.session.query(db.func.sum(UserBalance.pending_amount)).scalar() or 0
        total_earned = db.session.query(db.func.sum(UserBalance.total_earned)).scalar() or 0
        total_withdrawn = db.session.query(db.func.sum(UserBalance.total_withdrawn)).scalar() or 0
        
        # Pending withdrawals count
        pending_count = WithdrawalRequest.query.filter_by(status='pending').count()
        
        return render_template('admin/balance_management.html',
                             total_users_with_balance=total_users_with_balance,
                             total_available=total_available,
                             total_pending=total_pending,
                             total_earned=total_earned,
                             total_withdrawn=total_withdrawn,
                             pending_count=pending_count)
    except Exception as e:
        app.logger.error(f"Error loading balance management: {str(e)}")
        flash('Ошибка загрузки панели управления балансом', 'error')
        return redirect(url_for('admin_dashboard'))

@app.route('/admin/cashback-requests')
@admin_required
def admin_cashback_requests():
    """View all cashback requests"""
    from models import CallbackRequest
    
    # Get page number
    page = request.args.get('page', 1, type=int)
    per_page = 20
    
    # Filter cashback requests
    cashback_requests = CallbackRequest.query.filter(
        CallbackRequest.notes.contains('кешбек')
    ).order_by(CallbackRequest.created_at.desc()).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('admin/cashback_requests.html',
                         requests=cashback_requests)

@app.route('/admin/callback-request/<int:request_id>/status', methods=['POST'])
@admin_required
def update_callback_request_status(request_id):
    """Update callback request status"""
    from models import CallbackRequest
    
    try:
        data = request.get_json()
        new_status = data.get('status')
        
        callback_request = CallbackRequest.query.get_or_404(request_id)
        callback_request.status = new_status
        
        if new_status == 'Обработана':
            callback_request.processed_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Статус обновлен'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/count', methods=['GET'])
@login_required  
def get_favorites_count():
    """Get count of user's favorites - ONLY active properties"""
    from models import FavoriteProperty, FavoriteComplex, Property
    
    try:
        # ✅ ИСПРАВЛЕНО: Считаем только активные квартиры (JOIN по Property.id)
        # Конвертируем property_id в int т.к. они хранятся как varchar
        favorites = db.session.query(FavoriteProperty).filter_by(user_id=current_user.id).all()
        property_ids = [int(fav.property_id) for fav in favorites if fav.property_id and fav.property_id.isdigit()]
        
        properties_count = db.session.query(Property).filter(
            Property.id.in_(property_ids),
            Property.is_active == True
        ).count() if property_ids else 0
        
        complexes_count = FavoriteComplex.query.filter_by(user_id=current_user.id).count()
        
        return jsonify({
            'success': True,
            'properties_count': properties_count,
            'complexes_count': complexes_count,
            'total_count': properties_count + complexes_count
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/list', methods=['GET'])
@login_required  
def get_favorites_list():
    """Get user's favorite properties with full details (OPTIMIZED - loads only needed properties)
    
    ✅ UPDATED: Now shows ALL properties including sold ones with is_sold flag
    """
    from models import FavoriteProperty, Property, ResidentialComplex, Developer
    from services.property_matcher import PropertyMatcher
    from urllib.parse import urlencode
    
    try:
        favorites = db.session.query(FavoriteProperty).filter_by(user_id=current_user.id).order_by(FavoriteProperty.created_at.desc()).all()
        
        if not favorites:
            return jsonify({
                'success': True,
                'favorites': []
            })
        
        # ОПТИМИЗАЦИЯ: Получаем только нужные property_id
        property_ids = [int(fav.property_id) for fav in favorites if fav.property_id and fav.property_id.isdigit()]
        
        if not property_ids:
            return jsonify({
                'success': True,
                'favorites': []
            })
        
        # ОПТИМИЗАЦИЯ: Загружаем только нужные объекты с JOIN (одним запросом!)
        # ✅ ИЗМЕНЕНИЕ: Убрали фильтр Property.is_active == True чтобы показывать проданные объекты
        properties_query = db.session.query(
            Property,
            ResidentialComplex.name.label('complex_name'),
            ResidentialComplex.cashback_rate,
            ResidentialComplex.main_image.label('complex_image'),
            Developer.name.label('developer_name')
        ).outerjoin(
            ResidentialComplex, Property.complex_id == ResidentialComplex.id
        ).outerjoin(
            Developer, Property.developer_id == Developer.id
        ).filter(
            Property.id.in_(property_ids)
            # Показываем все объекты, включая проданные
        ).all()
        
        # Создаем словарь для быстрого поиска
        properties_dict = {}
        for prop, complex_name, cashback_rate, complex_image, developer_name in properties_query:
            # Определяем rooms текст
            rooms_text = f"{prop.rooms}-комн" if prop.rooms and prop.rooms > 0 else "Студия"
            
            properties_dict[prop.id] = {
                'id': str(prop.id),
                'inner_id': prop.inner_id,  # ✅ НОВОЕ ПОЛЕ: Добавили inner_id для ссылок
                'title': f"{rooms_text}, {prop.area} м², {prop.floor}/{prop.total_floors} эт.",
                'complex': complex_name or 'ЖК не указан',
                'district': prop.address or 'Адрес не указан',  # Полный адрес из БД
                'price': prop.price or 0,
                'image': complex_image or prop.main_image or '/static/images/no-photo.jpg',
                'cashback_rate': cashback_rate or 3.5,
                'cashback_amount': int((prop.price or 0) * (cashback_rate or 3.5) / 100),
                'developer': developer_name or 'Застройщик не указан',
                'is_sold': not prop.is_active,  # ✅ НОВОЕ ПОЛЕ: Флаг проданного объекта
                'status_label': 'ПРОДАН' if not prop.is_active else '',  # ✅ НОВОЕ ПОЛЕ: Метка статуса
            }
        
        # Формируем финальный список избранного
        favorites_list = []
        for fav in favorites:
            if not fav.property_id:
                continue
                
            # Конвертируем property_id в int для поиска в словаре (ключи - integers)
            property_id_int = int(fav.property_id) if fav.property_id.isdigit() else None
            property_data = properties_dict.get(property_id_int) if property_id_int else None
            
            if property_data:
                # Добавляем временную метку из избранного
                property_data['created_at'] = fav.created_at.strftime('%d.%m.%Y в %H:%M') if fav.created_at else 'Недавно'
                property_data['viewed'] = fav.viewed if hasattr(fav, 'viewed') else False
                
                # ✅ НОВОЕ: Добавляем URL для поиска аналогов (только для проданных объектов)
                if property_data.get('is_sold'):
                    search_params = PropertyMatcher.get_property_search_params(property_id_int)
                    if search_params:
                        property_data['similar_search_url'] = f"/properties?{urlencode(search_params)}"
                    else:
                        property_data['similar_search_url'] = "/properties"
                else:
                    property_data['similar_search_url'] = None
                
                favorites_list.append(property_data)
            else:
                # ✅ ОБНОВЛЕНО: Fallback если объект не найден или удален
                favorites_list.append({
                    'id': fav.property_id,
                    'inner_id': fav.property_id,
                    'title': f'Объект #{fav.property_id}',
                    'complex': 'Объект не найден',
                    'district': 'Возможно, объект был удален',
                    'price': 0,
                    'image': '/static/images/no-photo.jpg',
                    'cashback_amount': 0,
                    'created_at': fav.created_at.strftime('%d.%m.%Y в %H:%M') if fav.created_at else 'Недавно',
                    'viewed': False,
                    'is_sold': True,  # ✅ НОВОЕ
                    'status_label': 'УДАЛЕН',  # ✅ НОВОЕ
                    'similar_search_url': '/properties'  # ✅ НОВОЕ
                })
        
        return jsonify({
            'success': True,
            'favorites': favorites_list
        })
    
    except Exception as e:
        print(f"Error in get_favorites_list: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/mark-viewed/<property_id>', methods=['POST'])
@login_required
@csrf.exempt
def mark_favorite_viewed(property_id):
    """Mark favorite property as viewed (property_id is inner_id from frontend)"""
    from models import FavoriteProperty, Property
    
    try:
        property_obj = Property.query.filter_by(inner_id=str(property_id)).first()
        if not property_obj:
            return jsonify({'success': False, 'error': 'Property not found'}), 404
        
        favorite = FavoriteProperty.query.filter_by(
            user_id=current_user.id,
            property_id=str(property_id)
        ).first()
        
        if favorite:
            favorite.viewed = True
            db.session.commit()
            print(f"✅ Marked property {property_id} (db_id={property_obj.id}) as viewed for user {current_user.id}")
            return jsonify({'success': True})
        
        return jsonify({'success': False, 'error': 'Favorite not found'}), 404
    
    except Exception as e:
        db.session.rollback()
        print(f"❌ Error marking property {property_id} as viewed: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/mark-viewed/<complex_id>', methods=['POST'])
@login_required
@csrf.exempt
def mark_complex_favorite_viewed(complex_id):
    """Mark favorite complex as viewed (complex_id from frontend)"""
    from models import FavoriteComplex
    
    try:
        print(f"🔍 Looking for complex_id={complex_id} for user {current_user.id}")
        favorite = FavoriteComplex.query.filter_by(
            user_id=current_user.id,
            complex_id=str(complex_id)
        ).first()
        
        if not favorite:
            print(f"❌ Favorite complex {complex_id} not found for user {current_user.id}")
            return jsonify({'success': False, 'error': 'Favorite not found'}), 404
        
        print(f"📝 Before update: viewed={favorite.viewed}")
        favorite.viewed = True
        db.session.flush()
        print(f"📝 After flush: viewed={favorite.viewed}")
        db.session.commit()
        print(f"✅ Marked complex {complex_id} as viewed for user {current_user.id}")
        
        # Проверяем, что изменения сохранились
        db.session.refresh(favorite)
        print(f"✅ After refresh: viewed={favorite.viewed}")
        return jsonify({'success': True})
    
    except Exception as e:
        db.session.rollback()
        print(f"❌ Error marking complex {complex_id} as viewed: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

# Complex Favorites API
@app.route('/api/complexes/favorites', methods=['POST'])
@login_required  
@csrf.exempt  # Disable CSRF for API endpoint
def add_complex_to_favorites():
    """Add residential complex to favorites"""
    from models import FavoriteComplex
    data = request.get_json()
    
    complex_id = data.get('complex_id')
    complex_name = data.get('complex_name', 'ЖК')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    # Check if already in favorites
    existing = FavoriteComplex.query.filter_by(
        user_id=current_user.id,
        complex_id=str(complex_id)
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': 'Complex already in favorites'}), 400
    
    try:
        # Create favorite complex record
        favorite = FavoriteComplex(
            user_id=current_user.id,
            complex_id=str(complex_id),
            complex_name=complex_name,
            developer_name=data.get('developer_name', ''),
            complex_address=data.get('address', ''),
            district=data.get('district', ''),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            complex_image=data.get('image', ''),
            complex_url=data.get('url', ''),
            status=data.get('status', 'В продаже')
        )
        
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'ЖК добавлен в избранное'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/<complex_id>', methods=['DELETE'])
@login_required
@csrf.exempt  # Disable CSRF for API endpoint
def remove_complex_from_favorites(complex_id):
    """Remove residential complex from favorites"""
    from models import FavoriteComplex
    
    favorite = FavoriteComplex.query.filter_by(
        user_id=current_user.id,
        complex_id=str(complex_id)
    ).first()
    
    if not favorite:
        return jsonify({'success': False, 'error': 'Complex not in favorites'}), 404
    
    try:
        db.session.delete(favorite)
        db.session.commit()
        return jsonify({'success': True, 'message': 'ЖК удален из избранного'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/toggle', methods=['POST'])
@login_required
@csrf.exempt  # Disable CSRF for API endpoint
def toggle_complex_favorite():
    """Toggle favorite status for residential complex"""
    from models import FavoriteComplex
    data = request.get_json()
    complex_id = data.get('complex_id')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    try:
        existing = FavoriteComplex.query.filter_by(
            user_id=current_user.id,
            complex_id=str(complex_id)
        ).first()
        
        if existing:
            # Remove from favorites
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'favorited': False, 'message': 'ЖК удален из избранного'})
        else:
            # Add to favorites
            favorite = FavoriteComplex(
                user_id=current_user.id,
                complex_id=str(complex_id),
                complex_name=data.get('complex_name', 'ЖК'),
                developer_name=data.get('developer_name', ''),
                complex_address=data.get('address', ''),  # ✅ ИСПРАВЛЕНО: complex_address вместо address_display_name
                district=data.get('district', ''),
                min_price=data.get('min_price'),
                max_price=data.get('max_price'),
                complex_image=data.get('image', ''),
                complex_url=data.get('url', ''),
                status=data.get('status', 'В продаже')
            )
            
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'favorited': True, 'message': 'ЖК добавлен в избранное'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/list', methods=['GET'])
@login_required
def get_user_complex_favorites_list():
    """Get user's favorite complexes with full details from residential_complexes table"""
    from models import FavoriteComplex, ResidentialComplex, Developer, District
    
    try:
        # Получаем избранное пользователя
        favorites = FavoriteComplex.query.filter_by(user_id=current_user.id).order_by(FavoriteComplex.created_at.desc()).all()
        
        # Собираем ID комплексов
        complex_ids_int = []
        for fav in favorites:
            try:
                complex_ids_int.append(int(fav.complex_id))
            except:
                continue
        
        # Batch-загрузка реальных данных из residential_complexes
        complexes_dict = {}
        if complex_ids_int:
            real_complexes = db.session.query(
                ResidentialComplex.id,
                ResidentialComplex.name,
                ResidentialComplex.address,
                ResidentialComplex.main_image,
                ResidentialComplex.cashback_rate,
                District.name.label('district_name'),
                Developer.name.label('developer_name')
            ).outerjoin(District, ResidentialComplex.district_id == District.id)\
             .outerjoin(Developer, ResidentialComplex.developer_id == Developer.id)\
             .filter(ResidentialComplex.id.in_(complex_ids_int)).all()
            
            for rc in real_complexes:
                complexes_dict[rc.id] = rc
        
        # Batch-загрузка цен и фото из properties для каждого ЖК
        prices_dict = {}
        if complex_ids_int:
            # Получаем min/max цены и фото для каждого ЖК
            prices_query = text("""
                SELECT 
                    rc.id,
                    MIN(p.price) as min_price,
                    MAX(p.price) as max_price,
                    COALESCE(rc.main_image, rc.gallery_images, MIN(p.gallery_images)) as photos
                FROM residential_complexes rc
                LEFT JOIN properties p ON p.complex_id = rc.id AND p.is_active = true
                WHERE rc.id = ANY(:complex_ids)
                GROUP BY rc.id, rc.main_image, rc.gallery_images
            """)
            
            prices_result = db.session.execute(prices_query, {'complex_ids': complex_ids_int})
            prices_dict = {row[0]: {'min_price': row[1] or 0, 'max_price': row[2] or 0, 'photos': row[3]} for row in prices_result}
        
        # Собираем данные для ответа
        complexes_data = []
        for fav in favorites:
            try:
                complex_id_int = int(fav.complex_id)
                rc = complexes_dict.get(complex_id_int)
                
                if rc:
                    # Получаем цены и фото из prices_dict
                    complex_prices = prices_dict.get(complex_id_int, {})
                    photos_data = complex_prices.get('photos', '')
                    
                    # Извлекаем первое фото из JSON массива
                    image_url = '/static/images/no-image.jpg'
                    if photos_data:
                        try:
                            photos_list = json.loads(photos_data) if isinstance(photos_data, str) else photos_data
                            if photos_list and isinstance(photos_list, list) and len(photos_list) > 0:
                                image_url = photos_list[0]
                        except (json.JSONDecodeError, TypeError):
                            if isinstance(photos_data, str) and photos_data.strip():
                                image_url = photos_data
                    
                    # Используем реальные данные из БД
                    complexes_data.append({
                        'id': str(complex_id_int),
                        'name': rc.name or 'ЖК',
                        'address': rc.address or 'Не указано',
                        'district': rc.district_name or 'Не указано',
                        'developer': rc.developer_name or 'Не указано',
                        'image': image_url,
                        'cashback_rate': rc.cashback_rate or 5,
                        'min_price': complex_prices.get('min_price', 0),
                        'max_price': complex_prices.get('max_price', 0),
                        'url': f'/residential-complex/{complex_id_int}',
                        'status': 'В продаже',
                        'created_at': fav.created_at.strftime('%d.%m.%Y в %H:%M')
                    })
                else:
                    # Используем сохраненные данные если ЖК не найден
                    complexes_data.append({
                        'id': fav.complex_id,
                        'name': fav.complex_name or 'ЖК',
                        'address': fav.complex_address or 'Не указано',
                        'district': fav.district or 'Не указано',
                        'developer': fav.developer_name or 'Не указано',
                        'image': fav.complex_image or '',
                        'cashback_rate': 5,
                        'min_price': fav.min_price or 0,
                        'max_price': fav.max_price or 0,
                        'url': fav.complex_url or '',
                        'status': fav.status or 'В продаже',
                        'created_at': fav.created_at.strftime('%d.%m.%Y в %H:%M')
                    })
            except Exception as e:
                print(f"Error processing complex {fav.complex_id}: {e}")
                continue
        
        return jsonify({
            'success': True,
            'complexes': complexes_data
        })
    
    except Exception as e:
        print(f"Error in get_user_complex_favorites_list: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/favorites/clear-all', methods=['POST'])
@login_required  
@csrf.exempt  # Disable CSRF for API endpoint
def clear_all_favorites():
    """Clear all user's favorite properties"""
    from models import FavoriteProperty
    
    try:
        # Delete all favorites for current user
        deleted_count = db.session.query(FavoriteProperty).filter_by(user_id=current_user.id).delete()
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': f'Удалено {deleted_count} избранных квартир',
            'deleted_count': deleted_count
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/complexes/favorites/clear-all', methods=['POST'])
@login_required  
@csrf.exempt  # Disable CSRF for API endpoint
def clear_all_complex_favorites():
    """Clear all user's favorite complexes"""
    from models import FavoriteComplex
    
    try:
        # Delete all complex favorites for current user
        deleted_count = db.session.query(FavoriteComplex).filter_by(user_id=current_user.id).delete()
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': f'Удалено {deleted_count} избранных ЖК',
            'deleted_count': deleted_count
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/dashboard/data', methods=['GET'])
@login_required
def get_dashboard_data():
    """ОПТИМИЗИРОВАННЫЙ ENDPOINT: Получить все данные дашборда одним запросом"""
    from models import FavoriteProperty, FavoriteComplex, ComparisonProperty, ComparisonComplex, Recommendation, Collection, UserComparison
    
    try:
        # Все счетчики одним запросом к БД
        favorites_properties_count = FavoriteProperty.query.filter_by(user_id=current_user.id).count()
        favorites_complexes_count = FavoriteComplex.query.filter_by(user_id=current_user.id).count()
        comparison_properties_count = db.session.query(ComparisonProperty).join(
            UserComparison, ComparisonProperty.user_comparison_id == UserComparison.id
        ).filter(UserComparison.user_id == current_user.id).count()
        
        comparison_complexes_count = db.session.query(ComparisonComplex).join(
            UserComparison, ComparisonComplex.user_comparison_id == UserComparison.id
        ).filter(UserComparison.user_id == current_user.id).count()
        recommendations_count = Recommendation.query.filter(
            Recommendation.client_id == current_user.id,
            Recommendation.status != 'dismissed'
        ).count()
        collections_count = Collection.query.filter_by(assigned_to_user_id=current_user.id).count()
        
        return jsonify({
            'success': True,
            'favorites': {
                'properties': favorites_properties_count,
                'complexes': favorites_complexes_count,
                'total': favorites_properties_count + favorites_complexes_count
            },
            'comparison': {
                'properties': comparison_properties_count,
                'complexes': comparison_complexes_count,
                'total': comparison_properties_count + comparison_complexes_count
            },
            'recommendations': recommendations_count,
            'collections': collections_count
        })
    
    except Exception as e:
        print(f"Error in get_dashboard_data: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/searches', methods=['GET'])
@login_required
def get_saved_searches():
    """ЗАГЛУШКА: Сохраненные поиски (пока не реализовано)"""
    return jsonify({
        'success': True,
        'searches': []
    })

@app.route('/api/user/stats', methods=['GET'])
@login_required
def get_user_stats():
    """ЗАГЛУШКА: Статистика пользователя (пока не реализовано)"""
    return jsonify({
        'success': True,
        'views': 0,
        'favorites': 0,
        'applications': 0
    })

@app.route('/api/favorites/all', methods=['GET'])
@login_required
def get_all_favorites():
    """ОПТИМИЗИРОВАННЫЙ: Получить ВСЕ избранное (квартиры + ЖК) одним запросом"""
    from models import FavoriteProperty, FavoriteComplex, Property, ResidentialComplex, Developer, District
    
    try:
        # Получаем избранные квартиры
        favorites = db.session.query(FavoriteProperty).filter_by(user_id=current_user.id).order_by(FavoriteProperty.created_at.desc()).all()
        
        properties_list = []
        if favorites:
            print(f"DEBUG /api/favorites/all: Found {len(favorites)} favorites for user {current_user.id}")
            # Конвертируем property_id в int (они хранятся как varchar в БД)
            property_ids = [int(fav.property_id) for fav in favorites if fav.property_id and fav.property_id.isdigit()]
            print(f"DEBUG: property_ids after conversion: {property_ids}")
            
            if property_ids:
                properties_query = db.session.query(
                    Property,
                    ResidentialComplex.name.label('complex_name'),
                    ResidentialComplex.cashback_rate,
                    ResidentialComplex.main_image.label('complex_image'),
                    Developer.name.label('developer_name')
                ).outerjoin(
                    ResidentialComplex, Property.complex_id == ResidentialComplex.id
                ).outerjoin(
                    Developer, Property.developer_id == Developer.id
                ).filter(
                    Property.id.in_(property_ids)  # ✅ Убрали is_active чтобы показывать проданные объекты
                ).all()
                print(f"DEBUG: properties_query returned {len(properties_query)} results")
                
                properties_dict = {}
                for prop, complex_name, cashback_rate, complex_image, developer_name in properties_query:
                    rooms_text = f"{prop.rooms}-комн" if prop.rooms and prop.rooms > 0 else "Студия"
                    properties_dict[prop.id] = {  # Ключ - prop.id (integer)
                        'id': str(prop.id),
                        'title': f"{rooms_text}, {prop.area} м², {prop.floor}/{prop.total_floors} эт.",
                        'complex': complex_name or 'ЖК не указан',
                        'district': prop.address or 'Адрес не указан',
                        'price': prop.price or 0,
                        'image': complex_image or prop.main_image or '/static/images/no-photo.jpg',
                        'cashback_rate': cashback_rate or 3.5,
                        'cashback_amount': int((prop.price or 0) * (cashback_rate or 3.5) / 100),
                        'developer': developer_name or 'Застройщик не указан',
                        'is_sold': not prop.is_active,  # ✅ НОВОЕ ПОЛЕ: Флаг проданного объекта
                        'created_at': None,
                        'viewed': False
                    }
                
                for fav in favorites:
                    # Конвертируем property_id в int для поиска в словаре
                    property_id_int = int(fav.property_id) if fav.property_id and fav.property_id.isdigit() else None
                    if property_id_int and property_id_int in properties_dict:
                        prop_data = properties_dict[property_id_int]
                        prop_data['created_at'] = fav.created_at.strftime('%d.%m.%Y в %H:%M') if fav.created_at else 'Недавно'
                        prop_data['viewed'] = fav.viewed if hasattr(fav, 'viewed') else False
                        properties_list.append(prop_data)
        
        print(f"DEBUG: Final properties_list length: {len(properties_list)}")
        
        # Получаем избранные ЖК
        complex_favorites = FavoriteComplex.query.filter_by(user_id=current_user.id).order_by(FavoriteComplex.created_at.desc()).all()
        
        complexes_list = []
        if complex_favorites:
            complex_ids_int = []
            for fav in complex_favorites:
                try:
                    complex_ids_int.append(int(fav.complex_id))
                except:
                    continue
            
            if complex_ids_int:
                complexes_query = db.session.query(
                    ResidentialComplex.id,
                    ResidentialComplex.name,
                    ResidentialComplex.address,
                    ResidentialComplex.main_image,
                    ResidentialComplex.cashback_rate,
                    District.name.label('district_name'),
                    Developer.name.label('developer_name')
                ).outerjoin(District, ResidentialComplex.district_id == District.id)\
                 .outerjoin(Developer, ResidentialComplex.developer_id == Developer.id)\
                 .filter(ResidentialComplex.id.in_(complex_ids_int)).all()
                
                complexes_dict = {}
                for rc in complexes_query:
                    complexes_dict[rc.id] = rc
                
                # Получаем цены
                from sqlalchemy import text, func
                prices_query = text("""
                    SELECT 
                        complex_id,
                        MIN(price) as min_price,
                        MAX(price) as max_price,
                        MIN(main_image) as first_image
                    FROM properties 
                    WHERE complex_id = ANY(:complex_ids) AND is_active = true
                    GROUP BY complex_id
                """)
                prices_result = db.session.execute(prices_query, {"complex_ids": complex_ids_int})
                prices_dict = {row[0]: {'min_price': row[1], 'max_price': row[2], 'first_image': row[3]} for row in prices_result}
                
                for fav in complex_favorites:
                    try:
                        complex_id_int = int(fav.complex_id)
                        rc = complexes_dict.get(complex_id_int)
                        
                        if rc:
                            complex_prices = prices_dict.get(complex_id_int, {})
                            image_url = rc.main_image or complex_prices.get('first_image') or fav.complex_image or ''
                            
                            complexes_list.append({
                                'id': str(complex_id_int),
                                'name': rc.name or fav.complex_name or 'ЖК',
                                'address': rc.address or fav.complex_address or 'Не указано',
                                'district': rc.district_name or fav.district or 'Не указано',
                                'developer': rc.developer_name or fav.developer_name or 'Не указано',
                                'image': image_url,
                                'cashback_rate': rc.cashback_rate or 5,
                                'min_price': complex_prices.get('min_price', fav.min_price or 0),
                                'max_price': complex_prices.get('max_price', fav.max_price or 0),
                                'url': f'/residential-complex/{complex_id_int}',
                                'status': 'В продаже',
                                'created_at': fav.created_at.strftime('%d.%m.%Y в %H:%M'),
                                'viewed': fav.viewed if hasattr(fav, 'viewed') else False
                            })
                    except Exception as e:
                        print(f"Error processing complex {fav.complex_id}: {e}")
                        continue
        
        return jsonify({
            'success': True,
            'properties': properties_list,
            'complexes': complexes_list,
            'total': len(properties_list) + len(complexes_list)
        })
    
    except Exception as e:
        print(f"Error in get_all_favorites: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

# Manager Favorites API - Properties
@app.route('/api/manager/favorites', methods=['POST'])
@manager_required  
def manager_add_to_favorites():
    """Add property to manager's favorites"""
    from models import ManagerFavoriteProperty
    
    current_manager = current_user
    data = request.get_json()
    
    # Check if already in favorites
    existing = ManagerFavoriteProperty.query.filter_by(
        manager_id=current_manager.id,
        property_id=data.get('property_id')
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': 'Уже в избранном'})
    
    try:
        favorite = ManagerFavoriteProperty(
            manager_id=current_manager.id,
            property_id=data.get('property_id'),
            property_name=data.get('property_name', ''),
            property_type=data.get('property_type', ''),
            property_size=float(data.get('property_size', 0)),
            property_price=int(data.get('property_price', 0)),
            complex_name=data.get('complex_name', ''),
            developer_name=data.get('developer_name', ''),
            property_image=data.get('property_image'),
            property_url=data.get('property_url'),
            cashback_amount=int(data.get('cashback_amount', 0)),
            cashback_percent=float(data.get('cashback_percent', 0)),
            notes=data.get('notes', ''),
            recommended_for=data.get('recommended_for', '')
        )
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Добавлено в избранное'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/favorites/<property_id>', methods=['DELETE'])
@manager_required
def manager_remove_from_favorites(property_id):
    """Remove property from manager's favorites"""
    from models import ManagerFavoriteProperty
    
    current_manager = current_user
    
    favorite = ManagerFavoriteProperty.query.filter_by(
        manager_id=current_manager.id,
        property_id=property_id
    ).first()
    
    if favorite:
        try:
            db.session.delete(favorite)
            db.session.commit()
            return jsonify({'success': True, 'message': 'Удалено из избранного'})
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)}), 400
    
    return jsonify({'success': False, 'error': 'Объект не найден в избранном'}), 404

@app.route('/api/manager/favorites/clear', methods=['DELETE'])
@manager_required
def manager_clear_all_favorites():
    """Clear all properties from manager's favorites"""
    from models import ManagerFavoriteProperty
    
    current_manager = current_user
    
    try:
        # Delete all favorites for this manager
        deleted_count = ManagerFavoriteProperty.query.filter_by(
            manager_id=current_manager.id
        ).delete()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Удалено {deleted_count} объектов из избранного',
            'deleted_count': deleted_count
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/favorites/toggle', methods=['POST'])
@manager_required
def manager_toggle_favorite():
    """Toggle favorite status for property"""
    from models import ManagerFavoriteProperty
    
    current_manager = current_user
    
    data = request.get_json()
    property_id = data.get('property_id')
    
    if not property_id:
        return jsonify({'success': False, 'error': 'property_id required'}), 400
    
    print(f"DEBUG: Manager favorites toggle called by manager {current_manager.id} for property {property_id}")
    
    # Check if already in favorites
    existing = ManagerFavoriteProperty.query.filter_by(
        manager_id=current_manager.id,
        property_id=property_id
    ).first()
    
    try:
        if existing:
            # Remove from favorites
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'action': 'removed', 'is_favorite': False, 'message': 'Удалено из избранного'})
        else:
            # Add to favorites
            favorite = ManagerFavoriteProperty(
                manager_id=current_manager.id,
                property_id=property_id,
                property_name=data.get('property_name', ''),
                property_type=data.get('property_type', ''),
                property_size=float(data.get('property_size', 0)),
                property_price=int(data.get('property_price', 0)),
                complex_name=data.get('complex_name', ''),
                developer_name=data.get('developer_name', ''),
                property_image=data.get('property_image'),
                property_url=data.get('property_url'),
                cashback_amount=int(data.get('cashback_amount', 0)),
                cashback_percent=float(data.get('cashback_percent', 0)),
                notes=data.get('notes', ''),
                recommended_for=data.get('recommended_for', '')
            )
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'action': 'added', 'is_favorite': True, 'message': 'Добавлено в избранное'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/favorites/count', methods=['GET'])
@manager_required  
def manager_get_favorites_count():
    """Get count of manager's favorites"""
    from models import ManagerFavoriteProperty, ManagerFavoriteComplex
    
    current_manager = current_user
    
    try:
        # DEBUG: Log which tables we're querying
        print(f"🔍 DEBUG: /api/manager/favorites/count called - querying MANAGER tables for manager {current_manager.id}")
        
        properties_count = ManagerFavoriteProperty.query.filter_by(manager_id=current_manager.id).count()
        complexes_count = ManagerFavoriteComplex.query.filter_by(manager_id=current_manager.id).count()
        
        print(f"✅ Manager favorites count: {properties_count} properties, {complexes_count} complexes from MANAGER tables")
        
        return jsonify({
            'success': True,
            'properties_count': properties_count,
            'complexes_count': complexes_count,
            'total_count': properties_count + complexes_count
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

# Note: Manager Complex Favorites endpoints already exist below - no duplicates needed

@app.route('/api/manager/favorites/list', methods=['GET'])
@manager_required  
def manager_get_favorites_list():
    """Get manager's favorite properties with full details"""
    from models import ManagerFavoriteProperty, Property, ResidentialComplex, Developer
    
    current_manager = current_user
    
    try:
        print(f"🔍 DEBUG: /api/manager/favorites/list called for manager {current_manager.id}")
        
        favorites = db.session.query(ManagerFavoriteProperty).filter_by(manager_id=current_manager.id).order_by(ManagerFavoriteProperty.created_at.desc()).all()
        print(f"✅ Found {len(favorites)} favorites in MANAGER_FAVORITE_PROPERTIES")
        
        if not favorites:
            return jsonify({'success': True, 'favorites': []})
        
        # Получаем id (serial) из manager_favorite_properties.property_id
        property_ids = [int(fav.property_id) for fav in favorites if fav.property_id]
        print(f"🔍 DEBUG: Looking for property IDs: {property_ids[:5]}...")
        
        if not property_ids:
            return jsonify({'success': True, 'favorites': []})
        
        # Загружаем свойства по properties.id (serial)!
        properties_query = db.session.query(
            Property,
            ResidentialComplex.name.label('complex_name'),
            ResidentialComplex.cashback_rate,
            ResidentialComplex.main_image.label('complex_image'),
            Developer.name.label('developer_name')
        ).outerjoin(
            ResidentialComplex, Property.complex_id == ResidentialComplex.id
        ).outerjoin(
            Developer, Property.developer_id == Developer.id
        ).filter(
            Property.id.in_(property_ids)  # ✅ Ищем по properties.id!
        ).all()
        
        print(f"🔍 DEBUG: SQL returned {len(properties_query)} properties")
        
        # Создаем словарь: ключ = properties.id
        properties_dict = {}
        for prop, complex_name, cashback_rate, complex_image, developer_name in properties_query:
            rooms_text = f"{prop.rooms}-комн" if prop.rooms and prop.rooms > 0 else "Студия"
            
            properties_dict[prop.id] = {  # ✅ Ключ = properties.id
                'id': str(prop.id),
                'inner_id': prop.inner_id,
                'title': f"{rooms_text}, {prop.area} м², {prop.floor}/{prop.total_floors} эт.",
                'complex': complex_name or 'ЖК не указан',
                'district': prop.address or 'Адрес не указан',
                'price': prop.price or 0,
                'image': complex_image or prop.main_image or '/static/images/no-photo.jpg',
                'cashback_rate': cashback_rate or 3.5,
                'cashback_amount': int((prop.price or 0) * (cashback_rate or 3.5) / 100),
                'developer': developer_name or 'Застройщик не указан'
            }
        
        print(f"🔍 DEBUG: Created dict with {len(properties_dict)} entries")
        
        # Формируем финальный список
        favorites_list = []
        for fav in favorites:
            property_id_int = int(fav.property_id)
            property_data = properties_dict.get(property_id_int)  # ✅ Ищем по properties.id
            
            if property_data:
                property_data['created_at'] = fav.created_at.strftime('%d.%m.%Y в %H:%M') if fav.created_at else 'Недавно'
                favorites_list.append(property_data)
            else:
                print(f"⚠️ Property {fav.property_id} not found in database")
        
        print(f"✅ Returning {len(favorites_list)} favorites")
        
        return jsonify({
            'success': True,
            'favorites': favorites_list
        })
    
    except Exception as e:
        print(f"❌ ERROR in manager_get_favorites_list: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

    """Add residential complex to manager's favorites"""
    from models import ManagerFavoriteComplex
    
    current_manager = current_user
    data = request.get_json()
    
    complex_id = data.get('complex_id')
    complex_name = data.get('complex_name', 'ЖК')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    # Check if already in favorites
    existing = ManagerFavoriteComplex.query.filter_by(
        manager_id=current_manager.id,
        complex_id=str(complex_id)
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': 'Complex already in favorites'}), 400
    
    try:
        # Create favorite complex record
        favorite = ManagerFavoriteComplex(
            manager_id=current_manager.id,
            complex_id=str(complex_id),
            complex_name=complex_name,
            developer_name=data.get('developer_name', ''),
            complex_address=data.get('address', ''),
            district=data.get('district', ''),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            complex_image=data.get('image', ''),
            complex_url=data.get('url', ''),
            status=data.get('status', 'В продаже'),
            object_class_display_name=data.get('object_class_display_name', ''),
            notes=data.get('notes', ''),
            recommended_for=data.get('recommended_for', '')
        )
        
        db.session.add(favorite)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'ЖК добавлен в избранное'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/complexes/favorites/<complex_id>', methods=['DELETE'])
@manager_required
def manager_remove_complex_from_favorites(complex_id):
    """Remove residential complex from manager's favorites"""
    from models import ManagerFavoriteComplex
    
    current_manager = current_user
    
    favorite = ManagerFavoriteComplex.query.filter_by(
        manager_id=current_manager.id,
        complex_id=str(complex_id)
    ).first()
    
    if not favorite:
        return jsonify({'success': False, 'error': 'Complex not in favorites'}), 404
    
    try:
        db.session.delete(favorite)
        db.session.commit()
        return jsonify({'success': True, 'message': 'ЖК удален из избранного'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/complexes/favorites/clear', methods=['DELETE'])
@manager_required
def manager_clear_all_complex_favorites():
    """Clear all complexes from manager's favorites"""
    from models import ManagerFavoriteComplex
    
    current_manager = current_user
    
    try:
        # Delete all complex favorites for this manager
        deleted_count = ManagerFavoriteComplex.query.filter_by(
            manager_id=current_manager.id
        ).delete()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Удалено {deleted_count} ЖК из избранного',
            'deleted_count': deleted_count
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/complexes/favorites/toggle', methods=['POST'])
@manager_required
def manager_toggle_complex_favorite():
    """Toggle favorite status for residential complex"""
    from models import ManagerFavoriteComplex
    
    current_manager = current_user
    
    data = request.get_json()
    complex_id = data.get('complex_id')
    
    if not complex_id:
        return jsonify({'success': False, 'error': 'complex_id is required'}), 400
    
    try:
        existing = ManagerFavoriteComplex.query.filter_by(
            manager_id=current_manager.id,
            complex_id=str(complex_id)
        ).first()
        
        if existing:
            # Remove from favorites
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'favorited': False, 'message': 'ЖК удален из избранного'})
        else:
            # ✅ ИСПРАВЛЕНИЕ: Загружаем реальные данные ЖК из базы данных
            real_complex_name = 'ЖК без названия'
            real_developer_name = 'Застройщик не указан'
            real_address = 'Адрес не указан'
            real_district = 'Район не указан'
            real_min_price = 0
            real_max_price = 0
            real_image = '/static/images/no-photo.jpg'
            real_status = 'В продаже'
            real_object_class = ''
            
            try:
                # ✅ MIGRATED: Загружаем данные из normalized schema по complex_id
                from sqlalchemy import text
                complex_query = text("""
                    SELECT 
                        rc.name as complex_name,
                        d.name as developer_name,
                        rc.address AS address_display_name,
                        dist.name AS address_locality_name,
                        MIN(p.price) as min_price,
                        MAX(p.price) as max_price,
                        (SELECT p2.gallery_images FROM properties p2 
                         WHERE p2.complex_id = rc.id 
                         AND p2.gallery_images IS NOT NULL 
                         ORDER BY p2.price DESC LIMIT 1) AS photos,
                        rc.object_class_display_name
                    FROM residential_complexes rc
                    LEFT JOIN developers d ON rc.developer_id = d.id
                    LEFT JOIN districts dist ON rc.district_id = dist.id
                    LEFT JOIN properties p ON p.complex_id = rc.id
                    WHERE rc.id = :complex_id
                    GROUP BY rc.name, d.name, rc.address, dist.name, rc.id
                    LIMIT 1
                """)
                
                result = db.session.execute(complex_query, {'complex_id': str(complex_id)})
                row = result.fetchone()
                
                if row:
                    real_complex_name = row[0] or real_complex_name
                    real_developer_name = row[1] or real_developer_name  
                    real_address = row[2] or real_address
                    real_district = row[3] or real_district
                    real_min_price = int(row[4]) if row[4] else 0
                    real_max_price = int(row[5]) if row[5] else 0
                    real_object_class = row[7] or real_object_class
                    
                    # Парсим фото из JSON
                    if row[6]:
                        try:
                            import json
                            photos = json.loads(row[6]) if isinstance(row[6], str) else row[6]
                            if photos and isinstance(photos, list) and len(photos) > 0:
                                real_image = photos[0]  # Первое фото как основное
                        except Exception as photo_error:
                            print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                    
                    # Определяем статус по году сдачи
                    from datetime import datetime
                    current_year = datetime.now().year
                    
                    try:
                        # ✅ MIGRATED: Запрос статуса из normalized schema
                        status_query = text("""
                            SELECT end_build_year AS complex_building_end_build_year
                            FROM residential_complexes 
                            WHERE id = :complex_id 
                            AND end_build_year IS NOT NULL
                            LIMIT 1
                        """)
                        status_result = db.session.execute(status_query, {'complex_id': str(complex_id)})
                        status_row = status_result.fetchone()
                        
                        if status_row and status_row[0]:
                            build_year = int(status_row[0])
                            real_status = 'Сдан' if build_year <= current_year else 'Строится'
                    except:
                        pass
                        
            except Exception as e:
                print(f"Error loading real complex data for {complex_id}: {e}")
                # Продолжаем с fallback значениями
                pass
            
            # Add to favorites with REAL DATA
            favorite = ManagerFavoriteComplex(
                manager_id=current_manager.id,
                complex_id=str(complex_id),
                complex_name=real_complex_name,
                developer_name=real_developer_name,
                complex_address=real_address,
                district=real_district,
                min_price=real_min_price,
                max_price=real_max_price,
                complex_image=real_image,
                complex_url=data.get('url', f'/zk/{complex_id}'),
                status=real_status,
                object_class_display_name=real_object_class,
                notes=data.get('notes', ''),
                recommended_for=data.get('recommended_for', '')
            )
            
            db.session.add(favorite)
            db.session.commit()
            return jsonify({'success': True, 'favorited': True, 'message': 'ЖК добавлен в избранное'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/complexes/favorites/list', methods=['GET'])
@manager_required
def manager_get_complex_favorites_list():
    """Get manager's favorite complexes with full details"""
    from models import ManagerFavoriteComplex, ResidentialComplex, Developer, District
    from sqlalchemy.orm import joinedload, selectinload
    from sqlalchemy import or_
    
    current_manager = current_user
    
    try:
        # Загружаем избранное без broken relationship
        favorites = db.session.query(ManagerFavoriteComplex)\
            .filter_by(manager_id=current_manager.id)\
            .order_by(ManagerFavoriteComplex.created_at.desc()).all()
        
        # Собираем ID комплексов для batch-загрузки
        complex_ids_str = [fav.complex_id for fav in favorites if fav.complex_id]
        complex_ids_int = []
        for cid in complex_ids_str:
            try:
                complex_ids_int.append(int(cid))
            except (ValueError, TypeError):
                pass
        
        # BYPASSING broken favorites data - use direct ResidentialComplex lookup since FK is broken
        # Get complex names from ResidentialComplex table using favorites complex_id (if exists)
        complex_names = []
        for fav in favorites:
            if fav.complex_id:
                try:
                    complex_int_id = int(fav.complex_id)
                    rc = ResidentialComplex.query.get(complex_int_id)
                    if rc and rc.name:
                        complex_names.append(rc.name)
                except (ValueError, TypeError):
                    pass
        
        # Fallback: If no matches found, use all residential complexes for demo
        if not complex_names:
            all_complexes = ResidentialComplex.query.limit(10).all()
            complex_names = [rc.name for rc in all_complexes if rc.name]
        
        # ENSURE we include ALL favorite complex names even if not in excel_data
        # This prevents missing complexes in comparison
        for fav in favorites:
            if fav.complex_id:
                try:
                    complex_int_id = int(fav.complex_id)
                    rc = ResidentialComplex.query.get(complex_int_id)
                    if rc and rc.name and rc.name not in complex_names:
                        complex_names.append(rc.name)
                        print(f"DEBUG: Added missing favorite complex to search: {rc.name}")
                except (ValueError, TypeError):
                    pass
        excel_data = {}
        
        if complex_names:
            # SQL aggregation with proper expanding bind and name normalization
            from sqlalchemy import text, bindparam
            
            # Normalize names for matching
            normalized_names = tuple({n.strip().lower().replace('«','"').replace('»','"') 
                                    for n in complex_names if n})
            
            stmt = text("""
            SELECT 
                rc.name as complex_name,
                MIN(p.price) as min_price,
                MAX(p.price) as max_price,
                COUNT(p.id) as apartments_count,
                rc.address AS address_display_name,
                (SELECT p2.gallery_images FROM properties p2 
                 WHERE p2.complex_id = rc.id AND p2.gallery_images IS NOT NULL 
                 LIMIT 1) AS photos
            FROM residential_complexes rc
            LEFT JOIN properties p ON p.complex_id = rc.id
            WHERE lower(rc.name) IN :names
            GROUP BY rc.id, rc.name, rc.address
            """).bindparams(bindparam('names', expanding=True))
            
            result = db.session.execute(stmt, {'names': normalized_names})
            for row in result:
                # Store with original complex name for mapping
                for original_name in complex_names:
                    if original_name and original_name.strip().lower().replace('«','"').replace('»','"') == row.complex_name.lower():
                        excel_data[original_name] = {
                            'min_price': int(row.min_price) if row.min_price else 0,
                            'max_price': int(row.max_price) if row.max_price else 0,
                            'apartments_count': int(row.apartments_count) if row.apartments_count else 0,
                            'sample_address': row.address_display_name or '',
                            'photos': row.photos
                        }
                        break
            
            print(f"DEBUG: Searched {len(normalized_names)} names, found {len(excel_data)} matches")
            print(f"DEBUG: excel_data keys: {list(excel_data.keys())[:2]}")  # First 2 keys
        
        
        # Загружаем все комплексы сразу с joined данными  
        complexes_data = {}
        if complex_ids_str:
            complexes_query = db.session.query(ResidentialComplex)\
                .options(
                    joinedload(ResidentialComplex.developer), 
                    joinedload(ResidentialComplex.district),
                    selectinload(ResidentialComplex.buildings)
                )\
                .filter(or_(
                    ResidentialComplex.id.in_(complex_ids_int),
                    ResidentialComplex.complex_id.in_(complex_ids_str)
                ))
            
            for complex_data in complexes_query:
                complexes_data[str(complex_data.id)] = complex_data
                if complex_data.complex_id:
                    complexes_data[str(complex_data.complex_id)] = complex_data
        
        favorites_list = []
        for fav in favorites:
            # ✅ ИСПРАВЛЕНИЕ: Ищем данные по ResidentialComplex таблице и excel_properties
            real_complex_name = 'ЖК без названия'
            real_developer_name = 'Застройщик не указан'
            real_address = 'Адрес не указан'
            real_district = 'Район не указан'
            real_min_price = 0
            real_max_price = 0
            real_image = '/static/images/no-photo.jpg'
            real_status = 'В продаже'
            real_apartments_count = 0
            real_buildings_count = 1
            real_delivery_date = 'Не указано'
            
                # ✅ ИСПРАВЛЕНИЕ: Используем тот же SQL что и /residential-complexes для поиска по динамическим ID
            try:
                complex_db = None
                print(f"DEBUG: Searching for complex with fav.complex_id: {fav.complex_id}")
                
                if fav.complex_id:
                    # Сначала пробуем найти в residential_complexes (для старых записей)
                    try:
                        complex_int_id = int(fav.complex_id)
                        complex_db = ResidentialComplex.query.get(complex_int_id)
                        print(f"DEBUG: Found by id {complex_int_id}: {complex_db.name if complex_db else 'None'}")
                    except (ValueError, TypeError):
                        pass
                
                if complex_db and complex_db.name:
                    # Найдено в residential_complexes - используем эти данные
                    real_complex_name = complex_db.name
                    real_developer_name = complex_db.developer.name if complex_db.developer else real_developer_name
                    real_district = complex_db.district.name if complex_db.district else real_district
                    # Адрес берем из sales_address или оставляем placeholder для последующей загрузки из excel_properties
                    real_address = complex_db.sales_address if hasattr(complex_db, 'sales_address') and complex_db.sales_address else real_address
                    real_image = complex_db.main_image if hasattr(complex_db, 'main_image') and complex_db.main_image else real_image
                    print(f"DEBUG: ✅ Using residential_complexes data: {real_complex_name}")
                else:
                    # ✅ MIGRATED: Complex not found in residential_complexes table
                    # With normalized schema, all complexes should exist in residential_complexes
                    # If not found, will use default values set above
                    print(f"DEBUG: ⚠️ Complex with ID {fav.complex_id} not found in residential_complexes")
                
                # ✅ MIGRATED: Дополнительный поиск данных в normalized schema по названию ЖК (всегда выполняется)
                if real_complex_name != 'ЖК без названия':
                    from sqlalchemy import text
                    excel_query = text("""
                        SELECT 
                            MIN(p.price) as min_price,
                            MAX(p.price) as max_price,
                            COUNT(p.id) as apartments_count,
                            COUNT(DISTINCT b.id) as buildings_count,
                            rc.end_build_year AS complex_building_end_build_year,
                            rc.end_build_quarter AS complex_building_end_build_quarter,
                            (SELECT p2.gallery_images FROM properties p2 
                             WHERE p2.complex_id = rc.id AND p2.gallery_images IS NOT NULL 
                             LIMIT 1) AS photos,
                            rc.address AS address_display_name,
                            dist.name AS address_locality_name,
                            d.name as developer_name
                        FROM residential_complexes rc
                        LEFT JOIN properties p ON p.complex_id = rc.id
                        LEFT JOIN buildings b ON b.complex_id = rc.id
                        LEFT JOIN developers d ON rc.developer_id = d.id
                        LEFT JOIN districts dist ON rc.district_id = dist.id
                        WHERE rc.name = :complex_name
                        GROUP BY rc.id, rc.end_build_year, rc.end_build_quarter, rc.address, dist.name, d.name
                        LIMIT 1
                    """)
                    
                    # Use exact match on complex name (no LIKE pattern needed)
                    print(f"DEBUG: Searching normalized schema for complex: {real_complex_name}")
                    result = db.session.execute(excel_query, {'complex_name': real_complex_name})
                    row = result.fetchone()
                    
                    print(f"DEBUG: Normalized schema query result - found: {row is not None}, has price: {row[0] if row else 'N/A'}")
                    if row:
                        print(f"DEBUG: Normalized data - address: {row[7]}, district: {row[8]}, developer: {row[9]}")
                    
                    if row and row[0]:  # Если найдены данные
                        real_min_price = int(row[0]) if row[0] else 0
                        real_max_price = int(row[1]) if row[1] else 0
                        real_apartments_count = int(row[2]) if row[2] else 0
                        real_buildings_count = max(int(row[3]) if row[3] else 1, 1)
                        
                        # Парсим фото из JSON
                        if row[6]:
                            try:
                                import json
                                photos = json.loads(row[6]) if isinstance(row[6], str) else row[6]
                                if photos and isinstance(photos, list) and len(photos) > 0:
                                    # Берем фото ЖК, пропуская интерьеры квартир
                                    start_index = min(len(photos) // 4, 5) if len(photos) > 8 else 1
                                    real_image = photos[start_index] if len(photos) > start_index else photos[0]
                            except Exception as photo_error:
                                print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                        
                        # Обновляем адрес, район и застройщика из normalized schema если они не были заполнены
                        if row[7] and (not real_address or real_address == 'Адрес не указан'):
                            real_address = row[7]
                            print(f"DEBUG: Updated address from normalized schema: {real_address}")
                        if row[8] and (not real_district or real_district == 'Район не указан'):
                            real_district = row[8]
                            print(f"DEBUG: Updated district from normalized schema: {real_district}")
                        if row[9] and (not real_developer_name or real_developer_name == 'Застройщик не указан'):
                            real_developer_name = row[9]
                            print(f"DEBUG: Updated developer from normalized schema: {real_developer_name}")
                        
                        # Определяем статус и дату сдачи
                        if row[4] and row[5]:  # end_build_year и end_build_quarter
                            build_year = int(row[4])
                            build_quarter = int(row[5])
                            quarter_names = {1: 'I', 2: 'II', 3: 'III', 4: 'IV'}
                            quarter = quarter_names.get(build_quarter, build_quarter)
                            real_delivery_date = f"{quarter} кв. {build_year} г."
                            
                            from datetime import datetime
                            current_year = datetime.now().year
                            real_status = 'Сдан' if build_year <= current_year else 'Строится'
                        elif row[4]:  # только год
                            build_year = int(row[4])
                            real_delivery_date = f"{build_year} г."
                            from datetime import datetime
                            real_status = 'Сдан' if build_year <= datetime.now().year else 'Строится'
                                
            except Exception as e:
                print(f"Error loading complex data for {fav.complex_id}: {e}")
                pass
            
            # Ищем полные данные ЖК (ResidentialComplex)
            complex_data = complexes_data.get(str(fav.complex_id))
            
            # Безопасный способ создания slug с fallback
            try:
                url = f"/zk/{create_slug(real_complex_name)}" if real_complex_name and real_complex_name != 'ЖК без названия' else '#'
            except:
                url = '#'
            
            # ✅ Подтягиваем реальный кэшбек из ResidentialComplex или используем значение по умолчанию
            real_cashback_rate = 5.0
            real_housing_class = 'Комфорт'
            if complex_data:
                real_cashback_rate = complex_data.cashback_rate if complex_data.cashback_rate else 5.0
                real_housing_class = complex_data.object_class_display_name if complex_data.object_class_display_name else 'Комфорт'
            
            # ✅ ИСПОЛЬЗУЕМ ТОЛЬКО РЕАЛЬНЫЕ ДАННЫЕ - игнорируем старые placeholder
            favorites_list.append({
                'id': str(fav.complex_id),
                'name': real_complex_name,
                'developer': real_developer_name,
                'address': real_address,
                'district': real_housing_class,  # ✅ Показываем класс жилья вместо района
                'housing_class': real_housing_class,  # ✅ Класс жилья
                'min_price': real_min_price,
                'max_price': real_max_price,
                'apartments_count': real_apartments_count,
                'buildings_count': real_buildings_count,
                'image': real_image,
                'url': url,
                'status': real_status,
                'delivery_date': real_delivery_date,
                'notes': fav.notes or '',
                'recommended_for': fav.recommended_for or '',
                'created_at': fav.created_at.strftime('%d.%m.%Y в %H:%M') if fav.created_at else 'Недавно',
                'cashback_rate': real_cashback_rate  # ✅ Реальный кэшбек из базы данных
            })
        
        print(f"Found {len(favorites)} favorite complexes for manager {current_manager.id}")
        if favorites:
            print(f"First complex: {favorites_list[0]}")
        
        return jsonify({
            'success': True,
            'complexes': favorites_list,
            'favorite_complexes': favorites_list,  # добавить alias
            'favorites': favorites_list  # добавить alias
        })
    
    except Exception as e:
        print(f"Error loading favorite complexes: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

# User Management Routes
@app.route('/admin/users')
@admin_required
def admin_users():
    """User management page"""
    try:
        from models import Admin, User
        
        # ИСПРАВЛЕНО: Используем Flask-Login current_user
        current_admin = current_user
        
        page = request.args.get('page', 1, type=int)
        search = request.args.get('search', '', type=str)
        status = request.args.get('status', '', type=str)
        
        query = User.query
        
        if search:
            query = query.filter(User.email.contains(search) | User.full_name.contains(search))
        
        if status == 'active':
            query = query.filter_by(is_active=True)
        elif status == 'inactive':
            query = query.filter_by(is_active=False)
        elif status == 'verified':
            query = query.filter_by(is_verified=True)
        elif status == 'unverified':
            query = query.filter_by(is_verified=False)
        
        users = query.order_by(User.created_at.desc()).paginate(
            page=page, per_page=20, error_out=False
        )
        
        # Обработка пользователей для безопасного отображения дат
        from datetime import datetime
        for user in users.items:
            if user.created_at is None:
                # Устанавливаем текущую дату для пользователей без даты создания
                user.created_at = datetime.now()
        
        print(f"DEBUG: Loading admin_users page - Found {users.total} users")
        
        return render_template('admin/users.html', 
                             admin=current_admin, 
                             users=users,
                             search=search,
                             status=status)
                             
    except Exception as e:
        print(f"ERROR in admin_users: {str(e)}")
        import traceback
        traceback.print_exc()
        flash(f'Ошибка загрузки страницы пользователей: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))

@app.route('/admin/users/<int:user_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_user(user_id):
    """Edit user details"""
    from models import Admin, User, Manager
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    user = User.query.get_or_404(user_id)
    managers = Manager.query.filter_by(is_active=True).all()
    
    if request.method == 'POST':
        user.email = request.form.get('email')
        user.full_name = request.form.get('full_name')
        user.phone = request.form.get('phone')
        user.client_status = request.form.get('client_status')
        user.client_notes = request.form.get('client_notes')
        user.is_active = 'is_active' in request.form
        user.is_verified = 'is_verified' in request.form
        
        assigned_manager_id = request.form.get('assigned_manager_id')
        if assigned_manager_id and assigned_manager_id.isdigit():
            user.assigned_manager_id = int(assigned_manager_id)
        else:
            user.assigned_manager_id = None
        
        try:
            db.session.commit()
            flash('Пользователь успешно обновлен', 'success')
            return redirect(url_for('admin_users'))
        except Exception as e:
            db.session.rollback()
            flash('Ошибка при обновлении пользователя', 'error')
    
    return render_template('admin/edit_user.html', 
                         admin=current_admin, 
                         user=user,
                         managers=managers)

@app.route('/admin/users/<int:user_id>/toggle-status', methods=['POST'])
@admin_required
def admin_toggle_user_status(user_id):
    """Toggle user active status (block/activate)"""
    from models import User, Admin
    
    user = User.query.get_or_404(user_id)
    current_admin = current_user
    
    try:
        # Toggle the status
        user.is_active = not user.is_active
        status_text = "активирован" if user.is_active else "заблокирован"
        
        db.session.commit()
        
        # Log the action
        print(f"ADMIN ACTION: {current_admin.full_name} (ID: {current_admin.id}) {'activated' if user.is_active else 'blocked'} user {user.full_name} (ID: {user.id}, Email: {user.email})")
        
        flash(f'Пользователь {user.full_name} успешно {status_text}', 'success')
    except Exception as e:
        db.session.rollback()
        print(f"ERROR in admin_toggle_user_status: {str(e)}")
        flash(f'Ошибка при изменении статуса пользователя: {str(e)}', 'error')
    
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/delete', methods=['POST'])
@admin_required
def admin_delete_user(user_id):
    """Delete user"""
    from models import User
    
    user = User.query.get_or_404(user_id)
    
    try:
        db.session.delete(user)
        db.session.commit()
        flash('Пользователь успешно удален', 'success')
    except Exception as e:
        db.session.rollback()
        flash('Ошибка при удалении пользователя', 'error')
    
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/reset-password', methods=['POST'])
@admin_required
def admin_reset_user_password(user_id):
    """Admin reset user password - sends reset email"""
    from models import User
    
    user = User.query.get_or_404(user_id)
    
    try:
        # Generate reset token and send email
        token = user.generate_verification_token()
        db.session.commit()
        
        try:
            from email_service import send_password_reset_email
            send_password_reset_email(user, token)
            flash(f'Письмо сброса пароля отправлено на {user.email}', 'success')
        except Exception as e:
            print(f"Error sending password reset email: {e}")
            flash(f'Ошибка отправки письма: {str(e)}', 'error')
            
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при генерации токена: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/toggle-role', methods=['POST'])
@admin_required 
def admin_toggle_user_role(user_id):
    """Admin change user role"""
    from models import User
    
    user = User.query.get_or_404(user_id)
    new_role = request.form.get('role')
    
    # Validate role
    valid_roles = ['buyer', 'manager', 'admin', None]
    if new_role == '':
        new_role = None
    
    if new_role not in valid_roles:
        flash('Неверная роль пользователя', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        old_role = user.role or 'Не назначена'
        user.role = new_role
        db.session.commit()
        
        new_role_display = new_role or 'Не назначена'
        flash(f'Роль пользователя {user.email} изменена с "{old_role}" на "{new_role_display}"', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при изменении роли: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/bulk-role', methods=['POST'])
@admin_required
def admin_bulk_assign_role():
    """Bulk assign role to users"""
    from models import User
    
    user_ids = request.form.getlist('user_ids')
    new_role = request.form.get('role')
    
    if new_role == '':
        new_role = None
    
    valid_roles = ['buyer', 'manager', 'admin', None]
    if new_role not in valid_roles:
        flash('Неверная роль пользователя', 'error')
        return redirect(url_for('admin_users'))
    
    if not user_ids:
        flash('Не выбраны пользователи', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        users = User.query.filter(User.id.in_(user_ids)).all()
        role_display = new_role or 'Не назначена'
        updated_count = 0
        
        for user in users:
            user.role = new_role
            updated_count += 1
        
        db.session.commit()
        flash(f'Роль "{role_display}" назначена для {updated_count} пользователей', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при массовом назначении роли: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/bulk-status', methods=['POST'])
@admin_required
def admin_bulk_toggle_status():
    """Bulk toggle user status"""
    from models import User
    
    user_ids = request.form.getlist('user_ids')
    
    if not user_ids:
        flash('Не выбраны пользователи', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        users = User.query.filter(User.id.in_(user_ids)).all()
        activated_count = 0
        deactivated_count = 0
        
        for user in users:
            if user.is_active:
                user.is_active = False
                deactivated_count += 1
            else:
                user.is_active = True
                activated_count += 1
        
        db.session.commit()
        
        if activated_count > 0 and deactivated_count > 0:
            flash(f'Активировано: {activated_count}, деактивировано: {deactivated_count} пользователей', 'success')
        elif activated_count > 0:
            flash(f'Активировано {activated_count} пользователей', 'success')
        else:
            flash(f'Деактивировано {deactivated_count} пользователей', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при массовом изменении статуса: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/bulk-delete', methods=['POST'])
@admin_required
def admin_bulk_delete_users():
    """Bulk delete users"""
    from models import User
    
    user_ids = request.form.getlist('user_ids')
    
    if not user_ids:
        flash('Не выбраны пользователи', 'error')
        return redirect(url_for('admin_users'))
    
    try:
        users = User.query.filter(User.id.in_(user_ids)).all()
        deleted_count = len(users)
        
        for user in users:
            db.session.delete(user)
        
        db.session.commit()
        flash(f'Удалено {deleted_count} пользователей', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при массовом удалении: {str(e)}', 'error')
        
    return redirect(url_for('admin_users'))

@app.route('/admin/users/create', methods=['GET', 'POST'])
@csrf.exempt
@admin_required
def admin_create_user():
    """Create new user by admin"""
    from models import Admin, User, Manager
    import re
    import secrets
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    managers = Manager.query.filter_by(is_active=True).all()
    
    if request.method == 'POST':
        try:
            # Validate required fields
            full_name = request.form.get('full_name', '').strip()
            email = request.form.get('email', '').strip().lower()
            phone = request.form.get('phone', '').strip()
            
            if not all([full_name, email, phone]):
                flash('Заполните все обязательные поля', 'error')
                return render_template('admin/create_user.html', 
                                     admin=current_admin, 
                                     managers=managers)
            
            # Validate email format
            if not re.match(r'^[^\s@]+@[^\s@]+\.[^\s@]+$', email):
                flash('Некорректный формат email', 'error')
                return render_template('admin/create_user.html', 
                                     admin=current_admin, 
                                     managers=managers)
            
            # Check if user already exists
            existing_user = User.query.filter(
                (User.email == email) | (User.phone == phone)
            ).first()
            
            if existing_user:
                flash('Пользователь с таким email или телефоном уже существует', 'error')
                return render_template('admin/create_user.html', 
                                     admin=current_admin, 
                                     managers=managers)
            
            # Clean phone number
            phone_clean = re.sub(r'[^\d]', '', phone)
            if len(phone_clean) == 11 and phone_clean.startswith('8'):
                phone_clean = '7' + phone_clean[1:]
            elif len(phone_clean) == 10:
                phone_clean = '7' + phone_clean
            
            if len(phone_clean) != 11 or not phone_clean.startswith('7'):
                flash('Некорректный формат телефона', 'error')
                return render_template('admin/create_user.html', 
                                     admin=current_admin, 
                                     managers=managers)
            
            # Generate temporary password
            temp_password = secrets.token_urlsafe(12)
            
            # Create user
            user = User(
                email=email,
                full_name=full_name,
                phone=phone_clean,
                client_status=request.form.get('client_status', 'Новый'),
                client_notes=request.form.get('client_notes', ''),
                is_active='is_active' in request.form,
                is_verified='is_verified' in request.form,
                temp_password_hash=temp_password,  # Store temp password for sending
                created_by_admin=True
            )
            
            # Set assigned manager
            assigned_manager_id = request.form.get('assigned_manager_id')
            if assigned_manager_id and assigned_manager_id.isdigit():
                user.assigned_manager_id = int(assigned_manager_id)
            
            # Set temporary password
            user.set_password(temp_password)
            
            db.session.add(user)
            db.session.commit()
            
            print(f"DEBUG: Successfully created user {user.id}: {user.full_name} by admin")
            print(f"DEBUG: Temporary password: {temp_password}")
            
            # Show password to admin (no email/SMS sending for now)
            flash(f'Пользователь {full_name} успешно создан!', 'success')
            flash(f'Email для входа: {email}', 'info')
            flash(f'Временный пароль: {temp_password}', 'warning')
            flash('Скопируйте пароль - он больше не будет отображаться!', 'warning')
            
            return redirect(url_for('admin_users'))
        
        except Exception as e:
            db.session.rollback()
            print(f"Error creating user: {str(e)}")
            flash(f'Ошибка при создании пользователя: {str(e)}', 'error')
            return render_template('admin/create_user.html', 
                                 admin=current_admin, 
                                 managers=managers)
    
    return render_template('admin/create_user.html', 
                         admin=current_admin, 
                         managers=managers)

@app.route('/admin/users/<int:user_id>/verify', methods=['POST'])
@admin_required
def admin_verify_user(user_id):
    """Verify user account manually"""
    from models import User, Admin
    
    try:
        user = User.query.get_or_404(user_id)
        
        # Проверяем, что пользователь не верифицирован
        if user.is_verified:
            flash(f'Пользователь {user.full_name} уже подтвержден', 'info')
            return redirect(url_for('admin_users'))
        
        # Подтверждаем пользователя
        user.is_verified = True
        
        # ИСПРАВЛЕНО: Используем Flask-Login current_user
        # Логирование действия админа
        current_admin = current_user
        admin_name = current_admin.full_name if current_admin else 'Неизвестный админ'
        
        print(f"ADMIN ACTION: {admin_name} (ID: {current_admin.id}) verified user {user.full_name} (ID: {user.id}, Email: {user.email})")
        
        db.session.commit()
        flash(f'Аккаунт пользователя {user.full_name} успешно подтвержден', 'success')
        
        # Поддержка AJAX запросов
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': True,
                'message': f'Аккаунт пользователя {user.full_name} подтвержден',
                'user_id': user.id,
                'verified': True
            })
            
    except Exception as e:
        db.session.rollback()
        error_message = f'Ошибка при подтверждении пользователя: {str(e)}'
        print(f"Error verifying user {user_id}: {str(e)}")
        flash(error_message, 'error')
        
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': False,
                'error': error_message
            }), 500
    
    return redirect(url_for('admin_users'))

@app.route('/admin/users/<int:user_id>/unverify', methods=['POST'])
@admin_required 
def admin_unverify_user(user_id):
    """Unverify user account manually"""
    from models import User, Admin
    
    try:
        user = User.query.get_or_404(user_id)
        
        # Проверяем, что пользователь верифицирован
        if not user.is_verified:
            flash(f'Пользователь {user.full_name} уже не подтвержден', 'info')
            return redirect(url_for('admin_users'))
        
        # Отменяем подтверждение
        user.is_verified = False
        
        # ИСПРАВЛЕНО: Используем Flask-Login current_user
        # Логирование действия админа
        current_admin = current_user
        admin_name = current_admin.full_name if current_admin else 'Неизвестный админ'
        
        print(f"ADMIN ACTION: {admin_name} (ID: {current_admin.id}) unverified user {user.full_name} (ID: {user.id}, Email: {user.email})")
        
        db.session.commit()
        flash(f'Подтверждение аккаунта пользователя {user.full_name} отменено', 'warning')
        
        # Поддержка AJAX запросов
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': True,
                'message': f'Подтверждение аккаунта {user.full_name} отменено',
                'user_id': user.id,
                'verified': False
            })
            
    except Exception as e:
        db.session.rollback()
        error_message = f'Ошибка при отмене подтверждения: {str(e)}'
        print(f"Error unverifying user {user_id}: {str(e)}")
        flash(error_message, 'error')
        
        if request.headers.get('Content-Type') == 'application/json' or request.is_json:
            return jsonify({
                'success': False,
                'error': error_message
            }), 500
    
    return redirect(url_for('admin_users'))


# Property Management Routes
@app.route('/admin/property/<int:property_id>/mark-sold', methods=['POST'])
@admin_required
def admin_mark_property_sold(property_id):
    """
    Mark a property as sold and notify all users who have it in:
    - favorites
    - comparisons
    - presentations/collections
    """
    from models import Property
    from services.alert_service import AlertService
    
    try:
        property = Property.query.get_or_404(property_id)
        
        if not property.is_active:
            return jsonify({
                'success': False,
                'message': 'Объект уже помечен как проданный'
            }), 400
        
        # Mark property as sold (inactive)
        property.is_active = False
        property.status = 'Продан'
        
        db.session.commit()
        
        # Send notifications to all affected users
        logger.info(f"Property {property_id} marked as sold, sending notifications...")
        notification_result = AlertService.notify_property_sold(property_id)
        
        flash(f'Объект "{property.title}" помечен как проданный. Уведомления отправлены.', 'success')
        
        return jsonify({
            'success': True,
            'message': 'Объект помечен как проданный, уведомления отправлены',
            'property_id': property_id,
            'notifications_sent': notification_result
        })
        
    except Exception as e:
        db.session.rollback()
        error_message = f'Ошибка при пометке объекта как проданного: {str(e)}'
        logger.error(error_message)
        flash(error_message, 'error')
        
        return jsonify({
            'success': False,
            'error': error_message
        }), 500

# Manager Management Routes
@app.route('/admin/managers')
@admin_required
def admin_managers():
    """Manager management page"""
    from models import Admin, Manager
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    page = request.args.get('page', 1, type=int)
    search = request.args.get('search', '', type=str)
    status = request.args.get('status', '', type=str)
    
    query = Manager.query
    
    if search:
        query = query.filter(Manager.email.contains(search) | Manager.first_name.contains(search) | Manager.last_name.contains(search))
    
    if status == 'active':
        query = query.filter_by(is_active=True)
    elif status == 'inactive':
        query = query.filter_by(is_active=False)
    
    managers = query.order_by(Manager.created_at.desc()).paginate(
        page=page, per_page=20, error_out=False
    )
    
    return render_template('admin/managers.html', 
                         admin=current_admin, 
                         managers=managers,
                         search=search,
                         status=status)

@app.route('/admin/managers/<int:manager_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_manager(manager_id):
    """Edit manager details"""
    from models import Admin, Manager
    
    try:
        # ИСПРАВЛЕНО: Используем Flask-Login current_user
        current_admin = current_user
        manager = Manager.query.get(manager_id)
        
        if not manager:
            flash(f'Менеджер с ID {manager_id} не найден', 'error')
            return redirect(url_for('admin_managers'))
            
        print(f"DEBUG: Found manager {manager_id}: {manager.email}")
    except Exception as e:
        print(f"ERROR in admin_edit_manager: {e}")
        flash('Ошибка при загрузке менеджера', 'error')
        return redirect(url_for('admin_managers'))
    
    if request.method == 'POST':
        manager.email = request.form.get('email')
        manager.first_name = request.form.get('first_name')
        manager.last_name = request.form.get('last_name')
        manager.phone = request.form.get('phone')
        manager.position = request.form.get('position')
        manager.is_active = 'is_active' in request.form
        
        new_password = request.form.get('new_password')
        if new_password:
            manager.set_password(new_password)
        
        try:
            db.session.commit()
            flash('Менеджер успешно обновлен', 'success')
            return redirect(url_for('admin_managers'))
        except Exception as e:
            db.session.rollback()
            flash('Ошибка при обновлении менеджера', 'error')
    
    from datetime import datetime
    
    return render_template('admin/edit_manager.html', 
                         admin=current_admin, 
                         manager=manager,
                         current_date=datetime.utcnow())



# Blog Management Routes
@app.route('/admin/blog')
@admin_required
def admin_blog():
    """Blog management page"""
    from models import Admin, BlogPost
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    page = request.args.get('page', 1, type=int)
    search = request.args.get('search', '', type=str)
    status = request.args.get('status', '', type=str)
    category_id = request.args.get('category_id', '', type=str)
    
    query = BlogPost.query
    
    if search:
        query = query.filter(BlogPost.title.contains(search) | BlogPost.content.contains(search))
    
    if status:
        query = query.filter_by(status=status)
    
    if category_id:
        query = query.filter_by(category_id=int(category_id))
    
    posts = query.order_by(BlogPost.created_at.desc()).paginate(
        page=page, per_page=10, error_out=False
    )
    
    # Get categories for filter from Category table
    from models import Category
    categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
    
    return render_template('admin/blog.html', 
                         admin=current_admin, 
                         posts=posts,
                         search=search,
                         status=status,
                         category_id=category_id,
                         categories=categories)

@app.route('/admin/blog/create', methods=['GET', 'POST'])
@admin_required
# @csrf.exempt  # CSRF disabled  # Временно отключаем CSRF для отладки
def admin_create_post():
    """Create new blog post with full TinyMCE integration"""
    from models import Admin, BlogPost, Category
    from datetime import datetime
    import re
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    if request.method == 'GET':
        # Load categories for the form
        categories = Category.query.order_by(Category.name).all()
        return render_template('admin/create_article.html', admin=current_admin, categories=categories)
    
    if request.method == 'POST':
        try:
            title = request.form.get('title')
            content = request.form.get('content')
            excerpt = request.form.get('excerpt')
            category_id = request.form.get('category_id')
            
            # Handle featured image upload
            featured_image_url = request.form.get('featured_image', '')
            uploaded_file = request.files.get('featured_image_file')
            
            if uploaded_file and uploaded_file.filename:
                # Secure filename and save
                from werkzeug.utils import secure_filename
                import os
                filename = secure_filename(uploaded_file.filename)
                
                # Create upload directory if it doesn't exist
                upload_dir = 'static/uploads/blog'
                os.makedirs(upload_dir, exist_ok=True)
                
                # Save file with unique name
                import uuid
                unique_filename = f"{uuid.uuid4()}_{filename}"
                file_path = os.path.join(upload_dir, unique_filename)
                uploaded_file.save(file_path)
                
                # Set the URL for the database
                featured_image_url = f"/{file_path}"
            
            if not title or not content or not category_id:
                flash('Заголовок, содержание и категория обязательны', 'error')
                categories = Category.query.order_by(Category.name).all()
                return render_template('admin/create_article.html', admin=current_admin, categories=categories)
            
            # Get category name from category_id
            category = Category.query.get(int(category_id))
            if not category:
                flash('Выбранная категория не найдена', 'error')
                categories = Category.query.order_by(Category.name).all()
                return render_template('admin/create_article.html', admin=current_admin, categories=categories)
            
            # Generate slug from title
            slug = request.form.get('slug', '')
            if not slug:
                # Auto-generate slug from title
                def transliterate(text):
                    rus_to_eng = {
                        'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'yo', 'ж': 'zh', 'з': 'z',
                        'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r',
                        'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
                        'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'
                    }
                    return ''.join(rus_to_eng.get(char.lower(), char) for char in text)
                
                slug = transliterate(title.lower())
                slug = re.sub(r'[^\w\s-]', '', slug)
                slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure unique slug
            original_slug = slug
            counter = 1
            while BlogPost.query.filter_by(slug=slug).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            post = BlogPost(
                title=title,
                slug=slug,
                content=content,
                excerpt=excerpt,
                meta_title=request.form.get('meta_title'),
                meta_description=request.form.get('meta_description'),
                meta_keywords=request.form.get('meta_keywords'),
                category_id=category.id,  # Store category ID for proper relation
                category=category.name,  # Store category name for compatibility
                tags=request.form.get('tags'),
                featured_image=featured_image_url,
                status=request.form.get('status', 'draft'),
                author_id=current_admin.id,
                created_at=datetime.utcnow()
            )
            
            if post.status == 'published':
                post.published_at = datetime.utcnow()
            
            db.session.add(post)
            db.session.commit()
            
            # Update category article count
            if post.status == 'published':
                category.articles_count = BlogPost.query.filter_by(category=category.name, status='published').count()
                db.session.commit()
            
            flash('Статья успешно создана!', 'success')
            return redirect(url_for('admin_blog'))
            
        except Exception as e:
            db.session.rollback()
            print(f'ERROR creating blog post: {str(e)}')
            flash(f'Ошибка при создании статьи: {str(e)}', 'error')
            categories = Category.query.order_by(Category.name).all()
            return render_template('admin/create_article.html', admin=current_admin, categories=categories)


@app.route('/admin/blog/<int:post_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_post(post_id):
    """Edit blog post"""
    from models import Admin, BlogPost, Category
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    try:
        post = BlogPost.query.get_or_404(post_id)
    except Exception as e:
        flash(f'Статья не найдена: {str(e)}', 'error')
        return redirect(url_for('admin_blog'))
    
    if request.method == 'POST':
        post.title = request.form.get('title')
        post.content = request.form.get('content')
        post.excerpt = request.form.get('excerpt')
        post.meta_title = request.form.get('meta_title')
        post.meta_description = request.form.get('meta_description')
        post.meta_keywords = request.form.get('meta_keywords')
        post.category = request.form.get('category')
        post.tags = request.form.get('tags')
        post.featured_image = request.form.get('featured_image')
        
        old_status = post.status
        post.status = request.form.get('status', 'draft')
        
        # Handle publishing
        if post.status == 'published' and old_status != 'published':
            post.published_at = datetime.utcnow()
        elif post.status != 'published':
            post.published_at = None
        
        try:
            db.session.commit()
            flash('Статья успешно обновлена', 'success')
            return redirect(url_for('admin_blog'))
        except Exception as e:
            db.session.rollback()
            flash(f'Ошибка при обновлении статьи: {str(e)}', 'error')
    
    # Get categories for dropdown
    try:
        categories = Category.query.order_by(Category.name).all()
    except Exception as e:
        print(f'Error loading categories: {e}')
        categories = []
    
    return render_template('admin/blog_post_create.html', 
                         admin=current_admin, 
                         post=post, 
                         categories=categories)

@app.route('/admin/blog/<int:post_id>/delete', methods=['POST'])
@admin_required
def admin_delete_post(post_id):
    """Delete blog post"""
    from models import BlogPost
    
    post = BlogPost.query.get_or_404(post_id)
    
    try:
        db.session.delete(post)
        db.session.commit()
        flash('Статья успешно удалена', 'success')
    except Exception as e:
        db.session.rollback()
        flash('Ошибка при удалении статьи', 'error')
    
    return redirect(url_for('admin_blog'))

# Analytics Routes
@app.route('/admin/analytics/cashback')
@admin_required
def admin_cashback_analytics():
    """Cashback analytics page"""
    from models import Admin, CashbackApplication
    from sqlalchemy import func
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    # Monthly cashback stats
    monthly_stats = db.session.query(
        func.date_trunc('month', CashbackApplication.created_at).label('month'),
        func.count(CashbackApplication.id).label('count'),
        func.sum(CashbackApplication.cashback_amount).label('total_amount')
    ).group_by(func.date_trunc('month', CashbackApplication.created_at)).order_by('month').all()
    
    # Status breakdown
    status_stats = db.session.query(
        CashbackApplication.status,
        func.count(CashbackApplication.id).label('count'),
        func.sum(CashbackApplication.cashback_amount).label('total_amount')
    ).group_by(CashbackApplication.status).all()
    
    # Recent large cashbacks
    large_cashbacks = CashbackApplication.query.filter(
        CashbackApplication.cashback_amount >= 100000
    ).order_by(CashbackApplication.created_at.desc()).limit(10).all()
    
    return render_template('admin/cashback_analytics.html',
                         admin=current_admin,
                         monthly_stats=monthly_stats,
                         status_stats=status_stats,
                         large_cashbacks=large_cashbacks)

# Admin Blog Management Routes

@app.route('/admin/blog/<int:article_id>/edit', methods=['GET', 'POST'])
@admin_required  
def admin_edit_article(article_id):
    """Edit blog article"""
    from models import Admin, BlogPost
    import re
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    article = BlogPost.query.get_or_404(article_id)
    
    if request.method == 'POST':
        article.title = request.form.get('title')
        article.slug = request.form.get('slug')
        article.content = request.form.get('content')
        article.excerpt = request.form.get('excerpt')
        article.category = request.form.get('category')
        article.tags = request.form.get('tags')
        article.featured_image = request.form.get('featured_image')
        article.meta_title = request.form.get('meta_title')
        article.meta_description = request.form.get('meta_description')
        article.meta_keywords = request.form.get('meta_keywords')
        action = request.form.get('action', 'save')
        
        # Auto-generate slug if empty
        if not article.slug:
            slug = re.sub(r'[^\w\s-]', '', article.title.lower())
            slug = re.sub(r'[\s_-]+', '-', slug)
            article.slug = slug.strip('-')
        
        # Set status based on action
        if action == 'publish':
            article.status = 'published'
            if not article.published_at:
                article.published_at = datetime.now()
        else:
            article.status = request.form.get('status', 'draft')
        
        # Handle scheduled posts
        if article.status == 'scheduled':
            scheduled_str = request.form.get('scheduled_for')
            if scheduled_str:
                try:
                    article.scheduled_for = datetime.fromisoformat(scheduled_str)
                except:
                    pass
        else:
            article.scheduled_for = None
            
        article.updated_at = datetime.now()
        
        try:
            db.session.commit()
            flash('Статья успешно обновлена', 'success')
            return redirect(url_for('admin_blog'))
        except Exception as e:
            db.session.rollback()
            flash('Ошибка при обновлении статьи', 'error')
    
    return render_template('admin/create_article.html', admin=current_admin, article=article)

@app.route('/admin/blog/<int:article_id>/delete', methods=['POST'])
@admin_required
def admin_delete_article(article_id):
    """Delete blog article"""
    from models import BlogPost
    
    article = BlogPost.query.get_or_404(article_id)
    
    try:
        db.session.delete(article)
        db.session.commit()
        flash('Статья успешно удалена', 'success')
    except Exception as e:
        db.session.rollback()
        flash('Ошибка при удалении статьи', 'error')
    
    return redirect(url_for('admin_blog'))

@app.route('/admin/blog/<int:article_id>/publish', methods=['POST'])
@admin_required
def admin_publish_article(article_id):
    """Publish blog article"""
    from models import BlogPost
    
    article = BlogPost.query.get_or_404(article_id)
    article.status = 'published'
    article.published_at = datetime.now()
    article.updated_at = datetime.now()
    
    try:
        db.session.commit()
        flash('Статья успешно опубликована', 'success')
    except Exception as e:
        db.session.rollback()
        flash('Ошибка при публикации статьи', 'error')
    
    return redirect(url_for('admin_blog'))


# ==========================================
# ADMIN OFFERS MANAGEMENT ROUTES
# ==========================================

@app.route('/admin/complexes-offers')
@csrf.exempt
@admin_required
def admin_complexes_offers():
    """List all residential complexes for managing their offers"""
    from models import ResidentialComplex, Developer, Offer
    
    # Get search parameter
    search = request.args.get('search', '').strip()
    page = request.args.get('page', 1, type=int)
    per_page = 50
    
    # Build query with developer info
    query = ResidentialComplex.query.join(Developer, isouter=True)
    
    # Apply search filter if provided
    if search:
        query = query.filter(ResidentialComplex.name.ilike(f'%{search}%'))
    
    # Order by name
    query = query.order_by(ResidentialComplex.name)
    
    # Paginate results
    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    complexes = pagination.items
    
    # Count active offers for each complex
    for complex in complexes:
        complex.offers_count = Offer.query.filter_by(
            residential_complex_id=complex.id, 
            is_active=True
        ).count()
    
    return render_template('admin/complexes_offers_list.html',
                         admin=current_user,
                         complexes=complexes,
                         pagination=pagination,
                         search=search)

@app.route('/admin/complex/<int:complex_id>/offers')
@csrf.exempt
@admin_required
def admin_complex_offers(complex_id):
    """List all offers for a residential complex"""
    from models import ResidentialComplex, Offer
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    offers = Offer.query.filter_by(residential_complex_id=complex_id).order_by(Offer.sort_order, Offer.created_at.desc()).all()
    
    return render_template('admin/complex_offers.html',
                         admin=current_user,
                         complex=complex,
                         offers=offers)

@app.route('/admin/complex/<int:complex_id>/offer/new')
@csrf.exempt
@admin_required
def admin_new_offer(complex_id):
    """Form to create new offer"""
    from models import ResidentialComplex
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    
    return render_template('admin/complex_offers.html',
                         admin=current_user,
                         complex=complex,
                         offers=[],
                         show_form=True,
                         edit_offer=None)

@app.route('/admin/complex/<int:complex_id>/offer/create', methods=['POST'])
@admin_required
def admin_create_offer(complex_id):
    """Create new offer with image upload"""
    from models import ResidentialComplex, Offer
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    
    try:
        # Get form data
        title = request.form.get('title', '').strip()
        description = request.form.get('description', '').strip()
        is_active = request.form.get('is_active') == 'on'
        sort_order = int(request.form.get('sort_order', 0))
        
        # Validate title
        if not title:
            flash('Название акции обязательно', 'error')
            return redirect(url_for('admin_complex_offers', complex_id=complex_id))
        
        # Handle image upload
        image_file = request.files.get('image')
        if not image_file or image_file.filename == '':
            flash('Изображение обязательно для новой акции', 'error')
            return redirect(url_for('admin_complex_offers', complex_id=complex_id))
        
        # Validate file type
        allowed_extensions = {'.jpg', '.jpeg', '.png', '.webp'}
        filename = secure_filename(image_file.filename)
        file_ext = os.path.splitext(filename)[1].lower()
        
        if file_ext not in allowed_extensions:
            flash('Неподдерживаемый формат изображения. Используйте JPG, PNG или WEBP', 'error')
            return redirect(url_for('admin_complex_offers', complex_id=complex_id))
        
        # Generate unique filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_filename = f"{timestamp}_{filename}"
        
        # Save file
        upload_folder = 'static/uploads/offers'
        os.makedirs(upload_folder, exist_ok=True)
        file_path = os.path.join(upload_folder, unique_filename)
        image_file.save(file_path)
        
        # Store relative path in database
        image_url = f'/static/uploads/offers/{unique_filename}'
        
        # Create offer
        offer = Offer(
            residential_complex_id=complex_id,
            title=title,
            description=description,
            image_url=image_url,
            is_active=is_active,
            sort_order=sort_order
        )
        
        db.session.add(offer)
        db.session.commit()
        
        flash('Акция успешно создана', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при создании акции: {str(e)}', 'error')
    
    return redirect(url_for('admin_complex_offers', complex_id=complex_id))

@app.route('/api/admin/complex/<int:complex_id>/offer/add', methods=['POST'])
@admin_required
def api_admin_add_offer(complex_id):
    """
    API endpoint for adding offers from residential complex detail page.
    
    Accepts:
        - title (required): Offer title
        - description (optional): Offer description
        - sort_order (optional): Sort order (default 0)
        - image (required): Image file (max 5MB, jpg/jpeg/png/webp)
    
    Returns:
        JSON: {"success": True/False, "message"/"error": str}
    """
    from models import ResidentialComplex, Offer
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    try:
        # Check if complex exists
        complex = ResidentialComplex.query.get(complex_id)
        if not complex:
            return jsonify({'success': False, 'error': 'Жилой комплекс не найден'}), 404
        
        # Get form data
        title = request.form.get('title', '').strip()
        description = request.form.get('description', '').strip()
        sort_order = request.form.get('sort_order', '0')
        
        # Validate title (required)
        if not title:
            return jsonify({'success': False, 'error': 'Название акции обязательно'}), 400
        
        # Validate and parse sort_order
        try:
            sort_order = int(sort_order)
        except (ValueError, TypeError):
            sort_order = 0
        
        # Validate image file (required)
        image_file = request.files.get('image')
        if not image_file or image_file.filename == '':
            return jsonify({'success': False, 'error': 'Изображение обязательно'}), 400
        
        # Validate file size (max 5MB)
        image_file.seek(0, os.SEEK_END)
        file_size = image_file.tell()
        image_file.seek(0)
        
        max_size = 5 * 1024 * 1024  # 5MB in bytes
        if file_size > max_size:
            return jsonify({'success': False, 'error': 'Размер файла превышает 5 МБ'}), 400
        
        # Validate file type
        allowed_extensions = {'.jpg', '.jpeg', '.png', '.webp'}
        filename = secure_filename(image_file.filename)
        file_ext = os.path.splitext(filename)[1].lower()
        
        if file_ext not in allowed_extensions:
            return jsonify({'success': False, 'error': 'Неподдерживаемый формат изображения. Используйте JPG, JPEG, PNG или WEBP'}), 400
        
        # Generate unique filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_filename = f"{timestamp}_{filename}"
        
        # Save file to static/uploads/offers/
        upload_folder = 'static/uploads/offers'
        os.makedirs(upload_folder, exist_ok=True)
        file_path = os.path.join(upload_folder, unique_filename)
        image_file.save(file_path)
        
        # Store relative path in database (with leading slash)
        image_url = f'/static/uploads/offers/{unique_filename}'
        
        # Create offer record
        offer = Offer(
            residential_complex_id=complex_id,
            title=title,
            description=description if description else None,
            image_url=image_url,
            is_active=True,  # Set active by default
            sort_order=sort_order
        )
        
        db.session.add(offer)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Акция успешно добавлена',
            'offer': {
                'id': offer.id,
                'title': offer.title,
                'description': offer.description,
                'image_url': offer.image_url,
                'is_active': offer.is_active,
                'sort_order': offer.sort_order
            }
        }), 201
        
    except Exception as e:
        db.session.rollback()
        # Log the error for debugging
        print(f"Error creating offer: {str(e)}")
        return jsonify({'success': False, 'error': f'Ошибка при создании акции: {str(e)}'}), 500

@app.route('/api/admin/complex/<int:complex_id>/material/add', methods=['POST'])
@admin_required
def api_admin_add_material(complex_id):
    """API endpoint for adding marketing materials from residential complex detail page."""
    from models import ResidentialComplex, MarketingMaterial
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    try:
        # 1. Check if complex exists
        complex = ResidentialComplex.query.get(complex_id)
        if not complex:
            return jsonify({'success': False, 'error': 'Жилой комплекс не найден'}), 404
        
        # 2. Get and validate form data
        title = request.form.get('title', '').strip()
        description = request.form.get('description', '').strip()
        material_type = request.form.get('material_type', '').strip()
        sort_order = request.form.get('sort_order', '0')
        
        # Validate title (required)
        if not title:
            return jsonify({'success': False, 'error': 'Название материала обязательно'}), 400
        
        # 3. Validate material_type
        allowed_material_types = ["Буклет", "Фото", "Рендер", "Другое"]
        if not material_type or material_type not in allowed_material_types:
            return jsonify({'success': False, 'error': f'Тип материала должен быть одним из: {", ".join(allowed_material_types)}'}), 400
        
        # Validate and parse sort_order
        try:
            sort_order = int(sort_order)
        except (ValueError, TypeError):
            sort_order = 0
        
        # 4. Get and validate file (required)
        file = request.files.get('file')
        if not file or file.filename == '':
            return jsonify({'success': False, 'error': 'Файл обязателен'}), 400
        
        # 6. Validate file extension
        allowed_extensions = {'.pdf', '.jpg', '.jpeg', '.png', '.webp'}
        filename = secure_filename(file.filename)
        file_ext = os.path.splitext(filename)[1].lower()
        
        if file_ext not in allowed_extensions:
            return jsonify({'success': False, 'error': 'Неподдерживаемый формат файла. Используйте PDF, JPG, JPEG, PNG или WEBP'}), 400
        
        # Auto-detect file_type from extension
        if file_ext == '.pdf':
            file_type = 'pdf'
            max_size = 10 * 1024 * 1024  # 10MB
        else:
            file_type = 'image'
            max_size = 5 * 1024 * 1024  # 5MB
        
        # 5. Check file size based on type
        file.seek(0, os.SEEK_END)
        file_size = file.tell()
        file.seek(0)
        
        if file_size > max_size:
            max_size_mb = max_size / (1024 * 1024)
            return jsonify({'success': False, 'error': f'Размер файла превышает {max_size_mb:.0f} МБ'}), 400
        
        # 7. Generate unique filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_filename = f"{timestamp}_{filename}"
        
        # 8. Save to static/uploads/marketing_materials/
        upload_folder = 'static/uploads/marketing_materials'
        os.makedirs(upload_folder, exist_ok=True)
        file_path = os.path.join(upload_folder, unique_filename)
        file.save(file_path)
        
        # Store relative path in database (with leading slash)
        file_url = f'/static/uploads/marketing_materials/{unique_filename}'
        
        # 9. Create MarketingMaterial record
        material = MarketingMaterial(
            residential_complex_id=complex_id,
            title=title,
            description=description if description else None,
            file_url=file_url,
            file_type=file_type,
            material_type=material_type,
            is_active=True,
            sort_order=sort_order
        )
        
        db.session.add(material)
        db.session.commit()
        
        # 10. Return JSON success response
        return jsonify({
            'success': True,
            'message': 'Материал успешно добавлен',
            'material': {
                'id': material.id,
                'title': material.title,
                'file_url': material.file_url,
                'file_type': material.file_type,
                'material_type': material.material_type
            }
        }), 201
        
    except Exception as e:
        db.session.rollback()
        # Log the error for debugging
        print(f"Error creating marketing material: {str(e)}")
        return jsonify({'success': False, 'error': f'Ошибка при создании материала: {str(e)}'}), 500



@app.route('/admin/offer/<int:offer_id>/edit')
@csrf.exempt
@admin_required
def admin_edit_offer(offer_id):
    """Form to edit offer"""
    from models import Offer
    
    offer = Offer.query.get_or_404(offer_id)
    complex_id = offer.residential_complex_id
    
    from models import ResidentialComplex
    complex = ResidentialComplex.query.get_or_404(complex_id)
    offers = Offer.query.filter_by(residential_complex_id=complex_id).order_by(Offer.sort_order, Offer.created_at.desc()).all()
    
    return render_template('admin/complex_offers.html',
                         admin=current_user,
                         complex=complex,
                         offers=offers,
                         show_form=True,
                         edit_offer=offer)

@app.route('/admin/offer/<int:offer_id>/update', methods=['POST'])
@admin_required
def admin_update_offer(offer_id):
    """Update offer"""
    from models import Offer
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    offer = Offer.query.get_or_404(offer_id)
    complex_id = offer.residential_complex_id
    
    try:
        # Update form data
        offer.title = request.form.get('title', '').strip()
        offer.description = request.form.get('description', '').strip()
        offer.is_active = request.form.get('is_active') == 'on'
        offer.sort_order = int(request.form.get('sort_order', 0))
        
        # Validate title
        if not offer.title:
            flash('Название акции обязательно', 'error')
            return redirect(url_for('admin_complex_offers', complex_id=complex_id))
        
        # Handle image upload (optional for update)
        image_file = request.files.get('image')
        if image_file and image_file.filename != '':
            # Validate file type
            allowed_extensions = {'.jpg', '.jpeg', '.png', '.webp'}
            filename = secure_filename(image_file.filename)
            file_ext = os.path.splitext(filename)[1].lower()
            
            if file_ext not in allowed_extensions:
                flash('Неподдерживаемый формат изображения. Используйте JPG, PNG или WEBP', 'error')
                return redirect(url_for('admin_complex_offers', complex_id=complex_id))
            
            # Delete old image if exists
            if offer.image_url:
                old_image_path = offer.image_url.lstrip('/')
                if os.path.exists(old_image_path):
                    try:
                        os.remove(old_image_path)
                    except:
                        pass
            
            # Generate unique filename with timestamp
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            unique_filename = f"{timestamp}_{filename}"
            
            # Save file
            upload_folder = 'static/uploads/offers'
            os.makedirs(upload_folder, exist_ok=True)
            file_path = os.path.join(upload_folder, unique_filename)
            image_file.save(file_path)
            
            # Update image URL
            offer.image_url = f'/static/uploads/offers/{unique_filename}'
        
        offer.updated_at = datetime.utcnow()
        db.session.commit()
        
        flash('Акция успешно обновлена', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при обновлении акции: {str(e)}', 'error')
    
    return redirect(url_for('admin_complex_offers', complex_id=complex_id))

@app.route('/admin/offer/<int:offer_id>/delete', methods=['POST'])
@admin_required
def admin_delete_offer(offer_id):
    """Delete offer"""
    from models import Offer
    import os
    
    offer = Offer.query.get_or_404(offer_id)
    complex_id = offer.residential_complex_id
    
    try:
        # Delete image file if exists
        if offer.image_url:
            image_path = offer.image_url.lstrip('/')
            if os.path.exists(image_path):
                try:
                    os.remove(image_path)
                except:
                    pass
        
        db.session.delete(offer)
        db.session.commit()
        
        flash('Акция успешно удалена', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при удалении акции: {str(e)}', 'error')
    
    return redirect(url_for('admin_complex_offers', complex_id=complex_id))

# ==========================================
# Admin Marketing Materials Management Routes
# ==========================================

@app.route('/admin/complexes-materials')
@csrf.exempt
@admin_required
def admin_complexes_materials():
    """List all residential complexes for managing their marketing materials"""
    try:
        import logging
        from models import ResidentialComplex, Developer, MarketingMaterial
        from sqlalchemy import func
        from sqlalchemy.orm import joinedload
        
        logging.debug("Starting admin_complexes_materials")
        page = request.args.get('page', 1, type=int)
        per_page = 20
        
        logging.debug("Creating material_counts subquery")
        material_counts = db.session.query(
            MarketingMaterial.residential_complex_id,
            func.count(MarketingMaterial.id).label('materials_count')
        ).group_by(MarketingMaterial.residential_complex_id).subquery()
        
        logging.debug("Creating complexes_query")
        complexes_query = db.session.query(ResidentialComplex).options(
            joinedload(ResidentialComplex.developer)
        ).outerjoin(
            material_counts,
            ResidentialComplex.id == material_counts.c.residential_complex_id
        ).add_columns(
            func.coalesce(material_counts.c.materials_count, 0).label('materials_count')
        ).order_by(ResidentialComplex.name)
        
        logging.debug("Getting pagination")
        pagination = complexes_query.paginate(page=page, per_page=per_page, error_out=False)
        logging.debug(f"Pagination total: {pagination.total}, items: {len(pagination.items)}")
        
        complexes = []
        for i, row in enumerate(pagination.items):
            logging.debug(f"Processing row {i}: type={type(row)}, value={row}")
            complex_obj = row[0]
            materials_count = row[1]
            
            complexes.append({
                'id': complex_obj.id,
                'name': complex_obj.name,
                'address': complex_obj.address,
                'main_image': complex_obj.main_image,
                'developer': complex_obj.developer,
                'developer_name': complex_obj.developer.name if complex_obj.developer else 'Не указан',
                'materials_count': materials_count
            })
        
        logging.debug(f"Rendering template with {len(complexes)} complexes")
        return render_template('admin/complexes_materials_list.html',
                             admin=current_user,
                             complexes=complexes,
                             pagination=pagination)
    except Exception as e:
        import traceback
        import logging
        logging.error(f"ERROR in admin_complexes_materials: {str(e)}")
        logging.error(traceback.format_exc())
        return render_template('500.html'), 500



@app.route('/admin/complex/<int:complex_id>/materials')
@csrf.exempt
@admin_required
def admin_complex_materials(complex_id):
    """Manage marketing materials for a specific residential complex"""
    from models import ResidentialComplex, MarketingMaterial
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    materials = MarketingMaterial.query.filter_by(
        residential_complex_id=complex_id
    ).order_by(MarketingMaterial.sort_order, MarketingMaterial.created_at.desc()).all()
    
    return render_template('admin/complex_materials.html',
                         admin=current_user,
                         complex=complex,
                         materials=materials)


@app.route('/admin/complex/<int:complex_id>/material/create', methods=['POST'])
@admin_required
def admin_create_material(complex_id):
    """Create new marketing material with file upload"""
    from models import ResidentialComplex, MarketingMaterial
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    
    try:
        # Get form data
        title = request.form.get('title', '').strip()
        description = request.form.get('description', '').strip()
        material_type = request.form.get('material_type', 'other').strip()
        is_active = request.form.get('is_active') == 'on'
        sort_order = int(request.form.get('sort_order', 0))
        
        # Validate title
        if not title:
            flash('Название материала обязательно', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Validate material type
        allowed_material_types = ['brochure', 'photo', 'render', 'other']
        if material_type not in allowed_material_types:
            flash('Неверный тип материала', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Handle file upload
        file = request.files.get('file')
        if not file or file.filename == '':
            flash('Файл обязателен для нового материала', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Validate file type and size
        filename = secure_filename(file.filename)
        file_ext = os.path.splitext(filename)[1].lower()
        
        # Determine file type and validate
        if file_ext == '.pdf':
            file_type = 'pdf'
            max_size = 10 * 1024 * 1024  # 10MB
        elif file_ext in ['.jpg', '.jpeg', '.png', '.webp']:
            file_type = 'image'
            max_size = 5 * 1024 * 1024  # 5MB
        else:
            flash('Неподдерживаемый формат файла. Используйте PDF, JPG, PNG или WEBP', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Check file size
        file.seek(0, os.SEEK_END)
        file_size = file.tell()
        file.seek(0)
        
        if file_size > max_size:
            max_size_mb = max_size / (1024 * 1024)
            flash(f'Размер файла превышает максимально допустимый ({max_size_mb}MB)', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Generate unique filename with timestamp
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        unique_filename = f"{timestamp}_{filename}"
        
        # Save file
        upload_folder = 'static/uploads/marketing_materials'
        os.makedirs(upload_folder, exist_ok=True)
        file_path = os.path.join(upload_folder, unique_filename)
        file.save(file_path)
        
        # Store relative path in database
        file_url = f'/static/uploads/marketing_materials/{unique_filename}'
        
        # Create marketing material
        material = MarketingMaterial(
            residential_complex_id=complex_id,
            title=title,
            description=description,
            file_url=file_url,
            file_type=file_type,
            material_type=material_type,
            is_active=is_active,
            sort_order=sort_order
        )
        
        db.session.add(material)
        db.session.commit()
        
        flash('Материал успешно создан', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при создании материала: {str(e)}', 'error')
    
    return redirect(url_for('admin_complex_materials', complex_id=complex_id))


@app.route('/admin/material/<int:material_id>/update', methods=['POST'])
@admin_required
def admin_update_material(material_id):
    """Update marketing material"""
    from models import MarketingMaterial
    from werkzeug.utils import secure_filename
    import os
    from datetime import datetime
    
    material = MarketingMaterial.query.get_or_404(material_id)
    complex_id = material.residential_complex_id
    
    try:
        # Get form data
        title = request.form.get('title', '').strip()
        description = request.form.get('description', '').strip()
        material_type = request.form.get('material_type', 'other').strip()
        is_active = request.form.get('is_active') == 'on'
        sort_order = int(request.form.get('sort_order', 0))
        
        # Validate title
        if not title:
            flash('Название материала обязательно', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Validate material type
        allowed_material_types = ['brochure', 'photo', 'render', 'other']
        if material_type not in allowed_material_types:
            flash('Неверный тип материала', 'error')
            return redirect(url_for('admin_complex_materials', complex_id=complex_id))
        
        # Update basic fields
        material.title = title
        material.description = description
        material.material_type = material_type
        material.is_active = is_active
        material.sort_order = sort_order
        
        # Handle file replacement (optional)
        file = request.files.get('file')
        if file and file.filename != '':
            filename = secure_filename(file.filename)
            file_ext = os.path.splitext(filename)[1].lower()
            
            # Determine file type and validate
            if file_ext == '.pdf':
                file_type = 'pdf'
                max_size = 10 * 1024 * 1024  # 10MB
            elif file_ext in ['.jpg', '.jpeg', '.png', '.webp']:
                file_type = 'image'
                max_size = 5 * 1024 * 1024  # 5MB
            else:
                flash('Неподдерживаемый формат файла. Используйте PDF, JPG, PNG или WEBP', 'error')
                return redirect(url_for('admin_complex_materials', complex_id=complex_id))
            
            # Check file size
            file.seek(0, os.SEEK_END)
            file_size = file.tell()
            file.seek(0)
            
            if file_size > max_size:
                max_size_mb = max_size / (1024 * 1024)
                flash(f'Размер файла превышает максимально допустимый ({max_size_mb}MB)', 'error')
                return redirect(url_for('admin_complex_materials', complex_id=complex_id))
            
            # Delete old file if exists
            if material.file_url:
                old_file_path = material.file_url.lstrip('/')
                if os.path.exists(old_file_path):
                    try:
                        os.remove(old_file_path)
                    except:
                        pass
            
            # Generate unique filename with timestamp
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            unique_filename = f"{timestamp}_{filename}"
            
            # Save new file
            upload_folder = 'static/uploads/marketing_materials'
            os.makedirs(upload_folder, exist_ok=True)
            file_path = os.path.join(upload_folder, unique_filename)
            file.save(file_path)
            
            # Update file info in database
            material.file_url = f'/static/uploads/marketing_materials/{unique_filename}'
            material.file_type = file_type
        
        db.session.commit()
        flash('Материал успешно обновлен', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при обновлении материала: {str(e)}', 'error')
    
    return redirect(url_for('admin_complex_materials', complex_id=complex_id))


@app.route('/admin/material/<int:material_id>/delete', methods=['POST'])
@admin_required
def admin_delete_material(material_id):
    """Delete marketing material"""
    from models import MarketingMaterial
    import os
    
    material = MarketingMaterial.query.get_or_404(material_id)
    complex_id = material.residential_complex_id
    
    try:
        # Delete file if exists
        if material.file_url:
            file_path = material.file_url.lstrip('/')
            if os.path.exists(file_path):
                try:
                    os.remove(file_path)
                except:
                    pass
        
        db.session.delete(material)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Материал успешно удален'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


# Admin Complex Cashback Management Routes
@app.route('/admin/complexes/cashback')
@csrf.exempt  # CSRF disabled for admin routes
@admin_required
def admin_complex_cashback():
    """Complex cashback management page"""
    from models import Admin, ResidentialComplex
    from flask import request
    from sqlalchemy import and_, or_
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    # DEPRECATED: Auto-sync removed - all data now in normalized schema (Developers → ResidentialComplexes → Properties)
    # The auto-sync code that previously inserted residential complexes from excel_properties table
    # has been removed because we now use a fully normalized database schema where all data
    # is properly stored in: Developers, ResidentialComplexes, and Properties tables.
    
    # Get filter parameters
    search = request.args.get('search', '')
    district = request.args.get('district', '')
    status = request.args.get('status', '')
    page = int(request.args.get('page', 1))
    per_page = 20
    
    # Build query
    query = ResidentialComplex.query
    
    # Apply filters
    if search:
        query = query.filter(or_(
            ResidentialComplex.name.contains(search),
            ResidentialComplex.developer.has(name=search)
        ))
    
    if district:
        query = query.filter(ResidentialComplex.district.has(name=district))
    
    if status == 'active':
        query = query.filter(ResidentialComplex.is_active == True)
    elif status == 'inactive':
        query = query.filter(ResidentialComplex.is_active == False)
    
    # Paginate results
    complexes = query.order_by(ResidentialComplex.name).paginate(
        page=page, per_page=per_page, error_out=False
    )
    
    return render_template('admin/complex_cashback.html',
                         admin=current_admin,
                         complexes=complexes,
                         search=search,
                         district=district,
                         status=status)

@app.route('/admin/complex-cashback/<int:complex_id>/update-cashback', methods=['POST'])
@csrf.exempt  # CSRF disabled for admin routes
@admin_required
def update_complex_cashback(complex_id):
    """API endpoint to update complex cashback rate"""
    from models import ResidentialComplex
    
    try:
        complex = ResidentialComplex.query.get_or_404(complex_id)
        
        data = request.get_json()
        cashback_percent = data.get('cashback_percent')
        
        if cashback_percent is None:
            return jsonify({'success': False, 'message': 'Не указан процент кешбека'})
        
        # Validate percentage
        try:
            cashback_percent = float(cashback_percent)
            if cashback_percent < 0 or cashback_percent > 15:
                return jsonify({'success': False, 'message': 'Процент должен быть от 0% до 15%'})
        except (ValueError, TypeError):
            return jsonify({'success': False, 'message': 'Неверный формат процента'})
        
        # Update cashback rate
        complex.cashback_rate = cashback_percent
        complex.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({
            'success': True, 
            'message': 'Кешбек успешно обновлен',
            'cashback_percent': cashback_percent,
            'complex_name': complex.name
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error updating complex cashback: {e}")
        return jsonify({'success': False, 'message': 'Ошибка сервера'})

@app.route('/admin/complexes/cashback/create', methods=['GET', 'POST'])
@admin_required
def admin_create_complex_cashback():
    """Create new complex cashback settings"""
    from models import Admin, ResidentialComplex, District, Developer
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    if request.method == 'POST':
        name = request.form.get('name')
        developer_id = request.form.get('developer_id')
        district_id = request.form.get('district_id') 
        cashback_rate = request.form.get('cashback_rate', 5.0)
        
        try:
            # Create new complex
            complex = ResidentialComplex(
                name=name,
                slug=name.lower().replace(' ', '-'),
                developer_id=int(developer_id) if developer_id else None,
                district_id=int(district_id) if district_id else None,
                cashback_rate=float(cashback_rate),
                is_active=True,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            
            db.session.add(complex)
            db.session.commit()
            
            flash('ЖК успешно создан', 'success')
            return redirect(url_for('admin_complex_cashback'))
            
        except Exception as e:
            db.session.rollback()
            flash('Ошибка при создании ЖК', 'error')
    
    # Load data for form
    developers = Developer.query.filter_by(is_active=True).order_by(Developer.name).all()
    districts = District.query.filter_by(is_active=True).order_by(District.name).all()
    
    return render_template('admin/create_complex_cashback.html',
                         admin=current_admin,
                         developers=developers,
                         districts=districts)

@app.route('/admin/complexes/cashback/<int:complex_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_complex_cashback(complex_id):
    """Edit complex cashback settings"""
    from models import Admin, ResidentialComplex, District, Developer
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    complex = ResidentialComplex.query.get_or_404(complex_id)
    
    if request.method == 'POST':
        complex.name = request.form.get('name')
        complex.developer_id = int(request.form.get('developer_id')) if request.form.get('developer_id') else None
        complex.district_id = int(request.form.get('district_id')) if request.form.get('district_id') else None
        complex.cashback_rate = float(request.form.get('cashback_rate', 5.0))
        complex.is_active = bool(request.form.get('is_active'))
        complex.updated_at = datetime.utcnow()
        
        try:
            db.session.commit()
            flash('ЖК успешно обновлен', 'success')
            return redirect(url_for('admin_complex_cashback'))
        except Exception as e:
            db.session.rollback()
            flash('Ошибка при обновлении ЖК', 'error')
    
    # Load data for form
    developers = Developer.query.filter_by(is_active=True).order_by(Developer.name).all()
    districts = District.query.filter_by(is_active=True).order_by(District.name).all()
    
    return render_template('admin/edit_complex_cashback.html',
                         admin=current_admin,
                         complex=complex,
                         developers=developers,
                         districts=districts)

@app.route('/admin/complexes/cashback/<int:complex_id>/delete', methods=['POST'])
@admin_required
def admin_delete_complex_cashback(complex_id):
    """Delete complex cashback settings"""
    from models import ResidentialComplex
    
    complex = ResidentialComplex.query.get_or_404(complex_id)
    
    try:
        db.session.delete(complex)
        db.session.commit()
        flash('ЖК успешно удален', 'success')
    except Exception as e:
        db.session.rollback()
        flash('Ошибка при удалении ЖК', 'error')
    
    return redirect(url_for('admin_complex_cashback'))

# Helper function for secure image validation
def validate_image_file(file):
    """
    Validate uploaded image file for security.
    Returns (is_valid, error_message, file_extension)
    """
    ALLOWED_EXTENSIONS = {'.jpg', '.jpeg', '.png', '.webp'}
    ALLOWED_MIME_TYPES = {'image/jpeg', 'image/png', 'image/webp'}
    
    if not file or not file.filename:
        return False, 'Файл не выбран', None
    
    # Check file extension
    import os
    file_ext = os.path.splitext(file.filename)[1].lower()
    
    if file_ext not in ALLOWED_EXTENSIONS:
        return False, f'Недопустимый формат файла. Разрешены только: JPG, PNG, WebP', None
    
    # Verify MIME type by reading file header
    file.seek(0)
    header = file.read(12)
    file.seek(0)
    
    # Check magic bytes for common image formats
    is_valid_mime = False
    detected_type = None
    
    # JPEG: FF D8 FF
    if header[:3] == b'\xff\xd8\xff':
        is_valid_mime = True
        detected_type = 'image/jpeg'
    # PNG: 89 50 4E 47 0D 0A 1A 0A
    elif header[:8] == b'\x89\x50\x4e\x47\x0d\x0a\x1a\x0a':
        is_valid_mime = True
        detected_type = 'image/png'
    # WebP: RIFF....WEBP
    elif header[:4] == b'RIFF' and header[8:12] == b'WEBP':
        is_valid_mime = True
        detected_type = 'image/webp'
    
    if not is_valid_mime:
        return False, 'Файл не является допустимым изображением. Возможна попытка загрузки вредоносного файла.', None
    
    # Verify extension matches detected type
    if file_ext in ['.jpg', '.jpeg'] and detected_type != 'image/jpeg':
        return False, 'Расширение файла не соответствует содержимому', None
    if file_ext == '.png' and detected_type != 'image/png':
        return False, 'Расширение файла не соответствует содержимому', None
    if file_ext == '.webp' and detected_type != 'image/webp':
        return False, 'Расширение файла не соответствует содержимому', None
    
    return True, None, file_ext

# Admin Manager Management Routes  


@app.route('/admin/complex/<int:complex_id>/update-nearby', methods=['POST'])
@login_required
def admin_update_complex_nearby(complex_id):
    """Обновить близлежащие объекты для ЖК через OpenStreetMap API"""
    if not current_user.is_admin:
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        # Получаем ЖК из БД
        complex = db.session.query(ResidentialComplex).get(complex_id)
        if not complex:
            return jsonify({'success': False, 'error': 'ЖК не найден'}), 404
        
        # Проверяем наличие координат
        if not complex.latitude or not complex.longitude:
            return jsonify({
                'success': False,
                'error': 'У ЖК не указаны координаты. Добавьте широту и долготу для автоматического поиска.'
            }), 400
        
        # Получаем близлежащие объекты через Overpass API
        print(f"Fetching nearby places for {complex.name} at {complex.latitude}, {complex.longitude}")
        nearby_data = nearby_places.fetch_nearby_places(
            latitude=float(complex.latitude),
            longitude=float(complex.longitude),
            radius_meters=3000
        )
        
        # Сохраняем в БД
        complex.nearby = json.dumps(nearby_data, ensure_ascii=False)
        complex.nearby_updated_at = datetime.utcnow()
        db.session.commit()
        
        # Подсчитываем количество найденных объектов
        total_found = sum(len(nearby_data.get(cat, [])) for cat in ['transport', 'shopping', 'education', 'healthcare', 'leisure'])
        
        return jsonify({
            'success': True,
            'message': f'Близлежащие объекты обновлены. Найдено объектов: {total_found}',
            'data': {
                'transport': len(nearby_data.get('transport', [])),
                'shopping': len(nearby_data.get('shopping', [])),
                'education': len(nearby_data.get('education', [])),
                'healthcare': len(nearby_data.get('healthcare', [])),
                'leisure': len(nearby_data.get('leisure', [])),
                'total': total_found
            }
        })
    
    except Exception as e:
        print(f"Error updating nearby places: {e}")


@app.route('/admin/nearby/auto-update', methods=['POST'])
@login_required  
def admin_auto_update_nearby():
    """Автоматически обновить nearby для ЖК без данных (добавленных парсером)"""
    if not current_user.is_admin:
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        import nearby_auto_updater
        
        # Получаем параметры
        batch_size = int(request.form.get('batch_size', 5))
        
        # Запускаем обновление
        stats = nearby_auto_updater.process_batch(
            batch_size=batch_size,
            delay_between=2
        )
        
        return jsonify({
            'success': True,
            'stats': stats,
            'message': f"Обновлено {stats['success']} из {stats['total']} ЖК. Найдено {stats['objects_total']} объектов."
        })
    
    except Exception as e:
        print(f"Error in auto-update: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/admin/nearby/status', methods=['GET'])
@login_required
def admin_nearby_status():
    """Получить статистику по nearby данным"""
    if not current_user.is_admin:
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        from datetime import timedelta
        
        # Статистика
        total_complexes = db.session.query(ResidentialComplex).filter(
            ResidentialComplex.latitude.isnot(None),
            ResidentialComplex.longitude.isnot(None)
        ).count()
        
        with_nearby = db.session.query(ResidentialComplex).filter(
            ResidentialComplex.nearby.isnot(None),
            ResidentialComplex.nearby_updated_at.isnot(None)
        ).count()
        
        without_nearby = db.session.query(ResidentialComplex).filter(
            ResidentialComplex.latitude.isnot(None),
            ResidentialComplex.longitude.isnot(None),
            db.or_(
                ResidentialComplex.nearby.is_(None),
                ResidentialComplex.nearby_updated_at.is_(None)
            )
        ).count()
        
        six_months_ago = datetime.utcnow() - timedelta(days=180)
        outdated = db.session.query(ResidentialComplex).filter(
            ResidentialComplex.nearby_updated_at < six_months_ago
        ).count()
        
        return jsonify({
            'success': True,
            'stats': {
                'total_with_coordinates': total_complexes,
                'with_nearby_data': with_nearby,
                'without_nearby_data': without_nearby,
                'outdated': outdated,
                'completion_rate': round((with_nearby / total_complexes * 100) if total_complexes > 0 else 0, 1)
            }
        })
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


        import traceback


@app.route('/admin/nearby-manager')
@login_required
def admin_nearby_manager():
    """Страница управления автообновлением nearby данных"""
    if not current_user.is_admin:
        abort(403)
    
    from datetime import timedelta
    
    # Статистика
    total_complexes = db.session.query(ResidentialComplex).filter(
        ResidentialComplex.latitude.isnot(None),
        ResidentialComplex.longitude.isnot(None)
    ).count()
    
    with_nearby = db.session.query(ResidentialComplex).filter(
        ResidentialComplex.nearby.isnot(None),
        ResidentialComplex.nearby_updated_at.isnot(None)
    ).count()
    
    without_nearby = db.session.query(ResidentialComplex).filter(
        ResidentialComplex.latitude.isnot(None),
        ResidentialComplex.longitude.isnot(None),
        db.or_(
            ResidentialComplex.nearby.is_(None),
            ResidentialComplex.nearby_updated_at.is_(None)
        )
    ).all()
    
    six_months_ago = datetime.utcnow() - timedelta(days=180)
    outdated = db.session.query(ResidentialComplex).filter(
        ResidentialComplex.nearby_updated_at < six_months_ago
    ).all()
    
    stats = {
        'total': total_complexes,
        'with_data': with_nearby,
        'without_data_count': len(without_nearby),
        'without_data': without_nearby[:10],  # Показать первые 10
        'outdated_count': len(outdated),
        'outdated': outdated[:10],
        'completion_rate': round((with_nearby / total_complexes * 100) if total_complexes > 0 else 0, 1)
    }
    
    return render_template('admin/nearby_manager.html', stats=stats)




@app.route('/admin/managers/create', methods=['GET', 'POST'])
@admin_required
def admin_create_manager():
    """Create new manager"""
    from models import Admin, Manager
    from werkzeug.security import generate_password_hash
    import json
    import random
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    if request.method == 'POST':
        full_name = request.form.get('full_name', '')
        email = request.form.get('email')
        phone = request.form.get('phone')
        position = request.form.get('position', 'Менеджер')
        password = request.form.get('password', 'demo123')  # Default password
        password_confirm = request.form.get('password_confirm', 'demo123')
        is_active = request.form.get('is_active') != 'False'  # Default True
        
        # Handle profile image (file upload or URL)
        profile_image = None
        profile_image_file = request.files.get('profile_image_file')
        profile_image_url = request.form.get('profile_image_url')
        
        if profile_image_file and profile_image_file.filename:
            # Validate and save uploaded file with security checks
            try:
                import os
                import uuid
                from werkzeug.utils import secure_filename
                
                # SECURITY: Validate file type and MIME type
                is_valid, error_message, file_ext = validate_image_file(profile_image_file)
                
                if not is_valid:
                    flash(f'Ошибка загрузки изображения: {error_message}', 'error')
                    return render_template('admin/create_manager.html', admin=current_admin)
                
                # Create upload directory if not exists
                upload_dir = 'static/uploads/managers'
                os.makedirs(upload_dir, exist_ok=True)
                
                # Generate unique filename with validated extension
                unique_filename = f"{uuid.uuid4().hex}{file_ext}"
                filepath = os.path.join(upload_dir, unique_filename)
                
                # Save file
                profile_image_file.save(filepath)
                profile_image = f'/{filepath}'
                
            except Exception as e:
                flash(f'Ошибка загрузки файла: {str(e)}', 'error')
                profile_image = 'https://randomuser.me/api/portraits/men/1.jpg'
        elif profile_image_url:
            profile_image = profile_image_url
        else:
            profile_image = 'https://randomuser.me/api/portraits/men/1.jpg'
        
        # Split full name into first and last name
        name_parts = full_name.split(' ', 1)
        first_name = name_parts[0] if name_parts else 'Имя'
        last_name = name_parts[1] if len(name_parts) > 1 else 'Фамилия'
        
        # Validate passwords
        if password != password_confirm:
            flash('Пароли не совпадают', 'error')
            return render_template('admin/create_manager.html', admin=current_admin)
        
        if not password:
            password = 'demo123'  # Default password
        
        # Check if email already exists
        if email:
            existing_manager = Manager.query.filter_by(email=email).first()
            if existing_manager:
                flash('Менеджер с таким email уже существует', 'error')
                return render_template('admin/create_manager.html', admin=current_admin)
        
        # Create manager
        manager = Manager()
        manager.email = email or f'manager{random.randint(1000,9999)}@inback.ru'
        manager.first_name = first_name
        manager.last_name = last_name
        manager.phone = phone
        manager.position = position
        manager.profile_image = profile_image or 'https://randomuser.me/api/portraits/men/1.jpg'
        manager.set_password(password)
        manager.is_active = is_active
        
        try:
            db.session.add(manager)
            db.session.commit()
            flash('Менеджер успешно создан', 'success')
            return redirect(url_for('admin_managers'))
        except Exception as e:
            db.session.rollback()
            print(f"ERROR creating manager: {str(e)}")
            import traceback
            traceback.print_exc()
            flash(f'Ошибка при создании менеджера: {str(e)}', 'error')
    
    return render_template('admin/create_manager.html', admin=current_admin)

@app.route('/admin/managers/<int:manager_id>/delete', methods=['POST'])
@admin_required
def admin_delete_manager(manager_id):
    """Delete manager"""
    from models import Manager
    
    manager = Manager.query.get_or_404(manager_id)
    
    try:
        db.session.delete(manager)
        db.session.commit()
        flash('Менеджер успешно удален', 'success')
    except Exception as e:
        db.session.rollback()
        flash('Ошибка при удалении менеджера', 'error')
    
    return redirect(url_for('admin_managers'))

@app.route('/admin/managers/<int:manager_id>/toggle-status', methods=['POST'])
@admin_required
def admin_toggle_manager_status(manager_id):
    """Toggle manager active status"""
    from models import Manager
    
    manager = Manager.query.get_or_404(manager_id)
    manager.is_active = not manager.is_active
    
    try:
        db.session.commit()
        status = 'активирован' if manager.is_active else 'заблокирован'
        flash(f'Менеджер {status}', 'success')
    except Exception as e:
        db.session.rollback()
        flash('Ошибка при изменении статуса менеджера', 'error')
    
    return redirect(url_for('admin_managers'))

# Additional Pages Routes
@app.route('/careers')
def careers():
    """Careers page with dynamic data"""
    from models import Job, JobCategory, Admin
    
    try:
        # Check if current user is admin
        is_admin = False
        current_admin = None
        if 'admin_id' in session:
            admin_id = session.get('admin_id')
            current_admin = Admin.query.get(admin_id)
            is_admin = current_admin is not None
        
        # Get all active job categories
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        
        # Get all active jobs with their categories (excluding paused jobs)
        jobs = Job.query.filter(Job.is_active == True, Job.status == 'active').order_by(Job.is_featured.desc(), Job.created_at.desc()).all()
        
        return render_template('careers.html', 
                             categories=categories, 
                             jobs=jobs,
                             is_admin=is_admin,
                             admin=current_admin)
        
    except Exception as e:
        print(f"Error loading careers page: {e}")
        # Fallback to static page if database fails
        return render_template('careers.html', 
                             categories=[], 
                             jobs=[],
                             is_admin=False,
                             admin=None)

@app.route('/security')
def security():
    """Security page"""
    return render_template('security.html')





# Initialize logger for scheduler
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

# ============= APScheduler Configuration =============
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger
from apscheduler.triggers.interval import IntervalTrigger

scheduler = BackgroundScheduler(daemon=True)

def run_instant_alerts():
    """Background job: Check for new properties and send instant alerts every 5 minutes"""
    with app.app_context():
        try:
            logger.info("🔔 Running instant alerts check...")
            sent_count = AlertService.send_instant_alerts()
            logger.info(f"✅ Instant alerts job completed: {sent_count} alerts sent")
        except Exception as e:
            logger.error(f"❌ Error in instant alerts job: {e}", exc_info=True)

def run_daily_digest():
    """Background job: Send daily digest at 8:00 AM"""
    with app.app_context():
        try:
            logger.info("📧 Running daily digest job...")
            sent_count = AlertService.send_daily_digest()
            logger.info(f"✅ Daily digest job completed: {sent_count} digests sent")
        except Exception as e:
            logger.error(f"❌ Error in daily digest job: {e}", exc_info=True)

def run_weekly_digest():
    """Background job: Send weekly digest every Monday at 8:00 AM"""
    with app.app_context():
        try:
            logger.info("📆 Running weekly digest job...")
            sent_count = AlertService.send_weekly_digest()
            logger.info(f"✅ Weekly digest job completed: {sent_count} digests sent")
        except Exception as e:
            logger.error(f"❌ Error in weekly digest job: {e}", exc_info=True)

# Schedule background jobs
# Instant alerts: every 5 minutes
scheduler.add_job(
    func=run_instant_alerts,
    trigger=IntervalTrigger(minutes=5),
    id='instant_alerts_job',
    name='Check new properties and send instant alerts',
    replace_existing=True
)

# Daily digest: every day at 8:00 AM
scheduler.add_job(
    func=run_daily_digest,
    trigger=CronTrigger(hour=8, minute=0),
    id='daily_digest_job',
    name='Send daily property digest',
    replace_existing=True
)

# Weekly digest: every Monday at 8:00 AM
scheduler.add_job(
    func=run_weekly_digest,
    trigger=CronTrigger(day_of_week='mon', hour=8, minute=0),
    id='weekly_digest_job',
    name='Send weekly property digest',
    replace_existing=True
)

# Start scheduler only in main process (avoid duplication under Gunicorn)
if os.environ.get('ENABLE_SCHEDULER', 'false').lower() == 'true':
    scheduler.start()
    logger.info("✅ APScheduler started - Background jobs configured:")
    logger.info("   🔔 Instant alerts: Every 5 minutes")
    logger.info("   📧 Daily digest: Every day at 8:00 AM")
    logger.info("   📆 Weekly digest: Every Monday at 8:00 AM")
else:
    logger.info("⏸️  APScheduler skipped - Set ENABLE_SCHEDULER=true to run background jobs")

# Register shutdown only if scheduler is running
import atexit
if scheduler.running:
    atexit.register(lambda: scheduler.shutdown())

# ==================== BALANCE AND WITHDRAWAL API ENDPOINTS ====================

# User endpoints (require @login_required)
@app.route('/api/balance', methods=['GET'])
@login_required
def api_get_balance():
    """Get current balance for authenticated user with withdrawal restrictions"""
    try:
        from services.balance_service import BalanceService
        from services.withdrawal_service import WithdrawalService
        from decimal import Decimal
        
        balance_info = BalanceService.get_balance(current_user.id)
        
        # Calculate registration bonus and cashback amounts
        registration_bonus_amount = WithdrawalService._get_transaction_sum_by_type(
            current_user.id, 'registration_bonus'
        )
        cashback_earned_amount = WithdrawalService._get_transaction_sum_by_type(
            current_user.id, 'cashback_earned'
        )
        
        # Calculate withdrawable amount based on cashback restriction
        available_amount = Decimal(str(balance_info['available_amount']))
        
        if cashback_earned_amount == 0 and registration_bonus_amount > 0:
            # User has not received cashback yet - cannot withdraw registration bonus
            withdrawable_amount = max(Decimal('0'), available_amount - registration_bonus_amount)
        else:
            # User has received cashback - can withdraw everything
            withdrawable_amount = available_amount
        
        app.logger.debug(f"💰 Balance API for user {current_user.id}: "
                        f"available={available_amount}₽, "
                        f"registration_bonus={registration_bonus_amount}₽, "
                        f"cashback_earned={cashback_earned_amount}₽, "
                        f"withdrawable={withdrawable_amount}₽")
        
        return jsonify({
            'success': True,
            'available_amount': balance_info['available_amount'],
            'pending_amount': balance_info['pending_amount'],
            'total_earned': balance_info['total_earned'],
            'total_withdrawn': balance_info['total_withdrawn'],
            'currency': balance_info['currency'],
            # New fields for withdrawal restriction
            'registration_bonus_amount': float(registration_bonus_amount),
            'cashback_earned_amount': float(cashback_earned_amount),
            'withdrawable_amount': float(withdrawable_amount)
        })
    except Exception as e:
        app.logger.error(f"Error getting balance for user {current_user.id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/balance/transactions', methods=['GET'])
@login_required
def api_get_transactions():
    """Get transaction history for authenticated user"""
    try:
        from services.balance_service import BalanceService
        
        limit = int(request.args.get('limit', 50))
        offset = int(request.args.get('offset', 0))
        
        transactions = BalanceService.get_transaction_history(current_user.id, limit, offset)
        total_count = BalanceService.get_transaction_count(current_user.id)
        
        # Format transactions with ISO dates
        formatted_transactions = []
        for t in transactions:
            formatted_transactions.append({
                'id': t.id,
                'amount': float(t.amount),
                'type': t.transaction_type,
                'description': t.description,
                'created_at': t.created_at.isoformat() if t.created_at else None,
                'balance_before': float(t.balance_before),
                'balance_after': float(t.balance_after)
            })
        
        return jsonify({
            'success': True,
            'transactions': formatted_transactions,
            'total': total_count
        })
    except Exception as e:
        app.logger.error(f"Error getting transactions for user {current_user.id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400



@app.route('/api/admin/balance/transactions/<int:user_id>', methods=['GET'])
@admin_required
def api_admin_get_user_transactions(user_id):
    """Get transaction history for a specific user (admin only)"""
    try:
        from services.balance_service import BalanceService
        from models import User
        
        # Check if user exists
        user = User.query.get(user_id)
        if not user:
            return jsonify({'success': False, 'error': 'User not found'}), 404
        
        limit = request.args.get('limit', 50, type=int)
        offset = request.args.get('offset', 0, type=int)
        
        transactions = BalanceService.get_transaction_history(user_id, limit=limit, offset=offset)
        total_count = BalanceService.get_transaction_count(user_id)
        
        transactions_data = []
        for tx in transactions:
            transactions_data.append({
                'id': tx.id,
                'amount': float(tx.amount),
                'transaction_type': tx.transaction_type,
                'description': tx.description,
                'balance_before': float(tx.balance_before),
                'balance_after': float(tx.balance_after),
                'status': tx.status,
                'created_at': tx.created_at.strftime('%d.%m.%Y %H:%M'),
                'processed_at': tx.processed_at.strftime('%d.%m.%Y %H:%M') if tx.processed_at else None
            })
        
        return jsonify({
            'success': True,
            'transactions': transactions_data,
            'total_count': total_count,
            'user': {
                'id': user.id,
                'email': user.email,
                'full_name': user.full_name
            }
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/withdrawals', methods=['POST'])
@login_required
def api_create_withdrawal():
    """Create withdrawal request for authenticated user"""
    try:
        from services.withdrawal_service import WithdrawalService
        
        data = request.get_json()
        
        amount = data.get('amount')
        payout_method = data.get('payout_method')
        payout_details = data.get('payout_details')
        
        # Validation
        if not amount or float(amount) <= 0:
            return jsonify({'success': False, 'error': 'amount must be greater than 0'}), 400
        
        if not payout_method:
            return jsonify({'success': False, 'error': 'payout_method is required'}), 400
        
        if not payout_details:
            return jsonify({'success': False, 'error': 'payout_details is required'}), 400
        
        withdrawal_request = WithdrawalService.create_withdrawal_request(
            user_id=current_user.id,
            amount=amount,
            payout_method=payout_method,
            payout_details_dict=payout_details
        )
        
        app.logger.info(f"✅ Created withdrawal request #{withdrawal_request.id} for user {current_user.id}")
        
        return jsonify({
            'success': True,
            'request_id': withdrawal_request.id,
            'message': 'Withdrawal request created successfully'
        })
    except ValueError as e:
        app.logger.warning(f"Validation error creating withdrawal for user {current_user.id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        app.logger.error(f"Error creating withdrawal for user {current_user.id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/withdrawals', methods=['GET'])
@login_required
def api_get_withdrawals():
    """Get withdrawal requests for authenticated user"""
    try:
        from services.withdrawal_service import WithdrawalService
        import json
        
        status = request.args.get('status')
        limit = int(request.args.get('limit', 50))
        offset = int(request.args.get('offset', 0))
        
        requests_list = WithdrawalService.get_withdrawal_requests(
            user_id=current_user.id,
            status=status,
            limit=limit,
            offset=offset
        )
        total_count = WithdrawalService.get_withdrawal_request_count(
            user_id=current_user.id,
            status=status
        )
        
        # Format requests with ISO dates
        formatted_requests = []
        for r in requests_list:
            formatted_requests.append({
                'id': r.id,
                'amount': float(r.amount),
                'status': r.status,
                'payout_method': r.payout_method,
                'payout_details_dict': json.loads(r.payout_details) if r.payout_details else {},
                'created_at': r.created_at.isoformat() if r.created_at else None,
                'processed_at': r.processed_at.isoformat() if r.processed_at else None,
                'paid_at': r.paid_at.isoformat() if r.paid_at else None
            })
        
        return jsonify({
            'success': True,
            'requests': formatted_requests,
            'total': total_count
        })
    except Exception as e:
        app.logger.error(f"Error getting withdrawals for user {current_user.id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


# Admin endpoints (require @admin_required)
@app.route('/api/admin/balance/credit', methods=['POST'])
@admin_required
def api_admin_credit_balance():
    """Credit balance for a user (admin only)"""
    try:
        from services.balance_service import BalanceService
        from models import User
        
        data = request.get_json()
        
        user_id = data.get('user_id')
        amount = data.get('amount')
        description = data.get('description')
        transaction_type = data.get('transaction_type', 'bonus')
        deal_id = data.get('deal_id')
        
        # Validation
        if not user_id:
            return jsonify({'success': False, 'error': 'user_id is required'}), 400
        
        if not amount or float(amount) <= 0:
            return jsonify({'success': False, 'error': 'amount must be greater than 0'}), 400
        
        if not description:
            return jsonify({'success': False, 'error': 'description is required'}), 400
        
        # Check user exists
        user = User.query.get(user_id)
        if not user:
            return jsonify({'success': False, 'error': f'User {user_id} not found'}), 400
        
        transaction = BalanceService.credit_balance(
            user_id=user_id,
            amount=amount,
            description=description,
            transaction_type=transaction_type,
            deal_id=deal_id,
            created_by_id=current_user.id
        )
        
        app.logger.info(f"✅ Admin {current_user.id} credited {amount}₽ to user {user_id}")
        
        return jsonify({
            'success': True,
            'transaction_id': transaction.id
        })
    except ValueError as e:
        app.logger.warning(f"Validation error in admin credit: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        app.logger.error(f"Error in admin credit: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/admin/withdrawals', methods=['GET'])
@admin_required
def api_admin_get_withdrawals():
    """Get all withdrawal requests (admin only)"""
    try:
        from services.withdrawal_service import WithdrawalService
        import json
        
        status = request.args.get('status')
        limit = int(request.args.get('limit', 50))
        offset = int(request.args.get('offset', 0))
        
        requests_list = WithdrawalService.get_withdrawal_requests(
            user_id=None,  # Get all requests
            status=status,
            limit=limit,
            offset=offset
        )
        total_count = WithdrawalService.get_withdrawal_request_count(
            user_id=None,
            status=status
        )
        
        # Format requests with ISO dates and user info
        formatted_requests = []
        for r in requests_list:
            # Safe JSON parsing with error handling
            try:
                payout_details_dict = json.loads(r.payout_details) if (r.payout_details and r.payout_details.strip()) else {}
            except (ValueError, TypeError, json.JSONDecodeError):
                payout_details_dict = {}
            
            formatted_requests.append({
                'id': r.id,
                'user_id': r.user_id,
                'user_name': r.user.full_name if hasattr(r.user, 'full_name') and r.user.full_name else r.user.email,
                'user_email': r.user.email,
                'amount': float(r.amount),
                'status': r.status,
                'payout_method': r.payout_method,
                'payout_details_dict': payout_details_dict,
                'created_at': r.created_at.isoformat() if r.created_at else None,
                'processed_at': r.processed_at.isoformat() if r.processed_at else None,
                'paid_at': r.paid_at.isoformat() if r.paid_at else None,
                'rejection_reason': r.rejection_reason
            })
        
        return jsonify({
            'success': True,
            'requests': formatted_requests,
            'total': total_count
        })
    except Exception as e:
        app.logger.error(f"Error getting admin withdrawals: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/admin/withdrawals/<int:request_id>/approve', methods=['POST'])
@admin_required
def api_admin_approve_withdrawal(request_id):
    """Approve withdrawal request (admin only)"""
    try:
        from services.withdrawal_service import WithdrawalService
        
        withdrawal_request = WithdrawalService.approve_withdrawal(
            request_id=request_id,
            admin_id=current_user.id
        )
        
        app.logger.info(f"✅ Admin {current_user.id} approved withdrawal request #{request_id}")
        
        return jsonify({
            'success': True,
            'message': 'Withdrawal request approved successfully'
        })
    except ValueError as e:
        app.logger.warning(f"Validation error approving withdrawal {request_id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        app.logger.error(f"Error approving withdrawal {request_id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/admin/withdrawals/<int:request_id>/reject', methods=['POST'])
@admin_required
def api_admin_reject_withdrawal(request_id):
    """Reject withdrawal request (admin only)"""
    try:
        from services.withdrawal_service import WithdrawalService
        
        data = request.get_json()
        rejection_reason = data.get('rejection_reason')
        
        if not rejection_reason:
            return jsonify({'success': False, 'error': 'rejection_reason is required'}), 400
        
        withdrawal_request = WithdrawalService.reject_withdrawal(
            request_id=request_id,
            admin_id=current_user.id,
            rejection_reason=rejection_reason
        )
        
        app.logger.info(f"✅ Admin {current_user.id} rejected withdrawal request #{request_id}")
        
        return jsonify({
            'success': True,
            'message': 'Withdrawal request rejected successfully'
        })
    except ValueError as e:
        app.logger.warning(f"Validation error rejecting withdrawal {request_id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        app.logger.error(f"Error rejecting withdrawal {request_id}: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/admin/withdrawals/<int:request_id>/mark-paid', methods=['POST'])
@admin_required
def api_admin_mark_withdrawal_paid(request_id):
    """Mark withdrawal request as paid (admin only)"""
    try:
        from services.withdrawal_service import WithdrawalService
        
        withdrawal_request = WithdrawalService.mark_as_paid(
            request_id=request_id,
            admin_id=current_user.id
        )
        
        app.logger.info(f"✅ Admin {current_user.id} marked withdrawal request #{request_id} as paid")
        
        return jsonify({
            'success': True,
            'message': 'Withdrawal request marked as paid successfully'
        })
    except ValueError as e:
        app.logger.warning(f"Validation error marking withdrawal {request_id} as paid: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
    except Exception as e:
        app.logger.error(f"Error marking withdrawal {request_id} as paid: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/admin/users-with-balance')
@admin_required
def api_admin_users_with_balance():
    """Get all users with balance (admin only)"""
    try:
        from models import User, UserBalance
        
        users_with_balance = db.session.query(
            User.id.label('user_id'),
            User.email,
            User.full_name,
            UserBalance.available_amount.label('available'),
            UserBalance.pending_amount.label('pending'),
            UserBalance.total_earned,
            UserBalance.total_withdrawn
        ).join(UserBalance, User.id == UserBalance.user_id).filter(
            (UserBalance.available_amount > 0) | 
            (UserBalance.pending_amount > 0) |
            (UserBalance.total_earned > 0)
        ).all()
        
        users_list = [{
            'user_id': u.user_id,
            'email': u.email,
            'full_name': u.full_name,
            'available': float(u.available),
            'pending': float(u.pending),
            'total_earned': float(u.total_earned),
            'total_withdrawn': float(u.total_withdrawn)
        } for u in users_with_balance]
        
        return jsonify({'success': True, 'users': users_list})
    except Exception as e:
        app.logger.error(f"Error getting users with balance: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/admin/search-users')
@admin_required
def api_admin_search_users():
    """Search users by email or name (admin only)"""
    try:
        from models import User
        
        query = request.args.get('q', '').strip()
        if len(query) < 3:
            return jsonify({'success': True, 'users': []})
        
        users = User.query.filter(
            db.or_(
                User.email.ilike(f'%{query}%'),
                User.full_name.ilike(f'%{query}%')
            )
        ).limit(10).all()
        
        users_list = [{
            'id': u.id,
            'email': u.email,
            'full_name': u.full_name
        } for u in users]
        
        return jsonify({'success': True, 'users': users_list})
    except Exception as e:
        app.logger.error(f"Error searching users: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 400
if __name__ == '__main__':
    with app.app_context():
        from models import User, Manager, SavedSearch, SentSearch, CashbackRecord, Application, Favorite, Notification, District, Developer, ResidentialComplex, Street, RoomType, Admin, BlogPost, City, Offer, MarketingMaterial
        db.create_all()
        
        # Initialize cities
        try:
            init_cities()
            print("Cities initialized successfully")
        except Exception as e:
            print(f"Error initializing cities: {e}")
            db.session.rollback()
        
        # Initialize search data
        try:
            init_search_data()
            print("Search data initialized successfully")
        except Exception as e:
            print(f"Error initializing search data: {e}")
            db.session.rollback()

# Collection routes for clients
@app.route('/collections')
@login_required
def client_collections():
    """Show all collections assigned to current user"""
    from models import Collection
    collections = Collection.query.filter_by(assigned_to_user_id=current_user.id).order_by(Collection.created_at.desc()).all()
    return render_template('auth/client_collections.html', collections=collections)

@app.route('/collection/<int:collection_id>')
@login_required
def view_collection(collection_id):
    """View specific collection details"""
    from models import Collection
    collection = Collection.query.filter_by(id=collection_id, assigned_to_user_id=current_user.id).first()
    if not collection:
        flash('Подборка не найдена', 'error')
        return redirect(url_for('client_collections'))
    
    # Mark as viewed
    if collection.status == 'Отправлена':
        collection.status = 'Просмотрена'
        collection.viewed_at = datetime.utcnow()
        db.session.commit()
    
    return render_template('auth/view_collection.html', collection=collection)

@app.route('/collection/<int:collection_id>/mark-viewed', methods=['POST'])
@login_required
def mark_collection_viewed(collection_id):
    """Mark collection as viewed"""
    from models import Collection
    collection = Collection.query.filter_by(id=collection_id, assigned_to_user_id=current_user.id).first()
    if collection and collection.status == 'Отправлена':
        collection.status = 'Просмотрена'
        collection.viewed_at = datetime.utcnow()
        db.session.commit()
    return jsonify({'success': True})

# Manager collection routes
@app.route('/manager/collections')
@manager_required
def manager_collections():
    """Manager collections list"""
    from models import Collection, Manager
    current_manager = current_user
    collections = Collection.query.filter_by(created_by_manager_id=current_manager.id).order_by(Collection.created_at.desc()).all()
    return render_template('manager/collections.html', collections=collections, manager=current_manager)

@app.route('/manager/collections/new')
@manager_required
def manager_create_collection():
    """Create new collection"""
    from models import Manager, User
    current_manager = current_user
    # Get all clients assigned to this manager
    clients = User.query.filter_by(assigned_manager_id=current_manager.id).all()
    return render_template('manager/create_collection.html', manager=current_manager, clients=clients)

@app.route('/manager/collections/new', methods=['POST'])
@manager_required
def save_collection():
    """Save new collection"""
    from models import Collection, CollectionProperty, Manager
    
    current_manager = current_user
    
    title = request.form.get('title')
    description = request.form.get('description', '')
    assigned_to_user_id = request.form.get('assigned_to_user_id')
    tags = request.form.get('tags', '')
    action = request.form.get('action')
    property_ids = request.form.getlist('property_ids[]')
    property_notes = request.form.getlist('property_notes[]')
    
    if not title or not assigned_to_user_id:
        flash('Заполните обязательные поля', 'error')
        return render_template('manager/create_collection.html', manager=current_manager)
    
    try:
        # Create collection
        collection = Collection(
            title=title,
            description=description,
            created_by_manager_id=current_manager.id,
            assigned_to_user_id=int(assigned_to_user_id),
            tags=tags,
            status='Отправлена' if action == 'send' else 'Черновик',
            sent_at=datetime.utcnow() if action == 'send' else None
        )
        
        db.session.add(collection)
        db.session.flush()  # Get collection ID
        
        # Add properties to collection
        import json
        with open('data/properties.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        properties_dict = {prop['id']: prop for prop in properties_data}
        
        for i, prop_id in enumerate(property_ids):
            if prop_id in properties_dict:
                prop_data = properties_dict[prop_id]
                note = property_notes[i] if i < len(property_notes) else ''
                
                # DUAL WRITE: Resolve property to get both IDs
                property_obj, canonical_id = resolve_property_by_identifier(prop_id)
                if not property_obj:
                    continue  # Skip properties that don't exist in database
                
                collection_property = CollectionProperty(
                    collection_id=collection.id,
                    property_id=str(property_obj.id),  # Old: database ID
                    property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
                    property_name=prop_data['title'],
                    property_price=prop_data['price'],
                    complex_name=prop_data.get('residential_complex', ''),
                    property_type=f"{prop_data['rooms']}-комн",
                    property_size=prop_data.get('area'),
                    manager_note=note,
                    order_index=i
                )
                db.session.add(collection_property)
        
        db.session.commit()
        
        action_text = 'отправлена клиенту' if action == 'send' else 'сохранена как черновик'
        flash(f'Подборка "{title}" успешно {action_text}', 'success')
        return redirect(url_for('manager_collections'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка при сохранении подборки: {str(e)}', 'error')
        return render_template('manager/create_collection.html', manager=current_manager)

@app.route('/manager/analytics')
@manager_required
def manager_analytics():
    """Manager analytics page"""
    from models import Manager, User, Collection, CashbackApplication
    from sqlalchemy import func
    
    current_manager = current_user
    
    # Manager stats
    clients_count = User.query.filter_by(assigned_manager_id=current_manager.id).count()
    collections_count = Collection.query.filter_by(created_by_manager_id=current_manager.id).count()
    sent_collections = Collection.query.filter_by(created_by_manager_id=current_manager.id, status='Отправлена').count()
    
    # Monthly collection stats
    monthly_collections = db.session.query(
        func.date_trunc('month', Collection.created_at).label('month'),
        func.count(Collection.id).label('count')
    ).filter_by(created_by_manager_id=current_manager.id).group_by(
        func.date_trunc('month', Collection.created_at)
    ).order_by('month').all()
    
    # Client activity stats
    client_stats = db.session.query(
        User.client_status,
        func.count(User.id).label('count')
    ).filter_by(assigned_manager_id=current_manager.id).group_by(User.client_status).all()
    
    # Recent activity
    recent_collections = Collection.query.filter_by(
        created_by_manager_id=current_manager.id
    ).order_by(Collection.created_at.desc()).limit(5).all()
    
    return render_template('manager/analytics.html',
                         manager=current_manager,
                         clients_count=clients_count,
                         collections_count=collections_count,
                         sent_collections=sent_collections,
                         monthly_collections=monthly_collections,
                         client_stats=client_stats,
                         recent_collections=recent_collections)

@app.route('/manager/search-properties', methods=['POST'])
@manager_required
def manager_search_properties():
    """Search properties for collection"""
    import json
    
    data = request.get_json()
    min_price = data.get('min_price')
    max_price = data.get('max_price')
    rooms = data.get('rooms')
    
    try:
        with open('data/properties.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        filtered_properties = []
        for prop in properties_data:
            # Apply filters
            if min_price and prop['price'] < int(min_price):
                continue
            if max_price and prop['price'] > int(max_price):
                continue
            if rooms and str(prop['rooms']) != str(rooms):
                continue
                
            filtered_properties.append({
                'id': prop['id'],
                'title': f"{prop.get('rooms', 0)}-комн {prop.get('area', 0)} м²" if prop.get('rooms', 0) > 0 else f"Студия {prop.get('area', 0)} м²",
                'price': prop['price'],
                'complex_name': prop.get('residential_complex', 'ЖК не указан'),
                'rooms': prop['rooms'],
                'size': prop.get('area', 0)
            })
        
        return jsonify({'properties': filtered_properties[:50]})
    except Exception as e:
        return jsonify({'error': str(e)}), 400

# Additional API routes for collection management
@app.route('/api/manager/collection/<int:collection_id>/send', methods=['POST'])
@manager_required
def api_send_collection(collection_id):
    """Send collection to client"""
    from models import Collection
    
    current_manager = current_user
    collection = Collection.query.filter_by(id=collection_id, created_by_manager_id=current_manager.id).first()
    
    if not collection:
        return jsonify({'success': False, 'error': 'Подборка не найдена'}), 404
    
    if not collection.assigned_to_user_id:
        return jsonify({'success': False, 'error': 'Клиент не назначен'}), 400
    
    try:
        collection.status = 'Отправлена'
        collection.sent_at = datetime.utcnow()
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collection/<int:collection_id>/delete', methods=['DELETE'])
@manager_required 
def api_delete_collection(collection_id):
    """Delete collection"""
    from models import Collection
    
    current_manager = current_user
    collection = Collection.query.filter_by(id=collection_id, created_by_manager_id=current_manager.id).first()
    
    if not collection:
        return jsonify({'success': False, 'error': 'Подборка не найдена'}), 404
    
    try:
        db.session.delete(collection)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# Manager Saved Searches API routes
@app.route('/api/manager/saved-searches')
@manager_required
def get_manager_saved_searches():
    """Get manager's saved searches"""
    from models import ManagerSavedSearch
    
    current_manager = current_user
    try:
        searches = ManagerSavedSearch.query.filter_by(manager_id=current_manager.id).order_by(ManagerSavedSearch.last_used.desc()).all()
        searches_list = [search.to_dict() for search in searches]
        
        return jsonify({
            'success': True,
            'searches': searches_list,
            'count': len(searches_list)
        })
    except Exception as e:
        print(f"Error loading manager saved searches: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/saved-searches', methods=['POST'])
@manager_required
@csrf.exempt  # Temporarily disabled for debugging
def create_manager_saved_search():
    """Create a new saved search for manager"""
    from models import ManagerSavedSearch
    import json
    
    print(f"DEBUG: ===== create_manager_saved_search API CALLED =====")
    print(f"DEBUG: Method: {request.method}")
    print(f"DEBUG: Path: {request.path}")
    # Log safe headers only (no cookies/tokens)
    safe_headers = {k: v for k, v in request.headers.items() if k.lower() not in ['cookie', 'authorization']}
    print(f"DEBUG: Headers: {safe_headers}")
    
    current_manager = current_user
    print(f"DEBUG: Manager ID: {current_manager.id}")
    
    data = request.get_json()
    print(f"DEBUG: Raw request JSON: {data}")
    print(f"DEBUG: JSON type: {type(data)}")
    
    try:
        # Extract filters from the request
        filters = data.get('filters', {})
        print(f"DEBUG: Creating manager search with filters: {filters}")
        print(f"DEBUG: Full request data: {data}")
        print(f"DEBUG: Filters type: {type(filters)}")
        print(f"DEBUG: Filters empty check: {bool(filters)}")
        
        # Test if filters is actually empty - force some test data if needed
        if not filters or not any(filters.values()):
            print("DEBUG: Filters are empty, checking raw JSON...")
            raw_json = request.get_data(as_text=True)
            print(f"DEBUG: Raw request body: {raw_json}")
        
        filters_json = json.dumps(filters) if filters else None
        print(f"DEBUG: Filters JSON: {filters_json}")
        
        # Create new search
        search = ManagerSavedSearch(
            manager_id=current_manager.id,
            name=data.get('name'),
            description=data.get('description'),
            search_type=data.get('search_type', 'properties'),
            additional_filters=filters_json,
            is_template=data.get('is_template', False)
        )
        
        db.session.add(search)
        db.session.commit()
        print(f"DEBUG: Saved search with ID: {search.id}, additional_filters: {search.additional_filters}")
        
        # Verify the saved data
        db.session.refresh(search)
        print(f"DEBUG: Refreshed search additional_filters: {search.additional_filters}")
        
        return jsonify({
            'success': True,
            'search': search.to_dict(),
            'message': 'Поиск успешно сохранён'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Error creating manager saved search: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-search', methods=['POST'])
@manager_required
@csrf.exempt  # Temporarily disabled for debugging
def send_search_to_client():
    """Send manager's saved search to a client"""
    from models import ManagerSavedSearch, SentSearch, User, SavedSearch, UserNotification
    from email_service import send_notification
    import json
    
    current_manager = current_user
    data = request.get_json()
    
    try:
        search_id = data.get('search_id')
        client_id = data.get('client_id')
        message = data.get('message', '')
        
        # Get manager search
        manager_search = ManagerSavedSearch.query.filter_by(id=search_id, manager_id=current_manager.id).first()
        if not manager_search:
            return jsonify({'success': False, 'error': 'Поиск не найден'}), 404
            
        # Get client
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': 'Клиент не найден'}), 404
            
        # Create SavedSearch for client (copy manager search to client)
        client_search = SavedSearch(
            user_id=client_id,
            name=f"От менеджера: {manager_search.name}",
            description=f"{manager_search.description or ''}\n\n{message}".strip(),
            search_type=manager_search.search_type,
            additional_filters=manager_search.additional_filters,
            notify_new_matches=True
        )
        
        db.session.add(client_search)
        db.session.flush()  # Get the ID before final commit
        
        # Create sent search record
        sent_search = SentSearch(
            manager_id=current_manager.id,
            client_id=client_id,
            manager_search_id=search_id,
            name=manager_search.name,
            description=manager_search.description,
            additional_filters=manager_search.additional_filters,
            status='sent'
        )
        
        db.session.add(sent_search)
        db.session.flush()  # Get sent_search ID
        
        # Note: client_search is now created and linked via sent_search record
        
        # Update usage count
        manager_search.usage_count = (manager_search.usage_count or 0) + 1
        manager_search.last_used = datetime.utcnow()
        
        # Create notification for client
        notification = UserNotification(
            user_id=client_id,
            title="Новый поиск от менеджера",
            message=f"Ваш менеджер отправил вам поиск: {manager_search.name}",
            notification_type='info',
            icon='fas fa-search',
            action_url='/dashboard'
        )
        
        db.session.add(notification)
        
        # Логируем отправку поиска
        from models import UserActivity
        UserActivity.log_activity(
            user_id=client_id,
            activity_type='search_received',
            description=f'Получен новый поиск от менеджера: {manager_search.name}'
        )
        
        db.session.commit()
        
        # Send email notification
        try:
            send_notification(
                client.email,
                f"Новый поиск от менеджера: {manager_search.name}",
                f"Ваш менеджер отправил вам новый поиск недвижимости.\n\n"
                f"Название: {manager_search.name}\n"
                f"Описание: {manager_search.description or 'Без описания'}\n\n"
                f"{message}\n\n"
                f"Войдите в личный кабинет для просмотра: https://{request.host}/dashboard",
                user_id=client_id,
                notification_type='search_received'
            )
        except Exception as e:
            print(f"Error sending email notification: {e}")
        
        return jsonify({
            'success': True,
            'message': 'Поиск успешно отправлен клиенту'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error sending search to client: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/saved-search/<int:search_id>', methods=['DELETE'])
@manager_required
def delete_manager_saved_search(search_id):
    """Delete manager's saved search"""
    from models import ManagerSavedSearch
    
    current_manager = current_user
    
    try:
        search = ManagerSavedSearch.query.filter_by(id=search_id, manager_id=current_manager.id).first()
        if not search:
            return jsonify({'success': False, 'error': 'Поиск не найден'}), 404
            
        db.session.delete(search)
        db.session.commit()
        
        return jsonify({'success': True, 'message': 'Поиск удалён'})
        
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting manager saved search: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

# Developer appointment routes
@app.route('/book-appointment', methods=['GET', 'POST'])
@login_required
def book_appointment():
    """Book appointment with developer"""
    if request.method == 'POST':
        from models import DeveloperAppointment, BalanceTransaction
        from datetime import datetime
        
        property_id = request.form.get('property_id')
        developer_name = request.form.get('developer_name')
        complex_name = request.form.get('complex_name')
        appointment_date = request.form.get('appointment_date')
        appointment_time = request.form.get('appointment_time')
        client_name = request.form.get('client_name')
        client_phone = request.form.get('client_phone')
        notes = request.form.get('notes', '')
        
        try:
            appointment = DeveloperAppointment(
                user_id=current_user.id,
                property_id=property_id,
                developer_name=developer_name,
                complex_name=complex_name,
                appointment_date=datetime.strptime(appointment_date, '%Y-%m-%d'),
                appointment_time=appointment_time,
                client_name=client_name,
                client_phone=client_phone,
                notes=notes
            )
            
            db.session.add(appointment)
            db.session.commit()
            
            flash('Запись к застройщику успешно создана! Менеджер свяжется с вами для подтверждения.', 'success')
            return redirect(url_for('dashboard'))
            
        except Exception as e:
            db.session.rollback()
            flash('Ошибка при создании записи. Попробуйте еще раз.', 'error')
    
    # Get property data if property_id provided
    property_data = None
    property_id = request.args.get('property_id')
    if property_id:
        properties = load_properties()
        for prop in properties:
            if str(prop.get('id')) == property_id:
                property_data = prop
                break
    
    return render_template('book_appointment.html', property_data=property_data)

@app.route('/api/manager/add-client-old', methods=['POST'])
@manager_required
def add_client():
    """Add new client (old version - deprecated)"""
    from models import User
    from werkzeug.security import generate_password_hash
    import secrets
    
    data = request.get_json()
    first_name = data.get('first_name')
    last_name = data.get('last_name') 
    email = data.get('email')
    phone = data.get('phone')
    
    if not all([first_name, last_name, email]):
        return jsonify({'success': False, 'error': 'Заполните все обязательные поля'}), 400
    
    # Check if user exists
    existing_user = User.query.filter_by(email=email).first()
    if existing_user:
        return jsonify({'success': False, 'error': 'Пользователь с таким email уже существует'}), 400
    
    try:
        # Generate user ID and password
        user_id = secrets.token_hex(4).upper()
        password = 'demo123'  # Default password
        password_hash = generate_password_hash(password)
        
        current_manager = current_user
        
        user = User(
            first_name=first_name,
            last_name=last_name,
            email=email,
            phone=phone,
            password_hash=password_hash,
            user_id=user_id,
            assigned_manager_id=current_manager.id,
            client_status='Новый'
        )
        
        db.session.add(user)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'user': {
                'id': user.id,
                'full_name': user.full_name,
                'email': user.email,
                'phone': user.phone,
                'user_id': user.user_id,
                'password': password,
                'client_status': user.client_status
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/request-payout', methods=['POST'])
@login_required
def api_request_payout():
    """Request cashback payout"""
    from models import User, CashbackPayout
    from datetime import datetime
    
    try:
        user_id = current_user.id
        
        # Check if user has available cashback
        user = User.query.get(user_id)
        if not user:
            return jsonify({'success': False, 'error': 'Пользователь не найден'})
        
        # For demo purposes, assume available cashback of 125,000
        available_cashback = 125000
        
        if available_cashback <= 0:
            return jsonify({'success': False, 'error': 'Нет доступного кешбека для выплаты'})
        
        # Create payout request
        payout = CashbackPayout(
            user_id=user_id,
            amount=available_cashback,
            status='Запрошена',
            requested_at=datetime.utcnow()
        )
        
        db.session.add(payout)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Запрос на выплату успешно отправлен',
            'amount': available_cashback
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)})



# Error handlers
@app.errorhandler(404)
def not_found_error(error):
    """Handle 404 errors"""
    return render_template('errors/404.html'), 404

@app.errorhandler(500)
def internal_error(error):
    """Handle 500 errors"""
    db.session.rollback()
    return render_template('errors/500.html'), 500

@app.errorhandler(Exception)
def handle_exception(e):
    """Handle all other exceptions"""
    db.session.rollback()
    return render_template('errors/500.html'), 500

# City management API endpoints
@app.route('/api/change-city', methods=['POST'])
def change_city():
    """API endpoint to change current city"""
    try:
        from models import City
        
        data = request.get_json()
        city_slug = data.get('city_slug')
        city_name = data.get('city_name')
        
        if not city_slug:
            return jsonify({'success': False, 'message': 'Missing city data'})
        
        # Validate city exists in database
        city = City.query.filter_by(slug=city_slug, is_active=True).first()
        if not city:
            return jsonify({'success': False, 'message': 'City not found or inactive'})
        
        # Store city data in session
        session['city_id'] = city.id
        session['city_slug'] = city.slug
        session['city_name'] = city.name
        # Keep backward compatibility with old session keys
        session['current_city'] = city.name
        session['current_city_slug'] = city.slug
        
        return jsonify({
            'success': True,
            'message': f'City changed to {city.name}',
            'city': {
                'id': city.id,
                'name': city.name,
                'slug': city.slug
            }
        })
        
    except Exception as e:
        return jsonify({'success': False, 'message': 'Error changing city'})


@app.route('/api/cities')
def get_cities():
    """Get available cities"""
    try:
        from models import City
        cities = City.query.filter_by(is_active=True).all()
        logging.debug(f"Found {len(cities)} active cities in database")
        
        cities_data = []
        for city in cities:
            cities_data.append({
                'id': city.id,
                'name': city.name,
                'slug': city.slug,
                'is_default': city.is_default,
                'address_position_lat': city.latitude,
                'address_position_lon': city.longitude,
                'zoom_level': city.zoom_level
            })
            
            logging.debug(f"Added city: {city.name} (id={city.id})")
        logging.debug(f"Returning {len(cities_data)} cities to client")
        return jsonify({'cities': cities_data})
        
    except Exception as e:
        logging.error(f"Error fetching cities: {str(e)}", exc_info=True)
        # Fallback data if database not set up yet
        return jsonify({
            'cities': [
                {
                    'id': 1,
                    'name': 'Краснодар',
                    'slug': 'krasnodar',
                    'is_default': True,
                    'address_position_lat': 45.0355,
                    'address_position_lon': 38.9753,
                    'zoom_level': 12
                }
            ]
        })



@app.route('/api/districts/<int:city_id>')
def get_districts_by_city(city_id):
    """Get all districts for a specific city from District reference table"""
    try:
        from models import District
        
        districts = District.query.filter_by(
            city_id=city_id
        ).order_by(District.name).all()
        
        logging.debug(f"✅ Found {len(districts)} districts for city {city_id}")
        
        return jsonify({
            'success': True,
            'count': len(districts),
            'districts': [d.name for d in districts]
        })
        
    except Exception as e:
        logging.error(f"❌ Error fetching districts for city {city_id}: {str(e)}", exc_info=True)
        return jsonify({
            'success': False,
            'districts': [],
            'count': 0,
            'error': str(e)
        }), 500

def init_cities():
    """Initialize default cities in database"""
    try:
        from models import City
        
        # Check if cities already exist
        if City.query.count() == 0:
            cities_data = [
                {
                    'name': 'Краснодар',
                    'slug': 'krasnodar',
                    'is_active': True,
                    'is_default': True,
                    'phone': '8 (862) 266-62-16',
                    'email': 'krasnodar@inback.ru',
                    'address': 'г. Краснодар, ул. Красная, 32',
                    'address_position_lat': 45.0355,
                    'address_position_lon': 38.9753,
                    'zoom_level': 12,
                    'description': 'Кэшбек за новостройки в Краснодаре',
                    'meta_title': 'Кэшбек за новостройки в Краснодаре | InBack.ru',
                    'meta_description': 'Получите до 10% кэшбека при покупке новостройки в Краснодаре. Проверенные застройщики, юридическое сопровождение.'
                },
                {
                    'name': 'Москва',
                    'slug': 'moscow',
                    'is_active': False,
                    'is_default': False,
                    'phone': '8 (862) 266-62-16',
                    'email': 'moscow@inback.ru',
                    'address': 'г. Москва, ул. Тверская, 1',
                    'address_position_lat': 55.7558,
                    'address_position_lon': 37.6176,
                    'zoom_level': 11,
                    'description': 'Кэшбек за новостройки в Москве (скоро)',
                    'meta_title': 'Кэшбек за новостройки в Москве | InBack.ru',
                    'meta_description': 'Скоро: кэшбек сервис для покупки новостроек в Москве.'
                },
                {
                    'name': 'Санкт-Петербург',
                    'slug': 'spb',
                    'is_active': False,
                    'is_default': False,
                    'phone': '8 (862) 266-62-16',
                    'email': 'spb@inback.ru',
                    'address': 'г. Санкт-Петербург, Невский пр., 1',
                    'address_position_lat': 59.9311,
                    'address_position_lon': 30.3609,
                    'zoom_level': 11,
                    'description': 'Кэшбек за новостройки в Санкт-Петербурге (скоро)',
                    'meta_title': 'Кэшбек за новостройки в СПб | InBack.ru',
                    'meta_description': 'Скоро: кэшбек сервис для покупки новостроек в Санкт-Петербурге.'
                },
                {
                    'name': 'Сочи',
                    'slug': 'sochi',
                    'is_active': False,
                    'is_default': False,
                    'phone': '8 (862) 266-62-16',
                    'email': 'sochi@inback.ru',
                    'address': 'г. Сочи, ул. Курортный пр., 1',
                    'address_position_lat': 43.6028,
                    'address_position_lon': 39.7342,
                    'zoom_level': 12,
                    'description': 'Кэшбек за новостройки в Сочи (скоро)',
                    'meta_title': 'Кэшбек за новостройки в Сочи | InBack.ru',
                    'meta_description': 'Скоро: кэшбек сервис для покупки новостроек в Сочи.'
                }
            ]
            
            for city_data in cities_data:
                city = City(**city_data)
                db.session.add(city)
            
            db.session.commit()
            print("Cities initialized successfully")
            
    except Exception as e:
        print(f"Error initializing cities: {e}")

# Legacy API route removed - using Blueprint version instead

@api_bp.route('/searches', methods=['POST'])
def save_search():
    """Save user search parameters with manager-to-client sharing functionality"""
    from models import SavedSearch, User
    data = request.get_json()
    
    # Check authentication using helper function
    auth_info = check_api_authentication()
    if not auth_info:
        return jsonify({'success': False, 'error': 'Не авторизован'}), 401
    
    user_id = auth_info['user_id']
    user_role = auth_info['type']
    current_logged_user = auth_info['user']
    
    try:
        client_email = data.get('client_email')  # For managers
        
        print(f"DEBUG: Saving search with raw data: {data}")
        
        # Create filter object from submitted data
        filters = {}
        
        # Check if filters are nested in 'filters' object
        filter_data = data.get('filters', {}) if 'filters' in data else data
        
        # Extract filters from the data (new format)
        if 'rooms' in filter_data and filter_data['rooms']:
            if isinstance(filter_data['rooms'], list):
                room_list = [r for r in filter_data['rooms'] if r]  # Remove empty strings
                if room_list:
                    filters['rooms'] = room_list
            elif filter_data['rooms']:
                filters['rooms'] = [filter_data['rooms']]
                
        if 'districts' in filter_data and filter_data['districts']:
            if isinstance(filter_data['districts'], list):
                district_list = [d for d in filter_data['districts'] if d]  # Remove empty strings
                if district_list:
                    filters['districts'] = district_list
            elif filter_data['districts']:
                filters['districts'] = [filter_data['districts']]
                
        if 'developers' in filter_data and filter_data['developers']:
            if isinstance(filter_data['developers'], list):
                developer_list = [d for d in filter_data['developers'] if d]  # Remove empty strings
                if developer_list:
                    filters['developers'] = developer_list
            elif filter_data['developers']:
                filters['developers'] = [filter_data['developers']]
                
        if 'completion' in filter_data and filter_data['completion']:
            if isinstance(filter_data['completion'], list):
                completion_list = [c for c in filter_data['completion'] if c]  # Remove empty strings
                if completion_list:
                    filters['completion'] = completion_list
            elif filter_data['completion']:
                filters['completion'] = [filter_data['completion']]
                
        if 'priceFrom' in filter_data and filter_data['priceFrom'] and str(filter_data['priceFrom']) not in ['0', '']:
            filters['priceFrom'] = str(filter_data['priceFrom'])
        if 'priceTo' in filter_data and filter_data['priceTo'] and str(filter_data['priceTo']) not in ['0', '']:
            filters['priceTo'] = str(filter_data['priceTo'])
        if 'areaFrom' in filter_data and filter_data['areaFrom'] and str(filter_data['areaFrom']) not in ['0', '']:
            filters['areaFrom'] = str(filter_data['areaFrom'])
        if 'areaTo' in filter_data and filter_data['areaTo'] and str(filter_data['areaTo']) not in ['0', '']:
            filters['areaTo'] = str(filter_data['areaTo'])
            
        print(f"DEBUG: Extracted filters from {filter_data}: {filters}")

        # Create search with new format
        search = SavedSearch(
            user_id=user_id,
            name=data['name'],
            description=data.get('description'),
            search_type='properties',
            additional_filters=json.dumps(filters),
            notify_new_matches=data.get('notify_new_matches', True)
        )

        # Also save in legacy format for backwards compatibility
        if 'rooms' in data and data['rooms']:
            if isinstance(data['rooms'], list) and len(data['rooms']) > 0:
                search.property_type = data['rooms'][0]  # Use first room type
            else:
                search.property_type = data['rooms']
        if 'priceTo' in data and data['priceTo']:
            try:
                search.price_max = int(float(data['priceTo']) * 1000000)  # Convert millions to rubles
            except (ValueError, TypeError):
                pass
        if 'priceFrom' in data and data['priceFrom']:
            try:
                search.price_min = int(float(data['priceFrom']) * 1000000)  # Convert millions to rubles
            except (ValueError, TypeError):
                pass
        
        db.session.add(search)
        db.session.commit()
        
        # If manager specified client email, send search to client  
        if user_role == 'manager' and client_email:
            try:
                # Check if client exists
                client = User.query.filter_by(email=client_email).first()
                
                # If client exists, also save search to their account
                if client:
                    client_search = SavedSearch(
                        user_id=client.id,
                        name=data['name'] + ' (от менеджера)',
                        description=data.get('description'),
                        search_type='properties',
                        location=data.get('location'),
                        property_type=data.get('property_type'),
                        price_min=data.get('price_min'),
                        price_max=data.get('price_max'),
                        size_min=data.get('size_min'),
                        size_max=data.get('size_max'),
                        developer=data.get('developer'),
                        complex_name=data.get('complex_name'),
                        floor_min=data.get('floor_min'),
                        floor_max=data.get('floor_max'),
                        additional_filters=json.dumps(filters),
                        notify_new_matches=True
                    )
                    db.session.add(client_search)
                    db.session.commit()
                
                # Prepare search URL for client properties page  
                search_params = []
                
                # Convert manager filter format to client filter format
                if data.get('location'):
                    search_params.append(f"district={data['location']}")
                if data.get('developer'):
                    search_params.append(f"developer={data['developer']}")
                if data.get('property_type'):
                    search_params.append(f"rooms={data['property_type']}")
                if data.get('complex_name'):
                    search_params.append(f"complex={data['complex_name']}")
                if data.get('price_min'):
                    search_params.append(f"priceFrom={data['price_min'] / 1000000}")
                if data.get('price_max'):
                    search_params.append(f"priceTo={data['price_max'] / 1000000}")
                if data.get('size_min'):
                    search_params.append(f"areaFrom={data['size_min']}")
                if data.get('size_max'):
                    search_params.append(f"areaTo={data['size_max']}")
                
                search_url = f"{request.url_root}properties"
                if search_params:
                    search_url += "?" + "&".join(search_params)
                
                # Email content for client
                subject = f"Подборка недвижимости: {data['name']}"
                
                # Generate filter description for email
                filter_descriptions = []
                if data.get('property_type'):
                    filter_descriptions.append(f"Тип: {data['property_type']}")
                if data.get('location'):
                    filter_descriptions.append(f"Район: {data['location']}")
                if data.get('developer'):
                    filter_descriptions.append(f"Застройщик: {data['developer']}")
                if data.get('price_min') or data.get('price_max'):
                    price_min = f"{(data.get('price_min', 0) / 1000000):.1f}" if data.get('price_min') else "0"
                    price_max = f"{(data.get('price_max', 0) / 1000000):.1f}" if data.get('price_max') else "∞"
                    filter_descriptions.append(f"Цена: {price_min}-{price_max} млн ₽")
                if data.get('size_min') or data.get('size_max'):
                    area_min = str(data.get('size_min', 0)) if data.get('size_min') else "0"
                    area_max = str(data.get('size_max', 0)) if data.get('size_max') else "∞"
                    filter_descriptions.append(f"Площадь: {area_min}-{area_max} м²")
                
                filter_text = "<br>".join([f"• {desc}" for desc in filter_descriptions])
                
                html_content = f"""
                <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                    <h2 style="color: #0088CC;">Подборка недвижимости от InBack</h2>
                    
                    <p>Здравствуйте!</p>
                    
                    <p>Менеджер <strong>{current_user.full_name or current_user.username}</strong> подготовил для вас персональную подборку недвижимости.</p>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <h3 style="margin: 0 0 15px 0; color: #333;">Параметры поиска: {data['name']}</h3>
                        <div style="color: #666; line-height: 1.6;">
                            {filter_text}
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin: 30px 0;">
                        <a href="{search_url}" style="display: inline-block; background: #0088CC; color: white; padding: 15px 30px; text-decoration: none; border-radius: 8px; font-weight: bold;">
                            Посмотреть подборку
                        </a>
                    </div>
                    
                    <p style="color: #666; font-size: 14px;">
                        Если у вас есть вопросы, свяжитесь с вашим менеджером:<br>
                        <strong>{current_logged_user.full_name if hasattr(current_logged_user, 'full_name') else current_logged_user.email}</strong><br>
                        Email: {current_logged_user.email}
                    </p>
                    
                    <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
                    <p style="color: #999; font-size: 12px; text-align: center;">
                        InBack - ваш надежный партнер в поиске недвижимости
                    </p>
                </div>
                """
                
                # Send email using existing email service
                from email_service import send_email
                email_sent = send_email(
                    to_email=client_email,
                    subject=subject,
                    html_content=html_content,
                    template_name='collection'
                )
                
                if email_sent:
                    return jsonify({
                        'success': True, 
                        'search_id': search.id, 
                        'search': search.to_dict(),
                        'message': f'Поиск сохранен и отправлен клиенту на {client_email}',
                        'email_sent': True
                    })
                else:
                    return jsonify({
                        'success': True, 
                        'search_id': search.id, 
                        'search': search.to_dict(),
                        'message': 'Поиск сохранен, но не удалось отправить email клиенту',
                        'email_sent': False
                    })
                    
            except Exception as email_error:
                # Still return success for saved search even if email fails
                print(f"Email sending error: {email_error}")
                return jsonify({
                    'success': True, 
                    'search_id': search.id, 
                    'search': search.to_dict(),
                    'message': 'Поиск сохранен, но произошла ошибка при отправке email',
                    'email_sent': False,
                    'email_error': str(email_error)
                })
        
        return jsonify({'success': True, 'search_id': search.id, 'search': search.to_dict()})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

def check_api_authentication():
    """Helper function to check API authentication for both users and managers"""
    # Check if manager is logged in
    if 'manager_id' in session:
        from models import Manager
        manager = Manager.query.get(session['manager_id'])
        if manager:
            return {'type': 'manager', 'user_id': manager.id, 'user': manager}
    
    # Check if regular user is logged in  
    if current_user and hasattr(current_user, 'is_authenticated') and current_user.is_authenticated:
        return {'type': 'user', 'user_id': current_user.id, 'user': current_user}
    
    # Also check session for user_id (alternative authentication method)
    if 'user_id' in session:
        from models import User
        user = User.query.get(session['user_id'])
        if user:
            return {'type': 'user', 'user_id': user.id, 'user': user}
    
    return None

@app.route('/api/searches', methods=['GET', 'POST'])
@csrf.exempt
def saved_searches_endpoint():
    """Get or create user's saved searches"""
    from models import SavedSearch
    
    # Check authentication using helper function
    auth_info = check_api_authentication()
    if not auth_info:
        return jsonify({'success': False, 'error': 'Не авторизован'}), 401
    
    if request.method == 'GET':
        # Get saved searches for the authenticated user (manager or regular user) 
        searches = SavedSearch.query.filter_by(user_id=auth_info['user_id']).order_by(SavedSearch.created_at.desc()).all()
        
        return jsonify({
            'success': True,
            'searches': [search.to_dict() for search in searches]
        })
    
    elif request.method == 'POST':
        # Create new saved search
        data = request.get_json()
        name = data.get('name')
        description = data.get('description', '')
        notify_new_matches = data.get('notify_new_matches', False)
        search_type = data.get('search_type', 'properties')
        
        if not name:
            return jsonify({'success': False, 'error': 'Название поиска обязательно'}), 400
        
        try:
            # Extract search parameters (exclude metadata fields)
            exclude_fields = {'name', 'description', 'notify_new_matches', 'search_type'}
            search_params = {k: v for k, v in data.items() if k not in exclude_fields and v}
            
            search = SavedSearch()
            search.name = name
            search.description = description
            search.notify_new_matches = notify_new_matches
            search.search_type = search_type
            search.user_id = auth_info['user_id']
            search.created_at = datetime.utcnow()
            
            # Store search parameters as additional_filters JSON
            search.additional_filters = json.dumps(search_params)
            
            # Also set individual fields if they exist in the model
            for key, value in search_params.items():
                if hasattr(search, key):
                    setattr(search, key, value)
            
            db.session.add(search)
            db.session.commit()
            
            return jsonify({'success': True, 'search_id': search.id, 'message': 'Поиск сохранен'})
        except Exception as e:
            db.session.rollback()
            print(f"Error saving search: {e}")
            return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/saved-searches')
@login_required
def get_user_saved_searches():
    """Get user's saved searches"""
    from models import SavedSearch
    
    try:
        searches = SavedSearch.query.filter_by(user_id=current_user.id)\
            .order_by(SavedSearch.created_at.desc()).all()
        
        return jsonify({
            'success': True,
            'searches': [search.to_dict() for search in searches]
        })
    except Exception as e:
        print(f"Error loading user saved searches: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/saved-searches', methods=['POST'])
@login_required
@csrf.exempt
def create_user_saved_search():
    """Create a new saved search for user"""
    from models import SavedSearch
    import json
    
    data = request.get_json()
    
    try:
        filters = data.get('filters', {})
        filters_json = json.dumps(filters) if filters else None
        
        search = SavedSearch(
            user_id=current_user.id,
            name=data.get('name'),
            description=data.get('description'),
            search_type=data.get('search_type', 'properties'),
            additional_filters=filters_json,
            notify_new_matches=data.get('notify_new_matches', False)
        )
        
        db.session.add(search)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'search': search.to_dict(),
            'message': 'Поиск успешно сохранён'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Error creating user saved search: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/saved-searches/<int:search_id>', methods=['DELETE'])
@login_required
@csrf.exempt
def delete_user_saved_search(search_id):
    """Delete user's saved search"""
    from models import SavedSearch
    
    try:
        search = SavedSearch.query.filter_by(id=search_id, user_id=current_user.id).first()
        
        if not search:
            return jsonify({'success': False, 'error': 'Поиск не найден'}), 404
        
        db.session.delete(search)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Поиск успешно удалён'
        })
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting user saved search: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/saved-searches/count')
@login_required
def get_user_saved_searches_count():
    """Get count of user's saved searches"""
    from models import SavedSearch
    
    try:
        count = SavedSearch.query.filter_by(user_id=current_user.id).count()
        return jsonify({
            'success': True,
            'count': count
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400


# ==========================================
# USER NOTIFICATION SETTINGS API ENDPOINTS
# ==========================================

@app.route('/api/user/alert-settings', methods=['GET'])
@login_required
def get_user_alert_settings():
    """Get all user's saved searches with alert settings"""
    from models import SavedSearch, PropertyAlert
    
    searches = db.session.query(SavedSearch)\
        .filter_by(user_id=current_user.id)\
        .order_by(SavedSearch.last_used.desc())\
        .all()
    
    # Enrich each search with alert count
    result = []
    for search in searches:
        search_dict = search.to_dict()
        alert_count = db.session.query(PropertyAlert)\
            .filter_by(saved_search_id=search.id)\
            .count()
        search_dict['alert_count'] = alert_count
        result.append(search_dict)
    
    return jsonify({'success': True, 'searches': result})

@app.route('/api/user/alert-settings', methods=['POST'])
@login_required
@require_json_csrf
def update_user_alert_settings():
    """Update alert settings for a specific saved search"""
    data = request.get_json()
    search_id = data.get('search_id')
    
    if not search_id:
        return jsonify({'success': False, 'error': 'search_id required'}), 400
    
    search = db.session.query(SavedSearch)\
        .filter_by(id=search_id, user_id=current_user.id)\
        .first()
    
    if not search:
        return jsonify({'success': False, 'error': 'Поиск не найден'}), 404
    
    # Update fields
    if 'alert_enabled' in data:
        search.alert_enabled = bool(data['alert_enabled'])
    
    if 'alert_frequency' in data:
        freq = data['alert_frequency']
        if freq not in ['instant', 'daily', 'weekly', 'never']:
            return jsonify({'success': False, 'error': 'Invalid frequency'}), 400
        search.alert_frequency = freq
    
    if 'alert_channels' in data:
        channels = data['alert_channels']
        if not isinstance(channels, list):
            return jsonify({'success': False, 'error': 'Channels must be array'}), 400
        import json
        search.alert_channels = json.dumps(channels)
    
    db.session.commit()
    return jsonify({'success': True, 'search': search.to_dict()})

@app.route('/api/user/unsubscribe/<token>', methods=['GET'])
def unsubscribe_from_alerts(token):
    """Unsubscribe from alerts using token"""
    import jwt
    from models import SavedSearch
    
    try:
        payload = jwt.decode(token, app.secret_key, algorithms=['HS256'])
        user_id = payload.get('user_id')
        search_id = payload.get('search_id')
        
        search = db.session.query(SavedSearch)\
            .filter_by(id=search_id, user_id=user_id)\
            .first()
        
        if search:
            search.alert_enabled = False
            db.session.commit()
            return render_template('unsubscribe_success.html', search_name=search.name)
        
        return render_template('unsubscribe_error.html', error='Поиск не найден'), 404
        
    except Exception as e:
        return render_template('unsubscribe_error.html', error='Недействительная ссылка'), 400



@app.route('/api/user/alert-history', methods=['GET'])
@login_required
def get_alert_history():
    """Get user's alert history with pagination"""
    try:
        limit = int(request.args.get('limit', 20))
        offset = int(request.args.get('offset', 0))
        
        # Ensure limits are reasonable
        limit = min(limit, 100)
        offset = max(offset, 0)
        
        history_data = AlertService.get_alert_history(
            user_id=current_user.id,
            limit=limit,
            offset=offset
        )
        
        # Enrich with property details
        from models import Property
        for alert in history_data['alerts']:
            property = Property.query.get(alert.get('property_id'))
            if property:
                alert['property'] = {
                    'title': property.title,
                    'rooms': property.rooms,
                    'area': property.area,
                    'price': property.price,
                    'main_image': property.main_image,
                    'complex_name': property.residential_complex.name if property.residential_complex else None
                }
        
        return jsonify({
            'success': True,
            **history_data
        })
        
    except Exception as e:
        logger.error(f"Error getting alert history: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@login_required 
def get_saved_search(search_id):
    """Get saved search by ID - supports both user searches and manager shared searches"""
    try:
        from models import SavedSearch, SentSearch
        
        # First try user's own saved search
        search = SavedSearch.query.filter_by(id=search_id, user_id=current_user.id).first()
        
        # If not found, try manager shared search via SentSearch table
        if not search:
            sent_search = SentSearch.query.filter_by(
                client_id=current_user.id
            ).join(SavedSearch, SentSearch.manager_search_id == SavedSearch.id).filter(
                SavedSearch.id == search_id
            ).first()
            
            if sent_search:
                search = SavedSearch.query.get(search_id)
                # Use the additional_filters from sent_search if available
                if sent_search.additional_filters:
                    search._temp_filters = sent_search.additional_filters
        
        # If still not found, check if it's a global search available to all users
        if not search:
            search = SavedSearch.query.get(search_id)
            if search and not search.user_id:  # Global searches have no user_id
                pass  # Allow access
            else:
                search = None
        
        if not search:
            return jsonify({'success': False, 'error': 'Поиск не найден'})
        
        # Parse filters - check for temp filters from sent search first
        filters = {}
        if hasattr(search, '_temp_filters') and search._temp_filters:
            try:
                filters = json.loads(search._temp_filters)
            except:
                filters = {}
        elif search.additional_filters:
            try:
                filters = json.loads(search.additional_filters)
            except:
                filters = {}
        
        return jsonify({
            'success': True,
            'id': search.id,
            'name': search.name,
            'description': search.description,
            'search_filters': filters,
            'created_at': search.created_at.isoformat() if search.created_at else None
        })
        
    except Exception as e:
        print(f"Error getting saved search: {e}")
        return jsonify({'success': False, 'error': 'Ошибка сервера'})

@app.route('/api/searches/<int:search_id>', methods=['DELETE'])
@csrf.exempt
def delete_saved_search(search_id):
    """Delete saved search"""
    from models import SavedSearch
    
    # Check authentication using helper function
    auth_info = check_api_authentication()
    if not auth_info:
        return jsonify({'success': False, 'error': 'Не авторизован'}), 401
    
    user_id = auth_info['user_id']
    
    search = SavedSearch.query.filter_by(id=search_id, user_id=user_id).first()
    
    if not search:
        return jsonify({'success': False, 'error': 'Поиск не найден'}), 404
    
    try:
        db.session.delete(search)
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-property', methods=['POST'])
@login_required
def send_property_to_client_endpoint():
    """Send property search to client"""
    if current_user.role != 'manager':
        return jsonify({'success': False, 'error': 'Access denied'}), 403
    
    try:
        data = request.get_json()
        client_id = data.get('client_id')
        search_id = data.get('search_id')
        message = data.get('message', '')
        
        if not client_id or not search_id:
            return jsonify({'success': False, 'error': 'Client ID and Search ID are required'}), 400
        
        # Verify client exists and is a buyer
        client = User.query.filter_by(id=client_id, role='buyer').first()
        if not client:
            return jsonify({'success': False, 'error': 'Client not found'}), 404
        
        # Verify search exists and belongs to manager
        search = SavedSearch.query.filter_by(id=search_id, user_id=current_user.id).first()
        if not search:
            return jsonify({'success': False, 'error': 'Search not found'}), 404
        
        # Create recommendation record
        from models import ClientPropertyRecommendation
        recommendation = ClientPropertyRecommendation(
            manager_id=current_user.id,
            client_id=client_id,
            search_id=search_id,
            message=message
        )
        
        db.session.add(recommendation)
        db.session.commit()
        
        # Send notification to client (email)
        try:
            subject = f"Подборка квартир от {current_user.full_name}"
            text_message = f"""
Здравствуйте, {client.full_name}!

Ваш менеджер {current_user.full_name} подготовил для вас подборку квартир: {search.name}

{message if message else ''}

Перейдите в личный кабинет на сайте InBack.ru, чтобы посмотреть подборку.

С уважением,
Команда InBack.ru
            """
            
            from email_service import send_email
            send_email(
                to_email=client.email,
                subject=subject,
                text_content=text_message.strip(),
                template_name='recommendation'
            )
        except Exception as e:
            app.logger.warning(f"Failed to send email notification: {str(e)}")
        
        return jsonify({
            'success': True,
            'message': 'Property recommendation sent successfully'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# Property API routes for manager search
@app.route('/api/search/properties')
def search_properties_api():
    """Search properties for manager collection creation using normalized tables"""
    from repositories.property_repository import PropertyRepository
    
    try:
        district = request.args.get('district')
        developer = request.args.get('developer') 
        rooms = request.args.get('rooms')
        prop_type = request.args.get('type')
        price_min = request.args.get('price_min')
        price_max = request.args.get('price_max')
        area_min = request.args.get('area_min')
        
        filters = {}
        if price_min:
            filters['min_price'] = int(price_min)
        if price_max:
            filters['max_price'] = int(price_max)
        if area_min:
            filters['min_area'] = float(area_min)
        if rooms and rooms.isdigit():
            filters['rooms'] = [int(rooms)]
        if prop_type:
            filters['deal_type'] = prop_type
        
        properties = PropertyRepository.get_all_active(filters=filters, limit=100)
        
        filtered_properties = []
        for prop in properties:
            complex_obj = prop.residential_complex
            developer_obj = prop.developer
            
            district_name = complex_obj.district if complex_obj else ''
            developer_name = developer_obj.name if developer_obj else ''
            
            if district and district_name.lower() != district.lower():
                continue
            if developer and developer_name.lower() != developer.lower():
                continue
            if prop_type and prop.deal_type and prop.deal_type.lower() != prop_type.lower():
                continue
            
            price = prop.price or 0
            cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 5.0
            cashback = int(price * cashback_rate / 100)
            
            filtered_properties.append({
                'id': prop.inner_id or prop.id,
                'complex_name': complex_obj.name if complex_obj else '',
                'district': district_name,
                'developer': developer_name,
                'rooms': prop.rooms or 0,
                'price': price,
                'cashback': cashback,
                'area': prop.area or 0,
                'floor': f"{prop.floor}/{prop.total_floors}" if prop.floor and prop.total_floors else '',
                'type': prop.deal_type or 'Первичка'
            })
        
        filtered_properties = filtered_properties[:20]
        
        return jsonify({
            'success': True,
            'properties': filtered_properties
        })
    except Exception as e:
        print(f"Error searching properties: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/search/apartments')
def search_apartments_api():
    """Search apartments with full filtering using normalized tables"""
    from repositories.property_repository import PropertyRepository, ResidentialComplexRepository
    
    try:
        district = request.args.get('district')
        developer = request.args.get('developer') 
        rooms = request.args.get('rooms')
        complex_id = request.args.get('complex')
        price_min = request.args.get('price_min')
        price_max = request.args.get('price_max')
        area_min = request.args.get('area_min')
        area_max = request.args.get('area_max')
        floor_min = request.args.get('floor_min')
        floor_max = request.args.get('floor_max')
        status = request.args.get('status')
        finishing = request.args.get('finishing')
        
        filters = {}
        if price_min:
            filters['min_price'] = int(price_min)
        if price_max:
            filters['max_price'] = int(price_max)
        if area_min:
            filters['min_area'] = float(area_min)
        if area_max:
            filters['max_area'] = float(area_max)
        if complex_id:
            filters['complex_id'] = int(complex_id)
        if rooms and rooms != 'студия':
            if rooms.isdigit():
                filters['rooms'] = [int(rooms)]
        
        properties = PropertyRepository.get_all_active(filters=filters, limit=200)
        
        filtered_apartments = []
        for prop in properties:
            complex_obj = prop.residential_complex
            developer_obj = prop.developer
            
            district_name = complex_obj.district if complex_obj else ''
            developer_name = developer_obj.name if developer_obj else ''
            
            if district and district_name.lower() != district.lower():
                continue
            if developer and developer_name.lower() != developer.lower():
                continue
            
            if rooms == 'студия' and prop.rooms != 0:
                continue
            
            prop_floor = prop.floor if prop.floor else 0
            if floor_min and prop_floor < int(floor_min):
                continue
            if floor_max and prop_floor > int(floor_max):
                continue
            
            price = prop.price or 0
            cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 5.0
            cashback = int(price * cashback_rate / 100)
            
            photos_list = []
            if prop.gallery_images:
                try:
                    if isinstance(prop.gallery_images, list):
                        photos_list = prop.gallery_images
                    elif isinstance(prop.gallery_images, str):
                        photos_list = json.loads(prop.gallery_images)
                except:
                    pass
            
            filtered_apartments.append({
                'id': prop.inner_id or prop.id,
                'complex_name': complex_obj.name if complex_obj else '',
                'complex_id': prop.complex_id,
                'district': district_name,
                'developer': developer_name,
                'rooms': 'студия' if prop.rooms == 0 else prop.rooms,
                'price': price,
                'cashback': cashback,
                'area': prop.area or 0,
                'floor': prop.floor if prop.floor else '',
                'max_floor': prop.total_floors if prop.total_floors else '',
                'type': 'студия' if prop.rooms == 0 else f'{prop.rooms}-комн',
                'status': 'сдан',
                'finishing': prop.renovation_type or '',
                'images': photos_list,
                'description': prop.description or '',
                'features': []
            })
        
        filtered_apartments.sort(key=lambda x: x['price'])
        filtered_apartments = filtered_apartments[:50]
        
        complexes = ResidentialComplexRepository.get_all_active() if not city_id_filter else [
            c for c in ResidentialComplexRepository.get_all_active() 
            if c.city_id == city_id_filter
        ]
        complexes_data = {c.id: {'name': c.name, 'district': c.district} for c in complexes}
        
        return jsonify({
            'success': True,
            'apartments': filtered_apartments,
            'complexes': complexes_data
        })
    except Exception as e:
        print(f"Error searching apartments: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/complexes')
def get_complexes_api():
    """Get list of residential complexes for filter"""
    try:
        with open('data/residential_complexes.json', 'r', encoding='utf-8') as f:
            complexes_data = json.load(f)
        
        complexes_list = [
            {'id': complex_item.get('id'), 'name': complex_item.get('name', '')}
            for complex_item in complexes_data
        ]
        
        return jsonify({
            'success': True,
            'complexes': complexes_list
        })
    except Exception as e:
        print(f"Error loading complexes: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@csrf.exempt
@app.route('/api/properties/<property_id>')

@app.route('/api/properties/find-similar/<property_id>', methods=['GET'])
@login_required
def find_similar_properties(property_id):
    """Find similar properties for a given property (inner_id or database id)
    
    Returns similar properties based on:
    - Same city
    - Same number of rooms
    - Similar area (±15%)
    - Similar price (±20%)
    - Preferably same developer
    
    Usage:
        GET /api/properties/find-similar/1999611557?limit=10
    """
    from services.property_matcher import PropertyMatcher
    from models import Property
    
    try:
        # Конвертируем inner_id в database id
        property_obj = Property.query.filter_by(inner_id=str(property_id)).first()
        
        if not property_obj:
            # Try as database ID if inner_id lookup fails
            try:
                property_obj = Property.query.get(int(property_id))
            except (ValueError, TypeError):
                pass
        
        if not property_obj:
            return jsonify({
                'success': False,
                'error': 'Property not found'
            }), 404
        
        # Get limit from query params
        limit = request.args.get('limit', 10, type=int)
        limit = min(max(1, limit), 50)  # Clamp between 1 and 50
        
        # Find similar properties
        similar = PropertyMatcher.find_similar_properties(
            property_id=property_obj.id,
            limit=limit,
            city_id=property_obj.city_id
        )
        
        return jsonify({
            'success': True,
            'similar_properties': similar,
            'count': len(similar),
            'original_property': {
                'id': property_obj.id,
                'inner_id': property_obj.inner_id,
                'rooms': property_obj.rooms,
                'area': property_obj.area,
                'price': property_obj.price
            }
        })
    
    except Exception as e:
        print(f"Error finding similar properties: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/complexes/filter', methods=['POST'])
def filter_complexes_by_apartments():
    """Filter residential complexes based on apartment parameters"""
    from models import Property
    from repositories.property_repository import PropertyRepository, ResidentialComplexRepository
    
    try:
        filters = request.json or {}
        
        # Extract filters
        rooms = filters.get('rooms', [])  # e.g., ["1-комн", "2-комн"]
        price_from = filters.get('priceFrom')  # В млн
        price_to = filters.get('priceTo')  # В млн
        developers = filters.get('developers', [])
        completion = filters.get('completion', [])
        housing_class = filters.get('housingClass', [])
        area_from = filters.get('areaFrom')
        area_to = filters.get('areaTo')
        
        # Получаем все комплексы с координатами
        complexes_data = ResidentialComplexRepository.get_with_coordinates()
        property_stats = PropertyRepository.get_all_property_stats()
        
        filtered_complex_ids = set()
        
        # Если есть фильтр по комнатам, цене или площади - ищем через квартиры
        if rooms or price_from or price_to or area_from or area_to:
            # Строим SQL запрос для поиска квартир
            query = Property.query
            
            # Фильтр по комнатам
            if rooms:
                # Преобразуем "2-комн" -> 2
                room_numbers = []
                for r in rooms:
                    if 'студия' in r.lower():
                        room_numbers.append(0)
                    else:
                        try:
                            room_numbers.append(int(r.split('-')[0]))
                        except:
                            pass
                if room_numbers:
                    query = query.filter(Property.rooms.in_(room_numbers))
            
            # Фильтр по цене (млн рублей)
            if price_from:
                query = query.filter(Property.price >= price_from * 1000000)
            if price_to:
                query = query.filter(Property.price <= price_to * 1000000)
            
            # Фильтр по площади
            if area_from:
                query = query.filter(Property.area >= area_from)
            if area_to:
                query = query.filter(Property.area <= area_to)
            
            # Получаем ID комплексов с подходящими квартирами
            matching_properties = query.all()
            filtered_complex_ids = {p.complex_id for p in matching_properties if p.complex_id}
        
        # Формируем результаты
        residential_complexes = []
        current_year = 2025
        
        for row in complexes_data:
            complex_id = row.id
            
            # Пропускаем если нужна фильтрация по квартирам и комплекс не подходит
            if (rooms or price_from or price_to or area_from or area_to) and complex_id not in filtered_complex_ids:
                continue
            
            stats = property_stats.get(complex_id, {})
            
            # Пропускаем комплексы без квартир
            if not stats or stats.get('total_count', 0) == 0:
                continue
            
            # Фильтр по застройщику
            if developers and row.developer_name not in developers:
                continue
            
            # Фильтр по классу жилья
            if housing_class and row.object_class_display_name and row.object_class_display_name not in housing_class:
                continue
            
            # Статус и дата сдачи
            end_build_year = row.end_build_year
            end_build_quarter = row.end_build_quarter
            status = 'Не указан'
            completion_date = 'Не указан'
            
            if end_build_year:
                if end_build_year <= current_year:
                    status = 'Сдан'
                else:
                    status = 'Строится'
                if end_build_quarter:
                    completion_date = f"{end_build_quarter} кв. {end_build_year}"
                else:
                    completion_date = str(end_build_year)
            
            # Фильтр по сдаче/статусу
            if completion:
                match_found = False
                for filter_val in completion:
                    if filter_val == 'Сдан' and status == 'Сдан':
                        match_found = True
                        break
                    elif completion_date and filter_val in completion_date:
                        match_found = True
                        break
                if not match_found:
                    continue
            
            # Добавляем комплекс в результаты
            residential_complexes.append({
                'id': complex_id,
                'name': row.name or '',
                'developer': row.developer_name or '',
                'address': '',  # Not in get_with_coordinates()
                'district': 'Краснодарский край',
                'apartments_count': stats.get('total_count', 0),
                'price_from': int(stats.get('min_price', 0)),
                'coordinates': {
                    'lat': float(row.latitude),
                    'lng': float(row.longitude)
                } if row.latitude and row.longitude else None,
                'completion_date': completion_date,
                'status': status,
                'cashback_percent': float(row.cashback_rate or 3.5),
                'main_image': row.main_image or '/static/images/no-photo.jpg',
                'description': f'Жилой комплекс {row.name}',
                'object_class': row.object_class_display_name or 'Комфорт',
                'housing_class': row.object_class_display_name or 'Комфорт',
                'max_floors': 0,
                'url': f'/zk/{row.slug}' if row.slug else '#',
                'type': 'complex'
            })
        
        print(f"✅ Filtered {len(residential_complexes)} complexes (from {len(complexes_data)} total)")
        
        return jsonify({
            'success': True,
            'complexes': residential_complexes,
            'total': len(residential_complexes)
        })
        
    except Exception as e:
        print(f"❌ Error filtering complexes: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 400
def get_property_details(property_id):
    """Get detailed property information using normalized tables"""
    from repositories.property_repository import PropertyRepository
    
    try:
        prop = PropertyRepository.get_by_id(property_id)
        
        if not prop:
            return jsonify({'success': False, 'error': 'Property not found'}), 404
        
        complex_obj = prop.residential_complex
        developer_obj = prop.developer
        
        price = prop.price or 0
        cashback_rate = complex_obj.cashback_rate if complex_obj and complex_obj.cashback_rate else 5.0
        cashback = int(price * cashback_rate / 100)
        
        property_info = {
            'id': prop.inner_id or prop.id,
            'complex_name': complex_obj.name if complex_obj else '',
            'district': complex_obj.district if complex_obj else '',
            'developer': developer_obj.name if developer_obj else '',
            'rooms': prop.rooms or 0,
            'price': price,
            'cashback': cashback,
            'area': prop.area or 0,
            'floor': f"{prop.floor}/{prop.total_floors}" if prop.floor and prop.total_floors else '',
            'type': prop.deal_type or 'Первичка',
            'description': prop.description or '',
            'features': []
        }
        
        return jsonify({
            'success': True,
            'property': property_info
        })
    except Exception as e:
        print(f"Error getting property details: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/collections', methods=['POST'])
@manager_required
def create_collection_api():
    """Create a new property collection"""
    try:
        current_manager = current_user
            
        from models import Collection, CollectionProperty
        
        data = request.get_json()
        name = data.get('name')
        client_id = data.get('client_id')
        property_ids = data.get('property_ids', [])
        
        if not name or not client_id or not property_ids:
            return jsonify({'success': False, 'error': 'Missing required fields'}), 400
        
        # Create collection
        collection = Collection(
            title=name,
            assigned_to_user_id=client_id,
            created_by_manager_id=current_manager.id,
            status='Создана',
            description=f'Подборка из {len(property_ids)} объектов'
        )
        
        db.session.add(collection)
        db.session.flush()  # Get collection ID
        
        # Add properties to collection
        for prop_id in property_ids:
            # DUAL WRITE: Resolve property to get both IDs
            property_obj, canonical_id = resolve_property_by_identifier(prop_id)
            if not property_obj:
                continue  # Skip properties that don't exist
            
            collection_property = CollectionProperty(
                collection_id=collection.id,
                property_id=str(property_obj.id),  # Old: database ID
                property_inner_id=property_obj.inner_id  # NEW: canonical inner_id
            )
            db.session.add(collection_property)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'collection_id': collection.id,
            'message': 'Подборка успешно создана'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error creating collection: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/send-collection', methods=['POST'])
@manager_required
def send_collection_to_client():
    """Send property collection to client via email"""
    try:
        current_manager = current_user
            
        from models import User, Manager
        
        data = request.get_json()
        
        # TODO: Implement collection sending logic
        return jsonify({'success': True, 'message': 'Функция в разработке'})
        
    except Exception as e:
        print(f"Error sending collection: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

# ========== ПРЕЗЕНТАЦИИ API ==========

@app.route('/api/manager/presentations', methods=['GET'])
@manager_required
def get_manager_presentations():
    """Получить все презентации менеджера"""
    try:
        from models import Collection
        
        current_manager = current_user
        
        presentations = Collection.query.filter_by(
            created_by_manager_id=current_manager.id,
            collection_type='presentation'
        ).order_by(Collection.created_at.desc()).all()
        
        presentations_data = []
        for presentation in presentations:
            presentations_data.append(presentation.to_dict())
        
        return jsonify({
            'success': True,
            'presentations': presentations_data
        })
        
    except Exception as e:
        print(f"Error loading presentations: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/presentation/create', methods=['POST'])
@manager_required
# @require_json_csrf  # CSRF disabled
def create_presentation():
    """Создать новую презентацию"""
    from models import Collection
    from flask_login import current_user
    
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': 'Данные не предоставлены'}), 400
        
    title = data.get('title')
    description = data.get('description', '')
    client_name = data.get('client_name', '')
    client_phone = data.get('client_phone', '')
    
    if not title:
        return jsonify({'success': False, 'error': 'Название презентации обязательно'}), 400
    
    try:
        current_manager = current_user
            
        presentation = Collection(
            title=title,
            description=description,
            created_by_manager_id=current_manager.id,
            collection_type='presentation',
            client_name=client_name,
            client_phone=client_phone,
            status='Черновик'
        )
        
        # Генерируем уникальную ссылку
        presentation.generate_unique_url()
        
        db.session.add(presentation)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'presentation': presentation.to_dict(),
            'message': 'Презентация создана успешно'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400


def _load_presentation_properties_from_db(presentation_id):
    """
    ✅ Helper function: Load presentation properties from PostgreSQL
    Used by both manager view and public view to avoid code duplication.
    Returns enriched_properties list with all property data.
    """
    from models import CollectionProperty, Property
    from sqlalchemy.orm import joinedload
    
    # Get presentation properties
    collection_properties = CollectionProperty.query.filter_by(
        collection_id=presentation_id
    ).order_by(CollectionProperty.order_index).all()
    
    print(f"DEBUG: Found {len(collection_properties)} properties in presentation {presentation_id}")
    
    # ✅ Load property data directly from PostgreSQL with eager loading
    enriched_properties = []
    for cp in collection_properties:
        # ✅ FIXED: Smart search - try inner_id first, then database ID
        # cp.property_id can be either inner_id OR database ID (legacy data)
        property_obj = Property.query.options(
            joinedload(Property.residential_complex),
            joinedload(Property.developer),
            joinedload(Property.district)
        ).filter_by(inner_id=cp.property_id).first()
        
        # If not found by inner_id, try as database primary key
        if not property_obj:
            try:
                property_id_int = int(cp.property_id)
                property_obj = Property.query.options(
                    joinedload(Property.residential_complex),
                    joinedload(Property.developer),
                    joinedload(Property.district)
                ).get(property_id_int)
                if property_obj:
                    print(f"DEBUG: Found property {property_id_int} by database ID")
            except (ValueError, TypeError):
                print(f"DEBUG: Could not parse property_id {cp.property_id} as int")
        
        if property_obj:
            # ✅ Parse gallery_images JSON field properly
            main_image = 'https://via.placeholder.com/400x300?text=No+Photo'
            images = []
            
            if property_obj.gallery_images:
                try:
                    # Parse JSON array
                    if isinstance(property_obj.gallery_images, str):
                        photos = json.loads(property_obj.gallery_images)
                    else:
                        photos = property_obj.gallery_images
                    
                    if photos and isinstance(photos, list) and len(photos) > 0:
                        main_image = photos[0]
                        images = photos
                except (json.JSONDecodeError, TypeError) as e:
                    print(f"DEBUG: Error parsing gallery_images for property {property_id_int}: {e}")
            
            # Use main_image field if gallery is empty
            if not images and property_obj.main_image:
                main_image = property_obj.main_image
                images = [main_image]
            
            # ✅ Get data from relationships (same pattern as /properties route)
            complex_name = property_obj.residential_complex.name if property_obj.residential_complex else 'Не указан'
            developer_name = property_obj.developer.name if property_obj.developer else 'Не указан'
            district_name = property_obj.district.name if property_obj.district else 'Не указан'
            
            # ✅ Calculate cashback from residential_complex.cashback_rate
            cashback = 0
            cashback_rate = 0
            if property_obj.residential_complex and property_obj.residential_complex.cashback_rate:
                cashback_rate = float(property_obj.residential_complex.cashback_rate)
                cashback = int(property_obj.price * (cashback_rate / 100)) if property_obj.price else 0
            
            # Build room description
            rooms = property_obj.rooms or 0
            if rooms == 0:
                room_type = "Студия"
            else:
                room_type = f"{rooms}-комнатная квартира"
            
            # Build title (same format as /properties route)
            floor_text = f"{property_obj.floor}/{property_obj.total_floors} эт." if property_obj.floor and property_obj.total_floors else ""
            title = f"{room_type}, {property_obj.area} м²"
            if floor_text:
                title += f", {floor_text}"
            
            # ✅ Build enriched_property dict from Property ORM attributes
            enriched_property = {
                'id': property_obj.inner_id or property_obj.id,
                'property_id': property_obj.id,  # ✅ database ID for API calls
                'inner_id': property_obj.inner_id,  # ✅ inner_id for external refs
                'manager_note': cp.manager_note,  # ✅ Keep manager_note from CollectionProperty
                'order_index': cp.order_index,
                'rooms': rooms,
                'price': property_obj.price or 0,
                'area': property_obj.area or 0,
                'floor': property_obj.floor or 0,
                'total_floors': property_obj.total_floors or 0,
                'complex_name': complex_name,
                'property_type': 'Квартира',
                'images': images,
                'main_image': main_image,
                'layout_image': None,
                'address': property_obj.address or '',
                'latitude': float(property_obj.latitude) if property_obj.latitude else None,
                'longitude': float(property_obj.longitude) if property_obj.longitude else None,
                'description': property_obj.description or '',
                'features': [],
                'developer': developer_name,
                'district': district_name,
                'cashback': cashback,
                'cashback_available': bool(cashback > 0),
                'cashback_rate': cashback_rate,
                'price_per_sqm': property_obj.price_per_sqm or 0,
                'status': property_obj.status or 'available',
                'title': title,
                'url': f"/object/{property_obj.inner_id or property_obj.id}"
            }
            enriched_properties.append(enriched_property)
        else:
            print(f"DEBUG: Property {cp.property_id} not found in database")
    
    print(f"DEBUG: Enriched {len(enriched_properties)} properties from PostgreSQL")
    return enriched_properties

@app.route('/api/manager/presentation/<int:presentation_id>', methods=['GET'])
@manager_required
def get_presentation_data(presentation_id):
    """✅ FIXED: Load property data from PostgreSQL instead of Excel cache"""
    from models import Collection, CollectionProperty, Manager, Property
    from sqlalchemy.orm import joinedload
    
    current_manager = current_user
    print(f"DEBUG: Get presentation data - manager_id: {current_manager.id}, presentation_id: {presentation_id}")
    
    # Get presentation data
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_manager.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': 'Презентация не найдена или доступ запрещен'}), 404
    
    # Get presentation properties
    collection_properties = CollectionProperty.query.filter_by(
        collection_id=presentation_id
    ).order_by(CollectionProperty.order_index).all()
    
    print(f"DEBUG: Found {len(collection_properties)} properties in presentation")
    
    # ✅ FIXED: Load property data directly from PostgreSQL instead of Excel cache
    enriched_properties = []
    for cp in collection_properties:
        # ✅ FIXED: Smart search - try inner_id first, then database ID
        # cp.property_id can be either inner_id OR database ID (legacy data)
        property_obj = Property.query.options(
            joinedload(Property.residential_complex),
            joinedload(Property.developer),
            joinedload(Property.district)
        ).filter_by(inner_id=cp.property_id).first()
        
        # If not found by inner_id, try as database primary key
        if not property_obj:
            try:
                property_id_int = int(cp.property_id)
                property_obj = Property.query.options(
                    joinedload(Property.residential_complex),
                    joinedload(Property.developer),
                    joinedload(Property.district)
                ).get(property_id_int)
                if property_obj:
                    print(f"DEBUG: Found property {property_id_int} by database ID")
            except (ValueError, TypeError):
                print(f"DEBUG: Could not parse property_id {cp.property_id} as int")
        
        if property_obj:
            # ✅ Parse gallery_images JSON field properly
            main_image = 'https://via.placeholder.com/400x300?text=No+Photo'
            images = []
            
            if property_obj.gallery_images:
                try:
                    # Parse JSON array
                    if isinstance(property_obj.gallery_images, str):
                        photos = json.loads(property_obj.gallery_images)
                    else:
                        photos = property_obj.gallery_images
                    
                    if photos and isinstance(photos, list) and len(photos) > 0:
                        main_image = photos[0]
                        images = photos
                except (json.JSONDecodeError, TypeError) as e:
                    print(f"DEBUG: Error parsing gallery_images for property {property_id_int}: {e}")
            
            # Use main_image field if gallery is empty
            if not images and property_obj.main_image:
                main_image = property_obj.main_image
                images = [main_image]
            
            # ✅ Get data from relationships (same pattern as /properties route)
            complex_name = property_obj.residential_complex.name if property_obj.residential_complex else 'Не указан'
            developer_name = property_obj.developer.name if property_obj.developer else 'Не указан'
            district_name = property_obj.district.name if property_obj.district else 'Не указан'
            
            # ✅ Calculate cashback from residential_complex.cashback_rate
            cashback = 0
            cashback_rate = 0
            if property_obj.residential_complex and property_obj.residential_complex.cashback_rate:
                cashback_rate = float(property_obj.residential_complex.cashback_rate)
                cashback = int(property_obj.price * (cashback_rate / 100)) if property_obj.price else 0
            
            # Build room description
            rooms = property_obj.rooms or 0
            if rooms == 0:
                room_type = "Студия"
            else:
                room_type = f"{rooms}-комнатная квартира"
            
            # Build title (same format as /properties route)
            floor_text = f"{property_obj.floor}/{property_obj.total_floors} эт." if property_obj.floor and property_obj.total_floors else ""
            title = f"{room_type}, {property_obj.area} м²"
            if floor_text:
                title += f", {floor_text}"
            
            # ✅ Build enriched_property dict from Property ORM attributes
            enriched_property = {
                'id': property_obj.inner_id or property_obj.id,
                'property_id': property_obj.id,  # ✅ database ID for API calls
                'inner_id': property_obj.inner_id,  # ✅ inner_id for external refs
                'manager_note': cp.manager_note,  # ✅ Keep manager_note from CollectionProperty
                'order_index': cp.order_index,
                'rooms': rooms,
                'price': property_obj.price or 0,
                'area': property_obj.area or 0,
                'floor': property_obj.floor or 0,
                'total_floors': property_obj.total_floors or 0,
                'complex_name': complex_name,
                'property_type': 'Квартира',
                'images': images,
                'main_image': main_image,
                'layout_image': None,
                'address': property_obj.address or '',
                'latitude': float(property_obj.latitude) if property_obj.latitude else None,
                'longitude': float(property_obj.longitude) if property_obj.longitude else None,
                'description': property_obj.description or '',
                'features': [],
                'developer': developer_name,
                'district': district_name,
                'cashback': cashback,
                'cashback_available': bool(cashback > 0),
                'cashback_rate': cashback_rate,
                'price_per_sqm': property_obj.price_per_sqm or 0,
                'status': property_obj.status or 'available',
                'title': title,
                'url': f"/object/{property_obj.inner_id or property_obj.id}"
            }
            enriched_properties.append(enriched_property)
        else:
            print(f"DEBUG: Property {cp.property_id} not found in database")
    
    print(f"DEBUG: Enriched {len(enriched_properties)} properties from PostgreSQL")
    
    # Format presentation data for JSON response
    presentation_data = {
        'id': presentation.id,
        'title': presentation.title,
        'description': presentation.description,
        'client_name': presentation.client_name,
        'client_phone': presentation.client_phone,
        'status': presentation.status,
        'created_at': presentation.created_at.isoformat() if presentation.created_at else None,
        'view_count': presentation.view_count,
        'last_viewed_at': presentation.last_viewed_at.isoformat() if presentation.last_viewed_at else None,
        'properties_count': len(enriched_properties),
        'properties': enriched_properties,
        'unique_url': presentation.unique_url,
        'assigned_to_user_id': presentation.assigned_to_user_id
    }
    
    return jsonify({
        'success': True,
        'presentation': presentation_data
    })

@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def add_property_to_presentation(presentation_id):
    """Добавить квартиру в презентацию"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': 'Данные не предоставлены'}), 400
        
    property_id = data.get('property_id')
    manager_note = data.get('manager_note', '')
    
    if not property_id:
        return jsonify({'success': False, 'error': 'ID объекта не указан'}), 400
    
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_user.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': 'Презентация не найдена или у вас нет прав доступа'}), 404
    
    # Проверяем, не добавлена ли уже эта квартира
    existing = CollectionProperty.query.filter_by(
        collection_id=presentation_id,
        property_id=property_id
    ).first()
    
    if existing:
        return jsonify({'success': False, 'error': 'Квартира уже добавлена в презентацию'}), 400
    
    try:
        # Получаем информацию о квартире из JSON
        properties = load_properties()
        property_info = None
        
        for prop in properties:
            if str(prop.get('id')) == str(property_id):
                property_info = prop
                break
        
        if not property_info:
            return jsonify({'success': False, 'error': 'Квартира не найдена'}), 404
        
        # DUAL WRITE: Resolve property to get both IDs
        property_obj, canonical_id = resolve_property_by_identifier(property_id)
        if not property_obj:
            return jsonify({'success': False, 'error': 'Объект не найден в базе данных'}), 404
        
        collection_property = CollectionProperty(
            collection_id=presentation_id,
            property_id=str(property_obj.id),  # Old: database ID
            property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
            property_name=property_info.get('title', 'Квартира'),
            property_price=int(property_info.get('price', 0)) if property_info.get('price') else None,
            complex_name=property_info.get('residential_complex', ''),
            property_type=f"{property_info.get('rooms', 0)}-комнатная" if property_info.get('rooms', 0) > 0 else 'Студия',
            property_size=float(property_info.get('area', 0)) if property_info.get('area') else None,
            manager_note=manager_note,
            order_index=len(presentation.properties) + 1
        )
        
        db.session.add(collection_property)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Квартира добавлена в презентацию',
            'property': {
                'id': collection_property.id,
                'property_name': collection_property.property_name,
                'complex_name': collection_property.complex_name,
                'property_price': collection_property.property_price,
                'manager_note': collection_property.manager_note
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# НОВЫЕ API ЭНДПОИНТЫ ДЛЯ ПРЕЗЕНТАЦИЙ

@app.route('/api/manager/presentation/<int:presentation_id>/add-property', methods=['POST'])
@csrf.exempt
@manager_required
def add_property_to_presentation_fixed(presentation_id):
    """
    ✅ MIGRATED TO NORMALIZED TABLES (Property → ResidentialComplex → Developer)
    Добавить объект в презентацию (безопасная версия)
    Uses ONLY direct SQLAlchemy database queries with eager loading.
    """
    from models import Collection, CollectionProperty, Property
    from sqlalchemy.orm import joinedload
    from flask_login import current_user
    
    try:
        print(f"🎯 DEBUG: add_property_to_presentation_fixed called for presentation {presentation_id}")
        
        # 1. Validate input data
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'Данные не предоставлены'}), 400
            
        property_id = data.get('property_id')
        if not property_id:
            return jsonify({'success': False, 'error': 'ID объекта не указан'}), 400

        # Convert to int if it's a string, keep as int if already int
        try:
            property_id_int = int(property_id) if isinstance(property_id, str) else property_id
        except (ValueError, TypeError):
            return jsonify({'success': False, 'error': 'Недопустимый ID объекта'}), 400
        
        # Convert to string for VARCHAR column in CollectionProperty table
        property_id = str(property_id_int)
        
        current_manager = current_user
            
        # 2. Strict check for presentation ownership
        presentation = Collection.query.filter_by(
            id=presentation_id,
            created_by_manager_id=current_manager.id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return jsonify({'success': False, 'error': 'Презентация не найдена или у вас нет прав доступа'}), 404
        
        # 3. Check for duplicates
        existing = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=property_id
        ).first()
        
        if existing:
            return jsonify({'success': False, 'error': 'Объект уже добавлен в презентацию'}), 400
        
        # 4. Load property from database with eager loading for relationships
        property_obj = Property.query.options(
            joinedload(Property.residential_complex)
        ).get(property_id_int)
        
        print(f"🎯 DEBUG: DB lookup for property {property_id_int}, found: {property_obj is not None}")
        
        if not property_obj:
            print(f"❌ ERROR: Property {property_id_int} not found in database")
            return jsonify({'success': False, 'error': 'Объект не найден'}), 404
        
        print(f"✅ Property found in database: {property_obj.title}")
        
        # 5. Create CollectionProperty from database Property object
        # Format room type
        rooms = int(property_obj.rooms or 0)
        property_type = "Студия" if rooms == 0 else f"{rooms}-комн"
        
        # Get complex name safely (relationship already loaded via joinedload)
        complex_name = property_obj.residential_complex.name if property_obj.residential_complex else ''
        
        # Generate property name
        property_name = property_obj.title or f"{property_type} в {complex_name}"
        
        collection_property = CollectionProperty(
            collection_id=presentation_id,
            property_id=str(property_obj.id),  # Old: database ID
            property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
            property_name=property_name,
            property_price=int(property_obj.price) if property_obj.price else None,
            complex_name=complex_name,
            property_type=property_type,
            property_size=float(property_obj.area) if property_obj.area else None,
            order_index=len(presentation.properties) + 1
        )
        
        # 6. Save to database (ONCE only!)
        db.session.add(collection_property)
        db.session.commit()
        
        print(f"✅ Property {property_id_int} successfully added to presentation {presentation_id}")
        
        return jsonify({
            'success': True,
            'message': 'Объект добавлен в презентацию',
            'property': {
                'id': collection_property.id,
                'property_name': collection_property.property_name,
                'complex_name': collection_property.complex_name,
                'property_price': collection_property.property_price
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"❌ ERROR in add_property_to_presentation_fixed: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/presentation/<int:presentation_id>/property/<int:property_id>/comment', methods=['PUT'])
@csrf.exempt
@manager_required
def update_property_comment_in_presentation(presentation_id, property_id):
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    # Валидация входных данных
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': 'Данные не предоставлены'}), 400
        
    manager_note = data.get('manager_note', '').strip()
    
    current_manager = current_user
        
    # Строгая проверка владения презентацией
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_manager.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': 'Презентация не найдена или у вас нет прав доступа'}), 404    # ✅ FIXED: Use helper to resolve property by inner_id OR database ID
    property_obj, canonical_id = resolve_property_by_identifier(property_id)
    if not property_obj:
        return jsonify({'success': False, 'error': 'Объект не найден'}), 404
    
    # Search CollectionProperty using property_inner_id (canonical identifier)
    collection_property = CollectionProperty.query.filter(
        CollectionProperty.collection_id == presentation_id,
        CollectionProperty.property_inner_id == property_obj.inner_id
    ).first()
    
    if not collection_property:
        return jsonify({'success': False, 'error': 'Объект не найден в презентации'}), 404
    
    try:
        # Обновляем комментарий
        collection_property.manager_note = manager_note
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Комментарий обновлен',
            'property': {
                'id': collection_property.property_inner_id,
                'manager_note': collection_property.manager_note
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/presentation/<int:presentation_id>/status', methods=['PUT'])
@manager_required
# @require_json_csrf  # CSRF disabled
def update_presentation_status(presentation_id):
    """Переключить статус презентации между Черновик и Опубликовано"""
    from models import Collection
    from flask_login import current_user
    
    # Валидация входных данных
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': 'Данные не предоставлены'}), 400
        
    new_status = data.get('status', '').strip()
    
    # Валидация статуса
    if new_status not in ['Черновик', 'Опубликовано']:
        return jsonify({'success': False, 'error': 'Недопустимый статус'}), 400
    
    # Найти презентацию
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_user.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': 'Презентация не найдена или у вас нет прав доступа'}), 404
    
    try:
        # Обновляем статус и флаг публичности
        presentation.status = new_status
        presentation.is_public = (new_status == 'Опубликовано')
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Статус изменен на "{new_status}"',
            'status': presentation.status,
            'is_public': presentation.is_public
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

# ===== PDF AND PRINT ENDPOINTS =====

def fetch_pdf_context(property_id, presentation_id=None):
    """
    ✅ MIGRATED TO NORMALIZED SCHEMA (Property → ResidentialComplex → Developer)
    
    Fetch comprehensive context for PDF generation including:
    - Property details and images from properties table
    - Residential complex details and characteristics
    - Manager contact information
    
    FIXED: Uses SQLAlchemy text() with bindparams for SQLite compatibility
    FIXED: Added safe resource handling and division by zero protection
    MIGRATED: Uses normalized tables (properties, residential_complexes, developers)
    """
    import json
    from models import Collection, CollectionProperty, ResidentialComplex, Manager
    from sqlalchemy import text
    
    try:
        # Get property data using normalized schema with JOINs
        property_query = text("""
        SELECT p.inner_id, p.gallery_images as photos, rc.name as complex_name, p.complex_id,
               rc.object_class_display_name as complex_object_class_display_name, 
               rc.end_build_year as complex_building_end_build_year,
               rc.end_build_quarter as complex_building_end_build_quarter, 
               rc.has_big_check as complex_has_big_check,
               rc.financing_sber as complex_financing_sber, 
               rc.has_green_mortgage as complex_has_green_mortgage,
               p.rooms as object_rooms, p.area as object_area, 
               p.floor as object_min_floor, p.total_floors as object_max_floor,
               p.price, p.address as address_display_name, 
               p.latitude as address_position_lat, p.longitude as address_position_lon,
               d.name as developer_name, p.renovation_type as renovation_display_name
        FROM properties p
        LEFT JOIN residential_complexes rc ON p.complex_id = rc.id
        LEFT JOIN developers d ON p.developer_id = d.id
        WHERE p.id = :property_id
        """)
        
        # Use SQLAlchemy session with proper error handling
        result = db.session.execute(property_query, {'property_id': property_id})
        property_row = result.fetchone()
        
        if not property_row:
            return None
            
        # Convert to dictionary using _mapping for SQLAlchemy compatibility
        property_data = dict(property_row._mapping)
        
        # Parse photos JSON with safe error handling
        property_images = {'photos': [], 'plans': []}
        if property_data.get('photos'):
            try:
                photos_list = json.loads(property_data['photos'])
                if photos_list and isinstance(photos_list, list):
                    # First 6 images as main photos, 6-8 as plans (fixed logic)
                    property_images['photos'] = photos_list[:6]
                    property_images['plans'] = photos_list[6:8] if len(photos_list) > 6 else []
            except (json.JSONDecodeError, TypeError, ValueError):
                property_images['photos'] = []
                property_images['plans'] = []
        
        # Get residential complex data if available
        complex_data = {}
        complex_images = {'facade': [], 'territory': [], 'infrastructure': [], 'construction': []}
        complex_photos = []
        
        if property_data.get('complex_name'):
            try:
                # Load basic complex data from residential_complexes table
                complex_query = text("""
                SELECT name, slug, district_id, developer_id, cashback_rate,
                       object_class_display_name, start_build_year, start_build_quarter,
                       end_build_year, end_build_quarter, has_accreditation,
                       has_green_mortgage, has_big_check, with_renovation, financing_sber
                FROM residential_complexes 
                WHERE name = :complex_name
                """)
                complex_result = db.session.execute(complex_query, {'complex_name': property_data['complex_name']})
                complex_row = complex_result.fetchone()
                
                if complex_row:
                    complex_data = dict(complex_row._mapping)
                
                # Load complex photos from properties table using complex_id
                photos_query = text("""
                SELECT gallery_images AS photos FROM properties 
                WHERE complex_id = (SELECT id FROM residential_complexes WHERE name = :complex_name LIMIT 1) 
                AND gallery_images IS NOT NULL
                LIMIT 1
                """)
                photos_result = db.session.execute(photos_query, {'complex_name': property_data['complex_name']})
                photos_row = photos_result.fetchone()
                
                if photos_row and photos_row[0]:
                    try:
                        photos_data = json.loads(photos_row[0])
                        if isinstance(photos_data, list):
                            complex_photos = photos_data[:9]  # Take first 9 photos for 3x3 grid
                        elif isinstance(photos_data, dict):
                            # If photos are organized by categories  
                            all_photos = []
                            for category, photos_list in photos_data.items():
                                if isinstance(photos_list, list):
                                    all_photos.extend(photos_list)
                            complex_photos = all_photos[:9]  # Take first 9 photos for 3x3 grid
                    except (json.JSONDecodeError, TypeError):
                        complex_photos = []
                        
            except Exception as e:
                print(f"Error loading complex data: {e}")
        
        # Get manager information if presentation_id provided
        manager_data = {}
        if presentation_id:
            try:
                presentation = Collection.query.get(presentation_id)
                if presentation and presentation.created_by_manager_id:
                    manager = Manager.query.get(presentation.created_by_manager_id)
                    if manager:
                        manager_data = {
                            'name': manager.full_name or 'Менеджер',
                            'email': manager.email or '',
                            'phone': manager.phone or '+7 (XXX) XXX-XX-XX',
                            'photo_url': None  # Add if available
                        }
            except Exception as e:
                print(f"Error loading manager data: {e}")
        
        # Safe type conversion with defaults (using corrected column names)
        area = float(property_data.get('object_area') or 0)
        price = int(property_data.get('price') or 0)  # Fixed column name
        rooms = int(property_data.get('object_rooms') or 0)
        floor = int(property_data.get('object_min_floor') or 0)  # Fixed column name
        total_floors = int(property_data.get('object_max_floor') or 0)
        
        # Calculate price per sqm with division by zero protection
        price_per_sqm = 0
        if area > 0 and price > 0:
            try:
                price_per_sqm = int(price / area)
            except (ZeroDivisionError, ValueError):
                price_per_sqm = 0
        
        # Get cashback from complex data (loaded from residential_complexes table)
        cashback_rate = complex_data.get('cashback_rate', 5.0) if complex_data else 5.0
        cashback_amount = int(price * cashback_rate / 100) if price > 0 else 0
        
        # Construct full context with safe data types
        context = {
            'property': {
                'id': property_data.get('inner_id'),
                'rooms': rooms,
                'area': area,
                'floor': floor,
                'total_floors': total_floors,
                'price': price,
                'price_per_sqm': price_per_sqm,
                'finishing': property_data.get('renovation_display_name') or 'Не указан',
                'status': 'Активен',  # Default since column doesn't exist
                'address': property_data.get('address_display_name') or 'Адрес уточняется',
                'cashback_percent': cashback_rate,
                'cashback_amount': cashback_amount,
                'latitude': property_data.get('address_position_lat'),
                'longitude': property_data.get('address_position_lon'),
                'object_type': 'Квартира',  # Default since column doesn't exist
                'developer_name': property_data.get('developer_name') or '',
                'jk_name': property_data.get('complex_name') or '',
                'property_type': 'Квартира',  # Default since column doesn't exist
                'completion_date': None  # Will be set from complex data if available
            },
            'property_images': property_images,
            'complex': {
                'id': property_data.get('complex_id'),
                'name': property_data.get('complex_name') or '',
                'class': property_data.get('complex_object_class_display_name') or '',
                'completion_year': property_data.get('complex_building_end_build_year'),
                'completion_quarter': property_data.get('complex_building_end_build_quarter'),
                'has_big_check': bool(property_data.get('complex_has_big_check')),
                'financing_sber': bool(property_data.get('complex_financing_sber')),
                'has_green_mortgage': bool(property_data.get('complex_has_green_mortgage')),
                'developer': property_data.get('developer_name') or '',
                'photos': complex_photos,  # Added complex photos from database
                'features': []
            },
            'complex_images': complex_images,
            'manager': manager_data,
            'generated_at': property_data  # Full raw data for backwards compatibility
        }
        
        # Add completion date to property if available
        if context['complex']['completion_quarter'] and context['complex']['completion_year']:
            context['property']['completion_date'] = f"{context['complex']['completion_quarter']} кв. {context['complex']['completion_year']} г."
        
        # Add complex features list with safe checks
        features = []
        if complex_data.get('has_accreditation'):
            features.append('Аккредитован банками')
        if complex_data.get('has_green_mortgage') or property_data.get('complex_has_green_mortgage'):
            features.append('Льготная ипотека')  
        if complex_data.get('with_renovation'):
            features.append('С отделкой')
        if complex_data.get('financing_sber') or property_data.get('complex_financing_sber'):
            features.append('Финансирование Сбербанк')
        if complex_data.get('has_big_check') or property_data.get('complex_has_big_check'):
            features.append('Большой чек')
        
        context['complex']['features'] = features
        
        return context
        
    except Exception as e:
        print(f"Error in fetch_pdf_context: {e}")
        import traceback
        traceback.print_exc()
        return None

@app.route('/api/presentation/<int:presentation_id>/property/<string:property_id>/print')
@manager_required
def print_property(presentation_id, property_id):
    """Открыть версию объекта для печати с полными данными из базы"""
    from models import Collection, CollectionProperty, Property as PropertyModel
    
    # Find presentation
    presentation = Collection.query.get_or_404(presentation_id)
    
    # Resolve property identifier (could be inner_id or database ID)
    prop_obj, canonical_id = resolve_property_by_identifier(property_id)
    if not prop_obj:
        abort(404, description="Объект не найден")
    
    # Search in CollectionProperty using property_inner_id (canonical identifier)
    property_obj = CollectionProperty.query.filter(
        CollectionProperty.collection_id == presentation_id,
        CollectionProperty.property_inner_id == prop_obj.inner_id
    ).first()
    
    if not property_obj:
        return "Property not found in presentation", 404
    
    # Get comprehensive context using new function
    context = fetch_pdf_context(property_id, presentation_id)
    
    if not context:
        return "Property data not found", 404
    
    # Render print template with full context
    return render_template('print_property.html', 
                         property=context['property'],
                         property_images=context['property_images'],
                         complex=context['complex'],
                         complex_images=context['complex_images'],
                         manager=context['manager'],
                         presentation=presentation,
                         manager_note=getattr(property_obj, 'manager_note', None),
                         context=context)  # Full context for backwards compatibility

@app.route('/api/presentation/<int:presentation_id>/property/<string:property_id>/download')
@manager_required
def download_presentation_property_pdf(presentation_id, property_id):
    """Скачать объект в PDF формате"""
    from models import Collection, CollectionProperty
    from weasyprint import HTML, CSS
    from io import BytesIO
    import tempfile
    import os
    
    try:
        # Find presentation and property
        presentation = Collection.query.get_or_404(presentation_id)
        
        # ✅ FIXED: property_id is database ID, convert to inner_id
        from models import Property as PropertyModel
        try:
            property_id_int = int(property_id)
            property_model = PropertyModel.query.get(property_id_int)
            if not property_model:
                return "Property not found", 404
            inner_id_str = str(property_model.inner_id)
        except (ValueError, TypeError):
            # Fallback: assume it's inner_id
            inner_id_str = str(property_id)
        
        property_obj = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=inner_id_str
        ).first()
        
        if not property_obj:
            return "Property not found in presentation", 404
        
        # Get comprehensive context using new function (with inner_id)
        context = fetch_pdf_context(inner_id_str, presentation_id)
        
        if not context:
            return "Property data not found", 404
        
        # Render HTML for PDF with full context
        html_content = render_template('print_property.html', 
                                     property=context['property'],
                                     property_images=context['property_images'],
                                     complex=context['complex'],
                                     complex_images=context['complex_images'],
                                     manager=context['manager'],
                                     presentation=presentation,
                                     manager_note=property_obj.manager_note,
                                     context=context,
                                     for_pdf=True)
        
        # Generate PDF
        pdf_buffer = BytesIO()
        HTML(string=html_content, base_url=request.host_url).write_pdf(pdf_buffer)
        pdf_buffer.seek(0)
        
        return send_file(
            pdf_buffer,
            as_attachment=True,
            download_name=f'property_{property_id}.pdf',
            mimetype='application/pdf'
        )
        
    except Exception as e:
        print(f"Error generating PDF: {e}")
        return f"Error generating PDF: {str(e)}", 500

@app.route('/api/manager/presentation/<int:presentation_id>/download-all')
@manager_required
def download_all_properties(presentation_id):
    """Скачать все объекты презентации в ZIP архиве"""
    from models import Collection, CollectionProperty
    from weasyprint import HTML, CSS
    import zipfile
    from io import BytesIO
    import tempfile
    
    try:
        # Find presentation
        presentation = Collection.query.get_or_404(presentation_id)
        
        # Check ownership
        current_manager = current_user
        if presentation.created_by_manager_id != current_manager.id:
            return jsonify({'success': False, 'error': 'Access denied'}), 403
        
        # Get all properties in presentation
        properties = CollectionProperty.query.filter_by(
            collection_id=presentation_id
        ).all()
        
        print(f"DEBUG: Found {len(properties)} properties in presentation {presentation_id}")
        for prop in properties:
            print(f"DEBUG: Property ID: {prop.property_id}")
        
        if not properties:
            return jsonify({'success': False, 'error': 'No properties in presentation'}), 400
        
        # Create ZIP archive
        zip_buffer = BytesIO()
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for prop in properties:
                # Get property details from database using raw SQL for compatibility
                try:
                    query = text("""
                        SELECT 
                            p.inner_id AS id,
                            CAST(p.area AS FLOAT) AS area,
                            CAST(p.price AS INTEGER) AS price,
                            CAST(p.floor AS INTEGER) AS floor,
                            CAST(p.total_floors AS INTEGER) AS total_floors,
                            CAST(p.rooms AS INTEGER) AS rooms,
                            'Квартира' AS property_type,
                            p.address AS address_display_name,
                            rc.name AS jk_name,
                            d.name AS developer_name,
                            NULL AS completion_date
                        FROM properties p
                        LEFT JOIN residential_complexes rc ON p.complex_id = rc.id
                        LEFT JOIN developers d ON p.developer_id = d.id
                        WHERE p.id = :prop_id
                    """)
                    
                    # Convert property_id to int for inner_id lookup
                    try:
                        prop_id_int = int(prop.property_id)
                    except ValueError:
                        print(f"Invalid property ID format: {prop.property_id}")
                        continue
                        
                    result = db.session.execute(query, {'prop_id': prop_id_int}).fetchone()
                    
                    if not result:
                        print(f"Property {prop.property_id} not found in database")
                        continue  # Skip if property not found
                        
                    # Convert row to object and compute safe values
                    from types import SimpleNamespace
                    row_dict = dict(result._mapping)
                    
                    # Ensure safe types and compute price per sqm
                    row_dict['price'] = int(row_dict['price'] or 0)
                    row_dict['area'] = float(row_dict['area'] or 0)
                    row_dict['rooms'] = int(row_dict['rooms'] or 0)
                    
                    # Compute price per sqm safely
                    if row_dict['area'] and row_dict['area'] > 0:
                        row_dict['price_per_sqm'] = int(row_dict['price'] / row_dict['area'])
                    else:
                        row_dict['price_per_sqm'] = 0
                        
                    property_item = SimpleNamespace(**row_dict)
                    property_data = [property_item]
                except Exception as e:
                    print(f"Database error for property {prop.property_id}: {e}")
                    continue
                
                if property_data:
                    property_item = property_data[0]
                    
                    # Use fetch_pdf_context to get all necessary data
                    context = fetch_pdf_context(prop.property_id, presentation_id)
                    if not context:
                        print(f"Failed to get context for property {prop.property_id}")
                        continue
                    
                    # Generate HTML for PDF with complete context
                    html_content = render_template('print_property.html', 
                                                 property=context['property'],
                                                 property_images=context['property_images'],
                                                 complex=context['complex'],
                                                 complex_images=context['complex_images'],
                                                 manager=context['manager'],
                                                 presentation=presentation,
                                                 manager_note=getattr(prop, 'manager_note', None),
                                                 context=context,
                                                 for_pdf=True)
                    
                    # Generate PDF
                    pdf_buffer = BytesIO()
                    HTML(string=html_content, base_url=request.host_url).write_pdf(pdf_buffer)
                    
                    # Add to ZIP
                    filename = f'property_{prop.property_id}.pdf'
                    zip_file.writestr(filename, pdf_buffer.getvalue())
                    print(f"DEBUG: Added {filename} to ZIP (size: {len(pdf_buffer.getvalue())} bytes)")
        
        zip_buffer.seek(0)
        print(f"DEBUG: ZIP created with total size: {len(zip_buffer.getvalue())} bytes")
        
        return send_file(
            zip_buffer,
            as_attachment=True,
            download_name=f'presentation_{presentation_id}_all_properties.zip',
            mimetype='application/zip'
        )
        
    except Exception as e:
        print(f"Error creating ZIP: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# REMOVED: This function runs in executor, NOT as a Flask route
def generate_pdf_archive_background(unique_id, base_url):
    """Background task to generate PDF archive"""
    # CRITICAL: Must run within Flask application context to access database
    with app.app_context():
        try:
            from models import Collection, CollectionProperty
            import zipfile
            from weasyprint import HTML
            from io import BytesIO
            
            # Find presentation
            presentation = Collection.query.filter_by(
                unique_url=unique_id,
                collection_type='presentation'
            ).first()
            
            if not presentation:
                progress_storage[f"presentation_{unique_id}"] = {
                    'stage': 'error',
                    'progress': 0,
                    'message': 'Презентация не найдена'
                }
                return
            
            # Get properties with eager loading
            properties_data = CollectionProperty.query.filter_by(
                collection_id=presentation.id
            ).all()
            
            if not properties_data:
                progress_storage[f"presentation_{unique_id}"] = {
                    'stage': 'error',
                    'progress': 0,
                    'message': 'Нет объектов в презентации'
                }
                return
            
            total = len(properties_data)
            progress_storage[f"presentation_{unique_id}"] = {
                'stage': 'starting',
                'progress': 0,
                'current': 0,
                'total': total,
                'message': f'Начинаем создание {total} PDF файлов...'
            }
            
            print(f"DEBUG: Background task started for {total} properties")
            
            # Create temporary ZIP file
            zip_filename = f"presentation_{unique_id}_{int(time.time())}.zip"
            zip_path = os.path.join(TEMP_DOWNLOAD_DIR, zip_filename)
            
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for idx, cp in enumerate(properties_data, 1):
                    # Update progress
                    progress_pct = int((idx / total) * 90)  # 0-90% for PDF generation
                    progress_storage[f"presentation_{unique_id}"] = {
                        'stage': 'processing',
                        'progress': progress_pct,
                        'current': idx,
                        'total': total,
                        'message': f'Создаю PDF {idx} из {total}'
                    }
                    
                    # Use fetch_pdf_context to get all necessary data (same as download_all_properties_public)
                    context = fetch_pdf_context(cp.property_id, presentation.id)
                    if not context:
                        print(f"DEBUG: Failed to get context for property {cp.property_id}")
                        continue
                    
                    # Generate HTML for PDF with complete context (same template as download_all_properties_public)
                    html_content = render_template('print_property.html', 
                                                 property=context['property'],
                                                 property_images=context['property_images'],
                                                 complex=context['complex'],
                                                 complex_images=context['complex_images'],
                                                 manager=context['manager'],
                                                 presentation=presentation,
                                                 manager_note=getattr(cp, 'manager_note', None),
                                                 context=context,
                                                 for_pdf=True)
                    
                    # Generate PDF
                    pdf_buffer = BytesIO()
                    HTML(string=html_content, base_url=base_url).write_pdf(pdf_buffer)
                    
                    # Add to ZIP
                    pdf_filename = f"property_{cp.property_id}.pdf"
                    zipf.writestr(pdf_filename, pdf_buffer.getvalue())
                    
                    print(f"DEBUG: Added {pdf_filename} to ZIP (size: {len(pdf_buffer.getvalue())} bytes)")
            
            # Final progress
            progress_storage[f"presentation_{unique_id}"] = {
                'stage': 'complete',
                'progress': 100,
                'current': total,
                'total': total,
                'message': 'Архив готов!'
            }
            
            # Store file path
            file_storage[unique_id] = {
                'path': zip_path,
                'created_at': time.time()
            }
            
            print(f"DEBUG: ZIP created successfully: {zip_path}")
            
        except Exception as e:
            import traceback
            print(f"ERROR in background task: {str(e)}")
            traceback.print_exc()
            progress_storage[f"presentation_{unique_id}"] = {
                'stage': 'error',
                'progress': 0,
                'message': f'Ошибка: {str(e)}'
            }

@app.route('/presentation/view/<string:unique_id>/download-all')
def download_all_properties_public(unique_id):
    """Публичное скачивание всех объектов презентации в ZIP архиве"""
    from models import Collection, CollectionProperty
    from weasyprint import HTML, CSS
    import zipfile
    from io import BytesIO
    import tempfile
    
    try:
        # Find presentation by unique_id instead of presentation_id
        presentation = Collection.query.filter_by(
            unique_url=unique_id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return "Презентация не найдена", 404
        
        # Get all properties in presentation
        properties = CollectionProperty.query.filter_by(
            collection_id=presentation.id
        ).all()
        
        print(f"DEBUG: Found {len(properties)} properties in presentation {presentation.id}")
        for prop in properties:
            print(f"DEBUG: Property ID: {prop.property_id}")
        
        if not properties:
            return "Нет объектов в презентации", 400
        
        # Initialize progress tracking
        progress_key = f"presentation_{unique_id}"
        total_properties = len(properties)
        
        # Initialize progress at 0%
        progress_storage[progress_key] = {
            'stage': 'processing',
            'progress': 0,
            'current': 0,
            'total': total_properties,
            'message': f'Начинаю создание PDF файлов...'
        }
        print(f"DEBUG: Initialized progress for {total_properties} properties")
        
        # Create ZIP archive with real progress tracking
        zip_buffer = BytesIO()
        
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for current_index, prop in enumerate(properties, 1):
                # Update progress
                # progress = int((current_index / total_properties) * 90)  # Reserve 90-100% for finalization
                # progress_storage[progress_key] = {
                # 'stage': 'processing',
                # 'progress': progress,
                # 'current': current_index,
                # 'total': total_properties,
                # 'message': f'Создаю PDF для квартиры {current_index} из {total_properties}...'
                # }
                
                # Get property details from database using raw SQL for compatibility
                try:
                    query = text("""
                        SELECT 
                            p.inner_id AS id,
                            CAST(p.area AS FLOAT) AS area,
                            CAST(p.price AS INTEGER) AS price,
                            CAST(p.floor AS INTEGER) AS floor,
                            CAST(p.total_floors AS INTEGER) AS total_floors,
                            CAST(p.rooms AS INTEGER) AS rooms,
                            'Квартира' AS property_type,
                            p.address AS address_display_name,
                            rc.name AS jk_name,
                            d.name AS developer_name,
                            NULL AS completion_date
                        FROM properties p
                        LEFT JOIN residential_complexes rc ON p.complex_id = rc.id
                        LEFT JOIN developers d ON p.developer_id = d.id
                        WHERE p.id = :prop_id
                    """)
                    
                    # Convert property_id to int for inner_id lookup
                    try:
                        prop_id_int = int(prop.property_id)
                    except ValueError:
                        print(f"Invalid property ID format: {prop.property_id}")
                        continue
                        
                    result = db.session.execute(query, {'prop_id': prop_id_int}).fetchone()
                    
                    if not result:
                        print(f"Property {prop.property_id} not found in database")
                        continue  # Skip if property not found
                        
                    # Convert row to object and compute safe values
                    from types import SimpleNamespace
                    row_dict = dict(result._mapping)
                    
                    # Ensure safe types and compute price per sqm
                    row_dict['price'] = int(row_dict['price'] or 0)
                    row_dict['area'] = float(row_dict['area'] or 0)
                    row_dict['rooms'] = int(row_dict['rooms'] or 0)
                    
                    # Compute price per sqm safely
                    if row_dict['area'] and row_dict['area'] > 0:
                        row_dict['price_per_sqm'] = int(row_dict['price'] / row_dict['area'])
                    else:
                        row_dict['price_per_sqm'] = 0
                        
                    property_item = SimpleNamespace(**row_dict)
                    property_data = [property_item]
                except Exception as e:
                    print(f"Database error for property {prop.property_id}: {e}")
                    continue
                
                if property_data:
                    property_item = property_data[0]
                    
                    # Use fetch_pdf_context to get all necessary data
                    context = fetch_pdf_context(prop.property_id, presentation.id)
                    if not context:
                        print(f"Failed to get context for property {prop.property_id}")
                        continue
                    
                    # Generate HTML for PDF with complete context
                    html_content = render_template('print_property.html', 
                                                 property=context['property'],
                                                 property_images=context['property_images'],
                                                 complex=context['complex'],
                                                 complex_images=context['complex_images'],
                                                 manager=context['manager'],
                                                 presentation=presentation,
                                                 manager_note=getattr(prop, 'manager_note', None),
                                                 context=context,
                                                 for_pdf=True)
                    
                    # Generate PDF
                    pdf_buffer = BytesIO()
                    HTML(string=html_content, base_url=request.host_url).write_pdf(pdf_buffer)
                    
                    # Add to ZIP
                    filename = f'property_{prop.property_id}.pdf'
                    zip_file.writestr(filename, pdf_buffer.getvalue())
                    print(f"DEBUG: Added {filename} to ZIP (size: {len(pdf_buffer.getvalue())} bytes)")
                    
                    # Update progress after each PDF is created
                    progress_percent = int((current_index / total_properties) * 90)  # Reserve 90-100% for finalization
                    progress_storage[progress_key] = {
                        'stage': 'processing',
                        'progress': progress_percent,
                        'current': current_index,
                        'total': total_properties,
                        'message': f'Создаю PDF {current_index} из {total_properties}'
                    }
                    print(f"DEBUG: Progress update: {progress_percent}% ({current_index}/{total_properties})")
        
        # Final progress - creating archive
        progress_storage[progress_key] = {
            'stage': 'completing',
            'progress': 90,
            'message': 'Создаю архив...'
        }
        
        zip_buffer.seek(0)
        print(f"DEBUG: ZIP created with total size: {len(zip_buffer.getvalue())} bytes")
        
        # Mark as complete
        progress_storage[progress_key] = {
            'stage': 'complete',
            'progress': 100,
            'message': 'Готово! Скачивание началось.'
        }
        
        return send_file(
            zip_buffer,
            as_attachment=True,
            download_name=f'presentation_{presentation.title.replace(" ", "_")}_all_properties.zip',
            mimetype='application/zip'
        )
        
    except Exception as e:
        print(f"Error creating ZIP: {e}")
        
        # Update progress with error
        progress_key = f"presentation_{unique_id}"
        progress_storage[progress_key] = {
            'stage': 'error',
            'progress': 0,
            'message': f'Ошибка при создании архива: {str(e)}'
        }
        
        return f"Ошибка при создании архива: {str(e)}", 500

# Global progress storage for tracking real-time PDF generation
progress_storage = {}

# Temporary ZIP file storage system
TEMP_DOWNLOAD_DIR = '/tmp/presentation_downloads'
os.makedirs(TEMP_DOWNLOAD_DIR, exist_ok=True)

# Storage for file paths keyed by unique_id
file_storage = {}  # Format: {unique_id: {'path': '/tmp/...zip', 'created_at': timestamp}}

# Thread pool for background PDF generation
pdf_executor = ThreadPoolExecutor(max_workers=3, thread_name_prefix='pdf_gen')

def cleanup_old_files():
    """Remove ZIP files older than 1 hour"""
    try:
        now = time.time()
        for filepath in glob.glob(f"{TEMP_DOWNLOAD_DIR}/*.zip"):
            if os.path.exists(filepath):
                file_age = now - os.path.getmtime(filepath)
                if file_age > 3600:  # 1 hour
                    os.remove(filepath)
                    print(f"Cleaned up old file: {filepath}")
    except Exception as e:
        print(f"Error during cleanup: {e}")

# Schedule cleanup on startup and every 30 minutes
atexit.register(cleanup_old_files)

@app.route('/presentation/view/<string:unique_id>/progress')
def download_progress_stream(unique_id):
    """SSE endpoint для отслеживания реального прогресса создания PDF файлов"""
    from flask import Response
    import json
    import time
    from models import Collection, CollectionProperty
    
    try:
        # Find presentation by unique_id
        presentation = Collection.query.filter_by(
            unique_url=unique_id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            def error_stream():
                yield f"data: {json.dumps({'error': 'Презентация не найдена'})}\n\n"
            return Response(
                error_stream(),
                content_type='text/event-stream',
                headers={
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Connection': 'keep-alive',
                    'X-Accel-Buffering': 'no'
                }
            )
        
        # Get properties count
        properties = CollectionProperty.query.filter_by(
            collection_id=presentation.id
        ).all()
        
        if not properties:
            def error_stream():
                yield f"data: {json.dumps({'error': 'Нет объектов в презентации'})}\n\n"
            return Response(
                error_stream(),
                content_type='text/event-stream',
                headers={
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Connection': 'keep-alive',
                    'X-Accel-Buffering': 'no'
                }
            )
            
        def progress_generator():
            try:
                total = len(properties)
                progress_key = f"presentation_{unique_id}"
                
                # Initialize progress
                progress_storage[progress_key] = {
                    'stage': 'starting',
                    'progress': 0,
                    'current': 0,
                    'total': total,
                    'message': 'Начинаю создание PDF файлов...'
                }
                
                # Начальное сообщение
                yield f"data: {json.dumps(progress_storage[progress_key])}\n\n"
                time.sleep(1)
                
                # Wait for real progress updates from download endpoint
                last_progress = 0
                timeout_counter = 0
                
                while True:
                    if progress_key in progress_storage:
                        current_progress = progress_storage[progress_key]
                        
                        # Only send updates when progress changes
                        if current_progress['progress'] != last_progress or current_progress['stage'] != 'processing':
                            yield f"data: {json.dumps(current_progress)}\n\n"
                            last_progress = current_progress['progress']
                        
                        # Check if completed
                        if current_progress['stage'] == 'complete':
                            break
                            
                        # Check if error occurred
                        if current_progress['stage'] == 'error':
                            break
                    
                    time.sleep(0.5)
                    timeout_counter += 1
                    
                    # Timeout after 2 minutes
                    if timeout_counter > 240:
                        progress_storage[progress_key] = {
                            'stage': 'error',
                            'message': 'Превышено время ожидания',
                            'progress': 0
                        }
                        yield f"data: {json.dumps(progress_storage[progress_key])}\n\n"
                        break
                
                # Cleanup
                if progress_key in progress_storage:
                    del progress_storage[progress_key]
                    
            except Exception as e:
                yield f"data: {json.dumps({'error': f'Ошибка: {str(e)}'})}\n\n"
        
        return Response(
            progress_generator(),
            content_type='text/event-stream',
            headers={
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'Pragma': 'no-cache',
                'Expires': '0',
                'Connection': 'keep-alive',
                'X-Accel-Buffering': 'no',  # Disable nginx buffering
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Headers': 'Cache-Control',
                'Content-Type': 'text/event-stream; charset=utf-8'
            }
        )
        
    except Exception as e:
        def error_stream():
            yield f"data: {json.dumps({'error': f'Ошибка сервера: {str(e)}'})}\n\n"
        return Response(error_stream(), content_type='text/plain')


@app.route('/presentation/view/<string:unique_id>/progress-poll')

def poll_pdf_progress(unique_id):
    """Poll progress of background PDF generation"""
    try:
        progress_key = f"presentation_{unique_id}"
        
        if progress_key in progress_storage:
            return jsonify(progress_storage[progress_key])
        else:
            # No progress yet - task might not be started
            return jsonify({
                'status': 'pending',
                'progress': 0,
                'message': 'Ожидание запуска...'
            })
    except Exception as e:
        return jsonify({
            'status': 'error',
            'progress': 0,
            'message': str(e)
        }), 500

@app.route('/presentation/view/<string:unique_id>/start-generation', methods=['POST'])
def start_pdf_generation(unique_id):
    """Start background PDF generation task"""
    try:
        # Validate presentation exists
        from models import Collection
        presentation = Collection.query.filter_by(
            unique_url=unique_id,
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return jsonify({'error': 'Презентация не найдена'}), 404
        
        # Submit background task
        # Capture base_url from request context before submitting to executor
        base_url = request.url_root
        pdf_executor.submit(generate_pdf_archive_background, unique_id, base_url)
        
        return jsonify({
            'success': True,
            'message': 'Генерация запущена'
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/presentation/view/<string:unique_id>/download-result')
def download_pdf_result(unique_id):
    """Download the generated ZIP file"""
    try:
        # Check if file exists in storage
        if unique_id not in file_storage:
            return "Файл не найден или еще не готов", 404
        
        file_info = file_storage[unique_id]
        zip_path = file_info['path']
        
        if not os.path.exists(zip_path):
            return "Файл был удален", 404
        
        # Send file and clean up
        response = send_file(
            zip_path,
            as_attachment=True,
            download_name=f'presentation_{unique_id}.zip',
            mimetype='application/zip'
        )
        
        # Schedule cleanup (remove from storage after sending)
        def cleanup_after_send():
            time.sleep(5)  # Wait for download to start
            if unique_id in file_storage:
                del file_storage[unique_id]
            if os.path.exists(zip_path):
                os.remove(zip_path)
        
        threading.Thread(target=cleanup_after_send, daemon=True).start()
        
        return response
        
    except Exception as e:
        return f"Ошибка при скачивании: {str(e)}", 500
def download_progress_poll(unique_id):
    """Polling endpoint for PDF generation progress (replaces SSE)"""
    from flask import jsonify
    
    progress_key = f"presentation_{unique_id}"
    
    if progress_key in progress_storage:
        return jsonify(progress_storage[progress_key])
    else:
        # No progress yet or already completed
        return jsonify({
            'stage': 'waiting',
            'progress': 0,
            'message': 'Ожидание...'
        })

@app.route('/api/manager/presentation/<int:presentation_id>/send-email', methods=['POST'])
@manager_required
# @require_json_csrf  # CSRF disabled
def send_presentation_email(presentation_id):
    """Отправить презентацию на email"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    import smtplib
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText
    from email.mime.base import MIMEBase
    from email import encoders
    
    try:
        data = request.get_json()
        if not data or not data.get('email'):
            return jsonify({'success': False, 'error': 'Email не указан'}), 400
        
        email = data['email']
        
        # Find presentation
        presentation = Collection.query.get_or_404(presentation_id)
        
        # Check ownership
        current_manager = current_user
        if presentation.created_by_manager_id != current_manager.id:
            return jsonify({'success': False, 'error': 'Access denied'}), 403
        
        # Get properties count
        properties_count = CollectionProperty.query.filter_by(
            collection_id=presentation_id
        ).count()
        
        # Create simple email (without attachments for now)
        msg = MIMEMultipart()
        msg['From'] = "noreply@inback.ru"
        msg['To'] = email
        msg['Subject'] = f"Презентация недвижимости от InBack - {presentation.name}"
        
        # Email body
        body = f"""
        Здравствуйте!
        
        Высылаем вам подобранную презентацию недвижимости "{presentation.name}".
        
        Количество объектов: {properties_count}
        
        Чтобы посмотреть презентацию, перейдите по ссылке:
        {request.host_url}manager/presentation/{presentation_id}
        
        С уважением,
        Команда InBack
        """
        
        msg.attach(MIMEText(body, 'plain', 'utf-8'))
        
        # Send email (simplified version - would need real SMTP config)
        print(f"EMAIL SENT TO: {email}")
        print(f"EMAIL BODY: {body}")
        
        return jsonify({
            'success': True,
            'message': 'Презентация отправлена на email'
        })
        
    except Exception as e:
        print(f"Error sending email: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/presentation/<int:presentation_id>/add-complex', methods=['POST'])
@csrf.exempt
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def add_complex_to_presentation(presentation_id):
    """Добавить ЖК в презентацию (безопасная версия)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    # Валидация входных данных
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': 'Данные не предоставлены'}), 400
        
    complex_id = data.get('complex_id')
    if not complex_id:
        return jsonify({'success': False, 'error': 'ID ЖК не указан'}), 400
    
    # Get current manager
    current_manager = current_user
        
    # Строгая проверка владения презентацией
    presentation = Collection.query.filter_by(
        id=presentation_id,
        created_by_manager_id=current_manager.id,
        collection_type='presentation'
    ).first()
    
    if not presentation:
        return jsonify({'success': False, 'error': 'Презентация не найдена или у вас нет прав доступа'}), 404
    
    try:
        # Получаем все объекты из ЖК
        properties = load_properties()
        complex_properties = []
        
        for prop in properties:
            if str(prop.get('complex_id')) == str(complex_id):
                complex_properties.append(prop)
        
        if not complex_properties:
            return jsonify({'success': False, 'error': 'ЖК не найден или в нем нет объектов'}), 404
        
        added_count = 0
        for prop in complex_properties[:5]:  # Добавляем максимум 5 объектов из ЖК
            property_id = prop.get('ID')
            
            # Проверяем, не добавлен ли уже этот объект
            existing = CollectionProperty.query.filter_by(
                collection_id=presentation_id,
                property_id=property_id
            ).first()
            
            if not existing:
                # DUAL WRITE: Resolve property to get both IDs
                property_obj, canonical_id = resolve_property_by_identifier(property_id)
                if not property_obj:
                    continue  # Skip if property not found
                
                collection_property = CollectionProperty(
                    collection_id=presentation_id,
                    property_id=str(property_obj.id),  # Old: database ID
                    property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
                    property_name=f"{prop.get('Type', '')} в {prop.get('Complex', '')}",
                    property_price=int(prop.get('Price', 0)) if prop.get('Price') else None,
                    complex_name=prop.get('Complex', ''),
                    property_type=prop.get('Type', ''),
                    property_size=float(prop.get('Size', 0)) if prop.get('Size') else None,
                    order_index=len(presentation.properties) + added_count + 1
                )
                
                db.session.add(collection_property)
                added_count += 1
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Добавлено {added_count} объектов из ЖК в презентацию',
            'added_count': added_count
        })
        
    except Exception as e:
        db.session.rollback()
@app.route('/api/manager/presentation/create-with-property', methods=['POST'])
@csrf.exempt
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def create_presentation_with_property():
    """Создать презентацию и сразу добавить объект (безопасная версия)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    print(f"🎯 DEBUG: create_presentation_with_property called")
    # Валидация входных данных
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': 'Данные не предоставлены'}), 400
    print(f"🎯 DEBUG: Got data: {data}")
        
    title = data.get('title', '').strip()
    client_name = data.get('client_name', '').strip()
    property_id = data.get('property_id')
    
    # Строгая валидация обязательных полей
    if not title:
        return jsonify({'success': False, 'error': 'Название презентации обязательно'}), 400
    if not property_id:
        return jsonify({'success': False, 'error': 'ID объекта обязателен'}), 400
    
    
    # Convert to int if it's a string, keep as int if already int
    try:
        property_id_int = int(property_id) if isinstance(property_id, str) else property_id
        property_id = str(property_id_int)  # Convert to string for VARCHAR column
    except (ValueError, TypeError):
        return jsonify({'success': False, 'error': 'Недопустимый ID объекта'}), 400

    try:
        # Get current manager
        current_manager = current_user
        print(f"🎯 DEBUG: current_manager set to {current_manager}")
            
        # Создаем презентацию
        presentation = Collection(
            title=title,
            created_by_manager_id=current_manager.id,
            collection_type='presentation',
            client_name=client_name,
            status='Черновик'
        )
        print(f"🎯 DEBUG: presentation object created")
        
        presentation.generate_unique_url()
        print(f"🎯 DEBUG: unique URL generated")
        db.session.add(presentation)
        print(f"🎯 DEBUG: presentation added to session")
        db.session.flush()  # Получаем ID презентации
        print(f"🎯 DEBUG: flushed, presentation ID: {presentation.id}")
        
        # Добавляем объект - direct DB query instead of Excel cache
        from models import Property
        property_obj = Property.query.get(property_id_int)
        
        if not property_obj:
            print(f"🎯 DEBUG: Property {property_id} not found in database")
            return jsonify({'success': False, 'error': 'Объект не найден'}), 404
        
        print(f"🎯 DEBUG: property_obj found: {property_obj}")
        
        collection_property = CollectionProperty(
            collection_id=presentation.id,
            property_id=str(property_obj.id),  # Old: database ID
            property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
            property_name=property_obj.title or f"{property_obj.rooms}-комн в {property_obj.residential_complex.name if property_obj.residential_complex else ''}",
            property_price=property_obj.price,
            complex_name=property_obj.residential_complex.name if property_obj.residential_complex else '',
            property_type=f"{property_obj.rooms}-комн" if property_obj.rooms else "Студия",
            property_size=property_obj.area,
            order_index=1
        )
        print(f"🎯 DEBUG: collection_property created")
        
        db.session.add(collection_property)
        print(f"🎯 DEBUG: about to commit")
        db.session.commit()
        print(f"🎯 DEBUG: committed successfully")
        
        return jsonify({
            'success': True,
            'presentation': presentation.to_dict(),
            'message': 'Презентация создана и объект добавлен'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400
@app.route('/api/manager/presentation/create-with-complex', methods=['POST'])
@csrf.exempt
@manager_required
# # @require_json_csrf  # CSRF disabled  # CSRF disabled
def create_presentation_with_complex():
    """Создать презентацию и сразу добавить ЖК (безопасная версия)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    # Валидация входных данных
    data = request.get_json()
    if not data:
        return jsonify({'success': False, 'error': 'Данные не предоставлены'}), 400
        
    title = data.get('title', '').strip()
    client_name = data.get('client_name', '').strip()
    complex_id = data.get('complex_id')
    
    # Строгая валидация обязательных полей
    if not title:
        return jsonify({'success': False, 'error': 'Название презентации обязательно'}), 400
    if not complex_id:
        return jsonify({'success': False, 'error': 'ID ЖК обязателен'}), 400
    
    try:
        # Get current manager
        current_manager = current_user
            
        # Создаем презентацию
        presentation = Collection(
            title=title,
            created_by_manager_id=current_manager.id,
            collection_type='presentation', 
            client_name=client_name,
            status='Черновик'
        )
        
        presentation.generate_unique_url()
        db.session.add(presentation)
        db.session.flush()  # Получаем ID презентации
        
        # Добавляем объекты из ЖК
        properties = load_properties()
        complex_properties = []
        
        for prop in properties:
            if str(prop.get('complex_id')) == str(complex_id):
                complex_properties.append(prop)
        
        if not complex_properties:
            return jsonify({'success': False, 'error': 'ЖК не найден или в нем нет объектов'}), 404
        
        added_count = 0
        for prop in complex_properties[:5]:  # Добавляем максимум 5 объектов из ЖК
            property_id = prop.get('ID')
            
            # DUAL WRITE: Resolve property to get both IDs
            property_obj, canonical_id = resolve_property_by_identifier(property_id)
            if not property_obj:
                continue  # Skip if property not found
            
            collection_property = CollectionProperty(
                collection_id=presentation.id,
                property_id=str(property_obj.id),  # Old: database ID
                property_inner_id=property_obj.inner_id,  # NEW: canonical inner_id
                property_name=f"{prop.get('Type', '')} в {prop.get('Complex', '')}",
                property_price=int(prop.get('Price', 0)) if prop.get('Price') else None,
                complex_name=prop.get('Complex', ''),
                property_type=prop.get('Type', ''),
                property_size=float(prop.get('Size', 0)) if prop.get('Size') else None,
                order_index=added_count + 1
            )
            
            db.session.add(collection_property)
            added_count += 1
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'presentation': presentation.to_dict(),
            'message': f'Презентация создана с {added_count} объектами из ЖК'
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400


# ===== НОВЫЕ API ENDPOINT'Ы ДЛЯ ДЕЙСТВИЙ С ОБЪЕКТАМИ В ПРЕЗЕНТАЦИИ =====

# REMOVED DUPLICATE PRINT ENDPOINT - security fix
    from models import Collection, CollectionProperty
    
    try:
        # Найти презентацию
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            abort(404)
        
        # ✅ FIXED: property_id is database ID, convert to inner_id
        from models import Property as PropertyModel
        try:
            property_id_int = int(property_id)
            property_obj = PropertyModel.query.get(property_id_int)
            if not property_obj:
                return jsonify({'success': False, 'error': 'Объект не найден'}), 404
            inner_id_str = str(property_obj.inner_id)
        except (ValueError, TypeError):
            # Fallback: assume it's already inner_id
            inner_id_str = str(property_id)
        
        # Найти объект в презентации используя inner_id
        collection_property = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=inner_id_str
        ).first()
        
        if not collection_property:
            abort(404)
        
        # Загрузить полные данные объекта
        properties = load_properties()
        property_data = None
        
        for prop in properties:
            if str(prop.get('id')) == str(property_id) or str(prop.get('ID')) == str(property_id) or str(prop.get('inner_id')) == str(property_id):
                property_data = prop
                break
        
        if not property_data:
            abort(404)
        
        # Рендерить print-friendly версию
        return render_template('property_print.html', 
                             property=property_data,
                             presentation=presentation,
                             collection_property=collection_property)
        
    except Exception as e:
        print(f"Error in property_print_view: {e}")
        abort(500)


@app.route('/api/presentation/<int:presentation_id>/property/<string:property_id>/download')
def property_download_pdf(presentation_id, property_id):
    """Скачать PDF объекта из презентации"""
    from models import Collection, CollectionProperty
    from flask import make_response
    import io
    
    # Try to import weasyprint with fallback
    try:
        import weasyprint
        pdf_available = True
    except ImportError:
        pdf_available = False
    
    try:
        # Найти презентацию
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            abort(404)
        
        # ✅ FIXED: property_id is database ID, convert to inner_id
        from models import Property as PropertyModel
        try:
            property_id_int = int(property_id)
            property_obj = PropertyModel.query.get(property_id_int)
            if not property_obj:
                return jsonify({'success': False, 'error': 'Объект не найден'}), 404
            inner_id_str = str(property_obj.inner_id)
        except (ValueError, TypeError):
            # Fallback: assume it's already inner_id
            inner_id_str = str(property_id)
        
        # Найти объект в презентации используя inner_id
        collection_property = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=inner_id_str
        ).first()
        
        if not collection_property:
            abort(404)
        
        # Загрузить полные данные объекта используя fetch_pdf_context для получения фото и кэшбека
        context = fetch_pdf_context(property_id, presentation_id)
        
        if not context:
            abort(404)
        
        # Check if PDF generation is available
        if not pdf_available:
            # Fallback: redirect to print view
            return redirect(url_for('property_print_view', 
                                  presentation_id=presentation_id, 
                                  property_id=property_id))
        
        # Рендерить HTML для PDF с полным контекстом
        html_content = render_template('property_pdf.html', 
                                     property=context['property'],
                                     property_images=context['property_images'],
                                     complex=context['complex'],
                                     complex_images=context['complex_images'],
                                     manager=context['manager'],
                                     presentation=presentation,
                                     collection_property=collection_property)
        
        # Генерировать PDF
        try:
            pdf_buffer = io.BytesIO()
            weasyprint.HTML(string=html_content, base_url=request.url_root).write_pdf(pdf_buffer)
            pdf_buffer.seek(0)
            
            # Создать ASCII-safe имя файла для headers
            property_name = property_data.get('name', f"Объект_{property_id}")
            original_filename = f"{property_name}_{presentation.title}.pdf"
            
            # Create ASCII-safe filename for HTTP headers
            ascii_filename = f"property_{property_id}_{presentation_id}.pdf"
            
            # Clean original filename for RFC 5987 encoding if needed
            clean_filename = "".join(c for c in original_filename if c.isalnum() or c in (' ', '.', '_', '-')).rstrip()
        except Exception as pdf_error:
            print(f"PDF generation failed: {pdf_error}")
            # Fallback: redirect to print view
            return redirect(url_for('property_print_view', 
                                  presentation_id=presentation_id, 
                                  property_id=property_id))
        
        # Вернуть PDF как файл для скачивания с правильной кодировкой
        from urllib.parse import quote
        
        response = make_response(pdf_buffer.read())
        response.headers['Content-Type'] = 'application/pdf'
        
        # Use ASCII-safe filename in Content-Disposition with RFC 5987 fallback for Unicode
        try:
            # Try to encode original filename for browsers that support RFC 5987
            encoded_filename = quote(clean_filename.encode('utf-8'))
            response.headers['Content-Disposition'] = (
                f'attachment; '
                f'filename="{ascii_filename}"; '
                f'filename*=UTF-8\'\'{encoded_filename}'
            )
        except:
            # Fallback to ASCII-only filename
            response.headers['Content-Disposition'] = f'attachment; filename="{ascii_filename}"'
        
        return response
        
    except Exception as e:
        print(f"Error in property_download_pdf: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/presentation/<int:presentation_id>/property/<string:property_id>/view')
def property_view_redirect(presentation_id, property_id):
    """Перенаправить на полную страницу объекта на сайте"""
    from models import Collection, CollectionProperty
    
    try:
        # Найти презентацию
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            abort(404)
        
        # ✅ FIXED: property_id is database ID, convert to inner_id
        from models import Property as PropertyModel
        try:
            property_id_int = int(property_id)
            property_obj = PropertyModel.query.get(property_id_int)
            if not property_obj:
                return jsonify({'success': False, 'error': 'Объект не найден'}), 404
            inner_id_str = str(property_obj.inner_id)
        except (ValueError, TypeError):
            # Fallback: assume it's already inner_id
            inner_id_str = str(property_id)
        
        # Найти объект в презентации используя inner_id
        # Resolve property by inner_id OR database ID
        prop_obj, canonical_id = resolve_property_by_identifier(property_id)
        if not prop_obj:
            return jsonify({"success": False, "error": "Объект не найден"}), 404
        
        collection_property = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=inner_id_str
        ).first()
        
        if not collection_property:
            abort(404)
        
        # Перенаправить на страницу объекта
        return redirect(url_for('property_detail', property_id=property_id))
        
    except Exception as e:
        print(f"Error in property_view_redirect: {e}")
        abort(500)


@app.route('/api/manager/presentation/<int:presentation_id>/property/<string:property_id>/delete', methods=['DELETE'])
@manager_required
@csrf.exempt  # CSRF disabled for manager DELETE actions
def delete_property_from_presentation(presentation_id, property_id):
    """Удалить объект из презентации (только для менеджера-владельца)"""
    from models import Collection, CollectionProperty
    from flask_login import current_user
    
    try:
        # Найти презентацию
        presentation = Collection.query.filter_by(
            id=presentation_id, 
            collection_type='presentation'
        ).first()
        
        if not presentation:
            return jsonify({'success': False, 'error': 'Презентация не найдена'}), 404
        
        # Проверить права доступа - только создатель презентации может удалять объекты
        if presentation.created_by_manager_id != current_user.id:
            return jsonify({'success': False, 'error': 'Нет прав для удаления объектов из этой презентации'}), 403
        
        # ✅ FIXED: property_id is database ID, convert to inner_id
        from models import Property as PropertyModel
        try:
            property_id_int = int(property_id)
            property_obj = PropertyModel.query.get(property_id_int)
            if not property_obj:
                return jsonify({'success': False, 'error': 'Объект не найден'}), 404
            inner_id_str = str(property_obj.inner_id)
        except (ValueError, TypeError):
            # Fallback: assume it's already inner_id
            inner_id_str = str(property_id)
        
        # Найти объект в презентации используя inner_id
        collection_property = CollectionProperty.query.filter_by(
            collection_id=presentation_id,
            property_id=inner_id_str
        ).first()
        
        if not collection_property:
            return jsonify({'success': False, 'error': 'Объект не найден в презентации'}), 404
        
        # Удалить объект из презентации
        db.session.delete(collection_property)
        db.session.commit()
        
        # Обновить количество объектов в презентации
        remaining_properties = CollectionProperty.query.filter_by(collection_id=presentation_id).count()
        
        return jsonify({
            'success': True,
            'message': 'Объект успешно удален из презентации',
            'remaining_properties': remaining_properties
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error in delete_property_from_presentation: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


def send_collection_to_user():
    """Send collection to user - legacy function"""
    if request.method != 'POST':
        return jsonify({'success': False, 'error': 'Only POST method allowed'}), 405
    
    data = request.get_json()
    current_manager = current_user
    
    try:
        name = data.get('name')
        client_id = data.get('client_id')
        property_ids = data.get('property_ids', [])
        
        if not name or not client_id or not property_ids:
            return jsonify({'success': False, 'error': 'Missing required fields'}), 400
        
        # Get client and manager info
        client = User.query.get(client_id)
        manager = current_manager
        
        if not client or not manager:
            return jsonify({'success': False, 'error': 'Client or manager not found'}), 404
        
        # Load property details
        with open('data/properties_expanded.json', 'r', encoding='utf-8') as f:
            properties_data = json.load(f)
        
        selected_properties = []
        total_cashback = 0
        
        for prop_id in property_ids:
            for prop in properties_data:
                if str(prop.get('id')) == str(prop_id):
                    price = prop.get('price', 0)
                    cashback = int(price * 0.05)
                    total_cashback += cashback
                    
                    selected_properties.append({
                        'complex_name': prop.get('complex_name', ''),
                        'district': prop.get('district', ''),
                        'developer': prop.get('developer', ''),
                        'rooms': prop.get('rooms', 0),
                        'area': prop.get('area', 0),
                        'price': price,
                        'cashback': cashback,
                        'type': prop.get('type', ''),
                        'description': prop.get('description', '')
                    })
                    break
        
        # Create email content
        properties_list = '\n'.join([
            f"• {prop['complex_name']} ({prop['district']})\n"
            f"  {prop['rooms']}-комн., {prop['area']} м²\n"
            f"  Цена: {prop['price']:,} ₽\n"
            f"  Кешбек: {prop['cashback']:,} ₽\n"
            for prop in selected_properties
        ])
        
        subject = f"Подборка недвижимости: {name}"
        text_message = f"""
Здравствуйте, {client.full_name}!

Ваш менеджер {manager.full_name} подготовил для вас персональную подборку недвижимости "{name}".

ПОДОБРАННЫЕ ОБЪЕКТЫ ({len(selected_properties)} шт.):

{properties_list}

ОБЩИЙ КЕШБЕК: {total_cashback:,} ₽

Для получения подробной информации и записи на просмотр свяжитесь с вашим менеджером:
{manager.full_name}
Email: {manager.email}
Телефон: {manager.phone or 'не указан'}

Или перейдите в личный кабинет на сайте InBack.ru

С уважением,
Команда InBack.ru
        """.strip()
        
        # Send email
        try:
            from email_service import send_email
            send_email(
                to_email=client.email,
                subject=subject,
                text_content=text_message,
                template_name='collection'
            )
            
            return jsonify({
                'success': True,
                'message': f'Подборка отправлена на email {client.email}'
            })
            
        except Exception as e:
            print(f"Error sending email: {e}")
            return jsonify({'success': False, 'error': 'Ошибка отправки email'}), 500
        
    except Exception as e:
        print(f"Error sending collection: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/data/properties_expanded.json')
def properties_json():
    """Serve properties JSON data"""
    try:
        properties = load_properties()
        return jsonify(properties)
    except Exception as e:
        print(f"Error serving properties JSON: {e}")
        return jsonify([]), 500

# Database initialization will be done after all imports

# Client Recommendations API endpoints
@app.route('/api/user/collections', methods=['GET'])
@login_required
def api_user_get_collections():
    """Get collections assigned to current user"""
    from models import Collection
    import json
    from zoneinfo import ZoneInfo
    
    try:
        collections = Collection.query.filter_by(
            assigned_to_user_id=current_user.id
        ).order_by(Collection.created_at.desc()).all()
        
        collections_data = []
        for collection in collections:
            # Get manager info
            manager = collection.created_by
            manager_name = manager.full_name if manager else 'Менеджер'
            # Use manager's profile image if available, otherwise use first letter
            # Use manager's profile image if available and not randomuser.me, otherwise use first letter
            if manager and manager.profile_image and 'randomuser.me' not in manager.profile_image:
                # Convert relative path to absolute URL
                if manager.profile_image.startswith('http'):
                    manager_avatar = manager.profile_image
                else:
                    base_url = request.host_url.rstrip('/')
                    manager_avatar = f"{base_url}{manager.profile_image}"
            else:
                manager_avatar = manager_name[0].upper() if manager_name else 'М'
            
            # ✅ MIGRATED: Get properties with images from normalized tables
            properties_data = []
            for prop in collection.properties[:4]:
                # Load property from database using PropertyRepository
                property_obj = PropertyRepository.get_by_id(prop.property_id)
                if property_obj:
                    # Get first photo from photos array
                    image_url = ''
                    if property_obj.gallery_images:
                        try:
                            photos_list = json.loads(property_obj.gallery_images) if isinstance(property_obj.gallery_images, str) else property_obj.gallery_images
                            image_url = photos_list[0] if photos_list and len(photos_list) > 0 else ''
                        except Exception as photo_error:
                            print(f"DEBUG: Error parsing photos for property {prop.property_id}: {photo_error}")
                    
                    # Build title from property data
                    rooms_text = f"{property_obj.rooms}-комн" if property_obj.rooms and property_obj.rooms > 0 else "Студия"
                    area_text = f"{property_obj.area} м²" if property_obj.area else ""
                    title = f"{rooms_text}, {area_text}".strip(', ')
                    
                    properties_data.append({
                        'id': prop.property_id,
                        'image': image_url,
                        'title': title
                    })
            
            collections_data.append({
                'id': collection.id,
                'title': collection.title,
                'description': collection.description,
                'status': collection.status,
                'created_at': collection.created_at.replace(tzinfo=ZoneInfo('UTC')).astimezone(ZoneInfo('Europe/Moscow')).strftime('%d.%m.%Y в %H:%M'),
                'manager_name': manager_name,
                'manager_avatar': manager_avatar,
                'properties_count': len(collection.properties),
                'properties': properties_data,
                'unique_url': collection.unique_url
            })
        
        print(f"🎯 Collections API: returning {len(collections_data)} collections")
        
        return jsonify({
            'success': True,
            'collections': collections_data
        })
        
    except Exception as e:
        print(f"❌ Error loading collections: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 400

@login_required
def api_user_get_saved_searches():
    """Get saved searches for current user"""
    from models import SavedSearch
    
    try:
        # Get regular saved searches
        saved_searches = SavedSearch.query.filter_by(
            user_id=current_user.id
        ).order_by(SavedSearch.created_at.desc()).all()
        
        # Get sent searches from managers
        from models import SentSearch
        sent_searches = SentSearch.query.filter_by(
            client_id=current_user.id
        ).order_by(SentSearch.sent_at.desc()).all()
        
        searches_data = []
        
        # Add regular saved searches
        for search in saved_searches:
            filters = {}
            if search.filters:
                import json
                filters = json.loads(search.filters) if isinstance(search.filters, str) else search.filters
            
            searches_data.append({
                'id': search.id,
                'name': search.name,
                'filters': filters,
                'created_at': search.created_at.strftime('%d.%m.%Y'),
                'last_used': search.last_used.strftime('%d.%m.%Y') if search.last_used else None,
                'type': 'saved'
            })
        
        # Add sent searches from managers
        for search in sent_searches:
            filters = {}
            if search.additional_filters:
                import json
                filters = json.loads(search.additional_filters) if isinstance(search.additional_filters, str) else search.additional_filters
            
            searches_data.append({
                'id': search.id,
                'name': search.name,
                'filters': filters,
                'created_at': search.sent_at.strftime('%d.%m.%Y') if search.sent_at else 'Не указано',
                'last_used': search.applied_at.strftime('%d.%m.%Y') if search.applied_at else None,
                'type': 'sent',
                'from_manager': True
            })
        
        return jsonify({
            'success': True,
            'searches': searches_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/recommendations', methods=['GET'])
@login_required
def api_user_get_recommendations():
    """Get recommendations for current user"""
    from models import Recommendation, SentSearch
    from datetime import datetime
    
    try:
        print(f"DEBUG: Loading recommendations for user ID: {current_user.id}")
        
        # Get traditional recommendations
        recommendations = Recommendation.query.filter_by(
            client_id=current_user.id
        ).order_by(Recommendation.sent_at.desc()).all()
        
        print(f"DEBUG: Found {len(recommendations)} recommendations for user {current_user.id}")
        
        recommendations_data = []
        for rec in recommendations:
            rec_data = rec.to_dict()
            rec_data['manager_name'] = f"{rec.manager.first_name} {rec.manager.last_name}" if rec.manager else 'Менеджер'
            recommendations_data.append(rec_data)
        
        # Get sent searches from managers as recommendations  
        sent_searches = SentSearch.query.filter_by(client_id=current_user.id).order_by(SentSearch.sent_at.desc()).all()
        
        # Convert sent searches to recommendation format
        for search in sent_searches:
            search_rec = {
                'id': f'search_{search.id}',
                'title': f'Подбор недвижимости: {search.name}',
                'description': search.description or 'Персональный подбор от вашего менеджера',
                'recommendation_type': 'search',
                'item_id': str(search.id),
                'item_name': search.name,
                'manager_notes': f'Ваш менеджер {search.manager.name} подготовил персональный подбор недвижимости',
                'priority_level': 'high',
                'status': search.status,
                'viewed_at': search.viewed_at.isoformat() if search.viewed_at else None,
                'created_at': search.sent_at.isoformat() if search.sent_at else None,
                'sent_at': search.sent_at.isoformat() if search.sent_at else None,
                'manager_name': search.manager.name,
                'search_filters': search.additional_filters,
                'search_id': search.id
            }
            recommendations_data.append(search_rec)
        
        # Sort by creation date 
        recommendations_data.sort(key=lambda x: x.get('created_at', ''), reverse=True)
        
        return jsonify({
            'success': True, 
            'recommendations': recommendations_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/saved-searches/<int:search_id>')
@login_required
def get_saved_search_details(search_id):
    """Get saved search details for applying filters"""
    from models import SavedSearch
    
    try:
        user_id = session.get('user_id')
        if not user_id:
            return jsonify({'success': False, 'error': 'User not authenticated'}), 401
        
        # Get the saved search
        saved_search = SavedSearch.query.filter_by(id=search_id, user_id=user_id).first()
        if not saved_search:
            return jsonify({'success': False, 'error': 'Поиск не найден'}), 404
        
        return jsonify({
            'success': True,
            'id': saved_search.id,
            'name': saved_search.name,
            'description': saved_search.description,
            'search_filters': saved_search.additional_filters,
            'created_at': saved_search.created_at.isoformat() if saved_search.created_at else None
        })
        
    except Exception as e:
        print(f"Error getting saved search details: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/sent-searches')
@login_required
def get_sent_searches():
    """Get sent searches from managers as recommendations"""
    from models import SentSearch
    
    try:
        user_id = session.get('user_id')
        if not user_id:
            return jsonify({'success': False, 'error': 'User not authenticated'}), 401
        
        # Get sent searches
        sent_searches = SentSearch.query.filter_by(client_id=user_id).order_by(SentSearch.sent_at.desc()).all()
        
        # Format as recommendation-like objects
        search_list = []
        
        for search in sent_searches:
            search_list.append({
                'id': search.id,
                'name': search.name or 'Поиск от менеджера',
                'title': search.name or 'Поиск от менеджера',
                'description': search.description,
                'status': search.status or 'sent',
                'sent_at': search.sent_at.isoformat() if search.sent_at else None,
                'created_at': search.sent_at.isoformat() if search.sent_at else None,
                'search_filters': search.additional_filters,
                'manager_id': search.manager_id,
                'recommendation_type': 'search'
            })
        
        return jsonify({
            'success': True,
            'sent_searches': search_list
        })
        
    except Exception as e:
        print(f"Error getting sent searches: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/sent-search/<int:search_id>')
@login_required
def get_sent_search_detail(search_id):
    """Get details of a specific sent search from manager"""
    from models import SentSearch
    import json
    
    try:
        # Get the specific sent search for this client using current_user from Flask-Login
        sent_search = SentSearch.query.filter_by(id=search_id, client_id=current_user.id).first()
        
        if not sent_search:
            return jsonify({'success': False, 'error': 'Поиск не найден'}), 404
        
        # Parse additional_filters if it's a JSON string
        filters = sent_search.additional_filters
        if isinstance(filters, str):
            try:
                filters = json.loads(filters)
            except json.JSONDecodeError:
                filters = {}
        elif filters is None:
            filters = {}
        
        return jsonify({
            'success': True,
            'search': {
                'id': sent_search.id,
                'name': sent_search.name or 'Поиск от менеджера',
                'description': sent_search.description,
                'additional_filters': filters,
                'status': sent_search.status or 'sent',
                'sent_at': sent_search.sent_at.isoformat() if sent_search.sent_at else None,
                'manager_id': sent_search.manager_id
            }
        })
        
    except Exception as e:
        print(f"Error getting sent search detail: {e}")
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/recommendations/<rec_id>/viewed', methods=['POST'])
@login_required  
def api_mark_recommendation_viewed(rec_id):
    """Mark recommendation as viewed"""
    from models import Recommendation, SentSearch
    from datetime import datetime
    
    try:
        # Handle search recommendations
        if str(rec_id).startswith('search_'):
            search_id = int(rec_id.replace('search_', ''))
            sent_search = SentSearch.query.filter_by(
                id=search_id, 
                client_id=current_user.id
            ).first()
            
            if not sent_search:
                return jsonify({'success': False, 'error': 'Поиск не найден'}), 404
                
            if sent_search.status == 'sent':
                sent_search.status = 'viewed'
                sent_search.viewed_at = datetime.utcnow()
                db.session.commit()
            
            return jsonify({'success': True})
        
        # Handle traditional recommendations
        recommendation = Recommendation.query.filter_by(
            id=int(rec_id), 
            client_id=current_user.id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': 'Рекомендация не найдена'}), 404
            
        if recommendation.status == 'sent':
            recommendation.status = 'viewed'
            recommendation.viewed_at = datetime.utcnow()
            db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/recommendations/<int:rec_id>/dismiss', methods=['POST'])
@login_required
def api_dismiss_recommendation(rec_id):
    """Dismiss/hide recommendation"""
    from models import Recommendation
    from datetime import datetime
    
    try:
        recommendation = Recommendation.query.filter_by(
            id=rec_id, 
            client_id=current_user.id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': 'Рекомендация не найдена'}), 404
            
        # Mark as dismissed
        recommendation.status = 'dismissed'
        recommendation.viewed_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/recommendations/<rec_id>/apply', methods=['POST'])
@login_required  
def api_apply_search_recommendation(rec_id):
    """Apply search recommendation - redirect to properties with filters"""
    from models import SentSearch
    from datetime import datetime
    import json
    
    try:
        # Handle search recommendations only
        if not str(rec_id).startswith('search_'):
            return jsonify({'success': False, 'error': 'Только поиски можно применить'}), 400
            
        search_id = int(rec_id.replace('search_', ''))
        sent_search = SentSearch.query.filter_by(
            id=search_id, 
            client_id=current_user.id
        ).first()
        
        if not sent_search:
            return jsonify({'success': False, 'error': 'Поиск не найден'}), 404
        
        # Update search status
        sent_search.applied_at = datetime.utcnow()
        if sent_search.status == 'sent':
            sent_search.status = 'applied'
        db.session.commit()
        
        # Parse filters from the search
        filters = {}
        if sent_search.additional_filters:
            try:
                filters = json.loads(sent_search.additional_filters)
            except json.JSONDecodeError:
                pass
        
        return jsonify({
            'success': True, 
            'filters': filters
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/user/recommendation-categories', methods=['GET'])
@login_required
def api_user_get_categories():
    """Get all categories that have recommendations for current user"""
    from models import RecommendationCategory
    
    try:
        categories = RecommendationCategory.query.filter_by(
            client_id=current_user.id
        ).filter(RecommendationCategory.recommendations_count > 0).all()
        
        categories_data = []
        for category in categories:
            categories_data.append({
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'color': category.color,
                'recommendations_count': category.recommendations_count
            })
        
        return jsonify({
            'success': True,
            'categories': categories_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

# User Comparison Count API Endpoints
@app.route('/api/user/comparison/properties/count')
@login_required
def api_user_comparison_properties_count():
    """Get count of properties in comparison for current user"""
    from models import ComparisonProperty, UserComparison
    
    try:
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'count': 0
            })
        
        # Count properties in this comparison
        count = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'count': count
        })
        
    except Exception as e:
        print(f"Error getting user comparison properties count: {e}")
        return jsonify({'success': False, 'error': str(e), 'count': 0}), 500

@app.route('/api/user/comparison/complexes/count')
@login_required
def api_user_comparison_complexes_count():
    """Get count of complexes in comparison for current user"""
    from models import ComparisonComplex, UserComparison
    
    try:
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'count': 0
            })
        
        # Count complexes in this comparison
        count = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'count': count
        })
        
    except Exception as e:
        print(f"Error getting user comparison complexes count: {e}")
        return jsonify({'success': False, 'error': str(e), 'count': 0}), 500

# ========================================
# USER COMPARISON ENDPOINTS
# ========================================

@app.route('/api/user/comparison/property/add', methods=['POST'])
@login_required
def api_user_comparison_property_add():
    """Add property to user's comparison"""
    from models import UserComparison, ComparisonProperty
    
    try:
        data = request.get_json()
        property_id = str(data.get('property_id'))  # ✅ Конвертируем в строку
        
        if not property_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        # Find or create active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            user_comparison = UserComparison(
                user_id=current_user.id,
                name='Мое сравнение',
                is_active=True
            )
            db.session.add(user_comparison)
            db.session.flush()
        
        # Check if property already in comparison
        existing = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id,
            property_id=property_id
        ).first()
        
        if existing:
            count = ComparisonProperty.query.filter_by(
                user_comparison_id=user_comparison.id
            ).count()
            return jsonify({
                'success': True,
                'message': 'Объект уже в сравнении',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        if current_count >= 4:
            return jsonify({
                'success': False,
                'message': 'Максимум 4 объекта в сравнении',
                'count': current_count
            }), 400
        
        # Add property to comparison
        comparison_property = ComparisonProperty(
            user_comparison_id=user_comparison.id,
            property_id=property_id,
            property_name=data.get('property_name'),
            property_price=data.get('property_price'),
            complex_name=data.get('complex_name'),
            cashback=data.get('cashback', 0),
            area=data.get('area'),
            rooms=data.get('rooms'),
            order_index=current_count
        )
        db.session.add(comparison_property)
        db.session.commit()
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': 'Объект добавлен в сравнение',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding property to user comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/comparison/property/remove', methods=['POST'])
@csrf.exempt
@login_required
def api_user_comparison_property_remove():
    """Remove property from user's comparison"""
    from models import UserComparison, ComparisonProperty
    
    try:
        data = request.get_json()
        property_id = str(data.get('property_id'))  # ✅ Конвертируем в строку
        
        if not property_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'message': 'Сравнение пусто',
                'count': 0
            })
        
        # Find and delete property
        comparison_property = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id,
            property_id=property_id
        ).first()
        
        if comparison_property:
            db.session.delete(comparison_property)
            db.session.commit()
        
        # Get updated count
        count = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': 'Объект удален из сравнения',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing property from user comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/comparison/complex/add', methods=['POST'])
@login_required
def api_user_comparison_complex_add():
    """Add residential complex to user's comparison"""
    from models import UserComparison, ComparisonComplex
    
    try:
        data = request.get_json()
        complex_id = data.get('complex_id')
        
        print(f'🔵 DEBUG USER: Добавление ЖК - complex_id={complex_id}, data={data}')
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        # Find or create active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            user_comparison = UserComparison(
                user_id=current_user.id,
                name='Мое сравнение',
                is_active=True
            )
            db.session.add(user_comparison)
            db.session.flush()
            print(f'✅ DEBUG USER: Создан новый UserComparison id={user_comparison.id}')
        else:
            print(f'✅ DEBUG USER: Найден UserComparison id={user_comparison.id}')
        
        # Check if complex already in comparison
        existing = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id,
            complex_id=complex_id
        ).first()
        
        if existing:
            count = ComparisonComplex.query.filter_by(
                user_comparison_id=user_comparison.id
            ).count()
            print(f'⚠️ DEBUG USER: ЖК уже в сравнении, count={count}')
            return jsonify({
                'success': True,
                'message': 'ЖК уже в сравнении',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        if current_count >= 4:
            print(f'⚠️ DEBUG USER: Превышен лимит, count={current_count}')
            return jsonify({
                'success': False,
                'message': 'Максимум 4 ЖК в сравнении',
                'count': current_count
            }), 400
        
        # Add complex to comparison
        comparison_complex = ComparisonComplex(
            user_comparison_id=user_comparison.id,
            complex_id=complex_id,
            complex_name=data.get('complex_name'),
            developer_name=data.get('developer_name'),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            district=data.get('district'),
            photo=data.get('photo'),
            buildings_count=data.get('buildings_count'),
            apartments_count=data.get('apartments_count'),
            completion_date=data.get('completion_date'),
            status=data.get('status'),
            complex_class=data.get('complex_class'),
            cashback_rate=data.get('cashback_rate', 5.0),
            order_index=current_count
        )
        db.session.add(comparison_complex)
        db.session.commit()
        
        print(f'✅ DEBUG USER: ЖК добавлен в БД - id={comparison_complex.id}, complex_id={comparison_complex.complex_id}')
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': 'ЖК добавлен в сравнение',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"❌ Error adding complex to user comparison: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'message': str(e)}), 500
@app.route('/api/user/comparison/complex/remove', methods=['POST'])
@csrf.exempt
@login_required
def api_user_comparison_complex_remove():
    """Remove residential complex from user's comparison"""
    from models import UserComparison, ComparisonComplex
    
    try:
        data = request.get_json()
        complex_id = data.get('complex_id')
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'message': 'Сравнение пусто',
                'count': 0
            })
        
        # Find and delete complex
        comparison_complex = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id,
            complex_id=complex_id
        ).first()
        
        if comparison_complex:
            db.session.delete(comparison_complex)
            db.session.commit()
        
        # Get updated count
        count = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': 'ЖК удален из сравнения',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing complex from user comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/comparison/load')
def api_user_comparison_load():
    """Load all comparisons for current user from database with is_sold status check"""
    from models import UserComparison, ComparisonProperty, ComparisonComplex, Property
    
    try:
        # Handle unauthenticated users - return empty arrays instead of redirecting
        if not current_user.is_authenticated:
            return jsonify({
                'success': True,
                'properties': [],
                'complexes': [],
                'properties_count': 0,
                'complexes_count': 0
            })
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if not user_comparison:
            return jsonify({
                'success': True,
                'properties': [],
                'complexes': [],
                'properties_count': 0,
                'complexes_count': 0
            })
        
        # Get all comparison properties
        comparison_properties = ComparisonProperty.query.filter_by(
            user_comparison_id=user_comparison.id
        ).all()
        
        # Batch-загрузка Property объектов для проверки актуальности (избегаем N+1 запросов)
        property_ids = []
        for cp in comparison_properties:
            if cp.property_id:
                try:
                    # ComparisonProperty.property_id может быть как inner_id (string), так и database ID (int)
                    property_ids.append(int(cp.property_id))
                except (ValueError, TypeError):
                    # Если не удалось преобразовать в int, пропускаем
                    pass
        
        # Загружаем все Property объекты одним запросом
        live_properties = {}
        if property_ids:
            properties_query = Property.query.filter(Property.id.in_(property_ids)).all()
            live_properties = {p.id: p for p in properties_query}
        
        # Обогащаем данные флагом is_sold и status_label
        properties_data = []
        for cp in comparison_properties:
            cp_dict = cp.to_dict()
            
            # Получаем актуальный Property объект
            try:
                prop_id = int(cp.property_id) if cp.property_id else None
            except (ValueError, TypeError):
                prop_id = None
            
            live_prop = live_properties.get(prop_id) if prop_id else None
            
            # Добавляем флаги актуальности
            cp_dict['is_sold'] = not live_prop.is_active if live_prop else True
            cp_dict['status_label'] = 'НЕ В ПРОДАЖЕ' if cp_dict['is_sold'] else ''
            
            # Опционально: обновляем денормализованные данные если объект актуален
            if live_prop and live_prop.is_active:
                cp_dict['current_price'] = live_prop.price
                cp_dict['current_area'] = live_prop.area
            
            properties_data.append(cp_dict)
        
        # Get all complex IDs
        complexes = ComparisonComplex.query.filter_by(
            user_comparison_id=user_comparison.id
        ).all()
        complex_ids = [comp.complex_id for comp in complexes]
        
        return jsonify({
            'success': True,
            'properties': properties_data,
            'complexes': complex_ids,
            'properties_count': len(properties_data),
            'complexes_count': len(complex_ids)
        })
        
    except Exception as e:
        print(f"Error loading user comparison: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/comparison/clear', methods=['POST'])
def api_comparison_clear():
    """Clear all comparisons for current user"""
    from models import UserComparison, ComparisonProperty, ComparisonComplex
    
    try:
        # Handle unauthenticated users
        if not current_user.is_authenticated:
            return jsonify({
                'success': True,
                'message': 'Сравнения очищены (локально)'
            })
        
        # Find active user comparison
        user_comparison = UserComparison.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if user_comparison:
            # Delete all properties
            ComparisonProperty.query.filter_by(
                user_comparison_id=user_comparison.id
            ).delete()
            
            # Delete all complexes
            ComparisonComplex.query.filter_by(
                user_comparison_id=user_comparison.id
            ).delete()
            
            db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Все сравнения очищены'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error clearing comparisons: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# ========================================
# PUBLIC COMPARISON DELETE ENDPOINTS (No Auth Required)
# ========================================

@app.route('/api/comparison/remove-property', methods=['POST', 'DELETE'])
@csrf.exempt
def api_comparison_remove_property():
    """Remove property from comparison (works for both authenticated and unauthenticated users)"""
    from models import UserComparison, ManagerComparison, ComparisonProperty
    
    try:
        # Get property_id from request
        if request.method == 'DELETE':
            data = request.get_json() or {}
        else:
            data = request.get_json() or {}
        
        property_id = data.get('property_id')
        
        if not property_id:
            return jsonify({'success': False, 'error': 'Property ID is required'}), 400
        
        # Try to remove from database if user is authenticated
        deleted = False
        
        # Check if regular user is authenticated
        if current_user.is_authenticated:
            user_comparison = UserComparison.query.filter_by(
                user_id=current_user.id,
                is_active=True
            ).first()
            
            if user_comparison:
                comparison_property = ComparisonProperty.query.filter_by(
                    user_comparison_id=user_comparison.id,
                    property_id=property_id
                ).first()
                
                if comparison_property:
                    db.session.delete(comparison_property)
                    db.session.commit()
                    deleted = True
        
        # Check if manager is authenticated
        if isinstance(current_user._get_current_object(), Manager) and not deleted:
            current_manager = current_user
            manager_comparison = ManagerComparison.query.filter_by(
                manager_id=current_manager.id,
                is_active=True
            ).first()
            
            if manager_comparison:
                comparison_property = ComparisonProperty.query.filter_by(
                    manager_comparison_id=manager_comparison.id,
                    property_id=property_id
                ).first()
                
                if comparison_property:
                    db.session.delete(comparison_property)
                    db.session.commit()
                    deleted = True
        
        # Return success even if not in database (frontend will handle localStorage)
        return jsonify({
            'success': True,
            'message': 'Квартира удалена из сравнения',
            'deleted_from_db': deleted
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"❌ Error removing property from comparison: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/comparison/remove-complex', methods=['POST', 'DELETE'])
@csrf.exempt
def api_comparison_remove_complex():
    """Remove complex from comparison (works for both authenticated and unauthenticated users)"""
    from models import UserComparison, ManagerComparison, ComparisonComplex
    
    try:
        # Get complex_id from request
        if request.method == 'DELETE':
            data = request.get_json() or {}
        else:
            data = request.get_json() or {}
        
        complex_id = data.get('complex_id')
        
        if not complex_id:
            return jsonify({'success': False, 'error': 'Complex ID is required'}), 400
        
        # Try to remove from database if user is authenticated
        deleted = False
        
        # Check if regular user is authenticated
        if current_user.is_authenticated:
            user_comparison = UserComparison.query.filter_by(
                user_id=current_user.id,
                is_active=True
            ).first()
            
            if user_comparison:
                comparison_complex = ComparisonComplex.query.filter_by(
                    user_comparison_id=user_comparison.id,
                    complex_id=complex_id
                ).first()
                
                if comparison_complex:
                    db.session.delete(comparison_complex)
                    db.session.commit()
                    deleted = True
        
        # Check if manager is authenticated
        if isinstance(current_user._get_current_object(), Manager) and not deleted:
            current_manager = current_user
            manager_comparison = ManagerComparison.query.filter_by(
                manager_id=current_manager.id,
                is_active=True
            ).first()
            
            if manager_comparison:
                comparison_complex = ComparisonComplex.query.filter_by(
                    manager_comparison_id=manager_comparison.id,
                    complex_id=complex_id
                ).first()
                
                if comparison_complex:
                    db.session.delete(comparison_complex)
                    db.session.commit()
                    deleted = True
        
        # Return success even if not in database (frontend will handle localStorage)
        return jsonify({
            'success': True,
            'message': 'ЖК удален из сравнения',
            'deleted_from_db': deleted
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"❌ Error removing complex from comparison: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

# ========================================
# MANAGER COMPARISON ENDPOINTS
# ========================================

@app.route('/api/manager/comparison/property/add', methods=['POST'])
@manager_required
def api_manager_comparison_property_add():
    """Add property to manager's comparison"""
    from models import ManagerComparison, ComparisonProperty
    
    try:
        data = request.get_json()
        property_id = data.get('property_id')
        print(f'🔍 DEBUG: property/add called with data: {data}')
        print(f'🔍 DEBUG: property_id type: {type(property_id)}, value: {property_id}')
        
        # ✅ ИСПРАВЛЕНО: Конвертируем в строку, т.к. в БД property_id - VARCHAR
        property_id = str(property_id)
        print(f'✅ DEBUG: Converted property_id to string: {property_id}')
        
        if not property_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        current_manager = current_user
        
        # Find or create active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            manager_comparison = ManagerComparison(
                manager_id=current_manager.id,
                name='Сравнение для клиента',
                is_active=True
            )
            db.session.add(manager_comparison)
            db.session.flush()
        
        # Check if property already in comparison
        existing = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            property_id=property_id
        ).first()
        
        if existing:
            count = ComparisonProperty.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).count()
            return jsonify({
                'success': True,
                'message': 'Объект уже в сравнении',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        if current_count >= 4:
            return jsonify({
                'success': False,
                'message': 'Максимум 4 объекта в сравнении',
                'count': current_count
            }), 400
        
        # ✅ Get property inner_id for consistency with favorites system
        from models import Property
        property = Property.query.filter_by(id=property_id).first()
        
        if not property:
            return jsonify({
                'success': False,
                'message': 'Объект не найден'
            }), 404
        
        # Add property to comparison using Property.id
        comparison_property = ComparisonProperty(
            manager_comparison_id=manager_comparison.id,
            property_id=str(property.id),  # ✅ Use Property.id для консистентности с фронтендом
            property_name=data.get('property_name'),
            property_price=data.get('property_price'),
            complex_name=data.get('complex_name'),
            cashback=data.get('cashback', 0),
            area=data.get('area'),
            rooms=data.get('rooms'),
            order_index=current_count
        )
        db.session.add(comparison_property)
        db.session.commit()
        
        print(f"✅ Added property {property_id} (inner_id: {property.inner_id}) to comparison")
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': 'Объект добавлен в сравнение',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding property to manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500
@app.route('/api/manager/comparison/property/remove', methods=['POST'])
@manager_required
def api_manager_comparison_property_remove():
    """Remove property from manager's comparison"""
    from models import ManagerComparison, ComparisonProperty, Property
    
    try:
        data = request.get_json()
        property_id_or_inner_id = str(data.get('property_id'))  # ✅ Может быть inner_id или id
        
        if not property_id_or_inner_id:
            return jsonify({'success': False, 'message': 'Property ID is required'}), 400
        
        current_manager = current_user
        
        # Find active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            return jsonify({
                'success': True,
                'message': 'Сравнение пусто',
                'count': 0
            })
        
        # ВАЖНО: Конвертируем inner_id в Property.id если нужно
        # Сначала пробуем найти напрямую по property_id
        print(f'🔍 DEBUG: Received property_id={property_id_or_inner_id}')
        comparison_property = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            property_id=property_id_or_inner_id
        ).first()
        
        # Если не нашли, значит пришел inner_id - конвертируем в id
        if not comparison_property:
            print(f'🔍 DEBUG: Not found by direct ID, trying to convert inner_id to Property.id')
            property_obj = Property.query.filter_by(inner_id=property_id_or_inner_id).first()
            if property_obj:
                actual_property_id = str(property_obj.id)
                print(f'✅ DEBUG: Converted inner_id {property_id_or_inner_id} to Property.id {actual_property_id}')
                comparison_property = ComparisonProperty.query.filter_by(
                    manager_comparison_id=manager_comparison.id,
                    property_id=actual_property_id
                ).first()
            else:
                print(f'❌ DEBUG: Property not found with inner_id={property_id_or_inner_id}')
        
        print(f'🔍 DEBUG: Найдена запись? {comparison_property is not None}')
        if comparison_property:
            print(f'🔍 DEBUG: Удаляем запись id={comparison_property.id}, property_id={comparison_property.property_id}')
            db.session.delete(comparison_property)
            db.session.commit()
            print(f'✅ DEBUG: Запись удалена и commit выполнен')
        else:
            print(f'❌ DEBUG: Запись НЕ найдена для удаления!')
        
        # Get updated count
        count = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': 'Объект удален из сравнения',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing property from manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/clear', methods=['DELETE', 'POST'])
@csrf.exempt
@manager_required
def api_manager_comparison_clear():
    """Clear all items from manager's comparison"""
    from models import ManagerComparison, ComparisonProperty, ComparisonComplex
    
    try:
        current_manager = current_user
        print(f"🗑️ DEBUG: /api/manager/comparison/clear called by manager {current_manager.id}")
        
        # Find ALL active manager comparisons (not just first one!)
        manager_comparisons = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).all()
        
        if not manager_comparisons:
            print(f"ℹ️ DEBUG: No active comparison found for manager {current_manager.id}")
            return jsonify({
                'success': True,
                'message': 'Сравнение уже пусто',
                'deleted_properties': 0,
                'deleted_complexes': 0
            })
        
        print(f"🔍 DEBUG: Found {len(manager_comparisons)} active comparison(s), deleting items...")
        
        # Delete all properties and complexes from ALL active comparisons
        deleted_properties = 0
        deleted_complexes = 0
        
        for manager_comparison in manager_comparisons:
            deleted_properties += ComparisonProperty.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).delete()
            
            deleted_complexes += ComparisonComplex.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).delete()
        
        db.session.commit()
        
        print(f"✅ DEBUG: Cleared {deleted_properties} properties and {deleted_complexes} complexes")
        
        return jsonify({
            'success': True,
            'message': f'Сравнение очищено: {deleted_properties} квартир и {deleted_complexes} ЖК',
            'deleted_properties': deleted_properties,
            'deleted_complexes': deleted_complexes
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error clearing manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/complex/add', methods=['POST'])
@manager_required
def api_manager_comparison_complex_add():
    """Add residential complex to manager's comparison"""
    from models import ManagerComparison, ComparisonComplex
    
    try:
        data = request.get_json()
        complex_id = data.get('complex_id')
        print(f'🔍 DEBUG: complex/add called with data: {data}')
        print(f'🔍 DEBUG: complex_id type: {type(complex_id)}, value: {complex_id}')
        
        # Convert string ID to integer if needed
        try:
            complex_id = int(complex_id)
            print(f'✅ DEBUG: Converted complex_id to integer: {complex_id}')
        except (ValueError, TypeError) as e:
            print(f'❌ DEBUG: Failed to convert complex_id to integer: {e}')
            return jsonify({'success': False, 'message': 'Invalid complex ID format'}), 400
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        current_manager = current_user
        
        # Find or create active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            manager_comparison = ManagerComparison(
                manager_id=current_manager.id,
                name='Сравнение для клиента',
                is_active=True
            )
            db.session.add(manager_comparison)
            db.session.flush()
        
        # Check if complex already in comparison
        existing = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            complex_id=complex_id
        ).first()
        
        if existing:
            count = ComparisonComplex.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).count()
            return jsonify({
                'success': True,
                'message': 'ЖК уже в сравнении',
                'count': count
            })
        
        # Check maximum limit
        current_count = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        if current_count >= 4:
            return jsonify({
                'success': False,
                'message': 'Максимум 4 ЖК в сравнении',
                'count': current_count
            }), 400
        
        # Add complex to comparison
        comparison_complex = ComparisonComplex(
            manager_comparison_id=manager_comparison.id,
            complex_id=complex_id,
            complex_name=data.get('complex_name'),
            developer_name=data.get('developer_name'),
            min_price=data.get('min_price'),
            max_price=data.get('max_price'),
            district=data.get('district'),
            photo=data.get('photo'),
            buildings_count=data.get('buildings_count'),
            apartments_count=data.get('apartments_count'),
            completion_date=data.get('completion_date'),
            status=data.get('status'),
            complex_class=data.get('complex_class'),
            cashback_rate=data.get('cashback_rate', 5.0),
            order_index=current_count
        )
        db.session.add(comparison_complex)
        db.session.commit()
        
        new_count = current_count + 1
        return jsonify({
            'success': True,
            'message': 'ЖК добавлен в сравнение',
            'count': new_count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding complex to manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/complex/remove', methods=['POST'])
@manager_required
def api_manager_comparison_complex_remove():
    """Remove residential complex from manager's comparison"""
    from models import ManagerComparison, ComparisonComplex
    
    try:
        data = request.get_json()
        complex_id = str(data.get('complex_id'))  # ✅ Конвертируем в строку
        
        if not complex_id:
            return jsonify({'success': False, 'message': 'Complex ID is required'}), 400
        
        current_manager = current_user
        
        # Find active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            return jsonify({
                'success': True,
                'message': 'Сравнение пусто',
                'count': 0
            })
        
        # Find and delete complex
        print(f'🔍 DEBUG: Поиск ЖК для удаления - manager_comparison_id={manager_comparison.id}, complex_id={complex_id} (type={type(complex_id)})')
        comparison_complex = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id,
            complex_id=complex_id
        ).first()
        
        print(f'🔍 DEBUG: Найдена запись ЖК? {comparison_complex is not None}')
        if comparison_complex:
            print(f'🔍 DEBUG: Удаляем ЖК id={comparison_complex.id}, complex_id={comparison_complex.complex_id}')
            db.session.delete(comparison_complex)
            db.session.commit()
            print(f'✅ DEBUG: ЖК удален и commit выполнен')
        else:
            print(f'❌ DEBUG: Запись ЖК НЕ найдена для удаления!')
        
        # Get updated count
        count = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        return jsonify({
            'success': True,
            'message': 'ЖК удален из сравнения',
            'count': count
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error removing complex from manager comparison: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/manager/comparison/load')
def api_manager_comparison_load():
    """Load all comparisons for current manager from database with is_sold status check"""
    from models import ManagerComparison, ComparisonProperty, ComparisonComplex, Manager, Property
    
    try:
        # ИСПРАВЛЕНО: правильная проверка типа менеджера
        if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
            print(f"⚠️ DEBUG: User not authenticated or not a manager - returning empty comparison")
            return jsonify({
                'success': True,
                'properties': [],
                'complexes': [],
                'properties_count': 0,
                'complexes_count': 0
            })
        
        current_manager = current_user
        print(f"🔍 DEBUG: Loading comparisons from MANAGER_COMPARISONS table for manager {current_manager.id}")
        
        # ✅ ИСПРАВЛЕНО: Find ALL active manager comparisons (not just first one!)
        manager_comparisons = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).all()
        
        if not manager_comparisons:
            print(f"ℹ️ DEBUG: No active comparisons found")
            return jsonify({
                'success': True,
                'properties': [],
                'complexes': [],
                'properties_count': 0,
                'complexes_count': 0
            })
        
        print(f"🔍 DEBUG: Found {len(manager_comparisons)} active comparison(s)")
        
        # ✅ Collect all comparison properties from ALL active comparisons
        all_comparison_properties = []
        complex_ids = []
        
        for manager_comparison in manager_comparisons:
            # Get all property objects for this comparison
            properties = ComparisonProperty.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).all()
            all_comparison_properties.extend(properties)
            
            # Get all complex IDs
            complexes = ComparisonComplex.query.filter_by(
                manager_comparison_id=manager_comparison.id
            ).all()
            for comp in complexes:
                if str(comp.complex_id) not in complex_ids:  # Avoid duplicates
                    complex_ids.append(str(comp.complex_id))
        
        # Batch-загрузка Property объектов для проверки актуальности (избегаем N+1 запросов)
        property_ids = []
        for cp in all_comparison_properties:
            if cp.property_id:
                try:
                    # ComparisonProperty.property_id может быть как inner_id (string), так и database ID (int)
                    property_ids.append(int(cp.property_id))
                except (ValueError, TypeError):
                    # Если не удалось преобразовать в int, пропускаем
                    pass
        
        # Загружаем все Property объекты одним запросом
        live_properties = {}
        if property_ids:
            properties_query = Property.query.filter(Property.id.in_(property_ids)).all()
            live_properties = {p.id: p for p in properties_query}
        
        # Обогащаем данные флагом is_sold и status_label
        properties_data = []
        for cp in all_comparison_properties:
            cp_dict = cp.to_dict()
            
            # Получаем актуальный Property объект
            try:
                prop_id = int(cp.property_id) if cp.property_id else None
            except (ValueError, TypeError):
                prop_id = None
            
            live_prop = live_properties.get(prop_id) if prop_id else None
            
            # Добавляем флаги актуальности
            cp_dict['is_sold'] = not live_prop.is_active if live_prop else True
            cp_dict['status_label'] = 'НЕ В ПРОДАЖЕ' if cp_dict['is_sold'] else ''
            
            # Опционально: обновляем денормализованные данные если объект актуален
            if live_prop and live_prop.is_active:
                cp_dict['current_price'] = live_prop.price
                cp_dict['current_area'] = live_prop.area
            
            properties_data.append(cp_dict)
        
        print(f"✅ DEBUG: Loaded {len(properties_data)} properties and {len(complex_ids)} complexes")
        
        return jsonify({
            'success': True,
            'properties': properties_data,
            'complexes': complex_ids,
            'properties_count': len(properties_data),
            'complexes_count': len(complex_ids)
        })
        
    except Exception as e:
        print(f"Error loading manager comparison: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500



@app.route('/api/comparison/replace-property', methods=['POST'])
@csrf.exempt
@login_required
def replace_comparison_property():
    """Replace a sold property in comparison with a similar one"""
    from models import ComparisonProperty, Property
    
    try:
        data = request.get_json()
        old_property_id = data.get('old_property_id')  # ID to replace
        new_property_id = data.get('new_property_id')  # Replacement ID
        comparison_id = data.get('comparison_id')
        
        if not all([old_property_id, new_property_id, comparison_id]):
            return jsonify({'success': False, 'error': 'Missing required parameters'}), 400
        
        # Find the comparison property to replace
        cp = ComparisonProperty.query.filter_by(
            user_comparison_id=comparison_id,
            property_id=str(old_property_id)
        ).first()
        
        if not cp:
            return jsonify({'success': False, 'error': 'Property not found in comparison'}), 404
        
        # Get the new property data
        new_prop = Property.query.filter_by(id=int(new_property_id)).first()
        if not new_prop:
            # Try by inner_id if database ID doesn't work
            new_prop = Property.query.filter_by(inner_id=str(new_property_id)).first()
        
        if not new_prop or not new_prop.is_active:
            return jsonify({'success': False, 'error': 'New property not found or inactive'}), 404
        
        # Update the comparison property with new data
        cp.property_id = str(new_prop.id)
        cp.property_name = f"{new_prop.rooms if new_prop.rooms else 'Студия'}, {new_prop.area} м²"
        cp.property_price = new_prop.price
        cp.area = new_prop.area
        cp.rooms = str(new_prop.rooms) if new_prop.rooms else '0'
        
        # Update complex name if available
        if new_prop.residential_complex:
            cp.complex_name = new_prop.residential_complex.name
        
        # Calculate cashback if available
        if new_prop.residential_complex and new_prop.price:
            cashback_rate = new_prop.residential_complex.cashback_rate or 5.0
            cp.cashback = int(new_prop.price * cashback_rate / 100)
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Property replaced successfully',
            'new_property': {
                'id': new_prop.id,
                'property_id': str(new_prop.id),
                'property_name': cp.property_name,
                'property_price': cp.property_price,
                'area': cp.area,
                'complex_name': cp.complex_name,
                'cashback': cp.cashback,
                'is_sold': False,
                'status_label': ''
            }
        })
    
    except Exception as e:
        db.session.rollback()
        print(f"Error replacing property: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/user/phone/send-verification', methods=['POST'])
@login_required
def send_phone_verification():
    """Send verification code to user's phone"""
    from models import User
    import random
    from datetime import datetime, timedelta
    from scripts.sms_service import send_verification_code_sms
    
    try:
        data = request.get_json()
        phone = data.get('phone')
        
        if not phone:
            return jsonify({'success': False, 'message': 'Номер телефона обязателен'}), 400
        
        # Generate 6-digit verification code
        code = ''.join([str(random.randint(0, 9)) for _ in range(6)])
        
        # Save code and expiration to user
        current_user.phone = phone
        current_user.phone_verification_code = code
        current_user.phone_verification_expires = datetime.utcnow() + timedelta(minutes=10)
        db.session.commit()
        
        # Send SMS
        sms_sent = send_verification_code_sms(phone, code)
        
        if sms_sent:
            return jsonify({
                'success': True,
                'message': 'Код отправлен на ваш номер'
            })
        else:
            return jsonify({
                'success': False,
                'message': 'Ошибка отправки SMS. Попробуйте позже.'
            }), 500
            
    except Exception as e:
        db.session.rollback()
        print(f"Error sending verification code: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/user/phone/verify-code', methods=['POST'])
@login_required
def verify_phone_code():
    """Verify phone number with code"""
    from models import User
    from datetime import datetime
    
    try:
        data = request.get_json()
        code = data.get('code')
        
        if not code:
            return jsonify({'success': False, 'message': 'Код обязателен'}), 400
        
        # Check if code matches and not expired
        if not current_user.phone_verification_code:
            return jsonify({'success': False, 'message': 'Код не был отправлен'}), 400
        
        if current_user.phone_verification_expires < datetime.utcnow():
            return jsonify({'success': False, 'message': 'Код истек. Запросите новый.'}), 400
        
        if current_user.phone_verification_code != code:
            return jsonify({'success': False, 'message': 'Неверный код'}), 400
        
        # Mark phone as verified
        current_user.phone_verified = True
        current_user.phone_verification_code = None
        current_user.phone_verification_expires = None
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Телефон успешно подтвержден!'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error verifying phone code: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

# ========================================
# PRESENTATION SHARING (Manager to Client)
# ========================================

@app.route('/api/manager/collection/<int:collection_id>/assign-client', methods=['POST'])
@manager_required
def assign_client_to_presentation(collection_id):
    """Assign client to presentation"""
    from models import Collection, User
    
    try:
        current_manager = current_user
        data = request.get_json()
        
        if not data or 'client_id' not in data:
            return jsonify({'success': False, 'error': 'ID клиента не указан'}), 400
        
        client_id = data['client_id']
        
        # Get collection
        collection = Collection.query.filter_by(
            id=collection_id,
            created_by_manager_id=current_manager.id
        ).first()
        
        if not collection:
            return jsonify({'success': False, 'error': 'Презентация не найдена'}), 404
        
        # Verify client exists and is assigned to this manager
        client = User.query.filter_by(id=client_id, assigned_manager_id=current_manager.id).first()
        
        if not client:
            return jsonify({'success': False, 'error': 'Клиент не найден или не закреплен за вами'}), 404
        
        # Assign client to presentation
        collection.assigned_to_user_id = client_id
        collection.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Клиент {client.full_name} назначен презентации'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error assigning client to presentation: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/collection/<int:collection_id>/send-to-client', methods=['POST'])
@manager_required
def send_presentation_to_client(collection_id):
    """Send presentation from manager to client's personal dashboard"""
    from models import Collection, User, UserNotification
    
    try:
        current_manager = current_user
        
        # Get collection
        collection = Collection.query.filter_by(
            id=collection_id,
            created_by_manager_id=current_manager.id
        ).first()
        
        if not collection:
            return jsonify({'success': False, 'error': 'Презентация не найдена'}), 404
        
        if not collection.assigned_to_user_id:
            return jsonify({'success': False, 'error': 'Клиент не назначен'}), 400
        
        if len(collection.properties) == 0:
            return jsonify({'success': False, 'error': 'В презентации нет объектов'}), 400
        
        # Update collection status
        collection.status = 'Отправлена'
        collection.sent_at = datetime.utcnow()
        collection.updated_at = datetime.utcnow()
        
        # Create notification for client
        notification = UserNotification(
            user_id=collection.assigned_to_user_id,
            title='📦 Новая презентация от менеджера',
            message=f'Менеджер отправил вам презентацию "{collection.title}" с {len(collection.properties)} объектами',
            notification_type='success',
            icon='fas fa-gift',
            action_url=f'/dashboard#presentations'
        )
        db.session.add(notification)
        
        # Логируем отправку презентации
        from models import UserActivity
        UserActivity.log_activity(
            user_id=collection.assigned_to_user_id,
            activity_type='presentation_received',
            description=f'Получена новая презентация от менеджера: {collection.title} ({len(collection.properties)} объектов)'
        )
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Презентация отправлена клиенту'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error sending presentation to client: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/user/presentation/<int:presentation_id>/delete', methods=['DELETE'])
@login_required
@csrf.exempt  # CSRF disabled for user DELETE actions
def delete_user_presentation(presentation_id):
    """Delete presentation from user's dashboard"""
    from models import Collection
    
    try:
        # Get collection
        collection = Collection.query.filter_by(
            id=presentation_id,
            assigned_to_user_id=current_user.id
        ).first()
        
        if not collection:
            return jsonify({'success': False, 'error': 'Презентация не найдена'}), 404
        
        # Delete the collection
        db.session.delete(collection)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Презентация удалена'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting presentation: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/deals')
def api_manager_deals_count():
    """Get deals data for manager with count - used for preloading deals tab counter"""
    from models import Deal
    
    try:
        # Check if current user is a manager
        if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
            return jsonify({
                'success': True,
                'deals': [],
                'total': 0,
                'is_manager': False
            })
        
        current_manager = current_user
        
        # Get all deals for this manager
        deals = Deal.query.filter_by(manager_id=current_manager.id).all()
        
        deals_data = []
        for deal in deals:
            deals_data.append({
                'id': deal.id,
                'deal_number': deal.deal_number,
                'client_name': deal.client.full_name if deal.client else 'Unknown',
                'property_description': deal.property_description,
                'property_price': deal.property_price,
                'cashback_amount': deal.cashback_amount,
                'status': deal.status,
                'created_at': deal.created_at.isoformat() if deal.created_at else None
            })
        
        return jsonify({
            'success': True,
            'deals': deals_data,
            'total': len(deals_data),
            'is_manager': True
        })
        
    except Exception as e:
        print(f"Error getting deals count: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/comparison/count')
def api_manager_comparison_count():
    """Get count of items in manager comparison for navigation counter"""
    from models import ManagerComparison, ComparisonProperty, ComparisonComplex
    
    try:
        # Check if current user is a manager
        if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
            return jsonify({
                'success': True,
                'properties_count': 0,
                'complexes_count': 0,
                'total_count': 0
            })
        
        current_manager = current_user
        
        # Find active manager comparison
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        if not manager_comparison:
            return jsonify({
                'success': True,
                'properties_count': 0,
                'complexes_count': 0,
                'total_count': 0
            })
        
        # Count properties and complexes
        properties_count = ComparisonProperty.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        complexes_count = ComparisonComplex.query.filter_by(
            manager_comparison_id=manager_comparison.id
        ).count()
        
        total_count = properties_count + complexes_count
        
        return jsonify({
            'success': True,
            'properties_count': properties_count,
            'complexes_count': complexes_count,
            'total_count': total_count
        })
        
    except Exception as e:
        print(f"Error getting manager comparison count: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/manager/generate-comparison-pdf', methods=['POST'])
@csrf.exempt
def api_manager_generate_comparison_pdf():
    """Generate HTML comparison document for manager to send to client"""
    try:
        from models import Manager
        from datetime import datetime
        
        data = request.get_json()
        
        recipient_name = data.get('recipient_name', 'Клиент')
        message_notes = data.get('message_notes', '')
        hide_complex_names = data.get('hide_complex_names', False)
        hide_developer_names = data.get('hide_developer_names', False)
        hide_addresses = data.get('hide_addresses', False)
        properties = data.get('properties', [])
        complexes = data.get('complexes', [])
        
        # Get current manager info
        manager = current_user if current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager) else None
        manager_name = manager.full_name if manager else "InBack Менеджер"
        manager_phone = manager.phone if manager else "8 (862) 266-62-16"
        manager_email = manager.email if manager else "info@inback.ru"
        
        # Get manager avatar with full URL for downloadable HTML
        if manager and manager.profile_image:
            # If it's already a full URL (http/https), use it
            if manager.profile_image.startswith('http'):
                manager_avatar = manager.profile_image
            else:
                # Convert relative path to absolute URL
                base_url = request.host_url.rstrip('/')
                manager_avatar = f"{base_url}{manager.profile_image}"
        else:
            manager_avatar = "https://randomuser.me/api/portraits/men/45.jpg"
        
        # Get current date and time
        now = datetime.now()
        date_str = now.strftime('%d.%m.%Y')
        time_str = now.strftime('%H:%M')
        
        print(f"📄 Generating comparison PDF: {len(properties)} properties, {len(complexes)} complexes")
        
        # Build HTML document for comparison
        html_content = f"""<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Сравнение недвижимости - {recipient_name}</title>
    <style>
        * {{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }}
        
        body {{
            font-family: 'Arial', 'Helvetica', sans-serif;
            line-height: 1.6;
            color: #000;
            background: #fff;
            padding: 40px 20px;
            max-width: 1200px;
            margin: 0 auto;
        }}
        
        /* Print styles */
        @media print {{
            body {{
                padding: 20px;
            }}
            .no-print {{
                display: none !important;
            }}
            .page-break {{
                page-break-after: always;
            }}
        }}
        
        /* Header */
        .header {{
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #000;
        }}
        
        .header h1 {{
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 5px;
        }}
        
        .header .subtitle {{
            font-size: 18px;
            color: #555;
            margin-bottom: 20px;
        }}
        
        /* Manager info */
        .manager-info {{
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
            padding: 20px;
            background: #f8f8f8;
            border-radius: 8px;
        }}
        
        .manager-avatar {{
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #333;
        }}
        
        .manager-details {{
            text-align: left;
        }}
        
        .manager-details p {{
            margin: 5px 0;
            font-size: 14px;
        }}
        
        .manager-details strong {{
            font-weight: bold;
        }}
        
        /* Recipient info */
        .recipient-info {{
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            font-size: 16px;
        }}
        
        .recipient-info strong {{
            font-weight: bold;
        }}
        
        /* Notes */
        .notes {{
            margin: 20px 0;
            padding: 15px;
            background: #f0f0f0;
            border-left: 4px solid #333;
        }}
        
        .notes strong {{
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
        }}
        
        /* Section title */
        .section-title {{
            font-size: 20px;
            font-weight: bold;
            margin: 30px 0 15px 0;
            padding: 10px 0;
            border-bottom: 2px solid #000;
        }}
        
        /* Table */
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 12px;
        }}
        
        table th {{
            background: #f0f0f0;
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            font-weight: bold;
        }}
        
        table td {{
            border: 1px solid #ddd;
            padding: 10px;
            vertical-align: top;
        }}
        
        table tr:nth-child(even) {{
            background: #f9f9f9;
        }}
        
        table .label-col {{
            font-weight: bold;
            background: #f5f5f5;
            width: 180px;
        }}
        
        /* Footer */
        .footer {{
            text-align: center;
            margin-top: 50px;
            padding-top: 20px;
            border-top: 2px solid #000;
            font-size: 14px;
        }}
        
        .footer p {{
            margin: 5px 0;
        }}
        
        /* Print button */
        .print-btn {{
            position: fixed;
            top: 20px;
            right: 20px;
            background: #000;
            color: #fff;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 1000;
        }}
        
        .print-btn:hover {{
            background: #333;
        }}
        
        /* Sold property styles */
        .sold-property {{
            opacity: 0.6;
            background-color: #f3f4f6 !important;
        }}
        .sold-badge {{
            background: #dc2626;
            color: white;
            padding: 4px 12px;
            border-radius: 6px;
            font-weight: 600;
            display: inline-block;
            margin-left: 10px;
        }}
        .sold-text {{
            text-decoration: line-through;
            color: #6b7280;
        }}
        
    </style>
</head>
<body>
    <button onclick="window.print()" class="print-btn no-print">🖨️ Печать</button>
    
    <div class="header">
        <h1>InBack Недвижимость</h1>
        <div class="subtitle">Сравнение объектов недвижимости</div>
    </div>
    
    <div class="manager-info">
        <img src="{manager_avatar}" alt="Фото менеджера" class="manager-avatar">
        <div class="manager-details">
            <p><strong>Ваш персональный менеджер: {manager_name}</strong></p>
            <p>Телефон: {manager_phone}</p>
            <p>Email: {manager_email}</p>
        </div>
    </div>
    
    <div class="recipient-info">
        <p><strong>Подготовлено для: {recipient_name}</strong></p>
        <p>Дата: {date_str} в {time_str}</p>
    </div>
"""
        
        # Add notes if provided
        if message_notes:
            html_content += f"""
    <div class="notes">
        <strong>Заметки:</strong>
        <p>{message_notes}</p>
    </div>
"""
        
        # Add properties comparison table (vertical layout)
        if properties and len(properties) > 0:
            html_content += """
    <h2 class="section-title">Сравнение квартир</h2>
    <table>
        <thead>
            <tr>
                <th class="label-col">Характеристика</th>"""
            
            # Add column headers for each property
            for i, prop in enumerate(properties, 1):
                is_sold = prop.get('is_sold', False)
                header_text = f"Объект {i}"
                if is_sold:
                    header_text += ' <span class="sold-badge">ПРОДАН</span>'
                html_content += f"\n                <th>{header_text}</th>"
            
            html_content += """
            </tr>
        </thead>
        <tbody>
"""
            
            # Row: Название
            html_content += """
            <tr>
                <td class="label-col">Название</td>"""
            for prop in properties:
                name = prop.get('property_name', 'Не указано')
                is_sold = prop.get('is_sold', False)
                if is_sold:
                    html_content += f"\n                <td class=\"sold-text\">{name}</td>"
                else:
                    html_content += f"\n                <td>{name}</td>"
            html_content += "\n            </tr>"
            
            # Row: ЖК (if not hidden)
            if not hide_complex_names:
                html_content += """
            <tr>
                <td class="label-col">ЖК</td>"""
                for prop in properties:
                    html_content += f"\n                <td>{prop.get('complex_name', 'Не указано')}</td>"
                html_content += "\n            </tr>"
            
            # Row: Цена
            html_content += """
            <tr>
                <td class="label-col">Цена</td>"""
            for prop in properties:
                price = prop.get('property_price', 0)
                is_sold = prop.get('is_sold', False)
                if is_sold:
                    html_content += f"\n                <td class=\"sold-text\">{price:,.0f} ₽</td>"
                else:
                    html_content += f"\n                <td>{price:,.0f} ₽</td>"
            html_content += "\n            </tr>"
            
            # Row: Площадь
            html_content += """
            <tr>
                <td class="label-col">Площадь</td>"""
            for prop in properties:
                size = prop.get('property_size', 'Не указано')
                html_content += f"\n                <td>{size} м²</td>"
            html_content += "\n            </tr>"
            
            # Row: Комнаты
            html_content += """
            <tr>
                <td class="label-col">Комнаты</td>"""
            for prop in properties:
                rooms = prop.get('rooms', 'Не указано')
                # Show "Студия" instead of "0"
                if rooms == 0 or rooms == '0':
                    rooms_display = 'Студия'
                else:
                    rooms_display = rooms
                html_content += f"\n                <td>{rooms_display}</td>"
            html_content += "\n            </tr>"
            
            # Row: Этаж
            html_content += """
            <tr>
                <td class="label-col">Этаж</td>"""
            for prop in properties:
                floor = prop.get('floor', 'Не указано')
                html_content += f"\n                <td>{floor}</td>"
            html_content += "\n            </tr>"
            
            # Row: Всего этажей
            html_content += """
            <tr>
                <td class="label-col">Всего этажей</td>"""
            for prop in properties:
                total_floors = prop.get('total_floors', 'Не указано')
                html_content += f"\n                <td>{total_floors}</td>"
            html_content += "\n            </tr>"
            
            # Row: Район
            html_content += """
            <tr>
                <td class="label-col">Район</td>"""
            for prop in properties:
                district = prop.get('district', 'Не указано')
                html_content += f"\n                <td>{district}</td>"
            html_content += "\n            </tr>"
            
            # Row: Застройщик (if not hidden)
            if not hide_developer_names:
                html_content += """
            <tr>
                <td class="label-col">Застройщик</td>"""
                for prop in properties:
                    developer = prop.get('developer_name', 'Не указано')
                    html_content += f"\n                <td>{developer}</td>"
                html_content += "\n            </tr>"
            
            # Row: Адрес (if not hidden)
            if not hide_addresses:
                html_content += """
            <tr>
                <td class="label-col">Адрес</td>"""
                for prop in properties:
                    address = prop.get('address', 'Не указано')
                    html_content += f"\n                <td>{address}</td>"
                html_content += "\n            </tr>"
            
            html_content += """
        </tbody>
    </table>
"""
        
        # Add complexes comparison table (vertical layout)
        if complexes and len(complexes) > 0:
            html_content += """
    <div class="page-break"></div>
    <h2 class="section-title">Сравнение жилых комплексов</h2>
    <table>
        <thead>
            <tr>
                <th class="label-col">Характеристика</th>"""
            
            # Add column headers for each complex
            for i, complex_data in enumerate(complexes, 1):
                is_sold = complex_data.get('is_sold', False)
                header_text = f"ЖК {i}"
                if is_sold:
                    header_text += ' <span class="sold-badge">ПРОДАН</span>'
                html_content += f"\n                <th>{header_text}</th>"
            
            html_content += """
            </tr>
        </thead>
        <tbody>
"""
            
            # Row: Название ЖК
            if not hide_complex_names:
                html_content += """
            <tr>
                <td class="label-col">Название ЖК</td>"""
                for complex_data in complexes:
                    name = complex_data.get('name', 'Не указано')
                    is_sold = complex_data.get('is_sold', False)
                    if is_sold:
                        html_content += f"\n                <td class=\"sold-text\"><strong>{name}</strong></td>"
                    else:
                        html_content += f"\n                <td><strong>{name}</strong></td>"
                html_content += "\n            </tr>"
            
            # Row: Класс жилья
            html_content += """
            <tr>
                <td class="label-col">Класс жилья</td>"""
            for complex_data in complexes:
                obj_class = complex_data.get('object_class', 'Не указано')
                html_content += f"\n                <td>{obj_class}</td>"
            html_content += "\n            </tr>"
            
            # Row: Цена от
            html_content += """
            <tr>
                <td class="label-col">Цена от</td>"""
            for complex_data in complexes:
                min_price = complex_data.get('min_price', 0)
                is_sold = complex_data.get('is_sold', False)
                if is_sold:
                    html_content += f"\n                <td class=\"sold-text\">{min_price:,.0f} ₽</td>"
                else:
                    html_content += f"\n                <td>{min_price:,.0f} ₽</td>"
            html_content += "\n            </tr>"
            
            # Row: Цена до
            html_content += """
            <tr>
                <td class="label-col">Цена до</td>"""
            for complex_data in complexes:
                max_price = complex_data.get('max_price', 0)
                is_sold = complex_data.get('is_sold', False)
                if is_sold:
                    html_content += f"\n                <td class=\"sold-text\">{max_price:,.0f} ₽</td>"
                else:
                    html_content += f"\n                <td>{max_price:,.0f} ₽</td>"
            html_content += "\n            </tr>"
            
            # Row: Срок сдачи
            html_content += """
            <tr>
                <td class="label-col">Срок сдачи</td>"""
            for complex_data in complexes:
                completion = complex_data.get('completion_date', 'Не указано')
                html_content += f"\n                <td>{completion}</td>"
            html_content += "\n            </tr>"
            
            # Row: Кешбек
            html_content += """
            <tr>
                <td class="label-col">Кешбек</td>"""
            for complex_data in complexes:
                cashback_rate = complex_data.get('cashback_rate', 0)
                html_content += f"\n                <td>{cashback_rate}%</td>"
            html_content += "\n            </tr>"
            
            # Row: Застройщик (if not hidden)
            if not hide_developer_names:
                html_content += """
            <tr>
                <td class="label-col">Застройщик</td>"""
                for complex_data in complexes:
                    developer = complex_data.get('developer', 'Не указано')
                    html_content += f"\n                <td>{developer}</td>"
                html_content += "\n            </tr>"
            
            # Row: Адрес (if not hidden)
            if not hide_addresses:
                html_content += """
            <tr>
                <td class="label-col">Адрес</td>"""
                for complex_data in complexes:
                    address = complex_data.get('address', 'Не указано')
                    html_content += f"\n                <td>{address}</td>"
                html_content += "\n            </tr>"
            
            html_content += """
        </tbody>
    </table>
"""
        
        # Add footer
        html_content += f"""
    <div class="footer">
        <p><strong>InBack.ru</strong> - ваш кешбек за новостройки</p>
        <p>Документ создан {date_str} в {time_str}</p>
    </div>
</body>
</html>
"""
        
        # Return HTML for download
        response = app.response_class(
            response=html_content,
            status=200,
            mimetype='text/html; charset=utf-8'
        )
        
        # Set download filename with safe ASCII characters
        from datetime import datetime
        from unidecode import unidecode
        timestamp = datetime.now().strftime('%Y-%m-%d')
        # Convert recipient name to ASCII to avoid encoding issues
        safe_name = unidecode(recipient_name).replace(' ', '_')
        ascii_filename = f'Sravnenie_{safe_name}_{timestamp}.html'
        
        response.headers['Content-Disposition'] = f'attachment; filename="{ascii_filename}"'
        
        print(f"✅ Comparison HTML generated successfully")
        return response
        
    except Exception as e:
        print(f"❌ Error generating comparison PDF: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': 'Failed to generate comparison document', 'details': str(e)}), 500

@app.route('/api/recommendations/<int:rec_id>/respond', methods=['POST'])
@login_required
def api_respond_to_recommendation(rec_id):
    """Client responds to recommendation with interest/not interested"""
    from models import Recommendation
    from datetime import datetime
    
    try:
        data = request.get_json()
        response_type = data.get('response')  # 'interested' or 'not_interested'
        
        if response_type not in ['interested', 'not_interested']:
            return jsonify({'success': False, 'error': 'Неверный тип ответа'}), 400
            
        recommendation = Recommendation.query.filter_by(
            id=rec_id,
            client_id=current_user.id
        ).first()
        
        if not recommendation:
            return jsonify({'success': False, 'error': 'Рекомендация не найдена'}), 404
            
        recommendation.status = response_type
        recommendation.client_response = response_type
        recommendation.responded_at = datetime.utcnow()
        
        db.session.commit()
        
        # Notify manager about client response
        if recommendation.manager:
            try:
                from email_service import send_notification
                subject = f"Ответ клиента на рекомендацию: {recommendation.title}"
                message = f"""
Клиент {current_user.full_name} ответил на вашу рекомендацию:

Рекомендация: {recommendation.title}
Объект: {recommendation.item_name}
Ответ: {'Интересно' if response_type == 'interested' else 'Не интересно'}

Время ответа: {datetime.now().strftime('%d.%m.%Y %H:%M')}
"""
                send_notification(
                    recommendation.manager.email,
                    subject,
                    message,
                    notification_type="client_response"
                )
            except Exception as e:
                print(f"Error sending notification to manager: {e}")
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/manager/recommendation-categories/<int:client_id>', methods=['GET'])
def api_get_recommendation_categories(client_id):
    """Get recommendation categories for a specific client"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
        return jsonify({'success': False, 'error': 'Требуется авторизация менеджера'}), 401
    
    current_manager = current_user
    
    try:
        categories = RecommendationCategory.query.filter_by(
            manager_id=current_manager.id,
            client_id=client_id,
            is_active=True
        ).order_by(RecommendationCategory.last_used.desc()).all()
        
        categories_data = []
        for category in categories:
            categories_data.append({
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'color': category.color,
                'recommendations_count': category.recommendations_count,
                'last_used': category.last_used.strftime('%d.%m.%Y') if category.last_used else '',
                'created_at': category.created_at.strftime('%d.%m.%Y') if category.created_at else ''
            })
        
        return jsonify({
            'success': True,
            'categories': categories_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/recommendation-categories', methods=['POST'])
def api_create_recommendation_category():
    """Create new recommendation category"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
        return jsonify({'success': False, 'error': 'Требуется авторизация менеджера'}), 401
    
    current_manager = current_user
    
    try:
        data = request.get_json()
        category_name = data.get('name', '').strip()
        client_id = data.get('client_id')
        description = data.get('description', '').strip()
        color = data.get('color', 'blue')
        
        if not category_name or not client_id:
            return jsonify({'success': False, 'error': 'Название категории и клиент обязательны'}), 400
        
        # Check if category with this name already exists for this client
        existing = RecommendationCategory.query.filter_by(
            manager_id=current_manager.id,
            client_id=client_id,
            name=category_name,
            is_active=True
        ).first()
        
        if existing:
            return jsonify({'success': False, 'error': 'Категория с таким названием уже существует'}), 400
        
        # Create new category
        category = RecommendationCategory(
            name=category_name,
            description=description,
            manager_id=current_manager.id,
            client_id=client_id,
            color=color
        )
        
        db.session.add(category)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'category': {
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'color': category.color,
                'recommendations_count': 0,
                'created_at': category.created_at.strftime('%d.%m.%Y')
            }
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/all-categories', methods=['GET'])
def api_manager_all_categories():
    """Get all categories created by this manager"""
    from models import RecommendationCategory, User
    
    # Check if user is authenticated as manager
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
        return jsonify({'success': False, 'error': 'Требуется авторизация менеджера'}), 401
    
    current_manager = current_user
    
    try:
        categories = db.session.query(
            RecommendationCategory, 
            User.email.label('client_email')
        ).outerjoin(
            User, RecommendationCategory.client_id == User.id
        ).filter(
            RecommendationCategory.manager_id == current_manager.id
        ).order_by(
            RecommendationCategory.last_used.desc().nulls_last(),
            RecommendationCategory.created_at.desc()
        ).all()
        
        category_data = []
        for category, client_email in categories:
            category_data.append({
                'id': category.id,
                'name': category.name,
                'description': category.description,
                'client_email': client_email or 'Общая категория',
                'recommendations_count': category.recommendations_count,
                'is_active': category.is_active,
                'last_used': category.last_used.isoformat() if category.last_used else None,
                'created_at': category.created_at.isoformat()
            })
        
        return jsonify({
            'success': True,
            'categories': category_data
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/categories/global', methods=['POST'])
def api_manager_create_global_category():
    """Create a new global category template"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
        return jsonify({'success': False, 'error': 'Требуется авторизация менеджера'}), 401
    
    current_manager = current_user
    
    data = request.get_json()
    name = data.get('name', '').strip()
    description = data.get('description', '').strip()
    
    if not name:
        return jsonify({'success': False, 'error': 'Укажите название категории'}), 400
    
    try:
        # Create a template category without specific client
        category = RecommendationCategory(
            name=name,
            description=description,
            manager_id=current_manager.id,
            client_id=None,  # Global template
            is_template=True,
            recommendations_count=0
        )
        
        db.session.add(category)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'category': {
                'id': category.id,
                'name': category.name,
                'description': category.description
            }
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/categories/<int:category_id>/toggle', methods=['POST'])
def api_manager_toggle_category(category_id):
    """Toggle category active status"""
    from models import RecommendationCategory
    
    # Check if user is authenticated as manager
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Manager):
        return jsonify({'success': False, 'error': 'Требуется авторизация менеджера'}), 401
    
    current_manager = current_user
    
    data = request.get_json()
    is_active = data.get('is_active', True)
    
    try:
        category = RecommendationCategory.query.filter_by(
            id=category_id,
            manager_id=current_manager.id
        ).first()
        
        if not category:
            return jsonify({'success': False, 'error': 'Категория не найдена'}), 404
        
        category.is_active = is_active
        db.session.commit()
        
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

# Manager Dashboard API endpoints
@app.route('/api/manager/welcome-message', methods=['GET'])
@manager_required
def api_manager_welcome_message():
    """Get adaptive welcome message based on recent activity"""
    from models import User, Recommendation, Collection, SavedSearch, Manager
    from sqlalchemy import func, desc
    from datetime import datetime, timedelta
    
    current_manager = current_user
    
    if not current_manager:
        return jsonify({'success': False, 'error': 'Менеджер не найден'}), 404
    
    try:
        now = datetime.now()
        today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        week_start = today_start - timedelta(days=7)
        
        # Get recent activity counts
        recent_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == current_manager.id,
            Recommendation.created_at >= week_start
        ).count()
        
        today_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == current_manager.id,
            Recommendation.created_at >= today_start
        ).count()
        
        recent_collections = Collection.query.filter(
            Collection.created_by_manager_id == current_manager.id,
            Collection.created_at >= week_start
        ).count()
        
        total_clients = User.query.filter_by(assigned_manager_id=current_manager.id).count()
        
        new_clients_today = User.query.filter(
            User.assigned_manager_id == current_manager.id,
            User.created_at >= today_start
        ).count()
        
        # Get last activity time (use created_at if last_login_at doesn't exist)
        last_activity = getattr(current_manager, 'last_login_at', None) or current_manager.created_at
        hours_since_last_login = (now - last_activity).total_seconds() / 3600 if last_activity else 0
        
        # Get most recent activity
        latest_recommendation = Recommendation.query.filter_by(manager_id=current_manager.id).order_by(desc(Recommendation.created_at)).first()
        latest_collection = Collection.query.filter_by(created_by_manager_id=current_manager.id).order_by(desc(Collection.created_at)).first()
        
        # Generate adaptive message based on activity patterns
        messages = []
        
        # Time-based greeting
        hour = now.hour
        if 5 <= hour < 12:
            time_greeting = "Доброе утро"
        elif 12 <= hour < 18:
            time_greeting = "Добрый день"
        elif 18 <= hour < 23:
            time_greeting = "Добрый вечер"
        else:
            time_greeting = "Доброй ночи"
        
        first_name = current_manager.full_name.split()[0] if current_manager.full_name else 'Коллега'
        
        # Activity-based messages
        if hours_since_last_login >= 24:
            messages.append(f"{time_greeting}, {first_name}! Рады видеть вас снова.")
            if recent_recommendations > 0:
                messages.append(f"За время вашего отсутствия было отправлено {recent_recommendations} рекомендаций.")
        elif hours_since_last_login >= 8:
            messages.append(f"{time_greeting}, {first_name}! Добро пожаловать обратно.")
        else:
            messages.append(f"{time_greeting}, {first_name}!")
        
        # Recent activity highlights
        if today_recommendations > 0:
            messages.append(f"Сегодня вы уже отправили {today_recommendations} рекомендаций - отличная работа!")
        elif recent_recommendations > 0:
            messages.append(f"На этой неделе вы отправили {recent_recommendations} рекомендаций клиентам.")
        
        if new_clients_today > 0:
            messages.append(f"У вас {new_clients_today} новых клиентов сегодня.")
        
        if recent_collections > 0:
            messages.append(f"Создано {recent_collections} новых подборок на этой неделе.")
        
        # Motivational suggestions based on activity
        if recent_recommendations == 0 and recent_collections == 0:
            messages.append("Готовы создать новую подборку для клиентов?")
        elif total_clients > 0 and recent_recommendations < 3:
            messages.append("Возможно, стоит отправить рекомендации активным клиентам?")
        
        # Default fallback
        if len(messages) == 1:  # Only greeting
            messages.append("Панель управления менеджера недвижимости готова к работе.")
        
        # Activity context for additional UI hints
        activity_context = {
            'has_recent_activity': recent_recommendations > 0 or recent_collections > 0,
            'needs_attention': total_clients > 0 and recent_recommendations == 0,
            'high_activity': recent_recommendations >= 5 or recent_collections >= 3,
            'new_day': hours_since_last_login >= 8,
            'latest_recommendation_date': latest_recommendation.created_at.strftime('%d.%m.%Y') if latest_recommendation else None,
            'latest_collection_date': latest_collection.created_at.strftime('%d.%m.%Y') if latest_collection else None
        }
        
        return jsonify({
            'success': True,
            'messages': messages,
            'context': activity_context,
            'stats': {
                'recent_recommendations': recent_recommendations,
                'today_recommendations': today_recommendations,
                'recent_collections': recent_collections,
                'total_clients': total_clients,
                'new_clients_today': new_clients_today
            }
        })
        
    except Exception as e:
        print(f"Error generating welcome message: {e}")
        return jsonify({
            'success': True,
            'messages': [f"{time_greeting}, {first_name}!", "Панель управления менеджера недвижимости"],
            'context': {'has_recent_activity': False},
            'stats': {}
        })

@app.route('/api/manager/dashboard-stats', methods=['GET'])
@login_required
@manager_required
def api_manager_dashboard_stats():
    """Get manager dashboard statistics"""
    from models import User, Recommendation
    from sqlalchemy import func
    
    current_manager = current_user
    
    try:
        # Count clients assigned to this manager
        clients_count = User.query.filter_by(assigned_manager_id=current_manager.id).count()
        
        # Count recommendations sent by this manager
        recommendations_count = Recommendation.query.filter_by(manager_id=current_manager.id).count()
        
        # Count recommendations sent this month
        from datetime import datetime
        month_start = datetime.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        monthly_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == current_manager.id,
            Recommendation.sent_at >= month_start
        ).count()
        
        # Collections count (placeholder for now)
        collections_count = 5
        
        return jsonify({
            'success': True,
            'clients_count': clients_count,
            'recommendations_count': monthly_recommendations,
            'total_recommendations': recommendations_count,
            'collections_count': collections_count
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/activity-feed', methods=['GET'])
@manager_required
def api_manager_activity_feed():
    """Get manager activity feed"""
    from models import Recommendation, User, ManagerNotification
    from datetime import datetime, timedelta
    
    current_manager = current_user
    
    try:
        # Get recent activities (recommendations sent)
        from sqlalchemy.orm import joinedload
        recent_recommendations = Recommendation.query.filter_by(
            manager_id=current_manager.id
        ).options(joinedload(Recommendation.client)).order_by(Recommendation.sent_at.desc()).limit(10).all()
        
        # Получаем последние уведомления менеджера
        recent_notifications = ManagerNotification.query.filter_by(
            manager_id=current_manager.id
        ).order_by(ManagerNotification.created_at.desc()).limit(15).all()
        
        # Функция для форматирования времени
        def format_time_ago(timestamp):
            time_diff = datetime.utcnow() - timestamp
            if time_diff.days > 0:
                return f"{time_diff.days} дн. назад"
            elif time_diff.seconds > 3600:
                return f"{time_diff.seconds // 3600} ч. назад"
            else:
                return f"{time_diff.seconds // 60} мин. назад"
        
        # Создаем общий список с временными метками для сортировки
        all_activities = []
        
        # Добавляем уведомления
        for notification in recent_notifications:
            all_activities.append({
                'timestamp': notification.created_at,
                'activity': {
                    'title': notification.title,
                    'description': notification.message,
                    'time_ago': format_time_ago(notification.created_at),
                    'icon': 'eye' if notification.notification_type == 'presentation_view' else 'bell',
                    'color': 'purple' if notification.notification_type == 'presentation_view' else 'gray',
                    'is_read': notification.is_read,
                    'notification_id': notification.id,
                    'type': 'notification'
                }
            })
        
        # Добавляем рекомендации
        for rec in recent_recommendations:
            client_name = rec.client.full_name if rec.client and hasattr(rec.client, 'full_name') else 'Клиент'
            all_activities.append({
                'timestamp': rec.sent_at,
                'activity': {
                    'title': f'Отправлена рекомендация',
                    'description': f'{rec.title} для {client_name}',
                    'time_ago': format_time_ago(rec.sent_at),
                    'icon': 'paper-plane',
                    'color': 'blue',
                    'type': 'recommendation'
                }
            })
        
        # Сортируем по времени и берем только активности
        all_activities.sort(key=lambda x: x['timestamp'], reverse=True)
        activities = [item['activity'] for item in all_activities[:10]]  # Берем топ 10
        
        # Добавляем демо активности только если реальных активностей мало
        if len(activities) < 2:
            activities.extend([
                {
                    'title': 'Новый клиент добавлен',
                    'description': 'Демо Клиентов зарегистрировался в системе',
                    'time_ago': '2 ч. назад',
                    'icon': 'user-plus',
                    'color': 'green'
                },
                {
                    'title': 'Клиент просмотрел рекомендацию',
                    'description': 'Демо Клиентов открыл рекомендацию по ЖК "Солнечный"',
                    'time_ago': '4 ч. назад',
                    'icon': 'eye',
                    'color': 'purple'
                }
            ])
        
        return jsonify({
            'success': True,
            'activities': activities
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

@app.route('/api/manager/dashboard/all', methods=['GET'])
@manager_required
def api_manager_dashboard_all():
    """Агрегированный endpoint для быстрой загрузки панели менеджера - все данные за один запрос"""
    from models import (User, Recommendation, ManagerSavedSearch, Deal, ManagerComparison, 
                       ComparisonProperty, ComparisonComplex, ManagerFavoriteProperty, ManagerFavoriteComplex,
                       ManagerNotification, Manager)
    from sqlalchemy import func
    from datetime import datetime, timedelta
    
    current_manager = current_user
    
    try:
        # ===== 1. CLIENTS =====
        clients = User.query.filter_by(assigned_manager_id=current_manager.id).all()
        clients_data = [{
            'id': client.id,
            'full_name': client.full_name,
            'email': client.email,
            'phone': client.phone or '',
            'status': client.status if hasattr(client, 'status') else 'active',
            'search_preferences': client.search_preferences if hasattr(client, 'search_preferences') else None,
            'created_at': client.created_at.isoformat() if client.created_at else None
        } for client in clients]
        
        # ===== 2. WELCOME MESSAGE =====
        import pytz
        moscow_tz = pytz.timezone('Europe/Moscow')
        now_utc = datetime.utcnow()
        now_moscow = now_utc.replace(tzinfo=pytz.UTC).astimezone(moscow_tz)
        hour = now_moscow.hour
        
        if 5 <= hour < 12:
            time_greeting = "Доброе утро"
        elif 12 <= hour < 18:
            time_greeting = "Добрый день"
        else:
            time_greeting = "Добрый вечер"
        
        first_name = current_manager.full_name.split()[0] if current_manager.full_name else 'Менеджер'
        
        today = datetime.utcnow().date()
        week_ago = datetime.utcnow() - timedelta(days=7)
        
        recent_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == current_manager.id,
            Recommendation.sent_at >= week_ago
        ).count()
        
        today_recommendations = Recommendation.query.filter(
            Recommendation.manager_id == current_manager.id,
            func.date(Recommendation.sent_at) == today
        ).count()
        
        total_clients = len(clients_data)
        new_clients_today = User.query.filter(
            User.assigned_manager_id == current_manager.id,
            func.date(User.created_at) == today
        ).count()
        
        messages = [f"{time_greeting}, {first_name}! Рады видеть вас снова."]
        
        if new_clients_today > 0:
            messages.append(f"У вас {new_clients_today} новых клиентов сегодня!")
        elif recent_recommendations == 0:
            messages.append("Готовы создать новую подборку для клиентов?")
        elif today_recommendations > 0:
            messages.append(f"Отлично! Сегодня отправлено {today_recommendations} рекомендаций.")
        else:
            messages.append(f"На этой неделе отправлено {recent_recommendations} рекомендаций.")
        
        # ===== 3. ACTIVITY FEED =====
        from sqlalchemy.orm import joinedload
        recent_recs = Recommendation.query.filter_by(
            manager_id=current_manager.id
        ).options(joinedload(Recommendation.client)).order_by(Recommendation.sent_at.desc()).limit(10).all()
        
        recent_notifications = ManagerNotification.query.filter_by(
            manager_id=current_manager.id
        ).order_by(ManagerNotification.created_at.desc()).limit(15).all()
        
        def format_time_ago(timestamp):
            time_diff = datetime.utcnow() - timestamp
            if time_diff.days > 0:
                return f"{time_diff.days} дн. назад"
            elif time_diff.seconds > 3600:
                return f"{time_diff.seconds // 3600} ч. назад"
            else:
                return f"{time_diff.seconds // 60} мин. назад"
        
        all_activities = []
        
        for notification in recent_notifications:
            all_activities.append({
                'timestamp': notification.created_at,
                'activity': {
                    'title': notification.title,
                    'description': notification.message,
                    'time_ago': format_time_ago(notification.created_at),
                    'icon': 'eye' if notification.notification_type == 'presentation_view' else 'bell',
                    'color': 'purple' if notification.notification_type == 'presentation_view' else 'gray',
                    'is_read': notification.is_read,
                    'notification_id': notification.id,
                    'type': 'notification'
                }
            })
        
        for rec in recent_recs:
            client_name = rec.client.full_name if rec.client and hasattr(rec.client, 'full_name') else 'Клиент'
            all_activities.append({
                'timestamp': rec.sent_at,
                'activity': {
                    'title': 'Отправлена рекомендация',
                    'description': f'{rec.title} для {client_name}',
                    'time_ago': format_time_ago(rec.sent_at),
                    'icon': 'paper-plane',
                    'color': 'blue',
                    'type': 'recommendation'
                }
            })
        
        all_activities.sort(key=lambda x: x['timestamp'], reverse=True)
        activities = [item['activity'] for item in all_activities[:10]]
        
        if len(activities) < 2:
            activities.extend([
                {
                    'title': 'Новый клиент добавлен',
                    'description': 'Демо Клиентов зарегистрировался в системе',
                    'time_ago': '2 ч. назад',
                    'icon': 'user-plus',
                    'color': 'green'
                },
                {
                    'title': 'Клиент просмотрел рекомендацию',
                    'description': 'Демо Клиентов открыл рекомендацию по ЖК "Солнечный"',
                    'time_ago': '4 ч. назад',
                    'icon': 'eye',
                    'color': 'purple'
                }
            ])
        
        # ===== 4. FAVORITES COUNT =====
        properties_count = ManagerFavoriteProperty.query.filter_by(manager_id=current_manager.id).count()
        complexes_count = ManagerFavoriteComplex.query.filter_by(manager_id=current_manager.id).count()
        
        # ===== 5. SAVED SEARCHES =====
        saved_searches = ManagerSavedSearch.query.filter_by(manager_id=current_manager.id).order_by(ManagerSavedSearch.created_at.desc()).all()
        searches_data = [{
            'id': search.id,
            'name': search.name,
            'filters': json.loads(search.additional_filters) if search.additional_filters else {},
            'created_at': search.created_at.strftime('%d.%m.%Y')
        } for search in saved_searches]
        
        # ===== 6. RECOMMENDATIONS =====
        recommendations = Recommendation.query.filter_by(manager_id=current_manager.id).order_by(Recommendation.sent_at.desc()).limit(10).all()
        recs_data = []
        for rec in recommendations:
            client = User.query.get(rec.client_id) if rec.client_id else None
            recs_data.append({
                'id': rec.id,
                'title': rec.title,
                'client_name': client.full_name if client else 'Клиент удален',
                'sent_at': rec.sent_at.strftime('%d.%m.%Y в %H:%M'),
                'status': rec.status,
                'properties_count': len(rec.properties) if hasattr(rec, 'properties') else 0
            })
        
        # ===== 7. DEALS COUNT =====
        deals_count = Deal.query.filter_by(manager_id=current_manager.id).count()
        
        # ===== 8. COMPARISON COUNT =====
        manager_comparison = ManagerComparison.query.filter_by(
            manager_id=current_manager.id,
            is_active=True
        ).first()
        
        comparison_props = 0
        comparison_complexes = 0
        if manager_comparison:
            comparison_props = ComparisonProperty.query.filter_by(manager_comparison_id=manager_comparison.id).count()
            comparison_complexes = ComparisonComplex.query.filter_by(manager_comparison_id=manager_comparison.id).count()
        
        return jsonify({
            'success': True,
            'clients': clients_data,
            'welcome': {
                'messages': messages,
                'stats': {
                    'recent_recommendations': recent_recommendations,
                    'today_recommendations': today_recommendations,
                    'total_clients': total_clients,
                    'new_clients_today': new_clients_today
                }
            },
            'activities': activities,
            'favorites': {
                'properties_count': properties_count,
                'complexes_count': complexes_count,
                'total_count': properties_count + complexes_count
            },
            'saved_searches': {
                'count': len(searches_data),
                'searches': searches_data
            },
            'recommendations': recs_data,
            'deals_count': deals_count,
            'comparison': {
                'properties_count': comparison_props,
                'complexes_count': comparison_complexes,
                'total_count': comparison_props + comparison_complexes
            }
        })
        
    except Exception as e:
        import traceback
        print(f"Error loading manager dashboard data: {e}")
        print(traceback.format_exc())
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/manager/top-clients', methods=['GET'])
@login_required
@manager_required
def api_manager_top_clients():
    """Get top clients by interactions"""
    from models import User, Recommendation
    from sqlalchemy import func
    
    current_manager = current_user
    
    try:
        # Get clients with most interactions (recommendations received)
        top_clients = db.session.query(
            User,
            func.count(Recommendation.id).label('interactions_count')
        ).join(
            Recommendation, User.id == Recommendation.client_id
        ).filter(
            Recommendation.manager_id == current_manager.id
        ).group_by(User.id).order_by(
            func.count(Recommendation.id).desc()
        ).limit(5).all()
        
        clients_data = []
        for user, count in top_clients:
            clients_data.append({
                'id': user.id,
                'full_name': user.full_name,
                'email': user.email,
                'interactions_count': count
            })
        
        # Add demo clients if not enough data
        if len(clients_data) < 3:
            demo_clients = [
                {'id': 999, 'full_name': 'Демо Клиентов', 'email': 'demo@inback.ru', 'interactions_count': 8},
                {'id': 998, 'full_name': 'Анна Покупателева', 'email': 'buyer@test.ru', 'interactions_count': 5},
                {'id': 997, 'full_name': 'Петр Инвесторов', 'email': 'investor@test.ru', 'interactions_count': 3}
            ]
            clients_data.extend(demo_clients[:3-len(clients_data)])
        
        return jsonify({
            'success': True,
            'clients': clients_data
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400

# Blog Management Routes for Managers
@app.route('/admin/blog-manager')
@manager_required
def admin_blog_manager():
    """Manager blog management page"""
    from models import BlogArticle, Category
    
    try:
        # Get filter parameters
        search = request.args.get('search', '')
        status = request.args.get('status', '')
        category_id = request.args.get('category_id', '')
        
        # Build query
        query = BlogArticle.query
        
        if search:
            query = query.filter(BlogArticle.title.contains(search) | 
                               BlogArticle.content.contains(search))
        
        if status:
            query = query.filter(BlogArticle.status == status)
            
        if category_id:
            query = query.filter(BlogArticle.category_id == int(category_id))
        
        # Order by creation date
        articles = query.order_by(BlogArticle.created_at.desc()).all()
        
        # Get categories for filter dropdown
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        
        return render_template('admin/blog_manager.html',
                             articles=articles,
                             categories=categories,
                             search=search,
                             status=status,
                             category_id=category_id)
        
    except Exception as e:
        flash(f'Ошибка загрузки блога: {str(e)}', 'error')
        return redirect(url_for('manager_dashboard'))


@app.route('/admin/blog/create-new', methods=['GET', 'POST'])
@manager_required
def admin_create_new_article():
    """Create new blog article"""
    from models import Category, BlogArticle
    import re
    from datetime import datetime
    
    if request.method == 'GET':
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        return render_template('admin/blog_create_new.html', categories=categories)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt')
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status', 'draft')
        is_featured = 'is_featured' in request.form
        
        # Generate slug from title
        slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while BlogArticle.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        # Create article
        article = BlogArticle(
            title=title,
            slug=slug,
            excerpt=excerpt,
            content=content,
            category_id=int(category_id),
            author_id=current_user.id,
            status=status,
            is_featured=is_featured
        )
        
        # Set publish date if status is published
        if status == 'published':
            article.published_at = datetime.utcnow()
        
        # Calculate reading time (approx 200 words per minute)
        word_count = len(content.split()) if content else 0
        article.reading_time = max(1, word_count // 200)
        
        db.session.add(article)
        db.session.commit()
        
        flash('Статья успешно создана!', 'success')
        return redirect(url_for('admin_blog_manager'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка создания статьи: {str(e)}', 'error')
        return redirect(url_for('admin_create_new_article'))


@app.route('/admin/blog/<int:article_id>/edit-article', methods=['GET', 'POST'])
@manager_required 
def admin_edit_new_article(article_id):
    """Edit existing blog article"""
    from models import BlogArticle, Category
    import re
    from datetime import datetime
    
    article = BlogArticle.query.get_or_404(article_id)
    
    if request.method == 'GET':
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        return render_template('admin/blog_edit_new.html', article=article, categories=categories)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt') 
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status')
        is_featured = 'is_featured' in request.form
        
        # Update slug if title changed
        if title != article.title:
            slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure slug is unique (exclude current article)
            original_slug = slug
            counter = 1
            while BlogArticle.query.filter_by(slug=slug).filter(BlogArticle.id != article_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            article.slug = slug
        
        # Update article
        article.title = title
        article.excerpt = excerpt
        article.content = content
        article.category_id = int(category_id)
        article.status = status
        article.is_featured = is_featured
        article.updated_at = datetime.utcnow()
        
        # Set/update publish date if status changed to published
        if status == 'published' and not article.published_at:
            article.published_at = datetime.utcnow()
        
        # Recalculate reading time
        word_count = len(content.split()) if content else 0
        article.reading_time = max(1, word_count // 200)
        
        db.session.commit()
        
        flash('Статья успешно обновлена!', 'success')
        return redirect(url_for('admin_blog_manager'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка обновления статьи: {str(e)}', 'error')
        return redirect(url_for('admin_edit_new_article', article_id=article_id))


@app.route('/admin/blog/<int:article_id>/delete-article', methods=['POST'])
@manager_required
def admin_delete_new_article(article_id):
    """Delete blog article"""
    from models import BlogArticle
    
    try:
        article = BlogArticle.query.get_or_404(article_id)
        db.session.delete(article)
        db.session.commit()
        
        flash('Статья успешно удалена!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка удаления статьи: {str(e)}', 'error')
    
    return redirect(url_for('admin_blog_manager'))


@app.route('/admin/blog/categories')
@admin_required
def admin_blog_categories():
    """Manage blog categories"""
    from models import Admin, Category, BlogPost, BlogArticle
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    categories = Category.query.order_by(Category.sort_order, Category.name).all()
    
    # Добавляем подсчет статей для каждой категории
    for category in categories:
        # Считаем статьи из BlogPost (по названию категории)
        blog_post_count = BlogPost.query.filter_by(
            category=category.name, 
            status='published'
        ).count()
        
        # Считаем статьи из BlogArticle (по category_id)
        blog_article_count = BlogArticle.query.filter_by(
            category_id=category.id,
            status='published'
        ).count()
        
        # Общее количество статей
        category.articles_count = blog_post_count + blog_article_count
    
    return render_template('admin/blog_categories.html', admin=current_admin, categories=categories)


@app.route('/admin/blog/categories/create', methods=['GET', 'POST'])
@admin_required
# @csrf.exempt  # CSRF disabled  # Отключаем CSRF для админ панели
def admin_create_category():
    """Create new blog category - both form and JSON API"""
    from models import Admin, Category
    import re
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    # Handle JSON requests (from inline category creation)
    if request.is_json:
        try:
            data = request.get_json()
            name = data.get('name')
            description = data.get('description', '')
            
            if not name:
                return jsonify({'success': False, 'error': 'Название категории обязательно'})
            
            # Generate slug from Russian name
            def transliterate(text):
                rus_to_eng = {
                    'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'yo', 'ж': 'zh', 'з': 'z',
                    'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm', 'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r',
                    'с': 's', 'т': 't', 'у': 'u', 'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
                    'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya'
                }
                return ''.join(rus_to_eng.get(char.lower(), char) for char in text)
            
            slug = transliterate(name.lower())
            slug = re.sub(r'[^\w\s-]', '', slug)
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure unique slug
            original_slug = slug
            counter = 1
            while Category.query.filter_by(slug=slug).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            category = Category(
                name=name,
                slug=slug,
                description=description,
                is_active=True
            )
            
            db.session.add(category)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'category': {
                    'id': category.id,
                    'name': category.name,
                    'slug': category.slug
                }
            })
            
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)})
    
    # Handle form requests (standard category creation page)
    if request.method == 'GET':
        return render_template('admin/blog_category_create.html', admin=current_admin)
    
    try:
        name = request.form.get('name')
        if not name:
            flash('Название категории обязательно', 'error')
            return render_template('admin/blog_category_create.html', admin=current_admin)
            
        description = request.form.get('description', '')
        
        # Generate slug
        slug = re.sub(r'[^\w\s-]', '', name.lower())
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure unique slug
        original_slug = slug
        counter = 1
        while Category.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        category = Category(
            name=name,
            slug=slug,
            description=description
        )
        
        db.session.add(category)
        db.session.commit()
        
        flash(f'Категория "{name}" успешно создана!', 'success')
        return redirect(url_for('admin_blog'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка создания категории: {str(e)}', 'error')
        return render_template('admin/blog_category_create.html', admin=current_admin)


# Blog Public Routes  
@app.route('/blog-new')
def blog_new():
    """Public blog page"""
    from models import BlogArticle, Category
    
    try:
        # Get published articles
        articles = BlogArticle.query.filter_by(status='published').order_by(BlogArticle.published_at.desc()).all()
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        
        # Add pagination variables that template expects
        return render_template('blog.html', 
                             articles=articles, 
                             categories=categories,
                             total_pages=1,
                             current_page=1,
                             has_prev=False,
                             has_next=False,
                             prev_num=None,
                             next_num=None,
                             search_query='',
                             category_filter=None)
        
    except Exception as e:
        print(f"Blog error: {str(e)}")
        import traceback
        traceback.print_exc()
        # Fallback for when there's an error
        try:
            return render_template('blog.html', articles=[], categories=[])
        except:
            return "Временные проблемы с блогом. Попробуйте позже.", 500


@app.route('/blog-new/<slug>')
def blog_article_new(slug):
    """View single blog article"""
    from models import BlogArticle
    
    try:
        article = BlogArticle.query.filter_by(slug=slug, status='published').first_or_404()
        
        # Increment view count
        article.views_count += 1
        db.session.commit()
        
        # Get related articles from same category
        related_articles = BlogArticle.query.filter_by(
            category_id=article.category_id,
            status='published'
        ).filter(
            BlogArticle.id != article.id
        ).order_by(
            BlogArticle.published_at.desc()
        ).limit(3).all()
        
        return render_template('blog_article.html', 
                             article=article,
                             related_articles=related_articles)
        
    except Exception as e:
        flash('Статья не найдена', 'error')
        return redirect(url_for('blog_new'))


@app.route('/blog-new/category/<slug>')
def blog_category_new(slug):
    """View articles by category"""
    from models import Category, BlogArticle
    
    try:
        category = Category.query.filter_by(slug=slug, is_active=True).first_or_404()
        
        articles = BlogArticle.query.filter_by(
            category_id=category.id,
            status='published'
        ).order_by(
            BlogArticle.published_at.desc()
        ).all()
        
        return render_template('blog_category.html', 
                             category=category,
                             articles=articles)
        
    except Exception as e:
        flash('Категория не найдена', 'error')
        return redirect(url_for('blog_new'))


@app.route('/blog/<slug>')
def blog_post(slug):
    """Display single blog post by slug"""
    try:
        # Find post by slug - using direct SQL query
        from sqlalchemy import text
        result = db.session.execute(text("""
            SELECT id, title, slug, content, excerpt, category, featured_image, 
                   views_count, created_at, '' as author_name
            FROM blog_posts 
            WHERE slug = :slug AND status = 'published'
        """), {'slug': slug}).fetchone()
        
        if not result:
            flash('Статья не найдена', 'error')
            return redirect(url_for('blog'))
        
        # Convert to dict for template
        post = {
            'id': result[0],
            'title': result[1],
            'slug': result[2],
            'content': result[3],
            'excerpt': result[4],
            'category': result[5],
            'featured_image': result[6],
            'views_count': result[7] or 0,
            'created_at': result[8],
            'author_name': result[9] or 'InBack'
        }
        
        # Increment view count
        try:
            db.session.execute(text("""
                UPDATE blog_posts 
                SET views_count = COALESCE(views_count, 0) + 1 
                WHERE id = :id
            """), {'id': post['id']})
            db.session.commit()
            post['views_count'] += 1
        except Exception as e:
            db.session.rollback()
        
        # Get related posts from same category
        related_results = db.session.execute(text("""
            SELECT id, title, slug, excerpt, featured_image, created_at
            FROM blog_posts 
            WHERE category = :category AND status = 'published' AND id != :id
            ORDER BY created_at DESC
            LIMIT 3
        """), {'category': post['category'], 'id': post['id']}).fetchall()
        
        related_posts = []
        for r in related_results:
            related_posts.append({
                'id': r[0],
                'title': r[1], 
                'slug': r[2],
                'excerpt': r[3],
                'featured_image': r[4],
                'created_at': r[5]
            })
        
        return render_template('blog_post.html', 
                             post=post,
                             related_posts=related_posts)
        
    except Exception as e:
        flash('Ошибка загрузки статьи', 'error')
        return redirect(url_for('blog'))


# Admin Blog Management Routes
@app.route('/admin/blog-management')
@admin_required
def admin_blog_management():
    """Admin blog management page"""
    from models import BlogPost, Category
    
    try:
        # Get filter parameters
        search = request.args.get('search', '')
        status = request.args.get('status', '')
        category_name = request.args.get('category', '')
        page = request.args.get('page', 1, type=int)
        
        # Build query
        query = BlogPost.query
        
        if search:
            query = query.filter(BlogPost.title.contains(search) | 
                               BlogPost.content.contains(search))
        
        if status:
            query = query.filter(BlogPost.status == status)
            
        if category_name:
            query = query.filter(BlogPost.category == category_name)
        
        # Order by creation date and paginate
        posts = query.order_by(BlogPost.created_at.desc()).paginate(
            page=page, per_page=10, error_out=False
        )
        
        # Get categories for filter dropdown
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        
        # Get admin user for template
        from flask_login import current_user
        admin = current_user if current_user.is_authenticated else None
        
        return render_template('admin/blog_management.html',
                             posts=posts,
                             categories=categories,
                             search=search,
                             status=status,
                             category_name=category_name,
                             admin=admin)
        
    except Exception as e:
        flash(f'Ошибка загрузки блога: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/blog-management/create', methods=['GET', 'POST'])
@admin_required
def admin_create_blog_post():
    """Create new blog post"""
    from models import BlogPost, Category, Admin
    import re
    from datetime import datetime
    
    if request.method == 'GET':
        # ИСПРАВЛЕНО: Используем Flask-Login current_user
        # Get current admin
        current_admin = current_user
        
        categories = Category.query.order_by(Category.name).all()
        return render_template('admin/blog_post_create.html', categories=categories, admin=current_admin)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt')
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status', 'draft')
        is_featured = 'is_featured' in request.form
        featured_image = request.form.get('featured_image', '')
        meta_title = request.form.get('meta_title', '')
        meta_description = request.form.get('meta_description', '')
        keywords = request.form.get('keywords', '')
        
        # Get category name from category_id
        category = Category.query.get(int(category_id))
        if not category:
            flash('Выбранная категория не найдена', 'error')
            return redirect(url_for('admin_create_blog_post'))
        
        # Generate slug from title
        slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while BlogPost.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        # Calculate reading time (approx 200 words per minute)
        word_count = len(content.split()) if content else 0
        reading_time = max(1, word_count // 200)
        
        # Create blog post using BlogPost model
        post = BlogPost(
            title=title,
            slug=slug,
            excerpt=excerpt,
            content=content,
            category=category.name,  # Use category name, not ID
            author_id=1,  # Default author
            status=status,
            featured_image=featured_image,
            tags=keywords
        )
        
        if status == 'published':
            post.published_at = datetime.utcnow()
        
        db.session.add(post)
        db.session.commit()
        
        # Обновим счетчик статей в категории
        category.articles_count = BlogPost.query.filter_by(category=category.name, status='published').count()
        db.session.commit()
        
        print(f'DEBUG: Created article "{title}" in category "{category.name}" with status "{status}"')
        print(f'DEBUG: Updated category "{category.name}" article count to {category.articles_count}')
        
        flash('Статья успешно создана!', 'success')
        return redirect(url_for('admin_blog_management'))
        
    except Exception as e:
        db.session.rollback()
        print(f'ERROR creating blog post: {str(e)}')
        flash(f'Ошибка создания статьи: {str(e)}', 'error')
        return redirect(url_for('admin_create_blog_post'))

@app.route('/admin/upload-image', methods=['POST'])
@admin_required
@csrf.exempt
def admin_upload_image():
    """Upload image for TinyMCE editor and blog posts"""
    if 'file' not in request.files:
        return jsonify({'success': False, 'error': 'Файл не выбран'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'success': False, 'error': 'Файл не выбран'}), 400
    
    # Check if file is an image
    allowed_extensions = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
    if not (file.filename and '.' in file.filename and file.filename.rsplit('.', 1)[1].lower() in allowed_extensions):
        return jsonify({'success': False, 'error': 'Разрешены только изображения (PNG, JPG, JPEG, GIF, WebP)'}), 400
    
    try:
        # Generate secure filename
        from werkzeug.utils import secure_filename
        import os, uuid
        
        filename = secure_filename(file.filename) if file.filename else 'unnamed_file'
        
        # Create upload directory if it doesn't exist
        upload_dir = 'static/uploads/blog/content'
        os.makedirs(upload_dir, exist_ok=True)
        
        # Save file with unique name to avoid conflicts
        unique_filename = f"{uuid.uuid4()}_{filename}"
        file_path = os.path.join(upload_dir, unique_filename)
        file.save(file_path)
        
        # Return URL - TinyMCE expects 'location' field
        file_url = f"/{file_path}"
        
        return jsonify({
            'success': True,
            'location': file_url,  # TinyMCE expects 'location' field
            'url': file_url,       # Для совместимости с другими частями кода
            'filename': unique_filename
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': f'Ошибка загрузки файла: {str(e)}'}), 500

# Duplicate route removed - already defined earlier


@app.route('/admin/blog-management/<int:post_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_blog_post(post_id):
    """Edit blog post"""
    from models import BlogPost, Category, Admin
    import re
    from datetime import datetime
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    # Get current admin
    current_admin = current_user
    
    post = BlogPost.query.get_or_404(post_id)
    
    if request.method == 'GET':
        categories = Category.query.filter_by(is_active=True).order_by(Category.name).all()
        return render_template('admin/blog_post_create.html', post=post, categories=categories, admin=current_admin)
    
    try:
        # Get form data
        title = request.form.get('title')
        excerpt = request.form.get('excerpt')
        content = request.form.get('content')
        category_id = request.form.get('category_id')
        status = request.form.get('status')
        is_featured = 'is_featured' in request.form
        featured_image = request.form.get('featured_image', '')
        meta_title = request.form.get('meta_title', '')
        meta_description = request.form.get('meta_description', '')
        keywords = request.form.get('keywords', '')
        
        # Validation
        if not title or title.strip() == '':
            flash('Заголовок статьи обязателен', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))
        
        if not content or content.strip() == '':
            flash('Содержание статьи обязательно', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))
        
        if not category_id or category_id == '':
            flash('Выберите категорию статьи', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))

        # Get category name from category_id
        category = Category.query.get(int(category_id))
        if not category:
            flash('Выбранная категория не найдена', 'error')
            return redirect(url_for('admin_edit_blog_post', post_id=post_id))
        
        # Update slug if title changed
        if title != post.title:
            slug = re.sub(r'[^\w\s-]', '', (title or '').lower())
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            original_slug = slug
            counter = 1
            while BlogPost.query.filter_by(slug=slug).filter(BlogPost.id != post_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            post.slug = slug
        
        # Calculate reading time
        word_count = len(content.split()) if content else 0
        reading_time = max(1, word_count // 200)
        
        # Update post
        old_category = post.category
        post.title = title
        post.excerpt = excerpt
        post.content = content
        post.category = category.name  # BlogPost uses category name as string
        post.status = status
        post.is_featured = is_featured
        post.featured_image = featured_image
        post.meta_title = meta_title or title
        post.meta_description = meta_description or excerpt  
        post.tags = keywords  # BlogPost uses tags field
        post.reading_time = reading_time
        post.updated_at = datetime.utcnow()
        
        if status == 'published' and not post.published_at:
            post.published_at = datetime.utcnow()
        
        db.session.commit()
        
        # Update category article counts for both old and new categories
        for cat_name in [old_category, category.name]:
            if cat_name:
                cat = Category.query.filter_by(name=cat_name).first()
                if cat:
                    cat.articles_count = BlogPost.query.filter_by(category=cat_name, status='published').count()
        
        db.session.commit()
        
        flash('Статья успешно обновлена!', 'success')
        return redirect(url_for('admin_blog_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка обновления статьи: {str(e)}', 'error')
        return redirect(url_for('admin_edit_blog_post', post_id=post_id))


@app.route('/admin/blog-management/<int:post_id>/delete', methods=['POST'])
@admin_required
def admin_delete_blog_post(post_id):
    """Delete blog post"""
    from models import BlogPost, Category
    
    try:
        post = BlogPost.query.get_or_404(post_id)
        category_name = post.category
        
        db.session.delete(post)
        db.session.commit()
        
        # Update category article count
        if category_name:
            category = Category.query.filter_by(name=category_name).first()
            if category:
                category.articles_count = BlogPost.query.filter_by(category=category_name, status='published').count()
                db.session.commit()
        
        flash('Статья успешно удалена!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка удаления статьи: {str(e)}', 'error')
    
    return redirect(url_for('admin_blog_management'))


@app.route('/admin/blog-categories-management')
@admin_required
def admin_blog_categories_management():
    """Admin blog categories management"""
    from models import Category
    
    try:
        categories = Category.query.order_by(Category.sort_order).all()
        return render_template('admin/blog_categories.html', categories=categories)
        
    except Exception as e:
        flash(f'Ошибка загрузки категорий: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/blog-categories-management/create', methods=['GET', 'POST'])
@admin_required
def admin_create_blog_category_new():
    """Create blog category"""
    from models import Category
    import re
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'e',
            'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm',
            'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
            'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
            'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    if request.method == 'GET':
        return render_template('admin/blog_category_create.html')
    
    try:
        # Get form data
        name = request.form.get('name')
        description = request.form.get('description', '')
        color = request.form.get('color', 'blue')
        icon = request.form.get('icon', 'fas fa-folder')
        sort_order = request.form.get('sort_order', 0, type=int)
        
        # Generate slug with proper Russian transliteration
        slug = transliterate_russian_to_latin(name)
        slug = re.sub(r'[^a-z0-9\s-]', '', slug)  # Keep only safe characters
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while Category.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        category = Category(
            name=name,
            slug=slug,
            description=description,
            color=color,
            icon=icon,
            sort_order=sort_order,
            is_active=True,
            articles_count=0
        )
        
        db.session.add(category)
        db.session.commit()
        
        flash('Категория успешно создана!', 'success')
        return redirect(url_for('admin_blog_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка создания категории: {str(e)}', 'error')
        return redirect(url_for('admin_create_blog_category_new'))


@app.route('/admin/blog-categories-management/<int:category_id>/edit', methods=['GET', 'POST'])
@admin_required  
def admin_edit_blog_category_new(category_id):
    """Edit blog category"""
    from models import Category
    import re
    
    category = Category.query.get_or_404(category_id)
    
    if request.method == 'GET':
        return render_template('admin/blog_category_edit.html', category=category)
    
    try:
        # Get form data
        name = request.form.get('name')
        description = request.form.get('description', '')
        color = request.form.get('color', 'blue')
        icon = request.form.get('icon', 'fas fa-folder')
        sort_order = request.form.get('sort_order', 0, type=int)
        is_active = 'is_active' in request.form
        
        # Update slug if name changed
        if name != category.name:
            def transliterate_russian_to_latin(text):
                """Convert Russian text to Latin characters for URL slugs"""
                translit_map = {
                    'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'e',
                    'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm',
                    'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
                    'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
                    'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya',
                    ' ': '-', '_': '-'
                }
                
                result = ''
                for char in text.lower():
                    result += translit_map.get(char, char)
                
                return result
                
            slug = transliterate_russian_to_latin(name)
            slug = re.sub(r'[^a-z0-9\s-]', '', slug)  # Keep only safe characters
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            original_slug = slug
            counter = 1
            while Category.query.filter_by(slug=slug).filter(Category.id != category_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            category.slug = slug
        
        category.name = name
        category.description = description
        category.color = color
        category.icon = icon
        category.sort_order = sort_order
        category.is_active = is_active
        
        db.session.commit()
        
        flash('Категория успешно обновлена!', 'success')
        return redirect(url_for('admin_blog_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка обновления категории: {str(e)}', 'error')
        return redirect(url_for('admin_edit_blog_category_new', category_id=category_id))


@csrf.exempt
@app.route('/admin/blog-categories-management/<int:category_id>/delete', methods=['POST'])
@admin_required
def admin_delete_blog_category_new(category_id):
    """Delete blog category"""
    from models import Category, BlogArticle
    
    try:
        category = Category.query.get_or_404(category_id)
        
        # Check if category has posts
        posts_count = BlogArticle.query.filter_by(category_id=category_id).count()
        if posts_count > 0:
            flash(f'Нельзя удалить категорию с {posts_count} статьями. Сначала переместите статьи в другие категории.', 'error')
            return redirect(url_for('admin_blog_categories_management'))
        
        db.session.delete(category)
        db.session.commit()
        
        flash('Категория успешно удалена!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка удаления категории: {str(e)}', 'error')
    
    return redirect(url_for('admin_blog_categories_management'))


# === JOB MANAGEMENT ADMIN ROUTES ===

@app.route('/admin/jobs')
@admin_required
def admin_jobs_management():
    """Admin jobs management"""
    from models import Job, JobCategory, Admin
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    try:
        jobs = Job.query.order_by(Job.created_at.desc()).all()
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        
        # Calculate statistics
        stats = {
            'total': len(jobs),
            'active': len([job for job in jobs if job.status == 'active']),
            'paused': len([job for job in jobs if job.status == 'paused']),
            'closed': len([job for job in jobs if job.status == 'closed']),
            'featured': len([job for job in jobs if job.is_featured])
        }
        
        return render_template('admin/careers_panel.html', vacancies=jobs, categories=categories, admin=current_admin, stats=stats)
        
    except Exception as e:
        flash(f'Ошибка загрузки вакансий: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/jobs/create', methods=['GET', 'POST'])
@admin_required
def admin_create_job():
    """Create new job"""
    from models import Job, JobCategory, Admin
    import re
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'e',
            'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm',
            'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
            'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
            'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    if request.method == 'GET':
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        return render_template('admin/create_vacancy.html', categories=categories, admin=current_admin)
    
    try:
        # Get form data
        title = request.form.get('title')
        category_id = request.form.get('category_id', type=int)
        description = request.form.get('description')
        
        # Validate required fields
        if not title or not category_id or not description:
            flash('Заполните все обязательные поля', 'error')
            categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
            return render_template('admin/create_vacancy.html', categories=categories, admin=current_admin)
        requirements = request.form.get('requirements', '')
        benefits = request.form.get('benefits', '')
        responsibilities = request.form.get('responsibilities', '')
        location = request.form.get('location')
        salary_min = request.form.get('salary_min', type=int)
        salary_max = request.form.get('salary_max', type=int)
        employment_type = request.form.get('employment_type', 'full_time')
        experience_level = request.form.get('experience_level', '')
        is_remote = 'is_remote' in request.form
        is_featured = 'is_featured' in request.form
        
        # Additional fields
        department = request.form.get('department', '')
        is_urgent = 'is_urgent' in request.form
        status = request.form.get('status', 'active')
        contact_email = request.form.get('contact_email', '')
        contact_phone = request.form.get('contact_phone', '')
        meta_title = request.form.get('meta_title', '')
        meta_description = request.form.get('meta_description', '')
        
        # Generate slug
        slug = transliterate_russian_to_latin(title)
        slug = re.sub(r'[^a-z0-9\s-]', '', slug)
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while Job.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        job = Job(
            title=title,
            slug=slug,
            category_id=category_id,
            description=description,
            requirements=requirements,
            benefits=benefits,
            responsibilities=responsibilities,
            location=location,
            salary_min=salary_min,
            salary_max=salary_max,
            salary_currency='RUB',
            salary_period='month',
            employment_type=employment_type,
            experience_level=experience_level,
            is_remote=is_remote,
            is_featured=is_featured,
            is_urgent=is_urgent,
            status=status,
            department=department,
            is_active=True,
            contact_email=contact_email,
            contact_phone=contact_phone,
            meta_title=meta_title,
            meta_description=meta_description,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        
        db.session.add(job)
        db.session.commit()
        
        flash('Вакансия успешно создана!', 'success')
        return redirect(url_for('admin_jobs_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка создания вакансии: {str(e)}', 'error')
        return redirect(url_for('admin_create_job'))


@app.route('/admin/jobs/<int:job_id>/edit', methods=['GET', 'POST'])
@admin_required
def admin_edit_job(job_id):
    """Edit job"""
    from models import Job, JobCategory, Admin
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    job = Job.query.get_or_404(job_id)
    
    if request.method == 'GET':
        categories = JobCategory.query.filter_by(is_active=True).order_by(JobCategory.sort_order).all()
        return render_template('admin/edit_vacancy.html', job=job, categories=categories, admin=current_admin)
    
    try:
        # Update job data
        job.title = request.form.get('title')
        job.category_id = request.form.get('category_id', type=int)
        job.description = request.form.get('description')
        job.requirements = request.form.get('requirements', '')
        job.benefits = request.form.get('benefits', '')
        job.responsibilities = request.form.get('responsibilities', '')
        job.location = request.form.get('location')
        job.salary_min = request.form.get('salary_min', type=int)
        job.salary_max = request.form.get('salary_max', type=int)
        job.employment_type = request.form.get('employment_type', 'full_time')
        job.experience_level = request.form.get('experience_level', '')
        job.is_remote = 'is_remote' in request.form
        job.is_featured = 'is_featured' in request.form
        job.is_urgent = 'is_urgent' in request.form
        job.status = request.form.get('status', 'active')
        job.department = request.form.get('department', '')
        job.contact_email = request.form.get('contact_email', '')
        job.contact_phone = request.form.get('contact_phone', '')
        job.meta_title = request.form.get('meta_title', '')
        job.meta_description = request.form.get('meta_description', '')
        job.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        flash('Вакансия успешно обновлена!', 'success')
        return redirect(url_for('admin_jobs_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка обновления вакансии: {str(e)}', 'error')
        return redirect(url_for('admin_edit_job', job_id=job_id))


@app.route('/admin/jobs/<int:job_id>/delete', methods=['POST'])
@admin_required
def admin_delete_job(job_id):
    """Delete job"""
    from models import Job
    
    try:
        job = Job.query.get_or_404(job_id)
        db.session.delete(job)
        db.session.commit()
        
        flash('Вакансия успешно удалена!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка удаления вакансии: {str(e)}', 'error')
    
    return redirect(url_for('admin_jobs_management'))


@app.route('/job/<job_slug>')
def job_detail(job_slug):
    """Job detail page"""
    from models import Job
    
    try:
        job = Job.query.filter(Job.slug == job_slug, Job.is_active == True, Job.status == 'active').first_or_404()
        
        # Increment views count
        job.views_count = (job.views_count or 0) + 1
        db.session.commit()
        
        return render_template('vacancy_details.html', vacancy=job)
        
    except Exception as e:
        print(f"Job detail error: {e}")
        flash('Вакансия не найдена', 'error')
        return redirect(url_for('careers'))


@app.route('/job/<job_slug>/apply', methods=['POST'])
# @csrf.exempt  # Временно исключаем из CSRF защиты - TODO: добавить CSRF в форму
def submit_job_application(job_slug):
    """Submit job application with resume"""
    from models import Job
    import os
    import uuid
    from datetime import datetime
    
    try:
        # Find the job
        job = Job.query.filter(Job.slug == job_slug, Job.is_active == True, Job.status == 'active').first_or_404()
        
        # Get form data
        candidate_name = request.form.get('candidate_name', '').strip()
        candidate_phone = request.form.get('candidate_phone', '').strip()
        candidate_email = request.form.get('candidate_email', '').strip()
        cover_letter = request.form.get('cover_letter', '').strip()
        
        # Validate required fields
        if not candidate_name or not candidate_phone:
            flash('Имя и телефон обязательны для заполнения', 'error')
            return redirect(url_for('job_detail', job_slug=job_slug))
        
        # Validate phone format
        import re
        phone_pattern = r'^[\+]?[0-9\s\-\(\)]{10,18}$'
        if not re.match(phone_pattern, candidate_phone):
            flash('Неверный формат номера телефона', 'error')
            return redirect(url_for('job_detail', job_slug=job_slug))
        
        # Handle file upload
        resume_file = request.files.get('resume_file')
        resume_filename = None
        
        if resume_file and resume_file.filename:
            # Validate file
            allowed_extensions = {'pdf', 'doc', 'docx', 'txt', 'rtf'}
            filename = resume_file.filename.lower()
            
            if not any(filename.endswith('.' + ext) for ext in allowed_extensions):
                flash('Неподдерживаемый формат файла. Используйте PDF, DOC, DOCX, TXT или RTF', 'error')
                return redirect(url_for('job_detail', job_slug=job_slug))
            
            # Check file size (5MB max)
            resume_file.seek(0, 2)  # Seek to end
            file_size = resume_file.tell()
            resume_file.seek(0)  # Reset to beginning
            
            if file_size > 5 * 1024 * 1024:  # 5MB
                flash('Размер файла не должен превышать 5 МБ', 'error')
                return redirect(url_for('job_detail', job_slug=job_slug))
            
            # Save file with unique name
            file_extension = filename.split('.')[-1]
            unique_filename = f"{uuid.uuid4()}_{candidate_name.replace(' ', '_')}_{job.slug}.{file_extension}"
            resume_filename = secure_filename(unique_filename)
            
            # Ensure upload directory exists
            upload_dir = os.path.join(app.root_path, 'static', 'uploads', 'resumes')
            os.makedirs(upload_dir, exist_ok=True)
            
            # Save file
            resume_path = os.path.join(upload_dir, resume_filename)
            resume_file.save(resume_path)
        else:
            flash('Резюме обязательно для отправки', 'error')
            return redirect(url_for('job_detail', job_slug=job_slug))
        
        # Prepare email notification
        try:
            # Email to HR/Admin
            admin_subject = f"Новый отклик на вакансию: {job.title}"
            admin_message = f"""Поступил новый отклик на вакансию "{job.title}":

Кандидат: {candidate_name}
Телефон: {candidate_phone}
Email: {candidate_email if candidate_email else 'Не указан'}

Сопроводительное письмо:
{cover_letter if cover_letter else 'Не указано'}

Резюме сохранено: {resume_filename}

Вакансия: {job.title}
Отдел: {job.department}
Дата подачи: {datetime.now().strftime('%d.%m.%Y %H:%M')}
"""
            
            # Send notification using existing email service
            send_notification(
                subject=admin_subject,
                message=admin_message,
                to_email="hr@inback.ru",  # You can configure this
                notification_type="job_application"
            )
            
            # Optional: Send confirmation to candidate if email provided
            if candidate_email:
                candidate_subject = f"Спасибо за отклик на вакансию: {job.title}"
                candidate_message = f"""Здравствуйте, {candidate_name}!

Спасибо за ваш отклик на вакансию "{job.title}" в компании InBack.

Мы получили ваше резюме и рассмотрим его в ближайшее время. 
Если ваша кандидатура подойдет, мы свяжемся с вами по телефону {candidate_phone}.

С уважением,
Команда InBack
"""
                
                send_notification(
                    subject=candidate_subject,
                    message=candidate_message,
                    to_email=candidate_email,
                    notification_type="application_confirmation"
                )
            
        except Exception as e:
            print(f"Email sending error: {e}")
            # Don't fail the whole process if email fails
            pass
        
        flash('Спасибо! Ваше резюме отправлено. Мы свяжемся с вами в ближайшее время.', 'success')
        return redirect(url_for('job_detail', job_slug=job_slug))
        
    except Exception as e:
        print(f"Job application error: {e}")
        flash('Произошла ошибка при отправке резюме. Попробуйте еще раз.', 'error')
        return redirect(url_for('job_detail', job_slug=job_slug))


@app.route('/admin/jobs/<int:vacancy_id>/toggle-status', methods=['POST'])
@admin_required
def admin_toggle_vacancy_status(vacancy_id):
    """Toggle vacancy status between active and paused"""
    from models import Job
    
    job = Job.query.get_or_404(vacancy_id)
    
    # Toggle between 'active' and 'paused' status
    if job.status == 'active':
        job.status = 'paused'
        status_text = 'приостановлена'
    else:
        job.status = 'active'
        status_text = 'активна'
    
    try:
        db.session.commit()
        flash(f'Вакансия "{job.title}" {status_text}', 'success')
    except Exception as e:
        db.session.rollback()
        flash('Ошибка при изменении статуса вакансии', 'error')
    
    return redirect(url_for('admin_jobs_management'))


@app.route('/admin/job-categories')
@admin_required
def admin_job_categories_management():
    """Admin job categories management"""
    from models import JobCategory, Admin
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    try:
        categories = JobCategory.query.order_by(JobCategory.sort_order).all()
        return render_template('admin/job_categories_management.html', categories=categories, admin=current_admin)
        
    except Exception as e:
        flash(f'Ошибка загрузки категорий вакансий: {str(e)}', 'error')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/job-categories/create', methods=['GET', 'POST'])
@admin_required
@csrf.exempt
def admin_create_job_category():
    """Create new job category"""
    from models import JobCategory, Admin
    import re
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'e',
            'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm',
            'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
            'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
            'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    if request.method == 'GET':
        return render_template('admin/create_job_category.html', admin=current_admin)
    
    try:
        # Get form data
        name = request.form.get('name')
        description = request.form.get('description', '')
        color = request.form.get('color', 'blue')
        icon = request.form.get('icon', 'fas fa-briefcase')
        sort_order = request.form.get('sort_order', 0, type=int)
        
        # Generate slug
        slug = transliterate_russian_to_latin(name)
        slug = re.sub(r'[^a-z0-9\s-]', '', slug)
        slug = re.sub(r'[-\s]+', '-', slug).strip('-')
        
        # Ensure slug is unique
        original_slug = slug
        counter = 1
        while JobCategory.query.filter_by(slug=slug).first():
            slug = f"{original_slug}-{counter}"
            counter += 1
        
        category = JobCategory(
            name=name,
            slug=slug,
            description=description,
            color=color,
            icon=icon,
            sort_order=sort_order,
            is_active=True
        )
        
        db.session.add(category)
        db.session.commit()
        
        flash('Категория вакансий успешно создана!', 'success')
        return redirect(url_for('admin_job_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка создания категории вакансий: {str(e)}', 'error')
        return redirect(url_for('admin_create_job_category'))


@app.route('/admin/job-categories/<int:category_id>/edit', methods=['GET', 'POST'])
@csrf.exempt
@admin_required
def admin_edit_job_category(category_id):
    """Edit job category"""
    from models import JobCategory, Admin
    import re
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    current_admin = current_user
    
    category = JobCategory.query.get_or_404(category_id)
    
    def transliterate_russian_to_latin(text):
        """Convert Russian text to Latin characters for URL slugs"""
        translit_map = {
            'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'e',
            'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm',
            'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
            'ф': 'f', 'х': 'h', 'ц': 'c', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
            'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya',
            ' ': '-', '_': '-'
        }
        
        result = ''
        for char in text.lower():
            result += translit_map.get(char, char)
        
        return result
    
    if request.method == 'GET':
        return render_template('admin/edit_job_category.html', category=category, admin=current_admin)
    
    try:
        # Get new name first (before updating)
        new_name = request.form.get('name')
        
        # Update other fields
        category.description = request.form.get('description', '')
        category.color = request.form.get('color', 'blue')
        category.icon = request.form.get('icon', 'fas fa-briefcase')
        category.sort_order = request.form.get('sort_order', 0, type=int)
        category.is_active = 'is_active' in request.form
        
        # Update slug only if name changed
        if new_name and category.name != new_name:
            # Update name
            category.name = new_name
            
            # Generate new slug
            slug = transliterate_russian_to_latin(new_name)
            slug = re.sub(r'[^a-z0-9\s-]', '', slug)
            slug = re.sub(r'[-\s]+', '-', slug).strip('-')
            
            # Ensure slug is unique (excluding current category)
            original_slug = slug
            counter = 1
            while JobCategory.query.filter(JobCategory.slug == slug, JobCategory.id != category_id).first():
                slug = f"{original_slug}-{counter}"
                counter += 1
            
            category.slug = slug
        
        db.session.commit()
        
        flash('Категория вакансий успешно обновлена!', 'success')
        return redirect(url_for('admin_job_categories_management'))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка обновления категории вакансий: {str(e)}', 'error')
        return redirect(url_for('admin_edit_job_category', category_id=category_id))


@csrf.exempt
@app.route('/admin/job-categories/<int:category_id>/delete', methods=['POST'])
@admin_required
def admin_delete_job_category(category_id):
    """Delete job category"""
    from models import JobCategory, Job
    
    try:
        category = JobCategory.query.get_or_404(category_id)
        
        # Check if category has jobs
        jobs_count = Job.query.filter_by(category_id=category_id).count()
        if jobs_count > 0:
            flash(f'Нельзя удалить категорию с {jobs_count} вакансиями. Сначала переместите вакансии в другие категории.', 'error')
            return redirect(url_for('admin_job_categories_management'))
        
        db.session.delete(category)
        db.session.commit()
        
        flash('Категория вакансий успешно удалена!', 'success')
        
    except Exception as e:
        db.session.rollback()
        flash(f'Ошибка удаления категории вакансий: {str(e)}', 'error')
    
    return redirect(url_for('admin_job_categories_management'))


# Admin API Endpoints
@api_bp.route('/admin/clients-managers')
def admin_clients_managers_api():
    """API endpoint to get all clients and managers for admin panel"""
    from models import User, Manager, Admin
    
    # Check if user is admin
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Admin):
        return jsonify({'success': False, 'error': 'Доступ запрещен'}), 403
    
    try:
        # Get all users (clients)
        users = User.query.order_by(User.created_at.desc()).all()
        
        # Get all active managers (order by first_name since full_name is a property)
        managers = Manager.query.filter_by(is_active=True).order_by(Manager.first_name, Manager.last_name).all()
        
        # Format clients data
        clients_data = []
        for user in users:
            client = {
                'id': user.id,
                'user_id': f"USER-{user.id}",
                'full_name': user.full_name or 'Не указано',
                'email': user.email,
                'phone': user.phone,
                'created_at': user.created_at.strftime('%d.%m.%Y') if user.created_at else 'Не указано',
                'assigned_manager': None
            }
            
            # Add assigned manager info if exists
            if user.assigned_manager_id:
                manager = Manager.query.get(user.assigned_manager_id)
                if manager:
                    client['assigned_manager'] = {
                        'id': manager.id,
                        'name': manager.full_name
                    }
            
            clients_data.append(client)
        
        # Format managers data
        managers_data = []
        for manager in managers:
            # Count assigned clients
            assigned_count = User.query.filter_by(assigned_manager_id=manager.id).count()
            
            managers_data.append({
                'id': manager.id,
                'name': manager.full_name,
                'email': manager.email,
                'assigned_clients_count': assigned_count
            })
        
        return jsonify({
            'success': True,
            'clients': clients_data,
            'managers': managers_data
        })
        
    except Exception as e:
        print(f"ERROR in admin_clients_managers_api: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@api_bp.route('/admin/assign-client', methods=['POST'])
@csrf.exempt
def admin_assign_client_api():
    """API endpoint to assign/unassign manager to client"""
    from models import User, Manager, Admin
    
    # Check if user is admin
    if not current_user.is_authenticated or not isinstance(current_user._get_current_object(), Admin):
        return jsonify({'success': False, 'error': 'Доступ запрещен'}), 403
    
    try:
        data = request.get_json()
        client_id = data.get('client_id')
        manager_id = data.get('manager_id')
        
        if not client_id:
            return jsonify({'success': False, 'error': 'ID клиента не указан'}), 400
        
        # Get client
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': 'Клиент не найден'}), 404
        
        # Handle assignment/unassignment
        if manager_id:
            manager = Manager.query.get(manager_id)
            if not manager:
                return jsonify({'success': False, 'error': 'Менеджер не найден'}), 404
            
            if not manager.is_active:
                return jsonify({'success': False, 'error': 'Менеджер неактивен'}), 400
            
            client.assigned_manager_id = manager_id
            manager_name = manager.full_name
            message = f'Клиент {client.full_name} назначен менеджеру {manager_name}'
        else:
            # Unassign manager
            client.assigned_manager_id = None
            manager_name = None
            message = f'Менеджер удален у клиента {client.full_name}'
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': message,
            'manager_name': manager_name
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"ERROR in admin_assign_client_api: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


# Register API blueprint
app.register_blueprint(api_bp)

# Smart Search API Endpoints
@app.route('/api/smart-search')
def smart_search_api():
    """Умный поиск с OpenAI анализом"""
    query = request.args.get('q', '').strip()
    
    if not query:
        return jsonify({'results': [], 'criteria': {}, 'suggestions': []})
    
    try:
        # Анализируем запрос с помощью OpenAI (включая определение города)
        criteria = smart_search.analyze_search_query(query)
        # Search criteria processed
        
        # Получаем свойства и применяем фильтры
        properties = load_properties()
        
        # Автоматическая фильтрация по городу если он определен в запросе
        city_id = criteria.get('city_id')
        if city_id:
            # Фильтруем объекты по городу
            properties = [p for p in properties if p.get('city_id') == city_id]
            print(f"🌍 Автофильтр: оставлено {len(properties)} объектов для города ID {city_id}")
        
        # Применяем базовые фильтры на основе критериев
        filtered_properties = apply_smart_filters(properties, criteria)
        
        # Применяем семантический поиск если нужно
        if criteria.get('semantic_search') or criteria.get('features'):
            filtered_properties = smart_search.semantic_property_search(
                filtered_properties, query, criteria
            )
        
        # Подготавливаем результаты
        results = []
        for prop in filtered_properties[:20]:
            results.append({
                'type': 'property',
                'id': prop['id'],
                'title': f"{prop.get('rooms', 0)}-комн {prop.get('area', 0)} м²" if prop.get('rooms', 0) > 0 else f"Студия {prop.get('area', 0)} м²",
                'subtitle': f"{prop.get('complex_name', '')} • {prop['district']}",
                'price': prop['price'],
                'rooms': prop.get('rooms', 1),
                'area': prop.get('area', 0),
                'url': f"/object/{prop['id']}"
            })
        
        # Генерируем подсказки
        suggestions = smart_search.generate_search_suggestions(query)
        
        return jsonify({
            'results': results,
            'criteria': criteria,
            'suggestions': suggestions[:5],
            'total': len(filtered_properties),
            'detected_city': {
                'city_id': criteria.get('city_id'),
                'city_name': criteria.get('city_name'),
                'city_slug': criteria.get('city_slug')
            } if criteria.get('city_id') else None
        })
        
    except Exception as e:
        print(f"ERROR: Smart search failed: {e}")
        # Fallback к обычному поиску
        return jsonify({'results': [], 'error': str(e)})

@app.route('/api/search-suggestions')
# ❌ КЭШ ОТКЛЮЧЁН для отладки типов квартир
# @cache.memoize(timeout=300)
def search_suggestions_api():
    """Супер-быстрый API для автодополнения поиска - ПРИОРИТЕТ: данные из БД"""
    query = request.args.get('q', '').strip()
    if not query or len(query) < 1:
        return jsonify([])
    
    try:
        from smart_search import smart_search
        
        # 1. ПРИОРИТЕТ: Поиск по реальным данным БД (ЖК, застройщики, районы, улицы)
        db_suggestions = smart_search.database_suggestions(query, limit=8)
        
        # 2. Если нашли результаты в БД - возвращаем их
        if db_suggestions and len(db_suggestions) > 0:
            print(f"✅ Found {len(db_suggestions)} DB suggestions for '{query}'")
            return jsonify(db_suggestions)
        
        # 3. Если ничего не нашли в БД - используем fallback (хардкод подсказки)
        print(f"⚠️ No DB results for '{query}', using fallback")
        fallback_suggestions = smart_search.fallback_suggestions(query, limit=8)
        return jsonify(fallback_suggestions)
        
    except Exception as e:
        # В случае ошибки - используем fallback
        print(f"❌ Database search failed for '{query}': {e}")
        import traceback
        traceback.print_exc()
        return search_suggestions_fallback(query)

def search_suggestions_fallback(query):
    """✅ MIGRATED TO NORMALIZED TABLES: Fallback search using ResidentialComplexRepository"""
    suggestions = []
    query_lower = query.lower()
    
    try:
        # ✅ MIGRATED: Search complexes using ResidentialComplexRepository
        from models import ResidentialComplex
        complexes = (
            db.session.query(
                ResidentialComplex.name,
                func.count(Property.id).label('count')
            )
            .join(Property, ResidentialComplex.id == Property.complex_id)
            .filter(
                ResidentialComplex.name.ilike(f'%{query_lower}%'),
                Property.is_active == True
            )
            .group_by(ResidentialComplex.name)
            .order_by(func.count(Property.id).desc())
            .limit(4)
            .all()
        )
        
        for row in complexes:
            suggestions.append({
                'type': 'complex',
                'title': row[0],
                'subtitle': f'{row[1]} квартир',
                'icon': 'building',
                'url': f'/properties?residential_complex={row[0]}'
            })
        
        return jsonify({'suggestions': suggestions[:6]})
    except Exception as e:
        return jsonify({'suggestions': [], 'error': str(e)})

@app.route('/api/super-search')
@cache.memoize(timeout=180)  # Кэш на 3 минуты
def super_search_api():
    """Новый супер-быстрый поиск недвижимости"""
    query = request.args.get('q', '').strip()
    if not query:
        return jsonify({'results': [], 'total': 0})
    
    try:
        from smart_search import smart_search
        results = smart_search.search_properties(query, limit=50)
        return jsonify(results)
        
    except Exception as e:
        print(f"Super search error: {e}")
        return jsonify({'results': [], 'total': 0, 'error': str(e)})

@app.route('/api/metrics', methods=['POST'])
def collect_metrics():
    """Сбор метрик производительности для анализа"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'status': 'error', 'message': 'No data provided'}), 400
        
        # Логируем важные метрики
        metric_type = data.get('type', 'unknown')
        
        if metric_type == 'page_load':
            duration = data.get('duration', 0)
            url = data.get('url', 'unknown')
            print(f"⚡ Page Load: {url} in {round(duration)}ms")
        
        elif metric_type == 'search_performance':
            query = data.get('query', '')
            response_time = data.get('response_time', 0)
            results_count = data.get('results_count', 0)
            print(f"🔍 Search: '{query}' - {round(response_time)}ms, {results_count} results")
        
        # В реальном приложении здесь бы была запись в базу данных
        # для аналитики производительности
        
        return jsonify({'status': 'success'})
        
    except Exception as e:
        print(f"Metrics collection error: {e}")
        return jsonify({'status': 'error'}), 500

@app.route('/api/smart-suggestions')
def smart_suggestions_api():
    """API для получения умных подсказок поиска"""
    query = request.args.get('q', '').strip()
    
    if len(query) < 2:
        return jsonify({'suggestions': []})
    
    try:
        suggestions = smart_search.generate_search_suggestions(query)
        return jsonify({'suggestions': suggestions})
    except Exception as e:
        print(f"ERROR: Smart suggestions failed: {e}")
        return jsonify({'suggestions': []})

def apply_smart_filters(properties, criteria):
    """Применяет умные фильтры на основе критериев OpenAI"""
    filtered = properties.copy()
    
    # Фильтр по комнатам
    if criteria.get('rooms'):
        rooms_list = criteria['rooms']
        filtered = [p for p in filtered if str(p.get('rooms', '')) in rooms_list]
    
    # Фильтр по району
    if criteria.get('district'):
        district = criteria['district']
        filtered = [p for p in filtered if p.get('district', '') == district]
    
    # Фильтр по ключевым словам (типы недвижимости, классы, материалы)
    if criteria.get('keywords'):
        keywords_filtered = []
        for prop in filtered:
            prop_matches = False
            for keyword in criteria['keywords']:
                keyword_lower = keyword.lower()
                
                # Тип недвижимости
                prop_type_lower = prop.get('property_type', 'Квартира').lower()
                if keyword_lower == prop_type_lower:
                    prop_matches = True
                    break
                
                # Класс недвижимости (точное совпадение)
                prop_class_lower = prop.get('property_class', '').lower()
                if keyword_lower == prop_class_lower:
                    prop_matches = True
                    break
                
                # Материал стен
                wall_material_lower = prop.get('wall_material', '').lower()
                if keyword_lower in wall_material_lower:
                    prop_matches = True
                    break
                
                # Особенности
                features = prop.get('features', [])
                if any(keyword_lower in feature.lower() for feature in features):
                    prop_matches = True
                    break
                
                # Особая логика для ценовых категорий
                if keyword_lower == 'дорого' or keyword_lower == 'недорого':
                    # Эти ключевые слова обрабатываются отдельно после фильтрации
                    continue
                
                # Поиск в заголовке как fallback
                property_title = f"{prop.get('rooms', 0)}-комн {prop.get('area', 0)} м²" if prop.get('rooms', 0) > 0 else f"Студия {prop.get('area', 0)} м²"
                title_lower = property_title.lower()
                if keyword_lower in title_lower:
                    prop_matches = True
                    break
            
            if prop_matches:
                keywords_filtered.append(prop)
        
        filtered = keywords_filtered
        
        # Обработка ценовых ключевых слов после основной фильтрации
        if 'дорого' in criteria.get('keywords', []):
            # Сортируем по цене и берем верхние 50%
            filtered = sorted(filtered, key=lambda x: x.get('price', 0), reverse=True)
            filtered = filtered[:max(1, len(filtered)//2)]
        elif 'недорого' in criteria.get('keywords', []):
            # Сортируем по цене и берем нижние 50%
            filtered = sorted(filtered, key=lambda x: x.get('price', 0))
            filtered = filtered[:max(1, len(filtered)//2)]
    
    # Фильтр по особенностям
    if criteria.get('features'):
        features_list = criteria['features']
        features_filtered = []
        for prop in filtered:
            prop_features = [f.lower() for f in prop.get('features', [])]
            if any(feature.lower() in prop_features for feature in features_list):
                features_filtered.append(prop)
        filtered = features_filtered
    
    # Фильтр по цене
    if criteria.get('price_range'):
        price_range = criteria['price_range']
        if len(price_range) >= 1 and price_range[0]:
            min_price = price_range[0]
            filtered = [p for p in filtered if p.get('price', 0) >= min_price]
        if len(price_range) >= 2 and price_range[1]:
            max_price = price_range[1]
            filtered = [p for p in filtered if p.get('price', 0) <= max_price]
    
    return filtered

# Manager Client Management Routes
@app.route('/manager/clients')
@manager_required
def manager_clients():
    """Manager clients page"""
    from models import User, Manager
    
    current_manager = current_user
    
    if not current_manager:
        return redirect(url_for('manager_login'))
    
    # Get clients assigned to this manager
    clients = User.query.filter_by(assigned_manager_id=current_manager.id).order_by(User.created_at.desc()).all()
    
    return render_template('manager/clients.html', 
                         manager=current_manager,
                         clients=clients)

# Manager Deals Management Routes  
@app.route('/manager/deals')
@manager_required
def manager_deals():
    """Manager deals page"""
    from models import User, Manager, Deal, ResidentialComplex
    from sqlalchemy import func
    
    current_manager = current_user
    
    if not current_manager:
        return redirect(url_for('manager_login'))
    
    # Get deals for this manager
    deals = Deal.query.filter_by(manager_id=current_manager.id).order_by(Deal.created_at.desc()).all()
    
    # Get clients available for this manager (assigned OR unassigned)
    # Менеджер может создавать сделки для своих клиентов и для неназначенных клиентов
    assigned_clients = User.query.filter(
        db.or_(
            User.assigned_manager_id == current_manager.id,
            User.assigned_manager_id == None
        )
    ).filter_by(role='buyer').order_by(User.full_name).all()
    
    residential_complexes = ResidentialComplex.query.order_by(ResidentialComplex.name).all()
    
    # Calculate stats
    active_deals_count = Deal.query.filter(
        Deal.manager_id == current_manager.id,
        Deal.status.in_(['new', 'reserved', 'mortgage'])
    ).count()
    
    completed_deals_count = Deal.query.filter(
        Deal.manager_id == current_manager.id,
        Deal.status == 'completed'
    ).count()
    
    in_progress_deals_count = Deal.query.filter(
        Deal.manager_id == current_manager.id,
        Deal.status.in_(['reserved', 'mortgage'])
    ).count()
    
    # Calculate total cashback
    total_cashback = db.session.query(func.sum(Deal.cashback_amount)).filter(
        Deal.manager_id == current_manager.id,
        Deal.status == 'completed'
    ).scalar() or 0
    
    return render_template('manager/deals.html',
                         manager=current_manager,
                         deals=deals,
                         assigned_clients=assigned_clients,
                         residential_complexes=residential_complexes,
                         active_deals_count=active_deals_count,
                         completed_deals_count=completed_deals_count,
                         in_progress_deals_count=in_progress_deals_count,
                         total_cashback=int(total_cashback))


@app.route('/api/manager/add-client', methods=['POST'])
@manager_required
def manager_add_client():
    """Add new client"""
    from models import User, Manager
    import re
    
    current_manager = current_user
    print(f"DEBUG: Add client endpoint called by manager {current_manager.id}")
    print(f"DEBUG: Request method: {request.method}, Content-Type: {request.content_type}")
    print(f"DEBUG: Request is_json: {request.is_json}")
    
    try:
        # Accept both JSON and form data
        if request.is_json:
            data = request.get_json()
            print(f"DEBUG: Received JSON data: {data}")
            full_name = data.get('full_name', '').strip()
            email = data.get('email', '').strip().lower()
            phone = data.get('phone', '').strip() if data.get('phone') else None
            is_active = data.get('is_active', True)
        else:
            print(f"DEBUG: Received form data: {dict(request.form)}")
            full_name = request.form.get('full_name', '').strip()
            email = request.form.get('email', '').strip().lower()
            phone = request.form.get('phone', '').strip() if request.form.get('phone') else None
            is_active = 'is_active' in request.form
        
        print(f"DEBUG: Parsed data - name: {full_name}, email: {email}, phone: {phone}, active: {is_active}")
        
        # Validation
        if not full_name or len(full_name) < 2:
            return jsonify({'success': False, 'error': 'Полное имя должно содержать минимум 2 символа'}), 400
        
        # Email validation
        email_regex = r'^[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}$'
        if not email or not re.match(email_regex, email):
            return jsonify({'success': False, 'error': 'Введите корректный email адрес'}), 400
        
        # Phone validation (optional but must be correct format if provided)
        if phone:
            phone_regex = r'^\+7-\d{3}-\d{3}-\d{2}-\d{2}$'
            if not re.match(phone_regex, phone):
                return jsonify({'success': False, 'error': 'Телефон должен быть в формате +7-918-123-45-67'}), 400
        
        # Check if email already exists
        existing_user = User.query.filter_by(email=email).first()
        if existing_user:
            return jsonify({'success': False, 'error': 'Пользователь с таким email уже существует'}), 400
        
        # Generate temporary password
        import secrets
        import string
        temp_password = ''.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(8))
        
        # Create new user with temporary password
        user = User(
            full_name=full_name,
            email=email,
            phone=phone,
            is_active=is_active,
            role='buyer',
            assigned_manager_id=current_manager.id,
            registration_source='Manager',
            client_status='Новый'
        )
        user.set_password(temp_password)  # Set temporary password
        
        db.session.add(user)
        db.session.commit()
        
        print(f"DEBUG: Successfully created client {user.id}: {user.full_name}")
        
        # Send welcome email and SMS with credentials
        try:
            from email_service import send_email
            manager = Manager.query.get(manager_id)
            manager_name = manager.full_name if manager else 'Ваш менеджер'
            
            # Email with login credentials
            subject = "Ваш аккаунт создан в InBack.ru - Данные для входа"
            email_content = f"""Здравствуйте, {full_name}!

Для вас создан аккаунт на платформе InBack.ru

📧 Email для входа: {email}
🔑 Временный пароль: {temp_password}

🌐 Ссылка для входа: {request.url_root.rstrip('/')}/login

ВАЖНО: Рекомендуем сменить пароль после первого входа в разделе "Настройки профиля"

Ваш персональный менеджер: {manager_name}

По всем вопросам обращайтесь к своему менеджеру.

С уважением,
Команда InBack.ru"""
            
            send_email(
                to_email=email,
                subject=subject,
                content=email_content,
                template_name='notification'
            )
            print(f"DEBUG: Welcome email with credentials sent to {email}")
            
            # Send SMS if phone number provided
            if phone:
                try:
                    from sms_service import send_login_credentials_sms
                    
                    sms_sent = send_login_credentials_sms(
                        phone=phone,
                        email=email,
                        password=temp_password,
                        manager_name=manager_name,
                        login_url=f"{request.url_root.rstrip('/')}/login"
                    )
                    
                    if sms_sent:
                        print(f"DEBUG: SMS sent successfully to {phone}")
                    else:
                        print(f"DEBUG: SMS sending failed for {phone}")
                    
                except Exception as sms_e:
                    print(f"DEBUG: Failed to send SMS: {sms_e}")
                    
        except Exception as e:
            print(f"DEBUG: Failed to send welcome email: {e}")
        
        return jsonify({
            'success': True, 
            'client_id': user.id,
            'message': f'Клиент {full_name} успешно добавлен. Данные для входа отправлены на email {email}' + (f' и SMS на {phone}' if phone else '') + '.',
            'client_data': {
                'id': user.id,
                'full_name': user.full_name,
                'email': user.email,
                'phone': user.phone,
                'user_id': user.user_id,
                'login_url': f"{request.url_root.rstrip('/')}/login",
                'temp_password': temp_password  # Include for manager reference
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding client: {str(e)}")
        return jsonify({'success': False, 'error': f'Ошибка сервера: {str(e)}'}), 500

@app.route('/manager/get-client/<int:client_id>')
@manager_required
def manager_get_client(client_id):
    """Get client data for editing"""
    from models import User

# ================================
# DEAL MANAGEMENT API ENDPOINTS
# ================================

@app.route('/api/deals', methods=['POST'])
@manager_required
@require_json_csrf
def api_create_deal():
    """Create new deal (managers only)"""
    from models import Deal, Manager, User, ResidentialComplex
    from decimal import Decimal
    
    try:
        current_manager = current_user
        data = request.get_json()
        
        if not data:
            return jsonify({'success': False, 'error': 'Нет данных для обработки'}), 400
        
        # Validation - client_id and price are required
        if 'client_id' not in data or not data['client_id']:
            return jsonify({'success': False, 'error': 'Поле client_id обязательно'}), 400
        if 'property_price' not in data or not data['property_price']:
            return jsonify({'success': False, 'error': 'Поле property_price обязательно'}), 400
        
        # Get complex name from request
        complex_name = data.get('residential_complex_name', '').strip()
        if not complex_name:
            return jsonify({'success': False, 'error': 'Необходимо указать название ЖК'}), 400
        
        # Validate client exists and belongs to this manager
        client_id = int(data['client_id'])
        client = User.query.get(client_id)
        if not client:
            return jsonify({'success': False, 'error': 'Клиент не найден'}), 404
        
        # Менеджер может создавать сделки для:
        # 1. Своих назначенных клиентов (assigned_manager_id == current_manager.id)
        # 2. Неназначенных клиентов (assigned_manager_id is None)
        if client.assigned_manager_id is not None and client.assigned_manager_id != current_manager.id:
            return jsonify({'success': False, 'error': 'Этот клиент уже назначен другому менеджеру'}), 403
        
        # Validate price and cashback amounts
        try:
            property_price = Decimal(str(data['property_price']))
            cashback_amount = Decimal(str(data['cashback_amount']))
            
            if property_price <= 0:
                return jsonify({'success': False, 'error': 'Стоимость объекта должна быть больше 0'}), 400
            
            if cashback_amount < 0:
                return jsonify({'success': False, 'error': 'Сумма кешбека не может быть отрицательной'}), 400
                
            # Get complex cashback rate for validation
            max_rate = Decimal('0.15')  # Default max 15% cashback
            if cashback_amount > property_price * max_rate:  # Max cashback validation
                return jsonify({'success': False, 'error': f'Сумма кешбека не может превышать {max_rate * 100}% от стоимости объекта'}), 400
                
        except (ValueError, TypeError):
            return jsonify({'success': False, 'error': 'Некорректные значения цены или кешбека'}), 400
        
        # Create new deal
        deal = Deal(
            manager_id=current_manager.id,
            client_id=data['client_id'],
            residential_complex_name=complex_name,  # Save complex name as text
            property_price=property_price,
            cashback_amount=cashback_amount,
            property_description=data.get('property_description', ''),
            property_floor=data.get('property_floor'),
            property_area=data.get('property_area'),
            property_rooms=data.get('property_rooms', ''),
            status=data.get('status', 'new'),
            notes=data.get('notes', ''),
            client_notes=data.get('client_notes', '')
        )
        
        db.session.add(deal)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Сделка успешно создана',
            'deal': {
                'id': deal.id,
                'deal_number': deal.deal_number,
                'status': deal.status,
                'status_display': deal.status_display,
                'property_price': float(deal.property_price),
                'cashback_amount': float(deal.cashback_amount),
                'client_name': client.full_name,
                'complex_name': complex_name,
                'created_at': deal.created_at.isoformat()
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error creating deal: {e}")
        return jsonify({'success': False, 'error': 'Ошибка сервера при создании сделки'}), 500


@app.route('/api/deals', methods=['GET'])
def api_get_deals():
    """Get list of deals with filtering"""
    from models import Deal, Manager, User, ResidentialComplex
    from flask_login import current_user
    
    print("🤝 DEBUG: /api/deals endpoint called")
    
    try:
        # Check if user is manager or client
        is_manager = current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager)
        
        print(f"🤝 DEBUG: is_manager={is_manager}, authenticated={current_user.is_authenticated}")
        
        if is_manager:
            # Manager can see all their deals
            current_manager = current_user
            print(f"🤝 DEBUG: Manager ID = {current_manager.id}, Email = {current_manager.email}")
            deals_query = Deal.query.filter_by(manager_id=current_manager.id)
        elif current_user.is_authenticated:
            # Client can only see their own deals
            user_id = current_user.id
            print(f"🤝 DEBUG: Client ID = {user_id}")
            deals_query = Deal.query.filter_by(client_id=user_id)
        else:
            # No authentication
            print("🤝 DEBUG: User not authenticated")
            return jsonify({'success': False, 'error': 'Не авторизован'}), 401
        
        # Apply status filtering if provided
        status_filter = request.args.get('status')
        if status_filter:
            status_list = [s.strip() for s in status_filter.split(',') if s.strip()]
            if status_list:
                print(f"🤝 DEBUG: Applying status filter: {status_list}")
                deals_query = deals_query.filter(Deal.status.in_(status_list))
        
        # Order by creation date (newest first)
        deals = deals_query.order_by(Deal.created_at.desc()).all()
        
        print(f"🤝 DEBUG: Found {len(deals)} deals")
        if len(deals) > 0:
            print(f"🤝 DEBUG: First deal: ID={deals[0].id}, Client={deals[0].client.full_name}, Complex={deals[0].residential_complex_name}")
        
        # Format response
        deals_data = []
        for deal in deals:
            deals_data.append({
                'id': deal.id,
                'deal_number': deal.deal_number,
                'status': deal.status,
                'status_display': deal.status_display,
                'status_color': deal.status_color,
                'property_price': float(deal.property_price),
                'cashback_amount': float(deal.cashback_amount),
                'cashback_percentage': deal.get_cashback_percentage(),
                'property_description': deal.property_description,
                'property_floor': deal.property_floor,
                'property_area': deal.property_area,
                'property_rooms': deal.property_rooms,
                'notes': deal.notes,
                'client_notes': deal.client_notes,
                'client_name': deal.client.full_name,
                'manager_name': deal.manager.full_name,
                'complex_name': deal.residential_complex_name or (deal.residential_complex.name if deal.residential_complex else ''),
                'contract_date': deal.contract_date.isoformat() if deal.contract_date else None,
                'completion_date': deal.completion_date.isoformat() if deal.completion_date else None,
                'created_at': deal.created_at.isoformat(),
                'updated_at': deal.updated_at.isoformat(),
                'can_edit': deal.can_edit(current_manager.id if is_manager else current_user.id, is_manager)
            })
        
        print(f"🤝 DEBUG: Returning {len(deals_data)} deals to client")
        
        return jsonify({
            'success': True,
            'deals': deals_data,
            'total': len(deals_data),
            'is_manager': is_manager
        })
        
    except Exception as e:
        print(f"❌ Error getting deals: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': 'Ошибка сервера при получении сделок'}), 500



@app.route('/api/deals/<int:deal_id>', methods=['GET'])
@login_required
def api_get_deal(deal_id):
    """Get specific deal with access control"""
    from models import Deal
    
    try:
        deal = Deal.query.get(deal_id)
        if not deal:
            return jsonify({'success': False, 'error': 'Сделка не найдена'}), 404
        
        # Check access rights
        is_manager = current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager)
        
        if is_manager:
            # Manager can only see their own deals
            current_manager = current_user
            if deal.manager_id != current_manager.id:
                return jsonify({'success': False, 'error': 'Недостаточно прав для просмотра этой сделки'}), 403
        else:
            # Client can only see their own deals
            if deal.client_id != current_user.id:
                return jsonify({'success': False, 'error': 'Недостаточно прав для просмотра этой сделки'}), 403
        
        # Return deal data
        deal_data = {
            'id': deal.id,
            'deal_number': deal.deal_number,
            'status': deal.status,
            'status_display': deal.status_display,
            'status_color': deal.status_color,
            'property_price': float(deal.property_price),
            'cashback_amount': float(deal.cashback_amount),
            'cashback_percentage': deal.get_cashback_percentage(),
            'property_description': deal.property_description,
            'property_floor': deal.property_floor,
            'property_area': deal.property_area,
            'property_rooms': deal.property_rooms,
            'notes': deal.notes,
            'client_notes': deal.client_notes,
            'client_name': deal.client.full_name,
            'client_email': deal.client.email,
            'client_phone': deal.client.phone,
            'manager_name': deal.manager.full_name,
            'manager_email': deal.manager.email,
            'manager_phone': deal.manager.phone,
            'complex_name': deal.residential_complex_name or (deal.residential_complex.name if deal.residential_complex else ''),
            'complex_id': deal.residential_complex.id if deal.residential_complex else None,
            'contract_date': deal.contract_date.isoformat() if deal.contract_date else None,
            'completion_date': deal.completion_date.isoformat() if deal.completion_date else None,
            'created_at': deal.created_at.isoformat(),
            'updated_at': deal.updated_at.isoformat(),
            'can_edit': deal.can_edit(current_manager.id if is_manager else current_user.id, is_manager)
        }
        
        return jsonify({
            'success': True,
            'deal': deal_data
        })
        
    except Exception as e:
        print(f"Error getting deal {deal_id}: {e}")
        return jsonify({'success': False, 'error': 'Ошибка сервера при получении сделки'}), 500


@app.route('/api/deals/<int:deal_id>', methods=['PUT'])
@require_json_csrf
def api_update_deal(deal_id):
    """Update deal (status, notes)"""
    from models import Deal
    from datetime import datetime, date
    from flask_login import current_user
    
    try:
        # Check authentication
        is_manager = current_user.is_authenticated and isinstance(current_user._get_current_object(), Manager)
        
        if not is_manager and not current_user.is_authenticated:
            return jsonify({'success': False, 'error': 'Не авторизован'}), 401
        
        deal = Deal.query.get(deal_id)
        if not deal:
            return jsonify({'success': False, 'error': 'Сделка не найдена'}), 404
        
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'Нет данных для обновления'}), 400
        
        if is_manager:
            # Manager can only update their own deals
            current_manager = current_user
            if deal.manager_id != current_manager.id:
                return jsonify({'success': False, 'error': 'Недостаточно прав для редактирования этой сделки'}), 403
            
            # Manager can update all fields
            allowed_fields = ['status', 'notes', 'client_notes', 'property_description', 
                            'property_floor', 'property_area', 'property_rooms', 
                            'contract_date', 'completion_date']
            
            # Allow editing property_price and cashback_amount ONLY when changing to 'successful' status
            if 'status' in data and data['status'] == 'successful':
                allowed_fields.extend(['property_price', 'cashback_amount'])
                app.logger.info(f"💰 Manager {current_manager.id} ({current_manager.email}) is completing deal #{deal.deal_number} - allowing financial fields editing")
        else:
            # Client can only update their own deals and limited fields
            if deal.client_id != current_user.id:
                return jsonify({'success': False, 'error': 'Недостаточно прав для редактирования этой сделки'}), 403
            
            # Client can only update notes and only if deal is in editable status
            if deal.status not in ['new', 'object_reserved']:
                return jsonify({'success': False, 'error': 'Сделка больше не может быть отредактирована'}), 403
            
            allowed_fields = ['client_notes']
        
        # Store old values for logging
        old_status = deal.status
        old_property_price = float(deal.property_price) if deal.property_price else 0
        old_cashback_amount = float(deal.cashback_amount) if deal.cashback_amount else 0
        
        # Update allowed fields
        updated_fields = []
        
        for field in allowed_fields:
            if field in data:
                if field == 'status':
                    # Validate status
                    valid_statuses = ['new', 'object_reserved', 'mortgage', 'successful', 'rejected']
                    if data[field] not in valid_statuses:
                        return jsonify({'success': False, 'error': f'Недопустимый статус: {data[field]}'}), 400
                    # Save validated status
                    setattr(deal, field, data[field])
                    updated_fields.append(field)
                
                elif field in ['contract_date', 'completion_date']:
                    # Handle date fields
                    if data[field]:
                        try:
                            date_value = datetime.strptime(data[field], '%Y-%m-%d').date()
                            setattr(deal, field, date_value)
                            updated_fields.append(field)
                        except ValueError:
                            return jsonify({'success': False, 'error': f'Некорректный формат даты для {field}. Используйте YYYY-MM-DD'}), 400
                    else:
                        setattr(deal, field, None)
                        updated_fields.append(field)
                
                elif field == 'property_price':
                    # Validate and handle property_price
                    try:
                        price_value = float(data[field])
                        if price_value <= 0:
                            return jsonify({'success': False, 'error': 'Стоимость объекта должна быть больше нуля'}), 400
                        setattr(deal, field, price_value)
                        updated_fields.append(field)
                        app.logger.debug(f"💰 Deal #{deal.deal_number}: property_price set to {price_value}")
                    except (ValueError, TypeError):
                        return jsonify({'success': False, 'error': 'Некорректное значение стоимости объекта'}), 400
                
                elif field == 'cashback_amount':
                    # Validate and handle cashback_amount
                    try:
                        cashback_value = float(data[field])
                        if cashback_value < 0:
                            return jsonify({'success': False, 'error': 'Сумма кешбека не может быть отрицательной'}), 400
                        
                        # Check if cashback exceeds property price (use updated property_price if provided, otherwise use current)
                        property_price = float(data.get('property_price', deal.property_price))
                        if cashback_value > property_price:
                            return jsonify({'success': False, 'error': 'Сумма кешбека не может превышать стоимость объекта'}), 400
                        
                        setattr(deal, field, cashback_value)
                        updated_fields.append(field)
                        app.logger.debug(f"💰 Deal #{deal.deal_number}: cashback_amount set to {cashback_value}")
                    except (ValueError, TypeError):
                        return jsonify({'success': False, 'error': 'Некорректное значение суммы кешбека'}), 400
                
                else:
                    # Handle text fields
                    setattr(deal, field, data[field])
                    updated_fields.append(field)
        
        if not updated_fields:
            return jsonify({'success': False, 'error': 'Нет полей для обновления'}), 400
        
        # Update timestamp
        deal.updated_at = datetime.utcnow()
        
        # Comprehensive logging for financial fields changes
        if is_manager and ('property_price' in updated_fields or 'cashback_amount' in updated_fields):
            current_manager = current_user
            timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
            
            if 'property_price' in updated_fields:
                new_property_price = float(deal.property_price)
                if old_property_price != new_property_price:
                    app.logger.info(
                        f"💰 Deal #{deal.deal_number}: property_price changed from "
                        f"{old_property_price:,.2f}₽ to {new_property_price:,.2f}₽ "
                        f"by manager {current_manager.id} ({current_manager.email}) "
                        f"at {timestamp}"
                    )
            
            if 'cashback_amount' in updated_fields:
                new_cashback_amount = float(deal.cashback_amount)
                if old_cashback_amount != new_cashback_amount:
                    app.logger.info(
                        f"💰 Deal #{deal.deal_number}: cashback_amount changed from "
                        f"{old_cashback_amount:,.2f}₽ to {new_cashback_amount:,.2f}₽ "
                        f"by manager {current_manager.id} ({current_manager.email}) "
                        f"at {timestamp}"
                    )
        
        db.session.commit()
        
        # 💰 АВТОМАТИЧЕСКОЕ НАЧИСЛЕНИЕ БАЛАНСА ПРИ ЗАВЕРШЕНИИ СДЕЛКИ

        # Helper function для форматирования денег с копейками
        def _format_money_ru(amount):
            """Format Decimal/float as RUB with kopecks: 1 234,56 ₽"""
            from decimal import Decimal, ROUND_HALF_UP
            KOPECK = Decimal('0.01')
            rounded = Decimal(str(amount)).quantize(KOPECK, rounding=ROUND_HALF_UP)
            formatted = f"{rounded:,.2f}".replace(',', ' ').replace('.', ',')
            return f"{formatted} ₽"

        if 'status' in updated_fields and old_status != deal.status and deal.status == 'successful':
            try:
                from services.balance_service import BalanceService
                from models import BalanceTransaction
                
                # Проверить что баланс еще не начислен за эту сделку
                existing_transaction = BalanceTransaction.query.filter_by(
                    deal_id=deal.id,
                    transaction_type='cashback_earned'
                ).first()
                
                if not existing_transaction and deal.cashback_amount > 0:
                    # Начислить кешбек через новую систему балансов
                    transaction = BalanceService.credit_balance(
                        user_id=deal.client_id,
                        amount=deal.cashback_amount,
                        description=f'Кешбек по сделке {deal.deal_number} ({deal.residential_complex_name or "объект"})',
                        transaction_type='cashback_earned',
                        deal_id=deal.id,
                        created_by_id=deal.manager_id
                    )
                    
                    app.logger.info(f"✅ Кешбек {deal.cashback_amount}₽ начислен клиенту (user_id={deal.client_id}) за сделку {deal.deal_number}")
                    
                    # Отправить уведомление клиенту о начислении кешбека
                    try:
                        from telegram_bot import send_telegram_message
                        from models import User
                        client = User.query.get(deal.client_id)
                        
                        if client:
                            message = f"🎉 Поздравляем! Вам начислен кешбек {_format_money_ru(deal.cashback_amount)}₽ по сделке {deal.deal_number}.\n\nСредства доступны для вывода в личном кабинете."
                            
                            # Telegram
                            if client.telegram_chat_id:
                                send_telegram_message(client.telegram_chat_id, message)
                            
                            # Email
                            if client.email:
                                email_subject = f"Начислен кешбек {_format_money_ru(deal.cashback_amount)}₽"
                                email_body = f"""
Здравствуйте, {client.full_name or client.email.split('@')[0]}!

Поздравляем! Вам начислен кешбек {_format_money_ru(deal.cashback_amount)}₽ по сделке {deal.deal_number}.

Детали сделки:
- Объект: {deal.residential_complex_name or 'N/A'}
- Стоимость: {_format_money_ru(deal.property_price)}₽
- Кешбек: {_format_money_ru(deal.cashback_amount)}₽

Средства доступны для вывода в личном кабинете.

С уважением,
Команда InBack
"""
                                send_email_notification(client.email, email_subject, email_body)
                                
                            app.logger.info(f"✅ Уведомления отправлены клиенту {client.id} о начислении кешбека")
                    except Exception as e:
                        app.logger.error(f"Ошибка отправки уведомления о кешбеке: {str(e)}")
                    
            except Exception as e:
                app.logger.error(f"❌ Ошибка начисления кешбека для сделки {deal.id}: {str(e)}")
                # НЕ откатываем всю сделку если не удалось начислить баланс
                # Администратор может начислить вручную через админ-панель
        
        # Логируем изменение статуса
        if 'status' in updated_fields and old_status != deal.status:
            from models import UserActivity
            status_display_map = {
                'new': 'Новая',
                'object_reserved': 'Объект зарезервирован',
                'mortgage': 'Ипотека',
                'successful': 'Успешно завершена',
                'rejected': 'Отклонена'
            }
            old_status_display = status_display_map.get(old_status, old_status)
            new_status_display = status_display_map.get(deal.status, deal.status)
            
            UserActivity.log_activity(
                user_id=deal.client_id,
                activity_type='deal_status_update',
                description=f'Статус сделки {deal.deal_number} изменен с "{old_status_display}" на "{new_status_display}"'
            )
        
        return jsonify({
            'success': True,
            'message': 'Сделка успешно обновлена',
            'updated_fields': updated_fields,
            'deal': {
                'id': deal.id,
                'deal_number': deal.deal_number,
                'status': deal.status,
                'status_display': deal.status_display,
                'status_color': deal.status_color,
                'property_price': float(deal.property_price),
                'cashback_amount': float(deal.cashback_amount),
                'cashback_percentage': deal.get_cashback_percentage(),
                'property_description': deal.property_description,
                'property_floor': deal.property_floor,
                'property_area': deal.property_area,
                'property_rooms': deal.property_rooms,
                'notes': deal.notes,
                'client_notes': deal.client_notes,
                'client_name': deal.client.full_name,
                'complex_name': deal.residential_complex_name or (deal.residential_complex.name if deal.residential_complex else ''),
                'contract_date': deal.contract_date.isoformat() if deal.contract_date else None,
                'completion_date': deal.completion_date.isoformat() if deal.completion_date else None,
                'updated_at': deal.updated_at.isoformat()
            }
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error updating deal {deal_id}: {e}")
        return jsonify({'success': False, 'error': 'Ошибка сервера при обновлении сделки'}), 500


@app.route('/api/deals/<int:deal_id>', methods=['DELETE'])
@manager_required
@require_json_csrf
def api_delete_deal(deal_id):
    """Delete deal (managers only)"""
    from models import Deal
    
    try:
        deal = Deal.query.get(deal_id)
        if not deal:
            return jsonify({'success': False, 'error': 'Сделка не найдена'}), 404
        
        current_manager = current_user
        
        # Check if manager owns this deal
        if deal.manager_id != current_manager.id:
            return jsonify({'success': False, 'error': 'Недостаточно прав для удаления этой сделки'}), 403
        
        # Check if deal can be deleted (only new or rejected deals)
        if deal.status not in ['new', 'rejected']:
            return jsonify({'success': False, 'error': 'Нельзя удалить сделку со статусом "' + deal.status_display + '"'}), 400
        
        deal_number = deal.deal_number
        db.session.delete(deal)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'Сделка {deal_number} успешно удалена'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting deal {deal_id}: {e}")
        return jsonify({'success': False, 'error': 'Ошибка сервера при удалении сделки'}), 500

@app.route('/manager/edit-client', methods=['POST'])
@manager_required
def manager_edit_client():
    """Edit existing client"""
    from models import User
    
    current_manager = current_user
    
    try:
        client_id = request.form.get('client_id')
        full_name = request.form.get('full_name')
        email = request.form.get('email')
        phone = request.form.get('phone')
        is_active = 'is_active' in request.form
        
        if not client_id:
            return jsonify({'success': False, 'error': 'ID клиента не указан'}), 400
        
        # Try to find client assigned to this manager first, then any buyer
        client = User.query.filter_by(id=client_id, assigned_manager_id=current_manager.id).first()
        if not client:
            client = User.query.filter_by(id=client_id, role='buyer').first()
        
        if not client:
            return jsonify({'success': False, 'error': 'Клиент не найден'}), 404
        
        if not all([full_name, email]):
            return jsonify({'success': False, 'error': 'Заполните обязательные поля'}), 400
        
        # Check if email already exists (excluding current client)
        existing_user = User.query.filter(User.email == email, User.id != client_id).first()
        if existing_user:
            return jsonify({'success': False, 'error': 'Пользователь с таким email уже существует'}), 400
        
        # Update client data
        client.full_name = full_name
        client.email = email
        client.phone = phone
        client.is_active = is_active
        client.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/manager/delete-client', methods=['POST'])
@manager_required
def manager_delete_client():
    """Delete client"""
    from models import User
    
    current_manager = current_user
    
    try:
        # Handle both JSON and form data
        if request.content_type == 'application/json':
            data = request.get_json()
            client_id = data.get('client_id')
        else:
            client_id = request.form.get('client_id')
        
        if not client_id:
            return jsonify({'success': False, 'error': 'ID клиента не указан'}), 400
        
        # Try to find client assigned to this manager first, then any buyer
        client = User.query.filter_by(id=client_id, assigned_manager_id=current_manager.id).first()
        if not client:
            client = User.query.filter_by(id=client_id, role='buyer').first()
        
        if not client:
            return jsonify({'success': False, 'error': 'Клиент не найден'}), 404
        
        # Instead of deleting, mark as inactive
        client.is_active = False
        client.updated_at = datetime.utcnow()
        
        db.session.commit()
        
        return jsonify({'success': True})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

def send_callback_notification_email(callback_req, manager):
    """Send email notification about callback request"""
    try:
        from email_service import send_email
        
        # Email content
        subject = f"Новая заявка на обратный звонок - {callback_req.name}"
        
        # Build message content
        content = f"""
        Получена новая заявка на обратный звонок:
        
        Клиент: {callback_req.name}
        Телефон: {callback_req.phone}
        Email: {callback_req.email or 'Не указан'}
        Удобное время: {callback_req.preferred_time}
        
        Интересует: {callback_req.interest}
        Бюджет: {callback_req.budget}
        Планирует покупку: {callback_req.timing}
        
        Дополнительно: {callback_req.notes or 'Нет дополнительной информации'}
        
        Назначенный менеджер: {manager.full_name if manager else 'Не назначен'}
        Дата заявки: {callback_req.created_at.strftime('%d.%m.%Y %H:%M')}
        """
        
        # Try to send to manager first, then to admin email
        recipient_email = manager.email if manager else 'admin@inback.ru'
        
        success = send_email(
            to_email=recipient_email,
            subject=subject,
            content=content,
            template_name='notification'
        )
        
        if success:
            print(f"✓ Callback notification email sent to {recipient_email}")
        else:
            print(f"✗ Failed to send callback notification email to {recipient_email}")
            
    except Exception as e:
        print(f"Error sending callback notification email: {e}")


def send_callback_notification_telegram(callback_req, manager):
    """Send Telegram notification about callback request"""
    try:
        # Check if telegram_bot module can be imported
        try:
            from telegram_bot import send_telegram_message
        except ImportError as e:
            print(f"Telegram bot not available: {e}")
            return False
        
        # Calculate potential cashback
        potential_cashback = ""
        if callback_req.budget:
            if "млн" in callback_req.budget:
                # Extract average from range like "3-5 млн"
                numbers = [float(x) for x in callback_req.budget.replace(" млн", "").replace("руб", "").split("-") if x.strip().replace(".", "").replace(",", "").isdigit()]
                if numbers:
                    avg_price = sum(numbers) / len(numbers) * 1000000
                    cashback = int(avg_price * 0.02)
                    potential_cashback = f"💰 *Потенциальный кэшбек:* {cashback:,} руб. (2%)\n"
        
        # Enhanced Telegram message
        message = f"""📞 *НОВАЯ ЗАЯВКА НА ОБРАТНЫЙ ЗВОНОК*

👤 *КОНТАКТНАЯ ИНФОРМАЦИЯ:*
• Имя: {callback_req.name}
• Телефон: {callback_req.phone}
• Email: {callback_req.email or 'Не указан'}
• Удобное время звонка: {callback_req.preferred_time}

🔍 *КРИТЕРИИ ПОИСКА:*
• Интересует: {callback_req.interest or 'Не указано'}
• Бюджет: {callback_req.budget or 'Не указан'}
• Планы на покупку: {callback_req.timing or 'Не указано'}

{potential_cashback}📝 *ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ:*
{callback_req.notes or 'Нет дополнительной информации'}

📅 *ВРЕМЯ ЗАЯВКИ:* {callback_req.created_at.strftime('%d.%m.%Y в %H:%M')}
🌐 *ИСТОЧНИК:* Форма обратного звонка на сайте InBack.ru
👨‍💼 *НАЗНАЧЕННЫЙ МЕНЕДЖЕР:* {manager.full_name if manager else 'Не назначен'}

📋 *СЛЕДУЮЩИЕ ШАГИ:*
1️⃣ Перезвонить клиенту в указанное время
2️⃣ Провести консультацию по критериям
3️⃣ Подготовить персональную подборку
4️⃣ Запланировать показы объектов

⚡ *ВАЖНО:* Соблюдайте время, удобное для клиента!"""
        
        # Always send to admin chat for now
        chat_id = "730764738"  # Admin chat
        
        success = send_telegram_message(chat_id, message)
        
        if success:
            print(f"✓ Callback notification sent to Telegram chat {chat_id}")
        else:
            print(f"✗ Failed to send callback notification to Telegram")
            
    except Exception as e:
        print(f"Error sending callback notification to Telegram: {e}")


# Database initialization happens in the app context below

@app.route('/api/blog/search')
def blog_search_api():
    """API endpoint for instant blog search and suggestions"""
    from models import BlogPost, Category
    from sqlalchemy import or_, func
    
    try:
        query = request.args.get('q', '').strip()
        category = request.args.get('category', '').strip()
        suggestions_only = request.args.get('suggestions', '').lower() == 'true'
        
        # Start with base query - use BlogPost (where data actually is)
        search_query = BlogPost.query.filter(BlogPost.status == 'published')
        
        # Apply search filter
        if query:
            search_query = search_query.filter(
                or_(
                    BlogPost.title.ilike(f'%{query}%'),
                    BlogPost.content.ilike(f'%{query}%'),
                    BlogPost.excerpt.ilike(f'%{query}%')
                )
            )
        
        # Apply category filter
        if category:
            search_query = search_query.filter(BlogPost.category == category)
        
        # For suggestions, limit to title matches only
        if suggestions_only:
            if query:
                suggestions = search_query.filter(
                    BlogPost.title.ilike(f'%{query}%')
                ).limit(5).all()
                
                return jsonify({
                    'suggestions': [{
                        'title': post.title,
                        'slug': post.slug,
                        'category': post.category or 'Общее'
                    } for post in suggestions]
                })
            else:
                return jsonify({'suggestions': []})
        
        # For full search, return formatted articles
        articles = search_query.order_by(BlogPost.created_at.desc()).limit(20).all()
        
        formatted_articles = []
        for article in articles:
            formatted_articles.append({
                'title': article.title,
                'slug': article.slug,
                'excerpt': article.excerpt or '',
                'featured_image': article.featured_image or '',
                'category': article.category or 'Общее',
                'date': article.created_at.strftime('%d.%m.%Y'),
                'reading_time': getattr(article, 'reading_time', 5),
                'views': getattr(article, 'views', 0)
            })
        return jsonify({
            'articles': formatted_articles,
            'total': len(formatted_articles)
        })
        
    except Exception as e:
        print(f"ERROR in blog search API: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': 'Search failed', 'articles': [], 'suggestions': []}), 500

# Developer Scraper Management Endpoints
@app.route('/admin/scraper')
@admin_required
def admin_scraper():
    """Admin panel for developer scraper management"""
    from models import Admin
    
    # ИСПРАВЛЕНО: Используем Flask-Login current_user
    admin = current_user
    
    return render_template('admin/scraper.html', admin=admin)

@app.route('/admin/scraper/run', methods=['POST'])
@admin_required
def run_scraper():
    """Run the AI-powered developer scraper"""
    try:
        from developer_parser_integration import DeveloperParserService
        
        # Получаем параметр лимита (по умолчанию 10)
        limit = 10
        try:
            data = request.get_json(force=True) if request.data else {}
        except:
            data = {}
        
        if data:
            limit = data.get('limit', 10)
        
        service = DeveloperParserService()
        result = service.parse_and_save_developers(limit=limit)
        
        return jsonify({
            'success': True,
            'stats': {
                'developers_created': result.get('created', 0),
                'developers_updated': result.get('updated', 0),
                'total_processed': result.get('total_processed', 0),
                'errors': result.get('errors', 0)
            },
            'message': f'ИИ-парсинг завершен! Обработано {result["total_processed"]} застройщиков. Создано: {result["created"]}, обновлено: {result["updated"]}',
            'errors_list': result.get('errors_list', [])
        })
        
    except Exception as e:
        print(f"AI Scraper error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'success': False,
            'message': f'Ошибка при ИИ-парсинге: {str(e)}'
        }), 500

@app.route('/admin/scraper/test', methods=['POST'])
@admin_required
def test_scraper():
    """Test AI scraper with sample data"""
    try:
        # Простые тестовые данные
        test_data = {
            'name': 'Тестовый застройщик',
            'description': 'Описание тестового застройщика',
            'website': 'https://example.com',
            'phone': '+7-918-000-00-00',
            'email': 'test@example.com'
        }
        
        return jsonify({
            'success': True,
            'data': test_data,
            'stats': {
                'developers_tested': 1,
                'complexes_found': 0,
                'ai_extraction': True,
                'mock_data': True
            },
            'message': 'ИИ-тест завершен! Застройщик: Тестовый застройщик'
        })
        
    except Exception as e:
        print(f"AI Scraper test error: {e}")
        import traceback
        traceback.print_exc()
        
        return jsonify({
            'success': False,
            'message': f'Ошибка при тестировании ИИ-парсера: {str(e)}'
        }), 500

@app.route('/admin/scraper/statistics')
@admin_required
def scraper_statistics():
    """Get AI parser statistics"""
    try:
        from developer_parser_integration import DeveloperParserService
        
        service = DeveloperParserService()
        stats = service.get_parsing_statistics()
        
        return jsonify({
            'success': True,
            'data': stats
        })
        
    except Exception as e:
        print(f"Statistics error: {e}")
        return jsonify({
            'success': False,
            'message': f'Ошибка получения статистики: {str(e)}'
        }), 500

@app.route('/admin/scraper/files')
@admin_required
def scraper_files():
    """List scraped data files"""
    try:
        import glob
        import os
        from datetime import datetime
        
        files = glob.glob('scraped_developers_*.json')
        file_info = []
        
        for file in files:
            stat = os.stat(file)
            file_info.append({
                'name': file,
                'size': stat.st_size,
                'created': datetime.fromtimestamp(stat.st_ctime).strftime('%d.%m.%Y %H:%M'),
                'modified': datetime.fromtimestamp(stat.st_mtime).strftime('%d.%m.%Y %H:%M')
            })
        
        # Sort by creation time, newest first
        file_info.sort(key=lambda x: x['modified'], reverse=True)
        
        return jsonify({
            'success': True,
            'files': file_info
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'message': f'Ошибка при получении списка файлов: {str(e)}'
        }), 500

@app.route('/admin/scraper/view-file/<filename>')
@admin_required
def view_scraped_file(filename):
    """View scraped data file content"""
    try:
        import json
        import os
        
        # Security check - only allow scraped files
        if not filename.startswith('scraped_developers_') or not filename.endswith('.json'):
            return jsonify({'success': False, 'message': 'Недопустимое имя файла'}), 400
        
        if not os.path.exists(filename):
            return jsonify({'success': False, 'message': 'Файл не найден'}), 404
        
        with open(filename, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        return jsonify({
            'success': True,
            'data': data,
            'filename': filename
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'message': f'Ошибка при чтении файла: {str(e)}'
        }), 500

@app.route('/admin/upload-excel', methods=['POST'])
def admin_upload_excel():
    """Handle Excel file upload from admin panel"""
    try:
        if 'excel_file' not in request.files:
            return jsonify({'success': False, 'error': 'Файл не выбран'})
        
        file = request.files['excel_file']
        if file.filename == '':
            return jsonify({'success': False, 'error': 'Файл не выбран'})
        
        if not file.filename.endswith(('.xlsx', '.xls')):
            return jsonify({'success': False, 'error': 'Поддерживаются только файлы Excel (.xlsx, .xls)'})
        
        # Save file to attached_assets directory
        import os
        import uuid
        
        # Ensure attached_assets directory exists
        os.makedirs('attached_assets', exist_ok=True)
        
        # Generate unique filename
        file_extension = os.path.splitext(file.filename)[1]
        unique_filename = f"upload_{uuid.uuid4().hex[:8]}{file_extension}"
        file_path = os.path.join('attached_assets', unique_filename)
        
        # Save the file
        file.save(file_path)
        
        # Запуск импорта в фоновом процессе для больших файлов
        try:
            import threading
            import time
            
            # Создаем уникальный ID задачи
            task_id = unique_filename.replace('.', '_')
            
            # Статус импорта (будем хранить в глобальной переменной)
            global import_status
            if 'import_status' not in globals():
                import_status = {}
            
            import_status[task_id] = {
                'status': 'processing',
                'progress': 0,
                'message': 'Обработка файла...',
                'started_at': time.time()
            }
            
            def background_import():
                try:
                    with app.app_context():
                        result = import_excel_to_database(file_path)
                    
                    # Обновляем статус при успехе
                    import_status[task_id] = {
                        'status': 'completed',
                        'progress': 100,
                        'message': f'✅ {result["message"]} Импортировано: {result["imported"]} записей.',
                        'result': result,
                        'completed_at': time.time()
                    }
                    
                    # Очищаем кеш
                    global _properties_cache, _cache_timestamp
                    _properties_cache = None
                    _cache_timestamp = None
                    
                except Exception as import_error:
                    # Обновляем статус при ошибке
                    import_status[task_id] = {
                        'status': 'error',
                        'progress': 0,
                        'message': f'❌ Ошибка импорта: {str(import_error)}',
                        'error': str(import_error),
                        'failed_at': time.time()
                    }
            
            # Запускаем импорт в отдельном потоке
            thread = threading.Thread(target=background_import, daemon=True)
            thread.start()
            
            # Сразу возвращаем ответ о начале обработки
            return jsonify({
                'success': True,
                'message': f'📤 Файл загружен! Обработка запущена в фоне. Проверьте статус через несколько минут.',
                'task_id': task_id,
                'background': True
            })
            
        except Exception as import_error:
            return jsonify({
                'success': False, 
                'error': f'Ошибка запуска импорта: {str(import_error)}'
            })
            
    except Exception as e:
        return jsonify({'success': False, 'error': f'Ошибка обработки файла: {str(e)}'})

@app.route('/admin/check-import-status/<task_id>')
def admin_check_import_status(task_id):
    """Проверка статуса фонового импорта"""
    try:
        global import_status
        if 'import_status' not in globals():
            import_status = {}
        
        if task_id not in import_status:
            return jsonify({
                'success': False,
                'error': 'Задача не найдена'
            })
        
        status_info = import_status[task_id]
        
        # Добавляем время обработки
        import time
        if 'started_at' in status_info:
            elapsed = time.time() - status_info['started_at']
            status_info['elapsed_time'] = f"{elapsed:.1f} сек"
        
        return jsonify({
            'success': True,
            'status': status_info
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'Ошибка получения статуса: {str(e)}'
        })

# ================== REGIONAL FUNCTIONS ==================

def parse_address_components(address_display_name):
    """
    Парсит полный адрес и извлекает регион, город и район
    Пример: "Россия, Краснодарский край, Сочи, Кудепста м-н, Искры, 88 лит7"
    Возвращает: {'region': 'Краснодарский край', 'city': 'Сочи', 'district': 'Кудепста м-н'}
    """
    if not address_display_name:
        return {'region': None, 'city': None, 'district': None}
    
    # Разделяем адрес по запятым
    parts = [part.strip() for part in address_display_name.split(',')]
    
    result = {'region': None, 'city': None, 'district': None}
    
    # Ищем регион (обычно содержит "край", "область", "республика")
    for part in parts:
        if any(keyword in part.lower() for keyword in ['край', 'область', 'республика', 'федерация']):
            result['region'] = part
            break
    
    # Ищем город (после региона, обычно не содержит специальных суффиксов)
    region_found = False
    for part in parts:
        if result['region'] and part == result['region']:
            region_found = True
            continue
        
        if region_found and part != 'Россия':
            # Проверяем что это не улица или дом
            if not any(keyword in part.lower() for keyword in ['ул', 'улица', 'проспект', 'пр-т', 'переулок', 'пер', 'м-н', 'лит', 'стр', 'корп', 'д.']):
                # Проверяем что это не номер и не псевдо-город типа "Краснодар 6"
                if not part.replace(' ', '').replace('а', '').replace('б', '').replace('в', '').replace('г', '').isdigit():
                    # Дополнительная проверка на псевдо-города (название + пробел + число)
                    import re
                    if not re.match(r'^[а-яё]+\s+\d+$', part.lower()):
                        result['city'] = part
                        break
    
    # Ищем район/микрорайон (обычно содержит "м-н", "р-н" или идет после города)
    city_found = False
    for part in parts:
        if result['city'] and part == result['city']:
            city_found = True
            continue
            
        if city_found:
            # Если это район/микрорайон
            if any(keyword in part.lower() for keyword in ['м-н', 'р-н', 'район', 'микрорайон', 'мкр']):
                result['district'] = part
                break
            # Или если это название района без суффиксов (первое после города)
            elif not any(keyword in part.lower() for keyword in ['ул', 'улица', 'проспект', 'пр-т', 'лит', 'стр', 'корп', 'дом', 'д.']):
                # Проверяем что это не номер дома (содержит только цифры и буквы типа 2А, 10, 36 и т.д.)
                if not (part.replace('/', '').replace('к', '').replace('стр', '').replace('а', '').replace('б', '').replace('в', '').replace('г', '').replace(' ', '').isdigit() or len(part) <= 5):
                    result['district'] = part
                    break
    
    return result

def get_or_create_region(region_name):
    """Получить или создать регион в базе данных"""
    if not region_name:
        return None
        
    from models import Region
    
    # Ищем существующий регион
    region = Region.query.filter_by(name=region_name).first()
    
    if not region:
        # Создаем новый регион
        slug = region_name.lower().replace(' ', '-').replace('ский', '').replace('край', 'krai')
        region = Region(
            name=region_name,
            slug=slug,
            is_active=True,
            is_default=(region_name == 'Краснодарский край')  # Краснодарский край по умолчанию
        )
        db.session.add(region)
        try:
            db.session.commit()
            print(f"Created new region: {region_name}")
        except Exception as e:
            db.session.rollback()
            print(f"Error creating region {region_name}: {e}")
            return None
    
    return region

def get_or_create_city(city_name, region):
    """Получить или создать город в регионе"""
    if not city_name or not region:
        return None
        
    from models import City
    
    # Ищем существующий город в этом регионе
    city = City.query.filter_by(name=city_name, region_id=region.id).first()
    
    if not city:
        # Создаем новый город
        slug = city_name.lower().replace(' ', '-')
        city = City(
            name=city_name,
            slug=slug,
            region_id=region.id,
            is_active=True,
            is_default=(city_name == 'Краснодар')  # Краснодар по умолчанию
        )
        db.session.add(city)
        try:
            db.session.commit()
            print(f"Created new city: {city_name} in {region.name}")
        except Exception as e:
            db.session.rollback()
            print(f"Error creating city {city_name}: {e}")
            return None
    
    return city

def update_properties_with_regions():
    """Обновить все объекты недвижимости с региональной привязкой"""
    
    # ✅ MIGRATED: Use normalized Property model
    properties = Property.query.all()
    updated_count = 0
    
    print(f"Updating {len(properties)} properties with regional data...")
    
    for prop in properties:
        if prop.address_display_name:
            # Парсим адрес
            address_parts = parse_address_components(prop.address_display_name)
            
            # Обновляем парсеные поля
            prop.parsed_region = address_parts['region']
            prop.parsed_city = address_parts['city'] 
            prop.parsed_district = address_parts['district']
            
            # Создаем/находим регион и город
            if address_parts['region']:
                region = get_or_create_region(address_parts['region'])
                if region:
                    prop.region_id = region.id
                    
                    if address_parts['city']:
                        city = get_or_create_city(address_parts['city'], region)
                        if city:
                            prop.city_id = city.id
            
            updated_count += 1
            
            # Сохраняем по частям для избежания таймаутов
            if updated_count % 50 == 0:
                try:
                    db.session.commit()
                    print(f"Updated {updated_count} properties...")
                except Exception as e:
                    print(f"Error committing batch: {str(e)}")
                    db.session.rollback()
    
    # Финальный коммит
    try:
        db.session.commit()
        print(f"✅ Successfully updated {updated_count} properties with regional data")
    except Exception as e:
        print(f"Error in final commit: {str(e)}")
        db.session.rollback()
    
    return updated_count


# ==================== VIDEO MANAGEMENT API ====================
@app.route('/api/manager/complex/<int:complex_id>/video/add-link', methods=['POST'])
@admin_required
def add_complex_video_link(complex_id):
    """Добавить ссылку на видео для ЖК (только для менеджеров)"""
    try:
        data = request.get_json()
        url = data.get('url', '').strip()
        title = data.get('title', '').strip()
        description = data.get('description', '').strip()
        video_type = data.get('type', 'youtube')
        
        if not url or not title:
            return jsonify({'success': False, 'error': 'URL и название обязательны'}), 400
        
        # Получаем комплекс
        complex = ResidentialComplex.query.get(complex_id)
        if not complex:
            return jsonify({'success': False, 'error': 'Комплекс не найден'}), 404
        
        # Парсим существующие видео
        existing_videos = []
        if complex.videos:
            try:
                existing_videos = json.loads(complex.videos)
            except:
                existing_videos = []
        
        # Добавляем новое видео
        new_video = {
            'type': video_type,
            'url': url,
            'title': title
        }
        if description:
            new_video['description'] = description
        
        existing_videos.append(new_video)
        
        # Сохраняем
        complex.videos = json.dumps(existing_videos, ensure_ascii=False)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Видео успешно добавлено',
            'videos_count': len(existing_videos)
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error adding video link: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/manager/complex/<int:complex_id>/video/upload', methods=['POST'])
@admin_required
def upload_complex_video(complex_id):
    """Загрузить видео файл для ЖК (только для администраторов)"""
    app.logger.info(f"=== VIDEO UPLOAD START: complex_id={complex_id}")
    app.logger.info(f"=== request.files keys: {list(request.files.keys())}")
    
    try:
        import os
        from werkzeug.utils import secure_filename
        
        # Проверяем файл
        if 'video' not in request.files:
            app.logger.error("=== ERROR: 'video' not in request.files")
            return jsonify({'success': False, 'error': 'Файл не найден'}), 400
        
        file = request.files['video']
        app.logger.info(f"=== File received: {file.filename}")
        
        if file.filename == '':
            app.logger.error("=== ERROR: Empty filename")
            return jsonify({'success': False, 'error': 'Файл не выбран'}), 400
        
        # Проверяем расширение
        allowed_extensions = {'mp4', 'webm', 'mov', 'avi'}
        filename = secure_filename(file.filename)
        file_ext = filename.rsplit('.', 1)[1].lower() if '.' in filename else ''
        
        app.logger.info(f"=== File extension: {file_ext}")
        
        if file_ext not in allowed_extensions:
            app.logger.error(f"=== ERROR: Invalid extension {file_ext}")
            return jsonify({'success': False, 'error': 'Неподдерживаемый формат видео'}), 400
        
        # Получаем комплекс
        complex = ResidentialComplex.query.get(complex_id)
        if not complex:
            app.logger.error(f"=== ERROR: Complex {complex_id} not found")
            return jsonify({'success': False, 'error': 'Комплекс не найден'}), 404
        
        app.logger.info(f"=== Complex found: {complex.name}, slug: {complex.slug}")
        
        # Создаем уникальное имя файла
        import uuid
        unique_filename = f"{complex.slug}_{uuid.uuid4().hex[:8]}.{file_ext}"
        
        # Путь для сохранения
        upload_folder = 'static/uploads/complexes/videos'
        os.makedirs(upload_folder, exist_ok=True)
        file_path = os.path.join(upload_folder, unique_filename)
        
        app.logger.info(f"=== Saving file to: {file_path}")
        
        # Сохраняем файл
        file.save(file_path)
        
        # Обновляем БД
        relative_path = f"/{file_path}"
        complex.uploaded_video = relative_path
        db.session.commit()
        
        app.logger.info(f"=== VIDEO UPLOAD SUCCESS: {relative_path}")
        
        return jsonify({
            'success': True,
            'message': 'Видео успешно загружено',
            'video_path': relative_path
        })
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"=== VIDEO UPLOAD EXCEPTION: {str(e)}")
        import traceback
        app.logger.error(traceback.format_exc())
        return jsonify({'success': False, 'error': str(e)}), 500
        print(f"Error uploading video: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/manager/complex/<int:complex_id>/video/delete', methods=['DELETE'])
@manager_required  
def delete_complex_video(complex_id):
    """Удалить видео (ссылку или файл) для ЖК"""
    try:
        data = request.get_json()
        video_index = data.get('video_index')  # Индекс видео в массиве videos
        delete_uploaded = data.get('delete_uploaded', False)  # Удалить загруженное видео
        
        complex = ResidentialComplex.query.get(complex_id)
        if not complex:
            return jsonify({'success': False, 'error': 'Комплекс не найден'}), 404
        
        if video_index is not None:
            # Удаляем видео из массива
            if complex.videos:
                try:
                    videos = json.loads(complex.videos)
                    if 0 <= video_index < len(videos):
                        videos.pop(video_index)
                        complex.videos = json.dumps(videos, ensure_ascii=False) if videos else None
                except:
                    return jsonify({'success': False, 'error': 'Ошибка парсинга видео'}), 400
        
        if delete_uploaded and complex.uploaded_video:
            # Удаляем файл с диска
            import os
            try:
                file_path = complex.uploaded_video.lstrip('/')
                if os.path.exists(file_path):
                    os.remove(file_path)
            except:
                pass
            complex.uploaded_video = None
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Видео успешно удалено'
        })
        
    except Exception as e:
        db.session.rollback()
        print(f"Error deleting video: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

